require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"framer":[function(require,module,exports){
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	var Defaults, Framer, _;
	
	_ = __webpack_require__(1)._;
	
	if (window.ontouchstart === void 0) {
	  window.ontouchstart = null;
	}
	
	Framer = {};
	
	Framer._ = _;
	
	Framer.Utils = __webpack_require__(4);
	
	Framer.Color = (__webpack_require__(10)).Color;
	
	Framer.Layer = (__webpack_require__(13)).Layer;
	
	Framer.BackgroundLayer = (__webpack_require__(35)).BackgroundLayer;
	
	Framer.VideoLayer = (__webpack_require__(36)).VideoLayer;
	
	Framer.Events = (__webpack_require__(15)).Events;
	
	Framer.Gestures = (__webpack_require__(16)).Gestures;
	
	Framer.Animation = (__webpack_require__(18)).Animation;
	
	Framer.AnimationGroup = (__webpack_require__(37)).AnimationGroup;
	
	Framer.Screen = (__webpack_require__(5)).Screen;
	
	Framer.Canvas = (__webpack_require__(38)).Canvas;
	
	Framer.Align = (__webpack_require__(39)).Align;
	
	Framer.print = (__webpack_require__(40)).print;
	
	Framer.ScrollComponent = (__webpack_require__(43)).ScrollComponent;
	
	Framer.PageComponent = (__webpack_require__(44)).PageComponent;
	
	Framer.SliderComponent = (__webpack_require__(45)).SliderComponent;
	
	Framer.DeviceComponent = (__webpack_require__(46)).DeviceComponent;
	
	Framer.DeviceView = Framer.DeviceComponent;
	
	if (window) {
	  _.extend(window, Framer);
	}
	
	Framer.Context = (__webpack_require__(41)).Context;
	
	Framer.Config = (__webpack_require__(14)).Config;
	
	Framer.EventEmitter = (__webpack_require__(7)).EventEmitter;
	
	Framer.BaseClass = (__webpack_require__(6)).BaseClass;
	
	Framer.LayerStyle = (__webpack_require__(25)).LayerStyle;
	
	Framer.AnimationLoop = (__webpack_require__(47)).AnimationLoop;
	
	Framer.LinearAnimator = (__webpack_require__(19)).LinearAnimator;
	
	Framer.BezierCurveAnimator = (__webpack_require__(21)).BezierCurveAnimator;
	
	Framer.SpringDHOAnimator = (__webpack_require__(24)).SpringDHOAnimator;
	
	Framer.SpringRK4Animator = (__webpack_require__(22)).SpringRK4Animator;
	
	Framer.LayerDraggable = (__webpack_require__(27)).LayerDraggable;
	
	Framer.Importer = (__webpack_require__(48)).Importer;
	
	Framer.Extras = __webpack_require__(49);
	
	Framer.GestureInputRecognizer = new (__webpack_require__(53)).GestureInputRecognizer;
	
	Framer.Version = __webpack_require__(54);
	
	Framer.Loop = new Framer.AnimationLoop();
	
	Utils.domComplete(Framer.Loop.start);
	
	if (window) {
	  window.Framer = Framer;
	}
	
	Defaults = (__webpack_require__(17)).Defaults;
	
	Defaults.setup();
	
	Framer.resetDefaults = Defaults.reset;
	
	Framer.DefaultContext = new Framer.Context({
	  name: "Default"
	});
	
	Framer.DefaultContext.backgroundColor = "white";
	
	Framer.CurrentContext = Framer.DefaultContext;
	
	if (Utils.isMobile()) {
	  Framer.Extras.MobileScrollFix.enable();
	}
	
	if (!Utils.isTouch()) {
	  Framer.Extras.TouchEmulator.enable();
	}


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	exports._ = __webpack_require__(2);


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/**
	 * @license
	 * lodash 3.10.1 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern -d -o ./index.js`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	;(function() {
	
	  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
	  var undefined;
	
	  /** Used as the semantic version number. */
	  var VERSION = '3.10.1';
	
	  /** Used to compose bitmasks for wrapper metadata. */
	  var BIND_FLAG = 1,
	      BIND_KEY_FLAG = 2,
	      CURRY_BOUND_FLAG = 4,
	      CURRY_FLAG = 8,
	      CURRY_RIGHT_FLAG = 16,
	      PARTIAL_FLAG = 32,
	      PARTIAL_RIGHT_FLAG = 64,
	      ARY_FLAG = 128,
	      REARG_FLAG = 256;
	
	  /** Used as default options for `_.trunc`. */
	  var DEFAULT_TRUNC_LENGTH = 30,
	      DEFAULT_TRUNC_OMISSION = '...';
	
	  /** Used to detect when a function becomes hot. */
	  var HOT_COUNT = 150,
	      HOT_SPAN = 16;
	
	  /** Used as the size to enable large array optimizations. */
	  var LARGE_ARRAY_SIZE = 200;
	
	  /** Used to indicate the type of lazy iteratees. */
	  var LAZY_FILTER_FLAG = 1,
	      LAZY_MAP_FLAG = 2;
	
	  /** Used as the `TypeError` message for "Functions" methods. */
	  var FUNC_ERROR_TEXT = 'Expected a function';
	
	  /** Used as the internal argument placeholder. */
	  var PLACEHOLDER = '__lodash_placeholder__';
	
	  /** `Object#toString` result references. */
	  var argsTag = '[object Arguments]',
	      arrayTag = '[object Array]',
	      boolTag = '[object Boolean]',
	      dateTag = '[object Date]',
	      errorTag = '[object Error]',
	      funcTag = '[object Function]',
	      mapTag = '[object Map]',
	      numberTag = '[object Number]',
	      objectTag = '[object Object]',
	      regexpTag = '[object RegExp]',
	      setTag = '[object Set]',
	      stringTag = '[object String]',
	      weakMapTag = '[object WeakMap]';
	
	  var arrayBufferTag = '[object ArrayBuffer]',
	      float32Tag = '[object Float32Array]',
	      float64Tag = '[object Float64Array]',
	      int8Tag = '[object Int8Array]',
	      int16Tag = '[object Int16Array]',
	      int32Tag = '[object Int32Array]',
	      uint8Tag = '[object Uint8Array]',
	      uint8ClampedTag = '[object Uint8ClampedArray]',
	      uint16Tag = '[object Uint16Array]',
	      uint32Tag = '[object Uint32Array]';
	
	  /** Used to match empty string literals in compiled template source. */
	  var reEmptyStringLeading = /\b__p \+= '';/g,
	      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
	      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
	
	  /** Used to match HTML entities and HTML characters. */
	  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
	      reUnescapedHtml = /[&<>"'`]/g,
	      reHasEscapedHtml = RegExp(reEscapedHtml.source),
	      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
	
	  /** Used to match template delimiters. */
	  var reEscape = /<%-([\s\S]+?)%>/g,
	      reEvaluate = /<%([\s\S]+?)%>/g,
	      reInterpolate = /<%=([\s\S]+?)%>/g;
	
	  /** Used to match property names within property paths. */
	  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
	      reIsPlainProp = /^\w*$/,
	      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;
	
	  /**
	   * Used to match `RegExp` [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns)
	   * and those outlined by [`EscapeRegExpPattern`](http://ecma-international.org/ecma-262/6.0/#sec-escaperegexppattern).
	   */
	  var reRegExpChars = /^[:!,]|[\\^$.*+?()[\]{}|\/]|(^[0-9a-fA-Fnrtuvx])|([\n\r\u2028\u2029])/g,
	      reHasRegExpChars = RegExp(reRegExpChars.source);
	
	  /** Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks). */
	  var reComboMark = /[\u0300-\u036f\ufe20-\ufe23]/g;
	
	  /** Used to match backslashes in property paths. */
	  var reEscapeChar = /\\(\\)?/g;
	
	  /** Used to match [ES template delimiters](http://ecma-international.org/ecma-262/6.0/#sec-template-literal-lexical-components). */
	  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
	
	  /** Used to match `RegExp` flags from their coerced string values. */
	  var reFlags = /\w*$/;
	
	  /** Used to detect hexadecimal string values. */
	  var reHasHexPrefix = /^0[xX]/;
	
	  /** Used to detect host constructors (Safari > 5). */
	  var reIsHostCtor = /^\[object .+?Constructor\]$/;
	
	  /** Used to detect unsigned integer values. */
	  var reIsUint = /^\d+$/;
	
	  /** Used to match latin-1 supplementary letters (excluding mathematical operators). */
	  var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;
	
	  /** Used to ensure capturing order of template delimiters. */
	  var reNoMatch = /($^)/;
	
	  /** Used to match unescaped characters in compiled string literals. */
	  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
	
	  /** Used to match words to create compound words. */
	  var reWords = (function() {
	    var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
	        lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';
	
	    return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
	  }());
	
	  /** Used to assign default `context` object properties. */
	  var contextProps = [
	    'Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array',
	    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number',
	    'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'isFinite',
	    'parseFloat', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array',
	    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap'
	  ];
	
	  /** Used to make template sourceURLs easier to identify. */
	  var templateCounter = -1;
	
	  /** Used to identify `toStringTag` values of typed arrays. */
	  var typedArrayTags = {};
	  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	  typedArrayTags[uint32Tag] = true;
	  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	  typedArrayTags[dateTag] = typedArrayTags[errorTag] =
	  typedArrayTags[funcTag] = typedArrayTags[mapTag] =
	  typedArrayTags[numberTag] = typedArrayTags[objectTag] =
	  typedArrayTags[regexpTag] = typedArrayTags[setTag] =
	  typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
	
	  /** Used to identify `toStringTag` values supported by `_.clone`. */
	  var cloneableTags = {};
	  cloneableTags[argsTag] = cloneableTags[arrayTag] =
	  cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
	  cloneableTags[dateTag] = cloneableTags[float32Tag] =
	  cloneableTags[float64Tag] = cloneableTags[int8Tag] =
	  cloneableTags[int16Tag] = cloneableTags[int32Tag] =
	  cloneableTags[numberTag] = cloneableTags[objectTag] =
	  cloneableTags[regexpTag] = cloneableTags[stringTag] =
	  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
	  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
	  cloneableTags[errorTag] = cloneableTags[funcTag] =
	  cloneableTags[mapTag] = cloneableTags[setTag] =
	  cloneableTags[weakMapTag] = false;
	
	  /** Used to map latin-1 supplementary letters to basic latin letters. */
	  var deburredLetters = {
	    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
	    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
	    '\xc7': 'C',  '\xe7': 'c',
	    '\xd0': 'D',  '\xf0': 'd',
	    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
	    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
	    '\xcC': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
	    '\xeC': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
	    '\xd1': 'N',  '\xf1': 'n',
	    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
	    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
	    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
	    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
	    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
	    '\xc6': 'Ae', '\xe6': 'ae',
	    '\xde': 'Th', '\xfe': 'th',
	    '\xdf': 'ss'
	  };
	
	  /** Used to map characters to HTML entities. */
	  var htmlEscapes = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#39;',
	    '`': '&#96;'
	  };
	
	  /** Used to map HTML entities to characters. */
	  var htmlUnescapes = {
	    '&amp;': '&',
	    '&lt;': '<',
	    '&gt;': '>',
	    '&quot;': '"',
	    '&#39;': "'",
	    '&#96;': '`'
	  };
	
	  /** Used to determine if values are of the language type `Object`. */
	  var objectTypes = {
	    'function': true,
	    'object': true
	  };
	
	  /** Used to escape characters for inclusion in compiled regexes. */
	  var regexpEscapes = {
	    '0': 'x30', '1': 'x31', '2': 'x32', '3': 'x33', '4': 'x34',
	    '5': 'x35', '6': 'x36', '7': 'x37', '8': 'x38', '9': 'x39',
	    'A': 'x41', 'B': 'x42', 'C': 'x43', 'D': 'x44', 'E': 'x45', 'F': 'x46',
	    'a': 'x61', 'b': 'x62', 'c': 'x63', 'd': 'x64', 'e': 'x65', 'f': 'x66',
	    'n': 'x6e', 'r': 'x72', 't': 'x74', 'u': 'x75', 'v': 'x76', 'x': 'x78'
	  };
	
	  /** Used to escape characters for inclusion in compiled string literals. */
	  var stringEscapes = {
	    '\\': '\\',
	    "'": "'",
	    '\n': 'n',
	    '\r': 'r',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };
	
	  /** Detect free variable `exports`. */
	  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
	
	  /** Detect free variable `module`. */
	  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
	
	  /** Detect free variable `global` from Node.js. */
	  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;
	
	  /** Detect free variable `self`. */
	  var freeSelf = objectTypes[typeof self] && self && self.Object && self;
	
	  /** Detect free variable `window`. */
	  var freeWindow = objectTypes[typeof window] && window && window.Object && window;
	
	  /** Detect the popular CommonJS extension `module.exports`. */
	  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
	
	  /**
	   * Used as a reference to the global object.
	   *
	   * The `this` value is used if it's the global object to avoid Greasemonkey's
	   * restricted `window` object, otherwise the `window` object is used.
	   */
	  var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;
	
	  /*--------------------------------------------------------------------------*/
	
	  /**
	   * The base implementation of `compareAscending` which compares values and
	   * sorts them in ascending order without guaranteeing a stable sort.
	   *
	   * @private
	   * @param {*} value The value to compare.
	   * @param {*} other The other value to compare.
	   * @returns {number} Returns the sort order indicator for `value`.
	   */
	  function baseCompareAscending(value, other) {
	    if (value !== other) {
	      var valIsNull = value === null,
	          valIsUndef = value === undefined,
	          valIsReflexive = value === value;
	
	      var othIsNull = other === null,
	          othIsUndef = other === undefined,
	          othIsReflexive = other === other;
	
	      if ((value > other && !othIsNull) || !valIsReflexive ||
	          (valIsNull && !othIsUndef && othIsReflexive) ||
	          (valIsUndef && othIsReflexive)) {
	        return 1;
	      }
	      if ((value < other && !valIsNull) || !othIsReflexive ||
	          (othIsNull && !valIsUndef && valIsReflexive) ||
	          (othIsUndef && valIsReflexive)) {
	        return -1;
	      }
	    }
	    return 0;
	  }
	
	  /**
	   * The base implementation of `_.findIndex` and `_.findLastIndex` without
	   * support for callback shorthands and `this` binding.
	   *
	   * @private
	   * @param {Array} array The array to search.
	   * @param {Function} predicate The function invoked per iteration.
	   * @param {boolean} [fromRight] Specify iterating from right to left.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseFindIndex(array, predicate, fromRight) {
	    var length = array.length,
	        index = fromRight ? length : -1;
	
	    while ((fromRight ? index-- : ++index < length)) {
	      if (predicate(array[index], index, array)) {
	        return index;
	      }
	    }
	    return -1;
	  }
	
	  /**
	   * The base implementation of `_.indexOf` without support for binary searches.
	   *
	   * @private
	   * @param {Array} array The array to search.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseIndexOf(array, value, fromIndex) {
	    if (value !== value) {
	      return indexOfNaN(array, fromIndex);
	    }
	    var index = fromIndex - 1,
	        length = array.length;
	
	    while (++index < length) {
	      if (array[index] === value) {
	        return index;
	      }
	    }
	    return -1;
	  }
	
	  /**
	   * The base implementation of `_.isFunction` without support for environments
	   * with incorrect `typeof` results.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	   */
	  function baseIsFunction(value) {
	    // Avoid a Chakra JIT bug in compatibility modes of IE 11.
	    // See https://github.com/jashkenas/underscore/issues/1621 for more details.
	    return typeof value == 'function' || false;
	  }
	
	  /**
	   * Converts `value` to a string if it's not one. An empty string is returned
	   * for `null` or `undefined` values.
	   *
	   * @private
	   * @param {*} value The value to process.
	   * @returns {string} Returns the string.
	   */
	  function baseToString(value) {
	    return value == null ? '' : (value + '');
	  }
	
	  /**
	   * Used by `_.trim` and `_.trimLeft` to get the index of the first character
	   * of `string` that is not found in `chars`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @param {string} chars The characters to find.
	   * @returns {number} Returns the index of the first character not found in `chars`.
	   */
	  function charsLeftIndex(string, chars) {
	    var index = -1,
	        length = string.length;
	
	    while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}
	    return index;
	  }
	
	  /**
	   * Used by `_.trim` and `_.trimRight` to get the index of the last character
	   * of `string` that is not found in `chars`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @param {string} chars The characters to find.
	   * @returns {number} Returns the index of the last character not found in `chars`.
	   */
	  function charsRightIndex(string, chars) {
	    var index = string.length;
	
	    while (index-- && chars.indexOf(string.charAt(index)) > -1) {}
	    return index;
	  }
	
	  /**
	   * Used by `_.sortBy` to compare transformed elements of a collection and stable
	   * sort them in ascending order.
	   *
	   * @private
	   * @param {Object} object The object to compare.
	   * @param {Object} other The other object to compare.
	   * @returns {number} Returns the sort order indicator for `object`.
	   */
	  function compareAscending(object, other) {
	    return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
	  }
	
	  /**
	   * Used by `_.sortByOrder` to compare multiple properties of a value to another
	   * and stable sort them.
	   *
	   * If `orders` is unspecified, all valuess are sorted in ascending order. Otherwise,
	   * a value is sorted in ascending order if its corresponding order is "asc", and
	   * descending if "desc".
	   *
	   * @private
	   * @param {Object} object The object to compare.
	   * @param {Object} other The other object to compare.
	   * @param {boolean[]} orders The order to sort by for each property.
	   * @returns {number} Returns the sort order indicator for `object`.
	   */
	  function compareMultiple(object, other, orders) {
	    var index = -1,
	        objCriteria = object.criteria,
	        othCriteria = other.criteria,
	        length = objCriteria.length,
	        ordersLength = orders.length;
	
	    while (++index < length) {
	      var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
	      if (result) {
	        if (index >= ordersLength) {
	          return result;
	        }
	        var order = orders[index];
	        return result * ((order === 'asc' || order === true) ? 1 : -1);
	      }
	    }
	    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
	    // that causes it, under certain circumstances, to provide the same value for
	    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
	    // for more details.
	    //
	    // This also ensures a stable sort in V8 and other engines.
	    // See https://code.google.com/p/v8/issues/detail?id=90 for more details.
	    return object.index - other.index;
	  }
	
	  /**
	   * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
	   *
	   * @private
	   * @param {string} letter The matched letter to deburr.
	   * @returns {string} Returns the deburred letter.
	   */
	  function deburrLetter(letter) {
	    return deburredLetters[letter];
	  }
	
	  /**
	   * Used by `_.escape` to convert characters to HTML entities.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */
	  function escapeHtmlChar(chr) {
	    return htmlEscapes[chr];
	  }
	
	  /**
	   * Used by `_.escapeRegExp` to escape characters for inclusion in compiled regexes.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @param {string} leadingChar The capture group for a leading character.
	   * @param {string} whitespaceChar The capture group for a whitespace character.
	   * @returns {string} Returns the escaped character.
	   */
	  function escapeRegExpChar(chr, leadingChar, whitespaceChar) {
	    if (leadingChar) {
	      chr = regexpEscapes[chr];
	    } else if (whitespaceChar) {
	      chr = stringEscapes[chr];
	    }
	    return '\\' + chr;
	  }
	
	  /**
	   * Used by `_.template` to escape characters for inclusion in compiled string literals.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */
	  function escapeStringChar(chr) {
	    return '\\' + stringEscapes[chr];
	  }
	
	  /**
	   * Gets the index at which the first occurrence of `NaN` is found in `array`.
	   *
	   * @private
	   * @param {Array} array The array to search.
	   * @param {number} fromIndex The index to search from.
	   * @param {boolean} [fromRight] Specify iterating from right to left.
	   * @returns {number} Returns the index of the matched `NaN`, else `-1`.
	   */
	  function indexOfNaN(array, fromIndex, fromRight) {
	    var length = array.length,
	        index = fromIndex + (fromRight ? 0 : -1);
	
	    while ((fromRight ? index-- : ++index < length)) {
	      var other = array[index];
	      if (other !== other) {
	        return index;
	      }
	    }
	    return -1;
	  }
	
	  /**
	   * Checks if `value` is object-like.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	   */
	  function isObjectLike(value) {
	    return !!value && typeof value == 'object';
	  }
	
	  /**
	   * Used by `trimmedLeftIndex` and `trimmedRightIndex` to determine if a
	   * character code is whitespace.
	   *
	   * @private
	   * @param {number} charCode The character code to inspect.
	   * @returns {boolean} Returns `true` if `charCode` is whitespace, else `false`.
	   */
	  function isSpace(charCode) {
	    return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 ||
	      (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
	  }
	
	  /**
	   * Replaces all `placeholder` elements in `array` with an internal placeholder
	   * and returns an array of their indexes.
	   *
	   * @private
	   * @param {Array} array The array to modify.
	   * @param {*} placeholder The placeholder to replace.
	   * @returns {Array} Returns the new array of placeholder indexes.
	   */
	  function replaceHolders(array, placeholder) {
	    var index = -1,
	        length = array.length,
	        resIndex = -1,
	        result = [];
	
	    while (++index < length) {
	      if (array[index] === placeholder) {
	        array[index] = PLACEHOLDER;
	        result[++resIndex] = index;
	      }
	    }
	    return result;
	  }
	
	  /**
	   * An implementation of `_.uniq` optimized for sorted arrays without support
	   * for callback shorthands and `this` binding.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {Function} [iteratee] The function invoked per iteration.
	   * @returns {Array} Returns the new duplicate-value-free array.
	   */
	  function sortedUniq(array, iteratee) {
	    var seen,
	        index = -1,
	        length = array.length,
	        resIndex = -1,
	        result = [];
	
	    while (++index < length) {
	      var value = array[index],
	          computed = iteratee ? iteratee(value, index, array) : value;
	
	      if (!index || seen !== computed) {
	        seen = computed;
	        result[++resIndex] = value;
	      }
	    }
	    return result;
	  }
	
	  /**
	   * Used by `_.trim` and `_.trimLeft` to get the index of the first non-whitespace
	   * character of `string`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {number} Returns the index of the first non-whitespace character.
	   */
	  function trimmedLeftIndex(string) {
	    var index = -1,
	        length = string.length;
	
	    while (++index < length && isSpace(string.charCodeAt(index))) {}
	    return index;
	  }
	
	  /**
	   * Used by `_.trim` and `_.trimRight` to get the index of the last non-whitespace
	   * character of `string`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {number} Returns the index of the last non-whitespace character.
	   */
	  function trimmedRightIndex(string) {
	    var index = string.length;
	
	    while (index-- && isSpace(string.charCodeAt(index))) {}
	    return index;
	  }
	
	  /**
	   * Used by `_.unescape` to convert HTML entities to characters.
	   *
	   * @private
	   * @param {string} chr The matched character to unescape.
	   * @returns {string} Returns the unescaped character.
	   */
	  function unescapeHtmlChar(chr) {
	    return htmlUnescapes[chr];
	  }
	
	  /*--------------------------------------------------------------------------*/
	
	  /**
	   * Create a new pristine `lodash` function using the given `context` object.
	   *
	   * @static
	   * @memberOf _
	   * @category Utility
	   * @param {Object} [context=root] The context object.
	   * @returns {Function} Returns a new `lodash` function.
	   * @example
	   *
	   * _.mixin({ 'foo': _.constant('foo') });
	   *
	   * var lodash = _.runInContext();
	   * lodash.mixin({ 'bar': lodash.constant('bar') });
	   *
	   * _.isFunction(_.foo);
	   * // => true
	   * _.isFunction(_.bar);
	   * // => false
	   *
	   * lodash.isFunction(lodash.foo);
	   * // => false
	   * lodash.isFunction(lodash.bar);
	   * // => true
	   *
	   * // using `context` to mock `Date#getTime` use in `_.now`
	   * var mock = _.runInContext({
	   *   'Date': function() {
	   *     return { 'getTime': getTimeMock };
	   *   }
	   * });
	   *
	   * // or creating a suped-up `defer` in Node.js
	   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
	   */
	  function runInContext(context) {
	    // Avoid issues with some ES3 environments that attempt to use values, named
	    // after built-in constructors like `Object`, for the creation of literals.
	    // ES5 clears this up by stating that literals must use built-in constructors.
	    // See https://es5.github.io/#x11.1.5 for more details.
	    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
	
	    /** Native constructor references. */
	    var Array = context.Array,
	        Date = context.Date,
	        Error = context.Error,
	        Function = context.Function,
	        Math = context.Math,
	        Number = context.Number,
	        Object = context.Object,
	        RegExp = context.RegExp,
	        String = context.String,
	        TypeError = context.TypeError;
	
	    /** Used for native method references. */
	    var arrayProto = Array.prototype,
	        objectProto = Object.prototype,
	        stringProto = String.prototype;
	
	    /** Used to resolve the decompiled source of functions. */
	    var fnToString = Function.prototype.toString;
	
	    /** Used to check objects for own properties. */
	    var hasOwnProperty = objectProto.hasOwnProperty;
	
	    /** Used to generate unique IDs. */
	    var idCounter = 0;
	
	    /**
	     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	     * of values.
	     */
	    var objToString = objectProto.toString;
	
	    /** Used to restore the original `_` reference in `_.noConflict`. */
	    var oldDash = root._;
	
	    /** Used to detect if a method is native. */
	    var reIsNative = RegExp('^' +
	      fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
	      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	    );
	
	    /** Native method references. */
	    var ArrayBuffer = context.ArrayBuffer,
	        clearTimeout = context.clearTimeout,
	        parseFloat = context.parseFloat,
	        pow = Math.pow,
	        propertyIsEnumerable = objectProto.propertyIsEnumerable,
	        Set = getNative(context, 'Set'),
	        setTimeout = context.setTimeout,
	        splice = arrayProto.splice,
	        Uint8Array = context.Uint8Array,
	        WeakMap = getNative(context, 'WeakMap');
	
	    /* Native method references for those with the same name as other `lodash` methods. */
	    var nativeCeil = Math.ceil,
	        nativeCreate = getNative(Object, 'create'),
	        nativeFloor = Math.floor,
	        nativeIsArray = getNative(Array, 'isArray'),
	        nativeIsFinite = context.isFinite,
	        nativeKeys = getNative(Object, 'keys'),
	        nativeMax = Math.max,
	        nativeMin = Math.min,
	        nativeNow = getNative(Date, 'now'),
	        nativeParseInt = context.parseInt,
	        nativeRandom = Math.random;
	
	    /** Used as references for `-Infinity` and `Infinity`. */
	    var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
	        POSITIVE_INFINITY = Number.POSITIVE_INFINITY;
	
	    /** Used as references for the maximum length and index of an array. */
	    var MAX_ARRAY_LENGTH = 4294967295,
	        MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
	        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
	
	    /**
	     * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
	     * of an array-like value.
	     */
	    var MAX_SAFE_INTEGER = 9007199254740991;
	
	    /** Used to store function metadata. */
	    var metaMap = WeakMap && new WeakMap;
	
	    /** Used to lookup unminified function names. */
	    var realNames = {};
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates a `lodash` object which wraps `value` to enable implicit chaining.
	     * Methods that operate on and return arrays, collections, and functions can
	     * be chained together. Methods that retrieve a single value or may return a
	     * primitive value will automatically end the chain returning the unwrapped
	     * value. Explicit chaining may be enabled using `_.chain`. The execution of
	     * chained methods is lazy, that is, execution is deferred until `_#value`
	     * is implicitly or explicitly called.
	     *
	     * Lazy evaluation allows several methods to support shortcut fusion. Shortcut
	     * fusion is an optimization strategy which merge iteratee calls; this can help
	     * to avoid the creation of intermediate data structures and greatly reduce the
	     * number of iteratee executions.
	     *
	     * Chaining is supported in custom builds as long as the `_#value` method is
	     * directly or indirectly included in the build.
	     *
	     * In addition to lodash methods, wrappers have `Array` and `String` methods.
	     *
	     * The wrapper `Array` methods are:
	     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`,
	     * `splice`, and `unshift`
	     *
	     * The wrapper `String` methods are:
	     * `replace` and `split`
	     *
	     * The wrapper methods that support shortcut fusion are:
	     * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,
	     * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,
	     * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,
	     * and `where`
	     *
	     * The chainable wrapper methods are:
	     * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,
	     * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,
	     * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defaultsDeep`,
	     * `defer`, `delay`, `difference`, `drop`, `dropRight`, `dropRightWhile`,
	     * `dropWhile`, `fill`, `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`,
	     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
	     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
	     * `invoke`, `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`,
	     * `matchesProperty`, `memoize`, `merge`, `method`, `methodOf`, `mixin`,
	     * `modArgs`, `negate`, `omit`, `once`, `pairs`, `partial`, `partialRight`,
	     * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,
	     * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `restParam`,
	     * `reverse`, `set`, `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`,
	     * `sortByOrder`, `splice`, `spread`, `take`, `takeRight`, `takeRightWhile`,
	     * `takeWhile`, `tap`, `throttle`, `thru`, `times`, `toArray`, `toPlainObject`,
	     * `transform`, `union`, `uniq`, `unshift`, `unzip`, `unzipWith`, `values`,
	     * `valuesIn`, `where`, `without`, `wrap`, `xor`, `zip`, `zipObject`, `zipWith`
	     *
	     * The wrapper methods that are **not** chainable by default are:
	     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clone`, `cloneDeep`,
	     * `deburr`, `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`,
	     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`,
	     * `floor`, `get`, `gt`, `gte`, `has`, `identity`, `includes`, `indexOf`,
	     * `inRange`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
	     * `isEmpty`, `isEqual`, `isError`, `isFinite` `isFunction`, `isMatch`,
	     * `isNative`, `isNaN`, `isNull`, `isNumber`, `isObject`, `isPlainObject`,
	     * `isRegExp`, `isString`, `isUndefined`, `isTypedArray`, `join`, `kebabCase`,
	     * `last`, `lastIndexOf`, `lt`, `lte`, `max`, `min`, `noConflict`, `noop`,
	     * `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`, `random`, `reduce`,
	     * `reduceRight`, `repeat`, `result`, `round`, `runInContext`, `shift`, `size`,
	     * `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`, `startCase`,
	     * `startsWith`, `sum`, `template`, `trim`, `trimLeft`, `trimRight`, `trunc`,
	     * `unescape`, `uniqueId`, `value`, and `words`
	     *
	     * The wrapper method `sample` will return a wrapped value when `n` is provided,
	     * otherwise an unwrapped value is returned.
	     *
	     * @name _
	     * @constructor
	     * @category Chain
	     * @param {*} value The value to wrap in a `lodash` instance.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var wrapped = _([1, 2, 3]);
	     *
	     * // returns an unwrapped value
	     * wrapped.reduce(function(total, n) {
	     *   return total + n;
	     * });
	     * // => 6
	     *
	     * // returns a wrapped value
	     * var squares = wrapped.map(function(n) {
	     *   return n * n;
	     * });
	     *
	     * _.isArray(squares);
	     * // => false
	     *
	     * _.isArray(squares.value());
	     * // => true
	     */
	    function lodash(value) {
	      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
	        if (value instanceof LodashWrapper) {
	          return value;
	        }
	        if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
	          return wrapperClone(value);
	        }
	      }
	      return new LodashWrapper(value);
	    }
	
	    /**
	     * The function whose prototype all chaining wrappers inherit from.
	     *
	     * @private
	     */
	    function baseLodash() {
	      // No operation performed.
	    }
	
	    /**
	     * The base constructor for creating `lodash` wrapper objects.
	     *
	     * @private
	     * @param {*} value The value to wrap.
	     * @param {boolean} [chainAll] Enable chaining for all wrapper methods.
	     * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.
	     */
	    function LodashWrapper(value, chainAll, actions) {
	      this.__wrapped__ = value;
	      this.__actions__ = actions || [];
	      this.__chain__ = !!chainAll;
	    }
	
	    /**
	     * An object environment feature flags.
	     *
	     * @static
	     * @memberOf _
	     * @type Object
	     */
	    var support = lodash.support = {};
	
	    /**
	     * By default, the template delimiters used by lodash are like those in
	     * embedded Ruby (ERB). Change the following template settings to use
	     * alternative delimiters.
	     *
	     * @static
	     * @memberOf _
	     * @type Object
	     */
	    lodash.templateSettings = {
	
	      /**
	       * Used to detect `data` property values to be HTML-escaped.
	       *
	       * @memberOf _.templateSettings
	       * @type RegExp
	       */
	      'escape': reEscape,
	
	      /**
	       * Used to detect code to be evaluated.
	       *
	       * @memberOf _.templateSettings
	       * @type RegExp
	       */
	      'evaluate': reEvaluate,
	
	      /**
	       * Used to detect `data` property values to inject.
	       *
	       * @memberOf _.templateSettings
	       * @type RegExp
	       */
	      'interpolate': reInterpolate,
	
	      /**
	       * Used to reference the data object in the template text.
	       *
	       * @memberOf _.templateSettings
	       * @type string
	       */
	      'variable': '',
	
	      /**
	       * Used to import variables into the compiled template.
	       *
	       * @memberOf _.templateSettings
	       * @type Object
	       */
	      'imports': {
	
	        /**
	         * A reference to the `lodash` function.
	         *
	         * @memberOf _.templateSettings.imports
	         * @type Function
	         */
	        '_': lodash
	      }
	    };
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
	     *
	     * @private
	     * @param {*} value The value to wrap.
	     */
	    function LazyWrapper(value) {
	      this.__wrapped__ = value;
	      this.__actions__ = [];
	      this.__dir__ = 1;
	      this.__filtered__ = false;
	      this.__iteratees__ = [];
	      this.__takeCount__ = POSITIVE_INFINITY;
	      this.__views__ = [];
	    }
	
	    /**
	     * Creates a clone of the lazy wrapper object.
	     *
	     * @private
	     * @name clone
	     * @memberOf LazyWrapper
	     * @returns {Object} Returns the cloned `LazyWrapper` object.
	     */
	    function lazyClone() {
	      var result = new LazyWrapper(this.__wrapped__);
	      result.__actions__ = arrayCopy(this.__actions__);
	      result.__dir__ = this.__dir__;
	      result.__filtered__ = this.__filtered__;
	      result.__iteratees__ = arrayCopy(this.__iteratees__);
	      result.__takeCount__ = this.__takeCount__;
	      result.__views__ = arrayCopy(this.__views__);
	      return result;
	    }
	
	    /**
	     * Reverses the direction of lazy iteration.
	     *
	     * @private
	     * @name reverse
	     * @memberOf LazyWrapper
	     * @returns {Object} Returns the new reversed `LazyWrapper` object.
	     */
	    function lazyReverse() {
	      if (this.__filtered__) {
	        var result = new LazyWrapper(this);
	        result.__dir__ = -1;
	        result.__filtered__ = true;
	      } else {
	        result = this.clone();
	        result.__dir__ *= -1;
	      }
	      return result;
	    }
	
	    /**
	     * Extracts the unwrapped value from its lazy wrapper.
	     *
	     * @private
	     * @name value
	     * @memberOf LazyWrapper
	     * @returns {*} Returns the unwrapped value.
	     */
	    function lazyValue() {
	      var array = this.__wrapped__.value(),
	          dir = this.__dir__,
	          isArr = isArray(array),
	          isRight = dir < 0,
	          arrLength = isArr ? array.length : 0,
	          view = getView(0, arrLength, this.__views__),
	          start = view.start,
	          end = view.end,
	          length = end - start,
	          index = isRight ? end : (start - 1),
	          iteratees = this.__iteratees__,
	          iterLength = iteratees.length,
	          resIndex = 0,
	          takeCount = nativeMin(length, this.__takeCount__);
	
	      if (!isArr || arrLength < LARGE_ARRAY_SIZE || (arrLength == length && takeCount == length)) {
	        return baseWrapperValue((isRight && isArr) ? array.reverse() : array, this.__actions__);
	      }
	      var result = [];
	
	      outer:
	      while (length-- && resIndex < takeCount) {
	        index += dir;
	
	        var iterIndex = -1,
	            value = array[index];
	
	        while (++iterIndex < iterLength) {
	          var data = iteratees[iterIndex],
	              iteratee = data.iteratee,
	              type = data.type,
	              computed = iteratee(value);
	
	          if (type == LAZY_MAP_FLAG) {
	            value = computed;
	          } else if (!computed) {
	            if (type == LAZY_FILTER_FLAG) {
	              continue outer;
	            } else {
	              break outer;
	            }
	          }
	        }
	        result[resIndex++] = value;
	      }
	      return result;
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates a cache object to store key/value pairs.
	     *
	     * @private
	     * @static
	     * @name Cache
	     * @memberOf _.memoize
	     */
	    function MapCache() {
	      this.__data__ = {};
	    }
	
	    /**
	     * Removes `key` and its value from the cache.
	     *
	     * @private
	     * @name delete
	     * @memberOf _.memoize.Cache
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed successfully, else `false`.
	     */
	    function mapDelete(key) {
	      return this.has(key) && delete this.__data__[key];
	    }
	
	    /**
	     * Gets the cached value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf _.memoize.Cache
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the cached value.
	     */
	    function mapGet(key) {
	      return key == '__proto__' ? undefined : this.__data__[key];
	    }
	
	    /**
	     * Checks if a cached value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf _.memoize.Cache
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function mapHas(key) {
	      return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
	    }
	
	    /**
	     * Sets `value` to `key` of the cache.
	     *
	     * @private
	     * @name set
	     * @memberOf _.memoize.Cache
	     * @param {string} key The key of the value to cache.
	     * @param {*} value The value to cache.
	     * @returns {Object} Returns the cache object.
	     */
	    function mapSet(key, value) {
	      if (key != '__proto__') {
	        this.__data__[key] = value;
	      }
	      return this;
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     *
	     * Creates a cache object to store unique values.
	     *
	     * @private
	     * @param {Array} [values] The values to cache.
	     */
	    function SetCache(values) {
	      var length = values ? values.length : 0;
	
	      this.data = { 'hash': nativeCreate(null), 'set': new Set };
	      while (length--) {
	        this.push(values[length]);
	      }
	    }
	
	    /**
	     * Checks if `value` is in `cache` mimicking the return signature of
	     * `_.indexOf` by returning `0` if the value is found, else `-1`.
	     *
	     * @private
	     * @param {Object} cache The cache to search.
	     * @param {*} value The value to search for.
	     * @returns {number} Returns `0` if `value` is found, else `-1`.
	     */
	    function cacheIndexOf(cache, value) {
	      var data = cache.data,
	          result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];
	
	      return result ? 0 : -1;
	    }
	
	    /**
	     * Adds `value` to the cache.
	     *
	     * @private
	     * @name push
	     * @memberOf SetCache
	     * @param {*} value The value to cache.
	     */
	    function cachePush(value) {
	      var data = this.data;
	      if (typeof value == 'string' || isObject(value)) {
	        data.set.add(value);
	      } else {
	        data.hash[value] = true;
	      }
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates a new array joining `array` with `other`.
	     *
	     * @private
	     * @param {Array} array The array to join.
	     * @param {Array} other The other array to join.
	     * @returns {Array} Returns the new concatenated array.
	     */
	    function arrayConcat(array, other) {
	      var index = -1,
	          length = array.length,
	          othIndex = -1,
	          othLength = other.length,
	          result = Array(length + othLength);
	
	      while (++index < length) {
	        result[index] = array[index];
	      }
	      while (++othIndex < othLength) {
	        result[index++] = other[othIndex];
	      }
	      return result;
	    }
	
	    /**
	     * Copies the values of `source` to `array`.
	     *
	     * @private
	     * @param {Array} source The array to copy values from.
	     * @param {Array} [array=[]] The array to copy values to.
	     * @returns {Array} Returns `array`.
	     */
	    function arrayCopy(source, array) {
	      var index = -1,
	          length = source.length;
	
	      array || (array = Array(length));
	      while (++index < length) {
	        array[index] = source[index];
	      }
	      return array;
	    }
	
	    /**
	     * A specialized version of `_.forEach` for arrays without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns `array`.
	     */
	    function arrayEach(array, iteratee) {
	      var index = -1,
	          length = array.length;
	
	      while (++index < length) {
	        if (iteratee(array[index], index, array) === false) {
	          break;
	        }
	      }
	      return array;
	    }
	
	    /**
	     * A specialized version of `_.forEachRight` for arrays without support for
	     * callback shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns `array`.
	     */
	    function arrayEachRight(array, iteratee) {
	      var length = array.length;
	
	      while (length--) {
	        if (iteratee(array[length], length, array) === false) {
	          break;
	        }
	      }
	      return array;
	    }
	
	    /**
	     * A specialized version of `_.every` for arrays without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`.
	     */
	    function arrayEvery(array, predicate) {
	      var index = -1,
	          length = array.length;
	
	      while (++index < length) {
	        if (!predicate(array[index], index, array)) {
	          return false;
	        }
	      }
	      return true;
	    }
	
	    /**
	     * A specialized version of `baseExtremum` for arrays which invokes `iteratee`
	     * with one argument: (value).
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} comparator The function used to compare values.
	     * @param {*} exValue The initial extremum value.
	     * @returns {*} Returns the extremum value.
	     */
	    function arrayExtremum(array, iteratee, comparator, exValue) {
	      var index = -1,
	          length = array.length,
	          computed = exValue,
	          result = computed;
	
	      while (++index < length) {
	        var value = array[index],
	            current = +iteratee(value);
	
	        if (comparator(current, computed)) {
	          computed = current;
	          result = value;
	        }
	      }
	      return result;
	    }
	
	    /**
	     * A specialized version of `_.filter` for arrays without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     */
	    function arrayFilter(array, predicate) {
	      var index = -1,
	          length = array.length,
	          resIndex = -1,
	          result = [];
	
	      while (++index < length) {
	        var value = array[index];
	        if (predicate(value, index, array)) {
	          result[++resIndex] = value;
	        }
	      }
	      return result;
	    }
	
	    /**
	     * A specialized version of `_.map` for arrays without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns the new mapped array.
	     */
	    function arrayMap(array, iteratee) {
	      var index = -1,
	          length = array.length,
	          result = Array(length);
	
	      while (++index < length) {
	        result[index] = iteratee(array[index], index, array);
	      }
	      return result;
	    }
	
	    /**
	     * Appends the elements of `values` to `array`.
	     *
	     * @private
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to append.
	     * @returns {Array} Returns `array`.
	     */
	    function arrayPush(array, values) {
	      var index = -1,
	          length = values.length,
	          offset = array.length;
	
	      while (++index < length) {
	        array[offset + index] = values[index];
	      }
	      return array;
	    }
	
	    /**
	     * A specialized version of `_.reduce` for arrays without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @param {boolean} [initFromArray] Specify using the first element of `array`
	     *  as the initial value.
	     * @returns {*} Returns the accumulated value.
	     */
	    function arrayReduce(array, iteratee, accumulator, initFromArray) {
	      var index = -1,
	          length = array.length;
	
	      if (initFromArray && length) {
	        accumulator = array[++index];
	      }
	      while (++index < length) {
	        accumulator = iteratee(accumulator, array[index], index, array);
	      }
	      return accumulator;
	    }
	
	    /**
	     * A specialized version of `_.reduceRight` for arrays without support for
	     * callback shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @param {boolean} [initFromArray] Specify using the last element of `array`
	     *  as the initial value.
	     * @returns {*} Returns the accumulated value.
	     */
	    function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
	      var length = array.length;
	      if (initFromArray && length) {
	        accumulator = array[--length];
	      }
	      while (length--) {
	        accumulator = iteratee(accumulator, array[length], length, array);
	      }
	      return accumulator;
	    }
	
	    /**
	     * A specialized version of `_.some` for arrays without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     */
	    function arraySome(array, predicate) {
	      var index = -1,
	          length = array.length;
	
	      while (++index < length) {
	        if (predicate(array[index], index, array)) {
	          return true;
	        }
	      }
	      return false;
	    }
	
	    /**
	     * A specialized version of `_.sum` for arrays without support for callback
	     * shorthands and `this` binding..
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {number} Returns the sum.
	     */
	    function arraySum(array, iteratee) {
	      var length = array.length,
	          result = 0;
	
	      while (length--) {
	        result += +iteratee(array[length]) || 0;
	      }
	      return result;
	    }
	
	    /**
	     * Used by `_.defaults` to customize its `_.assign` use.
	     *
	     * @private
	     * @param {*} objectValue The destination object property value.
	     * @param {*} sourceValue The source object property value.
	     * @returns {*} Returns the value to assign to the destination object.
	     */
	    function assignDefaults(objectValue, sourceValue) {
	      return objectValue === undefined ? sourceValue : objectValue;
	    }
	
	    /**
	     * Used by `_.template` to customize its `_.assign` use.
	     *
	     * **Note:** This function is like `assignDefaults` except that it ignores
	     * inherited property values when checking if a property is `undefined`.
	     *
	     * @private
	     * @param {*} objectValue The destination object property value.
	     * @param {*} sourceValue The source object property value.
	     * @param {string} key The key associated with the object and source values.
	     * @param {Object} object The destination object.
	     * @returns {*} Returns the value to assign to the destination object.
	     */
	    function assignOwnDefaults(objectValue, sourceValue, key, object) {
	      return (objectValue === undefined || !hasOwnProperty.call(object, key))
	        ? sourceValue
	        : objectValue;
	    }
	
	    /**
	     * A specialized version of `_.assign` for customizing assigned values without
	     * support for argument juggling, multiple sources, and `this` binding `customizer`
	     * functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {Function} customizer The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     */
	    function assignWith(object, source, customizer) {
	      var index = -1,
	          props = keys(source),
	          length = props.length;
	
	      while (++index < length) {
	        var key = props[index],
	            value = object[key],
	            result = customizer(value, source[key], key, object, source);
	
	        if ((result === result ? (result !== value) : (value === value)) ||
	            (value === undefined && !(key in object))) {
	          object[key] = result;
	        }
	      }
	      return object;
	    }
	
	    /**
	     * The base implementation of `_.assign` without support for argument juggling,
	     * multiple sources, and `customizer` functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @returns {Object} Returns `object`.
	     */
	    function baseAssign(object, source) {
	      return source == null
	        ? object
	        : baseCopy(source, keys(source), object);
	    }
	
	    /**
	     * The base implementation of `_.at` without support for string collections
	     * and individual key arguments.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {number[]|string[]} props The property names or indexes of elements to pick.
	     * @returns {Array} Returns the new array of picked elements.
	     */
	    function baseAt(collection, props) {
	      var index = -1,
	          isNil = collection == null,
	          isArr = !isNil && isArrayLike(collection),
	          length = isArr ? collection.length : 0,
	          propsLength = props.length,
	          result = Array(propsLength);
	
	      while(++index < propsLength) {
	        var key = props[index];
	        if (isArr) {
	          result[index] = isIndex(key, length) ? collection[key] : undefined;
	        } else {
	          result[index] = isNil ? undefined : collection[key];
	        }
	      }
	      return result;
	    }
	
	    /**
	     * Copies properties of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy properties from.
	     * @param {Array} props The property names to copy.
	     * @param {Object} [object={}] The object to copy properties to.
	     * @returns {Object} Returns `object`.
	     */
	    function baseCopy(source, props, object) {
	      object || (object = {});
	
	      var index = -1,
	          length = props.length;
	
	      while (++index < length) {
	        var key = props[index];
	        object[key] = source[key];
	      }
	      return object;
	    }
	
	    /**
	     * The base implementation of `_.callback` which supports specifying the
	     * number of arguments to provide to `func`.
	     *
	     * @private
	     * @param {*} [func=_.identity] The value to convert to a callback.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {number} [argCount] The number of arguments to provide to `func`.
	     * @returns {Function} Returns the callback.
	     */
	    function baseCallback(func, thisArg, argCount) {
	      var type = typeof func;
	      if (type == 'function') {
	        return thisArg === undefined
	          ? func
	          : bindCallback(func, thisArg, argCount);
	      }
	      if (func == null) {
	        return identity;
	      }
	      if (type == 'object') {
	        return baseMatches(func);
	      }
	      return thisArg === undefined
	        ? property(func)
	        : baseMatchesProperty(func, thisArg);
	    }
	
	    /**
	     * The base implementation of `_.clone` without support for argument juggling
	     * and `this` binding `customizer` functions.
	     *
	     * @private
	     * @param {*} value The value to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @param {Function} [customizer] The function to customize cloning values.
	     * @param {string} [key] The key of `value`.
	     * @param {Object} [object] The object `value` belongs to.
	     * @param {Array} [stackA=[]] Tracks traversed source objects.
	     * @param {Array} [stackB=[]] Associates clones with source counterparts.
	     * @returns {*} Returns the cloned value.
	     */
	    function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
	      var result;
	      if (customizer) {
	        result = object ? customizer(value, key, object) : customizer(value);
	      }
	      if (result !== undefined) {
	        return result;
	      }
	      if (!isObject(value)) {
	        return value;
	      }
	      var isArr = isArray(value);
	      if (isArr) {
	        result = initCloneArray(value);
	        if (!isDeep) {
	          return arrayCopy(value, result);
	        }
	      } else {
	        var tag = objToString.call(value),
	            isFunc = tag == funcTag;
	
	        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
	          result = initCloneObject(isFunc ? {} : value);
	          if (!isDeep) {
	            return baseAssign(result, value);
	          }
	        } else {
	          return cloneableTags[tag]
	            ? initCloneByTag(value, tag, isDeep)
	            : (object ? value : {});
	        }
	      }
	      // Check for circular references and return its corresponding clone.
	      stackA || (stackA = []);
	      stackB || (stackB = []);
	
	      var length = stackA.length;
	      while (length--) {
	        if (stackA[length] == value) {
	          return stackB[length];
	        }
	      }
	      // Add the source value to the stack of traversed objects and associate it with its clone.
	      stackA.push(value);
	      stackB.push(result);
	
	      // Recursively populate clone (susceptible to call stack limits).
	      (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
	        result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
	      });
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.create` without support for assigning
	     * properties to the created object.
	     *
	     * @private
	     * @param {Object} prototype The object to inherit from.
	     * @returns {Object} Returns the new object.
	     */
	    var baseCreate = (function() {
	      function object() {}
	      return function(prototype) {
	        if (isObject(prototype)) {
	          object.prototype = prototype;
	          var result = new object;
	          object.prototype = undefined;
	        }
	        return result || {};
	      };
	    }());
	
	    /**
	     * The base implementation of `_.delay` and `_.defer` which accepts an index
	     * of where to slice the arguments to provide to `func`.
	     *
	     * @private
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @param {Object} args The arguments provide to `func`.
	     * @returns {number} Returns the timer id.
	     */
	    function baseDelay(func, wait, args) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return setTimeout(function() { func.apply(undefined, args); }, wait);
	    }
	
	    /**
	     * The base implementation of `_.difference` which accepts a single array
	     * of values to exclude.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Array} values The values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     */
	    function baseDifference(array, values) {
	      var length = array ? array.length : 0,
	          result = [];
	
	      if (!length) {
	        return result;
	      }
	      var index = -1,
	          indexOf = getIndexOf(),
	          isCommon = indexOf == baseIndexOf,
	          cache = (isCommon && values.length >= LARGE_ARRAY_SIZE) ? createCache(values) : null,
	          valuesLength = values.length;
	
	      if (cache) {
	        indexOf = cacheIndexOf;
	        isCommon = false;
	        values = cache;
	      }
	      outer:
	      while (++index < length) {
	        var value = array[index];
	
	        if (isCommon && value === value) {
	          var valuesIndex = valuesLength;
	          while (valuesIndex--) {
	            if (values[valuesIndex] === value) {
	              continue outer;
	            }
	          }
	          result.push(value);
	        }
	        else if (indexOf(values, value, 0) < 0) {
	          result.push(value);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.forEach` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array|Object|string} Returns `collection`.
	     */
	    var baseEach = createBaseEach(baseForOwn);
	
	    /**
	     * The base implementation of `_.forEachRight` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array|Object|string} Returns `collection`.
	     */
	    var baseEachRight = createBaseEach(baseForOwnRight, true);
	
	    /**
	     * The base implementation of `_.every` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`
	     */
	    function baseEvery(collection, predicate) {
	      var result = true;
	      baseEach(collection, function(value, index, collection) {
	        result = !!predicate(value, index, collection);
	        return result;
	      });
	      return result;
	    }
	
	    /**
	     * Gets the extremum value of `collection` invoking `iteratee` for each value
	     * in `collection` to generate the criterion by which the value is ranked.
	     * The `iteratee` is invoked with three arguments: (value, index|key, collection).
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} comparator The function used to compare values.
	     * @param {*} exValue The initial extremum value.
	     * @returns {*} Returns the extremum value.
	     */
	    function baseExtremum(collection, iteratee, comparator, exValue) {
	      var computed = exValue,
	          result = computed;
	
	      baseEach(collection, function(value, index, collection) {
	        var current = +iteratee(value, index, collection);
	        if (comparator(current, computed) || (current === exValue && current === result)) {
	          computed = current;
	          result = value;
	        }
	      });
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.fill` without an iteratee call guard.
	     *
	     * @private
	     * @param {Array} array The array to fill.
	     * @param {*} value The value to fill `array` with.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns `array`.
	     */
	    function baseFill(array, value, start, end) {
	      var length = array.length;
	
	      start = start == null ? 0 : (+start || 0);
	      if (start < 0) {
	        start = -start > length ? 0 : (length + start);
	      }
	      end = (end === undefined || end > length) ? length : (+end || 0);
	      if (end < 0) {
	        end += length;
	      }
	      length = start > end ? 0 : (end >>> 0);
	      start >>>= 0;
	
	      while (start < length) {
	        array[start++] = value;
	      }
	      return array;
	    }
	
	    /**
	     * The base implementation of `_.filter` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     */
	    function baseFilter(collection, predicate) {
	      var result = [];
	      baseEach(collection, function(value, index, collection) {
	        if (predicate(value, index, collection)) {
	          result.push(value);
	        }
	      });
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,
	     * without support for callback shorthands and `this` binding, which iterates
	     * over `collection` using the provided `eachFunc`.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {Function} predicate The function invoked per iteration.
	     * @param {Function} eachFunc The function to iterate over `collection`.
	     * @param {boolean} [retKey] Specify returning the key of the found element
	     *  instead of the element itself.
	     * @returns {*} Returns the found element or its key, else `undefined`.
	     */
	    function baseFind(collection, predicate, eachFunc, retKey) {
	      var result;
	      eachFunc(collection, function(value, key, collection) {
	        if (predicate(value, key, collection)) {
	          result = retKey ? key : value;
	          return false;
	        }
	      });
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.flatten` with added support for restricting
	     * flattening and specifying the start index.
	     *
	     * @private
	     * @param {Array} array The array to flatten.
	     * @param {boolean} [isDeep] Specify a deep flatten.
	     * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.
	     * @param {Array} [result=[]] The initial result value.
	     * @returns {Array} Returns the new flattened array.
	     */
	    function baseFlatten(array, isDeep, isStrict, result) {
	      result || (result = []);
	
	      var index = -1,
	          length = array.length;
	
	      while (++index < length) {
	        var value = array[index];
	        if (isObjectLike(value) && isArrayLike(value) &&
	            (isStrict || isArray(value) || isArguments(value))) {
	          if (isDeep) {
	            // Recursively flatten arrays (susceptible to call stack limits).
	            baseFlatten(value, isDeep, isStrict, result);
	          } else {
	            arrayPush(result, value);
	          }
	        } else if (!isStrict) {
	          result[result.length] = value;
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `baseForIn` and `baseForOwn` which iterates
	     * over `object` properties returned by `keysFunc` invoking `iteratee` for
	     * each property. Iteratee functions may exit iteration early by explicitly
	     * returning `false`.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @returns {Object} Returns `object`.
	     */
	    var baseFor = createBaseFor();
	
	    /**
	     * This function is like `baseFor` except that it iterates over properties
	     * in the opposite order.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @returns {Object} Returns `object`.
	     */
	    var baseForRight = createBaseFor(true);
	
	    /**
	     * The base implementation of `_.forIn` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForIn(object, iteratee) {
	      return baseFor(object, iteratee, keysIn);
	    }
	
	    /**
	     * The base implementation of `_.forOwn` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForOwn(object, iteratee) {
	      return baseFor(object, iteratee, keys);
	    }
	
	    /**
	     * The base implementation of `_.forOwnRight` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForOwnRight(object, iteratee) {
	      return baseForRight(object, iteratee, keys);
	    }
	
	    /**
	     * The base implementation of `_.functions` which creates an array of
	     * `object` function property names filtered from those provided.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Array} props The property names to filter.
	     * @returns {Array} Returns the new array of filtered property names.
	     */
	    function baseFunctions(object, props) {
	      var index = -1,
	          length = props.length,
	          resIndex = -1,
	          result = [];
	
	      while (++index < length) {
	        var key = props[index];
	        if (isFunction(object[key])) {
	          result[++resIndex] = key;
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `get` without support for string paths
	     * and default values.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array} path The path of the property to get.
	     * @param {string} [pathKey] The key representation of path.
	     * @returns {*} Returns the resolved value.
	     */
	    function baseGet(object, path, pathKey) {
	      if (object == null) {
	        return;
	      }
	      if (pathKey !== undefined && pathKey in toObject(object)) {
	        path = [pathKey];
	      }
	      var index = 0,
	          length = path.length;
	
	      while (object != null && index < length) {
	        object = object[path[index++]];
	      }
	      return (index && index == length) ? object : undefined;
	    }
	
	    /**
	     * The base implementation of `_.isEqual` without support for `this` binding
	     * `customizer` functions.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @param {Function} [customizer] The function to customize comparing values.
	     * @param {boolean} [isLoose] Specify performing partial comparisons.
	     * @param {Array} [stackA] Tracks traversed `value` objects.
	     * @param {Array} [stackB] Tracks traversed `other` objects.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     */
	    function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
	      if (value === other) {
	        return true;
	      }
	      if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
	        return value !== value && other !== other;
	      }
	      return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
	    }
	
	    /**
	     * A specialized version of `baseIsEqual` for arrays and objects which performs
	     * deep comparisons and tracks traversed objects enabling objects with circular
	     * references to be compared.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Function} [customizer] The function to customize comparing objects.
	     * @param {boolean} [isLoose] Specify performing partial comparisons.
	     * @param {Array} [stackA=[]] Tracks traversed `value` objects.
	     * @param {Array} [stackB=[]] Tracks traversed `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
	      var objIsArr = isArray(object),
	          othIsArr = isArray(other),
	          objTag = arrayTag,
	          othTag = arrayTag;
	
	      if (!objIsArr) {
	        objTag = objToString.call(object);
	        if (objTag == argsTag) {
	          objTag = objectTag;
	        } else if (objTag != objectTag) {
	          objIsArr = isTypedArray(object);
	        }
	      }
	      if (!othIsArr) {
	        othTag = objToString.call(other);
	        if (othTag == argsTag) {
	          othTag = objectTag;
	        } else if (othTag != objectTag) {
	          othIsArr = isTypedArray(other);
	        }
	      }
	      var objIsObj = objTag == objectTag,
	          othIsObj = othTag == objectTag,
	          isSameTag = objTag == othTag;
	
	      if (isSameTag && !(objIsArr || objIsObj)) {
	        return equalByTag(object, other, objTag);
	      }
	      if (!isLoose) {
	        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
	
	        if (objIsWrapped || othIsWrapped) {
	          return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
	        }
	      }
	      if (!isSameTag) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      // For more information on detecting circular references see https://es5.github.io/#JO.
	      stackA || (stackA = []);
	      stackB || (stackB = []);
	
	      var length = stackA.length;
	      while (length--) {
	        if (stackA[length] == object) {
	          return stackB[length] == other;
	        }
	      }
	      // Add `object` and `other` to the stack of traversed objects.
	      stackA.push(object);
	      stackB.push(other);
	
	      var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);
	
	      stackA.pop();
	      stackB.pop();
	
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.isMatch` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Array} matchData The propery names, values, and compare flags to match.
	     * @param {Function} [customizer] The function to customize comparing objects.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     */
	    function baseIsMatch(object, matchData, customizer) {
	      var index = matchData.length,
	          length = index,
	          noCustomizer = !customizer;
	
	      if (object == null) {
	        return !length;
	      }
	      object = toObject(object);
	      while (index--) {
	        var data = matchData[index];
	        if ((noCustomizer && data[2])
	              ? data[1] !== object[data[0]]
	              : !(data[0] in object)
	            ) {
	          return false;
	        }
	      }
	      while (++index < length) {
	        data = matchData[index];
	        var key = data[0],
	            objValue = object[key],
	            srcValue = data[1];
	
	        if (noCustomizer && data[2]) {
	          if (objValue === undefined && !(key in object)) {
	            return false;
	          }
	        } else {
	          var result = customizer ? customizer(objValue, srcValue, key) : undefined;
	          if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
	            return false;
	          }
	        }
	      }
	      return true;
	    }
	
	    /**
	     * The base implementation of `_.map` without support for callback shorthands
	     * and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns the new mapped array.
	     */
	    function baseMap(collection, iteratee) {
	      var index = -1,
	          result = isArrayLike(collection) ? Array(collection.length) : [];
	
	      baseEach(collection, function(value, key, collection) {
	        result[++index] = iteratee(value, key, collection);
	      });
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.matches` which does not clone `source`.
	     *
	     * @private
	     * @param {Object} source The object of property values to match.
	     * @returns {Function} Returns the new function.
	     */
	    function baseMatches(source) {
	      var matchData = getMatchData(source);
	      if (matchData.length == 1 && matchData[0][2]) {
	        var key = matchData[0][0],
	            value = matchData[0][1];
	
	        return function(object) {
	          if (object == null) {
	            return false;
	          }
	          return object[key] === value && (value !== undefined || (key in toObject(object)));
	        };
	      }
	      return function(object) {
	        return baseIsMatch(object, matchData);
	      };
	    }
	
	    /**
	     * The base implementation of `_.matchesProperty` which does not clone `srcValue`.
	     *
	     * @private
	     * @param {string} path The path of the property to get.
	     * @param {*} srcValue The value to compare.
	     * @returns {Function} Returns the new function.
	     */
	    function baseMatchesProperty(path, srcValue) {
	      var isArr = isArray(path),
	          isCommon = isKey(path) && isStrictComparable(srcValue),
	          pathKey = (path + '');
	
	      path = toPath(path);
	      return function(object) {
	        if (object == null) {
	          return false;
	        }
	        var key = pathKey;
	        object = toObject(object);
	        if ((isArr || !isCommon) && !(key in object)) {
	          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
	          if (object == null) {
	            return false;
	          }
	          key = last(path);
	          object = toObject(object);
	        }
	        return object[key] === srcValue
	          ? (srcValue !== undefined || (key in object))
	          : baseIsEqual(srcValue, object[key], undefined, true);
	      };
	    }
	
	    /**
	     * The base implementation of `_.merge` without support for argument juggling,
	     * multiple sources, and `this` binding `customizer` functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {Function} [customizer] The function to customize merged values.
	     * @param {Array} [stackA=[]] Tracks traversed source objects.
	     * @param {Array} [stackB=[]] Associates values with source counterparts.
	     * @returns {Object} Returns `object`.
	     */
	    function baseMerge(object, source, customizer, stackA, stackB) {
	      if (!isObject(object)) {
	        return object;
	      }
	      var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),
	          props = isSrcArr ? undefined : keys(source);
	
	      arrayEach(props || source, function(srcValue, key) {
	        if (props) {
	          key = srcValue;
	          srcValue = source[key];
	        }
	        if (isObjectLike(srcValue)) {
	          stackA || (stackA = []);
	          stackB || (stackB = []);
	          baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
	        }
	        else {
	          var value = object[key],
	              result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
	              isCommon = result === undefined;
	
	          if (isCommon) {
	            result = srcValue;
	          }
	          if ((result !== undefined || (isSrcArr && !(key in object))) &&
	              (isCommon || (result === result ? (result !== value) : (value === value)))) {
	            object[key] = result;
	          }
	        }
	      });
	      return object;
	    }
	
	    /**
	     * A specialized version of `baseMerge` for arrays and objects which performs
	     * deep merges and tracks traversed objects enabling objects with circular
	     * references to be merged.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {string} key The key of the value to merge.
	     * @param {Function} mergeFunc The function to merge values.
	     * @param {Function} [customizer] The function to customize merged values.
	     * @param {Array} [stackA=[]] Tracks traversed source objects.
	     * @param {Array} [stackB=[]] Associates values with source counterparts.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
	      var length = stackA.length,
	          srcValue = source[key];
	
	      while (length--) {
	        if (stackA[length] == srcValue) {
	          object[key] = stackB[length];
	          return;
	        }
	      }
	      var value = object[key],
	          result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
	          isCommon = result === undefined;
	
	      if (isCommon) {
	        result = srcValue;
	        if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {
	          result = isArray(value)
	            ? value
	            : (isArrayLike(value) ? arrayCopy(value) : []);
	        }
	        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
	          result = isArguments(value)
	            ? toPlainObject(value)
	            : (isPlainObject(value) ? value : {});
	        }
	        else {
	          isCommon = false;
	        }
	      }
	      // Add the source value to the stack of traversed objects and associate
	      // it with its merged value.
	      stackA.push(srcValue);
	      stackB.push(result);
	
	      if (isCommon) {
	        // Recursively merge objects and arrays (susceptible to call stack limits).
	        object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
	      } else if (result === result ? (result !== value) : (value === value)) {
	        object[key] = result;
	      }
	    }
	
	    /**
	     * The base implementation of `_.property` without support for deep paths.
	     *
	     * @private
	     * @param {string} key The key of the property to get.
	     * @returns {Function} Returns the new function.
	     */
	    function baseProperty(key) {
	      return function(object) {
	        return object == null ? undefined : object[key];
	      };
	    }
	
	    /**
	     * A specialized version of `baseProperty` which supports deep paths.
	     *
	     * @private
	     * @param {Array|string} path The path of the property to get.
	     * @returns {Function} Returns the new function.
	     */
	    function basePropertyDeep(path) {
	      var pathKey = (path + '');
	      path = toPath(path);
	      return function(object) {
	        return baseGet(object, path, pathKey);
	      };
	    }
	
	    /**
	     * The base implementation of `_.pullAt` without support for individual
	     * index arguments and capturing the removed elements.
	     *
	     * @private
	     * @param {Array} array The array to modify.
	     * @param {number[]} indexes The indexes of elements to remove.
	     * @returns {Array} Returns `array`.
	     */
	    function basePullAt(array, indexes) {
	      var length = array ? indexes.length : 0;
	      while (length--) {
	        var index = indexes[length];
	        if (index != previous && isIndex(index)) {
	          var previous = index;
	          splice.call(array, index, 1);
	        }
	      }
	      return array;
	    }
	
	    /**
	     * The base implementation of `_.random` without support for argument juggling
	     * and returning floating-point numbers.
	     *
	     * @private
	     * @param {number} min The minimum possible value.
	     * @param {number} max The maximum possible value.
	     * @returns {number} Returns the random number.
	     */
	    function baseRandom(min, max) {
	      return min + nativeFloor(nativeRandom() * (max - min + 1));
	    }
	
	    /**
	     * The base implementation of `_.reduce` and `_.reduceRight` without support
	     * for callback shorthands and `this` binding, which iterates over `collection`
	     * using the provided `eachFunc`.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {*} accumulator The initial value.
	     * @param {boolean} initFromCollection Specify using the first or last element
	     *  of `collection` as the initial value.
	     * @param {Function} eachFunc The function to iterate over `collection`.
	     * @returns {*} Returns the accumulated value.
	     */
	    function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
	      eachFunc(collection, function(value, index, collection) {
	        accumulator = initFromCollection
	          ? (initFromCollection = false, value)
	          : iteratee(accumulator, value, index, collection);
	      });
	      return accumulator;
	    }
	
	    /**
	     * The base implementation of `setData` without support for hot loop detection.
	     *
	     * @private
	     * @param {Function} func The function to associate metadata with.
	     * @param {*} data The metadata.
	     * @returns {Function} Returns `func`.
	     */
	    var baseSetData = !metaMap ? identity : function(func, data) {
	      metaMap.set(func, data);
	      return func;
	    };
	
	    /**
	     * The base implementation of `_.slice` without an iteratee call guard.
	     *
	     * @private
	     * @param {Array} array The array to slice.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function baseSlice(array, start, end) {
	      var index = -1,
	          length = array.length;
	
	      start = start == null ? 0 : (+start || 0);
	      if (start < 0) {
	        start = -start > length ? 0 : (length + start);
	      }
	      end = (end === undefined || end > length) ? length : (+end || 0);
	      if (end < 0) {
	        end += length;
	      }
	      length = start > end ? 0 : ((end - start) >>> 0);
	      start >>>= 0;
	
	      var result = Array(length);
	      while (++index < length) {
	        result[index] = array[index + start];
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.some` without support for callback shorthands
	     * and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     */
	    function baseSome(collection, predicate) {
	      var result;
	
	      baseEach(collection, function(value, index, collection) {
	        result = predicate(value, index, collection);
	        return !result;
	      });
	      return !!result;
	    }
	
	    /**
	     * The base implementation of `_.sortBy` which uses `comparer` to define
	     * the sort order of `array` and replaces criteria objects with their
	     * corresponding values.
	     *
	     * @private
	     * @param {Array} array The array to sort.
	     * @param {Function} comparer The function to define sort order.
	     * @returns {Array} Returns `array`.
	     */
	    function baseSortBy(array, comparer) {
	      var length = array.length;
	
	      array.sort(comparer);
	      while (length--) {
	        array[length] = array[length].value;
	      }
	      return array;
	    }
	
	    /**
	     * The base implementation of `_.sortByOrder` without param guards.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
	     * @param {boolean[]} orders The sort orders of `iteratees`.
	     * @returns {Array} Returns the new sorted array.
	     */
	    function baseSortByOrder(collection, iteratees, orders) {
	      var callback = getCallback(),
	          index = -1;
	
	      iteratees = arrayMap(iteratees, function(iteratee) { return callback(iteratee); });
	
	      var result = baseMap(collection, function(value) {
	        var criteria = arrayMap(iteratees, function(iteratee) { return iteratee(value); });
	        return { 'criteria': criteria, 'index': ++index, 'value': value };
	      });
	
	      return baseSortBy(result, function(object, other) {
	        return compareMultiple(object, other, orders);
	      });
	    }
	
	    /**
	     * The base implementation of `_.sum` without support for callback shorthands
	     * and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {number} Returns the sum.
	     */
	    function baseSum(collection, iteratee) {
	      var result = 0;
	      baseEach(collection, function(value, index, collection) {
	        result += +iteratee(value, index, collection) || 0;
	      });
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.uniq` without support for callback shorthands
	     * and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The function invoked per iteration.
	     * @returns {Array} Returns the new duplicate-value-free array.
	     */
	    function baseUniq(array, iteratee) {
	      var index = -1,
	          indexOf = getIndexOf(),
	          length = array.length,
	          isCommon = indexOf == baseIndexOf,
	          isLarge = isCommon && length >= LARGE_ARRAY_SIZE,
	          seen = isLarge ? createCache() : null,
	          result = [];
	
	      if (seen) {
	        indexOf = cacheIndexOf;
	        isCommon = false;
	      } else {
	        isLarge = false;
	        seen = iteratee ? [] : result;
	      }
	      outer:
	      while (++index < length) {
	        var value = array[index],
	            computed = iteratee ? iteratee(value, index, array) : value;
	
	        if (isCommon && value === value) {
	          var seenIndex = seen.length;
	          while (seenIndex--) {
	            if (seen[seenIndex] === computed) {
	              continue outer;
	            }
	          }
	          if (iteratee) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	        else if (indexOf(seen, computed, 0) < 0) {
	          if (iteratee || isLarge) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.values` and `_.valuesIn` which creates an
	     * array of `object` property values corresponding to the property names
	     * of `props`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array} props The property names to get values for.
	     * @returns {Object} Returns the array of property values.
	     */
	    function baseValues(object, props) {
	      var index = -1,
	          length = props.length,
	          result = Array(length);
	
	      while (++index < length) {
	        result[index] = object[props[index]];
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.dropRightWhile`, `_.dropWhile`, `_.takeRightWhile`,
	     * and `_.takeWhile` without support for callback shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to query.
	     * @param {Function} predicate The function invoked per iteration.
	     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function baseWhile(array, predicate, isDrop, fromRight) {
	      var length = array.length,
	          index = fromRight ? length : -1;
	
	      while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}
	      return isDrop
	        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
	        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
	    }
	
	    /**
	     * The base implementation of `wrapperValue` which returns the result of
	     * performing a sequence of actions on the unwrapped `value`, where each
	     * successive action is supplied the return value of the previous.
	     *
	     * @private
	     * @param {*} value The unwrapped value.
	     * @param {Array} actions Actions to peform to resolve the unwrapped value.
	     * @returns {*} Returns the resolved value.
	     */
	    function baseWrapperValue(value, actions) {
	      var result = value;
	      if (result instanceof LazyWrapper) {
	        result = result.value();
	      }
	      var index = -1,
	          length = actions.length;
	
	      while (++index < length) {
	        var action = actions[index];
	        result = action.func.apply(action.thisArg, arrayPush([result], action.args));
	      }
	      return result;
	    }
	
	    /**
	     * Performs a binary search of `array` to determine the index at which `value`
	     * should be inserted into `array` in order to maintain its sort order.
	     *
	     * @private
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     */
	    function binaryIndex(array, value, retHighest) {
	      var low = 0,
	          high = array ? array.length : low;
	
	      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
	        while (low < high) {
	          var mid = (low + high) >>> 1,
	              computed = array[mid];
	
	          if ((retHighest ? (computed <= value) : (computed < value)) && computed !== null) {
	            low = mid + 1;
	          } else {
	            high = mid;
	          }
	        }
	        return high;
	      }
	      return binaryIndexBy(array, value, identity, retHighest);
	    }
	
	    /**
	     * This function is like `binaryIndex` except that it invokes `iteratee` for
	     * `value` and each element of `array` to compute their sort ranking. The
	     * iteratee is invoked with one argument; (value).
	     *
	     * @private
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     */
	    function binaryIndexBy(array, value, iteratee, retHighest) {
	      value = iteratee(value);
	
	      var low = 0,
	          high = array ? array.length : 0,
	          valIsNaN = value !== value,
	          valIsNull = value === null,
	          valIsUndef = value === undefined;
	
	      while (low < high) {
	        var mid = nativeFloor((low + high) / 2),
	            computed = iteratee(array[mid]),
	            isDef = computed !== undefined,
	            isReflexive = computed === computed;
	
	        if (valIsNaN) {
	          var setLow = isReflexive || retHighest;
	        } else if (valIsNull) {
	          setLow = isReflexive && isDef && (retHighest || computed != null);
	        } else if (valIsUndef) {
	          setLow = isReflexive && (retHighest || isDef);
	        } else if (computed == null) {
	          setLow = false;
	        } else {
	          setLow = retHighest ? (computed <= value) : (computed < value);
	        }
	        if (setLow) {
	          low = mid + 1;
	        } else {
	          high = mid;
	        }
	      }
	      return nativeMin(high, MAX_ARRAY_INDEX);
	    }
	
	    /**
	     * A specialized version of `baseCallback` which only supports `this` binding
	     * and specifying the number of arguments to provide to `func`.
	     *
	     * @private
	     * @param {Function} func The function to bind.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {number} [argCount] The number of arguments to provide to `func`.
	     * @returns {Function} Returns the callback.
	     */
	    function bindCallback(func, thisArg, argCount) {
	      if (typeof func != 'function') {
	        return identity;
	      }
	      if (thisArg === undefined) {
	        return func;
	      }
	      switch (argCount) {
	        case 1: return function(value) {
	          return func.call(thisArg, value);
	        };
	        case 3: return function(value, index, collection) {
	          return func.call(thisArg, value, index, collection);
	        };
	        case 4: return function(accumulator, value, index, collection) {
	          return func.call(thisArg, accumulator, value, index, collection);
	        };
	        case 5: return function(value, other, key, object, source) {
	          return func.call(thisArg, value, other, key, object, source);
	        };
	      }
	      return function() {
	        return func.apply(thisArg, arguments);
	      };
	    }
	
	    /**
	     * Creates a clone of the given array buffer.
	     *
	     * @private
	     * @param {ArrayBuffer} buffer The array buffer to clone.
	     * @returns {ArrayBuffer} Returns the cloned array buffer.
	     */
	    function bufferClone(buffer) {
	      var result = new ArrayBuffer(buffer.byteLength),
	          view = new Uint8Array(result);
	
	      view.set(new Uint8Array(buffer));
	      return result;
	    }
	
	    /**
	     * Creates an array that is the composition of partially applied arguments,
	     * placeholders, and provided arguments into a single array of arguments.
	     *
	     * @private
	     * @param {Array|Object} args The provided arguments.
	     * @param {Array} partials The arguments to prepend to those provided.
	     * @param {Array} holders The `partials` placeholder indexes.
	     * @returns {Array} Returns the new array of composed arguments.
	     */
	    function composeArgs(args, partials, holders) {
	      var holdersLength = holders.length,
	          argsIndex = -1,
	          argsLength = nativeMax(args.length - holdersLength, 0),
	          leftIndex = -1,
	          leftLength = partials.length,
	          result = Array(leftLength + argsLength);
	
	      while (++leftIndex < leftLength) {
	        result[leftIndex] = partials[leftIndex];
	      }
	      while (++argsIndex < holdersLength) {
	        result[holders[argsIndex]] = args[argsIndex];
	      }
	      while (argsLength--) {
	        result[leftIndex++] = args[argsIndex++];
	      }
	      return result;
	    }
	
	    /**
	     * This function is like `composeArgs` except that the arguments composition
	     * is tailored for `_.partialRight`.
	     *
	     * @private
	     * @param {Array|Object} args The provided arguments.
	     * @param {Array} partials The arguments to append to those provided.
	     * @param {Array} holders The `partials` placeholder indexes.
	     * @returns {Array} Returns the new array of composed arguments.
	     */
	    function composeArgsRight(args, partials, holders) {
	      var holdersIndex = -1,
	          holdersLength = holders.length,
	          argsIndex = -1,
	          argsLength = nativeMax(args.length - holdersLength, 0),
	          rightIndex = -1,
	          rightLength = partials.length,
	          result = Array(argsLength + rightLength);
	
	      while (++argsIndex < argsLength) {
	        result[argsIndex] = args[argsIndex];
	      }
	      var offset = argsIndex;
	      while (++rightIndex < rightLength) {
	        result[offset + rightIndex] = partials[rightIndex];
	      }
	      while (++holdersIndex < holdersLength) {
	        result[offset + holders[holdersIndex]] = args[argsIndex++];
	      }
	      return result;
	    }
	
	    /**
	     * Creates a `_.countBy`, `_.groupBy`, `_.indexBy`, or `_.partition` function.
	     *
	     * @private
	     * @param {Function} setter The function to set keys and values of the accumulator object.
	     * @param {Function} [initializer] The function to initialize the accumulator object.
	     * @returns {Function} Returns the new aggregator function.
	     */
	    function createAggregator(setter, initializer) {
	      return function(collection, iteratee, thisArg) {
	        var result = initializer ? initializer() : {};
	        iteratee = getCallback(iteratee, thisArg, 3);
	
	        if (isArray(collection)) {
	          var index = -1,
	              length = collection.length;
	
	          while (++index < length) {
	            var value = collection[index];
	            setter(result, value, iteratee(value, index, collection), collection);
	          }
	        } else {
	          baseEach(collection, function(value, key, collection) {
	            setter(result, value, iteratee(value, key, collection), collection);
	          });
	        }
	        return result;
	      };
	    }
	
	    /**
	     * Creates a `_.assign`, `_.defaults`, or `_.merge` function.
	     *
	     * @private
	     * @param {Function} assigner The function to assign values.
	     * @returns {Function} Returns the new assigner function.
	     */
	    function createAssigner(assigner) {
	      return restParam(function(object, sources) {
	        var index = -1,
	            length = object == null ? 0 : sources.length,
	            customizer = length > 2 ? sources[length - 2] : undefined,
	            guard = length > 2 ? sources[2] : undefined,
	            thisArg = length > 1 ? sources[length - 1] : undefined;
	
	        if (typeof customizer == 'function') {
	          customizer = bindCallback(customizer, thisArg, 5);
	          length -= 2;
	        } else {
	          customizer = typeof thisArg == 'function' ? thisArg : undefined;
	          length -= (customizer ? 1 : 0);
	        }
	        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	          customizer = length < 3 ? undefined : customizer;
	          length = 1;
	        }
	        while (++index < length) {
	          var source = sources[index];
	          if (source) {
	            assigner(object, source, customizer);
	          }
	        }
	        return object;
	      });
	    }
	
	    /**
	     * Creates a `baseEach` or `baseEachRight` function.
	     *
	     * @private
	     * @param {Function} eachFunc The function to iterate over a collection.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new base function.
	     */
	    function createBaseEach(eachFunc, fromRight) {
	      return function(collection, iteratee) {
	        var length = collection ? getLength(collection) : 0;
	        if (!isLength(length)) {
	          return eachFunc(collection, iteratee);
	        }
	        var index = fromRight ? length : -1,
	            iterable = toObject(collection);
	
	        while ((fromRight ? index-- : ++index < length)) {
	          if (iteratee(iterable[index], index, iterable) === false) {
	            break;
	          }
	        }
	        return collection;
	      };
	    }
	
	    /**
	     * Creates a base function for `_.forIn` or `_.forInRight`.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new base function.
	     */
	    function createBaseFor(fromRight) {
	      return function(object, iteratee, keysFunc) {
	        var iterable = toObject(object),
	            props = keysFunc(object),
	            length = props.length,
	            index = fromRight ? length : -1;
	
	        while ((fromRight ? index-- : ++index < length)) {
	          var key = props[index];
	          if (iteratee(iterable[key], key, iterable) === false) {
	            break;
	          }
	        }
	        return object;
	      };
	    }
	
	    /**
	     * Creates a function that wraps `func` and invokes it with the `this`
	     * binding of `thisArg`.
	     *
	     * @private
	     * @param {Function} func The function to bind.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @returns {Function} Returns the new bound function.
	     */
	    function createBindWrapper(func, thisArg) {
	      var Ctor = createCtorWrapper(func);
	
	      function wrapper() {
	        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	        return fn.apply(thisArg, arguments);
	      }
	      return wrapper;
	    }
	
	    /**
	     * Creates a `Set` cache object to optimize linear searches of large arrays.
	     *
	     * @private
	     * @param {Array} [values] The values to cache.
	     * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
	     */
	    function createCache(values) {
	      return (nativeCreate && Set) ? new SetCache(values) : null;
	    }
	
	    /**
	     * Creates a function that produces compound words out of the words in a
	     * given string.
	     *
	     * @private
	     * @param {Function} callback The function to combine each word.
	     * @returns {Function} Returns the new compounder function.
	     */
	    function createCompounder(callback) {
	      return function(string) {
	        var index = -1,
	            array = words(deburr(string)),
	            length = array.length,
	            result = '';
	
	        while (++index < length) {
	          result = callback(result, array[index], index);
	        }
	        return result;
	      };
	    }
	
	    /**
	     * Creates a function that produces an instance of `Ctor` regardless of
	     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
	     *
	     * @private
	     * @param {Function} Ctor The constructor to wrap.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createCtorWrapper(Ctor) {
	      return function() {
	        // Use a `switch` statement to work with class constructors.
	        // See http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
	        // for more details.
	        var args = arguments;
	        switch (args.length) {
	          case 0: return new Ctor;
	          case 1: return new Ctor(args[0]);
	          case 2: return new Ctor(args[0], args[1]);
	          case 3: return new Ctor(args[0], args[1], args[2]);
	          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
	          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
	          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
	          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
	        }
	        var thisBinding = baseCreate(Ctor.prototype),
	            result = Ctor.apply(thisBinding, args);
	
	        // Mimic the constructor's `return` behavior.
	        // See https://es5.github.io/#x13.2.2 for more details.
	        return isObject(result) ? result : thisBinding;
	      };
	    }
	
	    /**
	     * Creates a `_.curry` or `_.curryRight` function.
	     *
	     * @private
	     * @param {boolean} flag The curry bit flag.
	     * @returns {Function} Returns the new curry function.
	     */
	    function createCurry(flag) {
	      function curryFunc(func, arity, guard) {
	        if (guard && isIterateeCall(func, arity, guard)) {
	          arity = undefined;
	        }
	        var result = createWrapper(func, flag, undefined, undefined, undefined, undefined, undefined, arity);
	        result.placeholder = curryFunc.placeholder;
	        return result;
	      }
	      return curryFunc;
	    }
	
	    /**
	     * Creates a `_.defaults` or `_.defaultsDeep` function.
	     *
	     * @private
	     * @param {Function} assigner The function to assign values.
	     * @param {Function} customizer The function to customize assigned values.
	     * @returns {Function} Returns the new defaults function.
	     */
	    function createDefaults(assigner, customizer) {
	      return restParam(function(args) {
	        var object = args[0];
	        if (object == null) {
	          return object;
	        }
	        args.push(customizer);
	        return assigner.apply(undefined, args);
	      });
	    }
	
	    /**
	     * Creates a `_.max` or `_.min` function.
	     *
	     * @private
	     * @param {Function} comparator The function used to compare values.
	     * @param {*} exValue The initial extremum value.
	     * @returns {Function} Returns the new extremum function.
	     */
	    function createExtremum(comparator, exValue) {
	      return function(collection, iteratee, thisArg) {
	        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
	          iteratee = undefined;
	        }
	        iteratee = getCallback(iteratee, thisArg, 3);
	        if (iteratee.length == 1) {
	          collection = isArray(collection) ? collection : toIterable(collection);
	          var result = arrayExtremum(collection, iteratee, comparator, exValue);
	          if (!(collection.length && result === exValue)) {
	            return result;
	          }
	        }
	        return baseExtremum(collection, iteratee, comparator, exValue);
	      };
	    }
	
	    /**
	     * Creates a `_.find` or `_.findLast` function.
	     *
	     * @private
	     * @param {Function} eachFunc The function to iterate over a collection.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new find function.
	     */
	    function createFind(eachFunc, fromRight) {
	      return function(collection, predicate, thisArg) {
	        predicate = getCallback(predicate, thisArg, 3);
	        if (isArray(collection)) {
	          var index = baseFindIndex(collection, predicate, fromRight);
	          return index > -1 ? collection[index] : undefined;
	        }
	        return baseFind(collection, predicate, eachFunc);
	      };
	    }
	
	    /**
	     * Creates a `_.findIndex` or `_.findLastIndex` function.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new find function.
	     */
	    function createFindIndex(fromRight) {
	      return function(array, predicate, thisArg) {
	        if (!(array && array.length)) {
	          return -1;
	        }
	        predicate = getCallback(predicate, thisArg, 3);
	        return baseFindIndex(array, predicate, fromRight);
	      };
	    }
	
	    /**
	     * Creates a `_.findKey` or `_.findLastKey` function.
	     *
	     * @private
	     * @param {Function} objectFunc The function to iterate over an object.
	     * @returns {Function} Returns the new find function.
	     */
	    function createFindKey(objectFunc) {
	      return function(object, predicate, thisArg) {
	        predicate = getCallback(predicate, thisArg, 3);
	        return baseFind(object, predicate, objectFunc, true);
	      };
	    }
	
	    /**
	     * Creates a `_.flow` or `_.flowRight` function.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new flow function.
	     */
	    function createFlow(fromRight) {
	      return function() {
	        var wrapper,
	            length = arguments.length,
	            index = fromRight ? length : -1,
	            leftIndex = 0,
	            funcs = Array(length);
	
	        while ((fromRight ? index-- : ++index < length)) {
	          var func = funcs[leftIndex++] = arguments[index];
	          if (typeof func != 'function') {
	            throw new TypeError(FUNC_ERROR_TEXT);
	          }
	          if (!wrapper && LodashWrapper.prototype.thru && getFuncName(func) == 'wrapper') {
	            wrapper = new LodashWrapper([], true);
	          }
	        }
	        index = wrapper ? -1 : length;
	        while (++index < length) {
	          func = funcs[index];
	
	          var funcName = getFuncName(func),
	              data = funcName == 'wrapper' ? getData(func) : undefined;
	
	          if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {
	            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
	          } else {
	            wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);
	          }
	        }
	        return function() {
	          var args = arguments,
	              value = args[0];
	
	          if (wrapper && args.length == 1 && isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
	            return wrapper.plant(value).value();
	          }
	          var index = 0,
	              result = length ? funcs[index].apply(this, args) : value;
	
	          while (++index < length) {
	            result = funcs[index].call(this, result);
	          }
	          return result;
	        };
	      };
	    }
	
	    /**
	     * Creates a function for `_.forEach` or `_.forEachRight`.
	     *
	     * @private
	     * @param {Function} arrayFunc The function to iterate over an array.
	     * @param {Function} eachFunc The function to iterate over a collection.
	     * @returns {Function} Returns the new each function.
	     */
	    function createForEach(arrayFunc, eachFunc) {
	      return function(collection, iteratee, thisArg) {
	        return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
	          ? arrayFunc(collection, iteratee)
	          : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
	      };
	    }
	
	    /**
	     * Creates a function for `_.forIn` or `_.forInRight`.
	     *
	     * @private
	     * @param {Function} objectFunc The function to iterate over an object.
	     * @returns {Function} Returns the new each function.
	     */
	    function createForIn(objectFunc) {
	      return function(object, iteratee, thisArg) {
	        if (typeof iteratee != 'function' || thisArg !== undefined) {
	          iteratee = bindCallback(iteratee, thisArg, 3);
	        }
	        return objectFunc(object, iteratee, keysIn);
	      };
	    }
	
	    /**
	     * Creates a function for `_.forOwn` or `_.forOwnRight`.
	     *
	     * @private
	     * @param {Function} objectFunc The function to iterate over an object.
	     * @returns {Function} Returns the new each function.
	     */
	    function createForOwn(objectFunc) {
	      return function(object, iteratee, thisArg) {
	        if (typeof iteratee != 'function' || thisArg !== undefined) {
	          iteratee = bindCallback(iteratee, thisArg, 3);
	        }
	        return objectFunc(object, iteratee);
	      };
	    }
	
	    /**
	     * Creates a function for `_.mapKeys` or `_.mapValues`.
	     *
	     * @private
	     * @param {boolean} [isMapKeys] Specify mapping keys instead of values.
	     * @returns {Function} Returns the new map function.
	     */
	    function createObjectMapper(isMapKeys) {
	      return function(object, iteratee, thisArg) {
	        var result = {};
	        iteratee = getCallback(iteratee, thisArg, 3);
	
	        baseForOwn(object, function(value, key, object) {
	          var mapped = iteratee(value, key, object);
	          key = isMapKeys ? mapped : key;
	          value = isMapKeys ? value : mapped;
	          result[key] = value;
	        });
	        return result;
	      };
	    }
	
	    /**
	     * Creates a function for `_.padLeft` or `_.padRight`.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify padding from the right.
	     * @returns {Function} Returns the new pad function.
	     */
	    function createPadDir(fromRight) {
	      return function(string, length, chars) {
	        string = baseToString(string);
	        return (fromRight ? string : '') + createPadding(string, length, chars) + (fromRight ? '' : string);
	      };
	    }
	
	    /**
	     * Creates a `_.partial` or `_.partialRight` function.
	     *
	     * @private
	     * @param {boolean} flag The partial bit flag.
	     * @returns {Function} Returns the new partial function.
	     */
	    function createPartial(flag) {
	      var partialFunc = restParam(function(func, partials) {
	        var holders = replaceHolders(partials, partialFunc.placeholder);
	        return createWrapper(func, flag, undefined, partials, holders);
	      });
	      return partialFunc;
	    }
	
	    /**
	     * Creates a function for `_.reduce` or `_.reduceRight`.
	     *
	     * @private
	     * @param {Function} arrayFunc The function to iterate over an array.
	     * @param {Function} eachFunc The function to iterate over a collection.
	     * @returns {Function} Returns the new each function.
	     */
	    function createReduce(arrayFunc, eachFunc) {
	      return function(collection, iteratee, accumulator, thisArg) {
	        var initFromArray = arguments.length < 3;
	        return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
	          ? arrayFunc(collection, iteratee, accumulator, initFromArray)
	          : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
	      };
	    }
	
	    /**
	     * Creates a function that wraps `func` and invokes it with optional `this`
	     * binding of, partial application, and currying.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to reference.
	     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to prepend to those provided to the new function.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
	     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
	      var isAry = bitmask & ARY_FLAG,
	          isBind = bitmask & BIND_FLAG,
	          isBindKey = bitmask & BIND_KEY_FLAG,
	          isCurry = bitmask & CURRY_FLAG,
	          isCurryBound = bitmask & CURRY_BOUND_FLAG,
	          isCurryRight = bitmask & CURRY_RIGHT_FLAG,
	          Ctor = isBindKey ? undefined : createCtorWrapper(func);
	
	      function wrapper() {
	        // Avoid `arguments` object use disqualifying optimizations by
	        // converting it to an array before providing it to other functions.
	        var length = arguments.length,
	            index = length,
	            args = Array(length);
	
	        while (index--) {
	          args[index] = arguments[index];
	        }
	        if (partials) {
	          args = composeArgs(args, partials, holders);
	        }
	        if (partialsRight) {
	          args = composeArgsRight(args, partialsRight, holdersRight);
	        }
	        if (isCurry || isCurryRight) {
	          var placeholder = wrapper.placeholder,
	              argsHolders = replaceHolders(args, placeholder);
	
	          length -= argsHolders.length;
	          if (length < arity) {
	            var newArgPos = argPos ? arrayCopy(argPos) : undefined,
	                newArity = nativeMax(arity - length, 0),
	                newsHolders = isCurry ? argsHolders : undefined,
	                newHoldersRight = isCurry ? undefined : argsHolders,
	                newPartials = isCurry ? args : undefined,
	                newPartialsRight = isCurry ? undefined : args;
	
	            bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
	            bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);
	
	            if (!isCurryBound) {
	              bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
	            }
	            var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],
	                result = createHybridWrapper.apply(undefined, newData);
	
	            if (isLaziable(func)) {
	              setData(result, newData);
	            }
	            result.placeholder = placeholder;
	            return result;
	          }
	        }
	        var thisBinding = isBind ? thisArg : this,
	            fn = isBindKey ? thisBinding[func] : func;
	
	        if (argPos) {
	          args = reorder(args, argPos);
	        }
	        if (isAry && ary < args.length) {
	          args.length = ary;
	        }
	        if (this && this !== root && this instanceof wrapper) {
	          fn = Ctor || createCtorWrapper(func);
	        }
	        return fn.apply(thisBinding, args);
	      }
	      return wrapper;
	    }
	
	    /**
	     * Creates the padding required for `string` based on the given `length`.
	     * The `chars` string is truncated if the number of characters exceeds `length`.
	     *
	     * @private
	     * @param {string} string The string to create padding for.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the pad for `string`.
	     */
	    function createPadding(string, length, chars) {
	      var strLength = string.length;
	      length = +length;
	
	      if (strLength >= length || !nativeIsFinite(length)) {
	        return '';
	      }
	      var padLength = length - strLength;
	      chars = chars == null ? ' ' : (chars + '');
	      return repeat(chars, nativeCeil(padLength / chars.length)).slice(0, padLength);
	    }
	
	    /**
	     * Creates a function that wraps `func` and invokes it with the optional `this`
	     * binding of `thisArg` and the `partials` prepended to those provided to
	     * the wrapper.
	     *
	     * @private
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {Array} partials The arguments to prepend to those provided to the new function.
	     * @returns {Function} Returns the new bound function.
	     */
	    function createPartialWrapper(func, bitmask, thisArg, partials) {
	      var isBind = bitmask & BIND_FLAG,
	          Ctor = createCtorWrapper(func);
	
	      function wrapper() {
	        // Avoid `arguments` object use disqualifying optimizations by
	        // converting it to an array before providing it `func`.
	        var argsIndex = -1,
	            argsLength = arguments.length,
	            leftIndex = -1,
	            leftLength = partials.length,
	            args = Array(leftLength + argsLength);
	
	        while (++leftIndex < leftLength) {
	          args[leftIndex] = partials[leftIndex];
	        }
	        while (argsLength--) {
	          args[leftIndex++] = arguments[++argsIndex];
	        }
	        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	        return fn.apply(isBind ? thisArg : this, args);
	      }
	      return wrapper;
	    }
	
	    /**
	     * Creates a `_.ceil`, `_.floor`, or `_.round` function.
	     *
	     * @private
	     * @param {string} methodName The name of the `Math` method to use when rounding.
	     * @returns {Function} Returns the new round function.
	     */
	    function createRound(methodName) {
	      var func = Math[methodName];
	      return function(number, precision) {
	        precision = precision === undefined ? 0 : (+precision || 0);
	        if (precision) {
	          precision = pow(10, precision);
	          return func(number * precision) / precision;
	        }
	        return func(number);
	      };
	    }
	
	    /**
	     * Creates a `_.sortedIndex` or `_.sortedLastIndex` function.
	     *
	     * @private
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {Function} Returns the new index function.
	     */
	    function createSortedIndex(retHighest) {
	      return function(array, value, iteratee, thisArg) {
	        var callback = getCallback(iteratee);
	        return (iteratee == null && callback === baseCallback)
	          ? binaryIndex(array, value, retHighest)
	          : binaryIndexBy(array, value, callback(iteratee, thisArg, 1), retHighest);
	      };
	    }
	
	    /**
	     * Creates a function that either curries or invokes `func` with optional
	     * `this` binding and partially applied arguments.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to reference.
	     * @param {number} bitmask The bitmask of flags.
	     *  The bitmask may be composed of the following flags:
	     *     1 - `_.bind`
	     *     2 - `_.bindKey`
	     *     4 - `_.curry` or `_.curryRight` of a bound function
	     *     8 - `_.curry`
	     *    16 - `_.curryRight`
	     *    32 - `_.partial`
	     *    64 - `_.partialRight`
	     *   128 - `_.rearg`
	     *   256 - `_.ary`
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to be partially applied.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
	      var isBindKey = bitmask & BIND_KEY_FLAG;
	      if (!isBindKey && typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var length = partials ? partials.length : 0;
	      if (!length) {
	        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
	        partials = holders = undefined;
	      }
	      length -= (holders ? holders.length : 0);
	      if (bitmask & PARTIAL_RIGHT_FLAG) {
	        var partialsRight = partials,
	            holdersRight = holders;
	
	        partials = holders = undefined;
	      }
	      var data = isBindKey ? undefined : getData(func),
	          newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];
	
	      if (data) {
	        mergeData(newData, data);
	        bitmask = newData[1];
	        arity = newData[9];
	      }
	      newData[9] = arity == null
	        ? (isBindKey ? 0 : func.length)
	        : (nativeMax(arity - length, 0) || 0);
	
	      if (bitmask == BIND_FLAG) {
	        var result = createBindWrapper(newData[0], newData[2]);
	      } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
	        result = createPartialWrapper.apply(undefined, newData);
	      } else {
	        result = createHybridWrapper.apply(undefined, newData);
	      }
	      var setter = data ? baseSetData : setData;
	      return setter(result, newData);
	    }
	
	    /**
	     * A specialized version of `baseIsEqualDeep` for arrays with support for
	     * partial deep comparisons.
	     *
	     * @private
	     * @param {Array} array The array to compare.
	     * @param {Array} other The other array to compare.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Function} [customizer] The function to customize comparing arrays.
	     * @param {boolean} [isLoose] Specify performing partial comparisons.
	     * @param {Array} [stackA] Tracks traversed `value` objects.
	     * @param {Array} [stackB] Tracks traversed `other` objects.
	     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	     */
	    function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
	      var index = -1,
	          arrLength = array.length,
	          othLength = other.length;
	
	      if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
	        return false;
	      }
	      // Ignore non-index properties.
	      while (++index < arrLength) {
	        var arrValue = array[index],
	            othValue = other[index],
	            result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;
	
	        if (result !== undefined) {
	          if (result) {
	            continue;
	          }
	          return false;
	        }
	        // Recursively compare arrays (susceptible to call stack limits).
	        if (isLoose) {
	          if (!arraySome(other, function(othValue) {
	                return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
	              })) {
	            return false;
	          }
	        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
	          return false;
	        }
	      }
	      return true;
	    }
	
	    /**
	     * A specialized version of `baseIsEqualDeep` for comparing objects of
	     * the same `toStringTag`.
	     *
	     * **Note:** This function only supports comparing values with tags of
	     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {string} tag The `toStringTag` of the objects to compare.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function equalByTag(object, other, tag) {
	      switch (tag) {
	        case boolTag:
	        case dateTag:
	          // Coerce dates and booleans to numbers, dates to milliseconds and booleans
	          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
	          return +object == +other;
	
	        case errorTag:
	          return object.name == other.name && object.message == other.message;
	
	        case numberTag:
	          // Treat `NaN` vs. `NaN` as equal.
	          return (object != +object)
	            ? other != +other
	            : object == +other;
	
	        case regexpTag:
	        case stringTag:
	          // Coerce regexes to strings and treat strings primitives and string
	          // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
	          return object == (other + '');
	      }
	      return false;
	    }
	
	    /**
	     * A specialized version of `baseIsEqualDeep` for objects with support for
	     * partial deep comparisons.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Function} [customizer] The function to customize comparing values.
	     * @param {boolean} [isLoose] Specify performing partial comparisons.
	     * @param {Array} [stackA] Tracks traversed `value` objects.
	     * @param {Array} [stackB] Tracks traversed `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
	      var objProps = keys(object),
	          objLength = objProps.length,
	          othProps = keys(other),
	          othLength = othProps.length;
	
	      if (objLength != othLength && !isLoose) {
	        return false;
	      }
	      var index = objLength;
	      while (index--) {
	        var key = objProps[index];
	        if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
	          return false;
	        }
	      }
	      var skipCtor = isLoose;
	      while (++index < objLength) {
	        key = objProps[index];
	        var objValue = object[key],
	            othValue = other[key],
	            result = customizer ? customizer(isLoose ? othValue : objValue, isLoose? objValue : othValue, key) : undefined;
	
	        // Recursively compare objects (susceptible to call stack limits).
	        if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
	          return false;
	        }
	        skipCtor || (skipCtor = key == 'constructor');
	      }
	      if (!skipCtor) {
	        var objCtor = object.constructor,
	            othCtor = other.constructor;
	
	        // Non `Object` object instances with different constructors are not equal.
	        if (objCtor != othCtor &&
	            ('constructor' in object && 'constructor' in other) &&
	            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	          return false;
	        }
	      }
	      return true;
	    }
	
	    /**
	     * Gets the appropriate "callback" function. If the `_.callback` method is
	     * customized this function returns the custom method, otherwise it returns
	     * the `baseCallback` function. If arguments are provided the chosen function
	     * is invoked with them and its result is returned.
	     *
	     * @private
	     * @returns {Function} Returns the chosen function or its result.
	     */
	    function getCallback(func, thisArg, argCount) {
	      var result = lodash.callback || callback;
	      result = result === callback ? baseCallback : result;
	      return argCount ? result(func, thisArg, argCount) : result;
	    }
	
	    /**
	     * Gets metadata for `func`.
	     *
	     * @private
	     * @param {Function} func The function to query.
	     * @returns {*} Returns the metadata for `func`.
	     */
	    var getData = !metaMap ? noop : function(func) {
	      return metaMap.get(func);
	    };
	
	    /**
	     * Gets the name of `func`.
	     *
	     * @private
	     * @param {Function} func The function to query.
	     * @returns {string} Returns the function name.
	     */
	    function getFuncName(func) {
	      var result = func.name,
	          array = realNames[result],
	          length = array ? array.length : 0;
	
	      while (length--) {
	        var data = array[length],
	            otherFunc = data.func;
	        if (otherFunc == null || otherFunc == func) {
	          return data.name;
	        }
	      }
	      return result;
	    }
	
	    /**
	     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
	     * customized this function returns the custom method, otherwise it returns
	     * the `baseIndexOf` function. If arguments are provided the chosen function
	     * is invoked with them and its result is returned.
	     *
	     * @private
	     * @returns {Function|number} Returns the chosen function or its result.
	     */
	    function getIndexOf(collection, target, fromIndex) {
	      var result = lodash.indexOf || indexOf;
	      result = result === indexOf ? baseIndexOf : result;
	      return collection ? result(collection, target, fromIndex) : result;
	    }
	
	    /**
	     * Gets the "length" property value of `object`.
	     *
	     * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
	     * that affects Safari on at least iOS 8.1-8.3 ARM64.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {*} Returns the "length" value.
	     */
	    var getLength = baseProperty('length');
	
	    /**
	     * Gets the propery names, values, and compare flags of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the match data of `object`.
	     */
	    function getMatchData(object) {
	      var result = pairs(object),
	          length = result.length;
	
	      while (length--) {
	        result[length][2] = isStrictComparable(result[length][1]);
	      }
	      return result;
	    }
	
	    /**
	     * Gets the native function at `key` of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {string} key The key of the method to get.
	     * @returns {*} Returns the function if it's native, else `undefined`.
	     */
	    function getNative(object, key) {
	      var value = object == null ? undefined : object[key];
	      return isNative(value) ? value : undefined;
	    }
	
	    /**
	     * Gets the view, applying any `transforms` to the `start` and `end` positions.
	     *
	     * @private
	     * @param {number} start The start of the view.
	     * @param {number} end The end of the view.
	     * @param {Array} transforms The transformations to apply to the view.
	     * @returns {Object} Returns an object containing the `start` and `end`
	     *  positions of the view.
	     */
	    function getView(start, end, transforms) {
	      var index = -1,
	          length = transforms.length;
	
	      while (++index < length) {
	        var data = transforms[index],
	            size = data.size;
	
	        switch (data.type) {
	          case 'drop':      start += size; break;
	          case 'dropRight': end -= size; break;
	          case 'take':      end = nativeMin(end, start + size); break;
	          case 'takeRight': start = nativeMax(start, end - size); break;
	        }
	      }
	      return { 'start': start, 'end': end };
	    }
	
	    /**
	     * Initializes an array clone.
	     *
	     * @private
	     * @param {Array} array The array to clone.
	     * @returns {Array} Returns the initialized clone.
	     */
	    function initCloneArray(array) {
	      var length = array.length,
	          result = new array.constructor(length);
	
	      // Add array properties assigned by `RegExp#exec`.
	      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
	        result.index = array.index;
	        result.input = array.input;
	      }
	      return result;
	    }
	
	    /**
	     * Initializes an object clone.
	     *
	     * @private
	     * @param {Object} object The object to clone.
	     * @returns {Object} Returns the initialized clone.
	     */
	    function initCloneObject(object) {
	      var Ctor = object.constructor;
	      if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
	        Ctor = Object;
	      }
	      return new Ctor;
	    }
	
	    /**
	     * Initializes an object clone based on its `toStringTag`.
	     *
	     * **Note:** This function only supports cloning values with tags of
	     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	     *
	     * @private
	     * @param {Object} object The object to clone.
	     * @param {string} tag The `toStringTag` of the object to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the initialized clone.
	     */
	    function initCloneByTag(object, tag, isDeep) {
	      var Ctor = object.constructor;
	      switch (tag) {
	        case arrayBufferTag:
	          return bufferClone(object);
	
	        case boolTag:
	        case dateTag:
	          return new Ctor(+object);
	
	        case float32Tag: case float64Tag:
	        case int8Tag: case int16Tag: case int32Tag:
	        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
	          var buffer = object.buffer;
	          return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);
	
	        case numberTag:
	        case stringTag:
	          return new Ctor(object);
	
	        case regexpTag:
	          var result = new Ctor(object.source, reFlags.exec(object));
	          result.lastIndex = object.lastIndex;
	      }
	      return result;
	    }
	
	    /**
	     * Invokes the method at `path` on `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {Array} args The arguments to invoke the method with.
	     * @returns {*} Returns the result of the invoked method.
	     */
	    function invokePath(object, path, args) {
	      if (object != null && !isKey(path, object)) {
	        path = toPath(path);
	        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
	        path = last(path);
	      }
	      var func = object == null ? object : object[path];
	      return func == null ? undefined : func.apply(object, args);
	    }
	
	    /**
	     * Checks if `value` is array-like.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	     */
	    function isArrayLike(value) {
	      return value != null && isLength(getLength(value));
	    }
	
	    /**
	     * Checks if `value` is a valid array-like index.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	     */
	    function isIndex(value, length) {
	      value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
	      length = length == null ? MAX_SAFE_INTEGER : length;
	      return value > -1 && value % 1 == 0 && value < length;
	    }
	
	    /**
	     * Checks if the provided arguments are from an iteratee call.
	     *
	     * @private
	     * @param {*} value The potential iteratee value argument.
	     * @param {*} index The potential iteratee index or key argument.
	     * @param {*} object The potential iteratee object argument.
	     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
	     */
	    function isIterateeCall(value, index, object) {
	      if (!isObject(object)) {
	        return false;
	      }
	      var type = typeof index;
	      if (type == 'number'
	          ? (isArrayLike(object) && isIndex(index, object.length))
	          : (type == 'string' && index in object)) {
	        var other = object[index];
	        return value === value ? (value === other) : (other !== other);
	      }
	      return false;
	    }
	
	    /**
	     * Checks if `value` is a property name and not a property path.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @param {Object} [object] The object to query keys on.
	     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	     */
	    function isKey(value, object) {
	      var type = typeof value;
	      if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
	        return true;
	      }
	      if (isArray(value)) {
	        return false;
	      }
	      var result = !reIsDeepProp.test(value);
	      return result || (object != null && value in toObject(object));
	    }
	
	    /**
	     * Checks if `func` has a lazy counterpart.
	     *
	     * @private
	     * @param {Function} func The function to check.
	     * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.
	     */
	    function isLaziable(func) {
	      var funcName = getFuncName(func);
	      if (!(funcName in LazyWrapper.prototype)) {
	        return false;
	      }
	      var other = lodash[funcName];
	      if (func === other) {
	        return true;
	      }
	      var data = getData(other);
	      return !!data && func === data[0];
	    }
	
	    /**
	     * Checks if `value` is a valid array-like length.
	     *
	     * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	     */
	    function isLength(value) {
	      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	    }
	
	    /**
	     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` if suitable for strict
	     *  equality comparisons, else `false`.
	     */
	    function isStrictComparable(value) {
	      return value === value && !isObject(value);
	    }
	
	    /**
	     * Merges the function metadata of `source` into `data`.
	     *
	     * Merging metadata reduces the number of wrappers required to invoke a function.
	     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
	     * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
	     * augment function arguments, making the order in which they are executed important,
	     * preventing the merging of metadata. However, we make an exception for a safe
	     * common case where curried functions have `_.ary` and or `_.rearg` applied.
	     *
	     * @private
	     * @param {Array} data The destination metadata.
	     * @param {Array} source The source metadata.
	     * @returns {Array} Returns `data`.
	     */
	    function mergeData(data, source) {
	      var bitmask = data[1],
	          srcBitmask = source[1],
	          newBitmask = bitmask | srcBitmask,
	          isCommon = newBitmask < ARY_FLAG;
	
	      var isCombo =
	        (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) ||
	        (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) ||
	        (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);
	
	      // Exit early if metadata can't be merged.
	      if (!(isCommon || isCombo)) {
	        return data;
	      }
	      // Use source `thisArg` if available.
	      if (srcBitmask & BIND_FLAG) {
	        data[2] = source[2];
	        // Set when currying a bound function.
	        newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
	      }
	      // Compose partial arguments.
	      var value = source[3];
	      if (value) {
	        var partials = data[3];
	        data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
	        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
	      }
	      // Compose partial right arguments.
	      value = source[5];
	      if (value) {
	        partials = data[5];
	        data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
	        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
	      }
	      // Use source `argPos` if available.
	      value = source[7];
	      if (value) {
	        data[7] = arrayCopy(value);
	      }
	      // Use source `ary` if it's smaller.
	      if (srcBitmask & ARY_FLAG) {
	        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
	      }
	      // Use source `arity` if one is not provided.
	      if (data[9] == null) {
	        data[9] = source[9];
	      }
	      // Use source `func` and merge bitmasks.
	      data[0] = source[0];
	      data[1] = newBitmask;
	
	      return data;
	    }
	
	    /**
	     * Used by `_.defaultsDeep` to customize its `_.merge` use.
	     *
	     * @private
	     * @param {*} objectValue The destination object property value.
	     * @param {*} sourceValue The source object property value.
	     * @returns {*} Returns the value to assign to the destination object.
	     */
	    function mergeDefaults(objectValue, sourceValue) {
	      return objectValue === undefined ? sourceValue : merge(objectValue, sourceValue, mergeDefaults);
	    }
	
	    /**
	     * A specialized version of `_.pick` which picks `object` properties specified
	     * by `props`.
	     *
	     * @private
	     * @param {Object} object The source object.
	     * @param {string[]} props The property names to pick.
	     * @returns {Object} Returns the new object.
	     */
	    function pickByArray(object, props) {
	      object = toObject(object);
	
	      var index = -1,
	          length = props.length,
	          result = {};
	
	      while (++index < length) {
	        var key = props[index];
	        if (key in object) {
	          result[key] = object[key];
	        }
	      }
	      return result;
	    }
	
	    /**
	     * A specialized version of `_.pick` which picks `object` properties `predicate`
	     * returns truthy for.
	     *
	     * @private
	     * @param {Object} object The source object.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {Object} Returns the new object.
	     */
	    function pickByCallback(object, predicate) {
	      var result = {};
	      baseForIn(object, function(value, key, object) {
	        if (predicate(value, key, object)) {
	          result[key] = value;
	        }
	      });
	      return result;
	    }
	
	    /**
	     * Reorder `array` according to the specified indexes where the element at
	     * the first index is assigned as the first element, the element at
	     * the second index is assigned as the second element, and so on.
	     *
	     * @private
	     * @param {Array} array The array to reorder.
	     * @param {Array} indexes The arranged array indexes.
	     * @returns {Array} Returns `array`.
	     */
	    function reorder(array, indexes) {
	      var arrLength = array.length,
	          length = nativeMin(indexes.length, arrLength),
	          oldArray = arrayCopy(array);
	
	      while (length--) {
	        var index = indexes[length];
	        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
	      }
	      return array;
	    }
	
	    /**
	     * Sets metadata for `func`.
	     *
	     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
	     * period of time, it will trip its breaker and transition to an identity function
	     * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
	     * for more details.
	     *
	     * @private
	     * @param {Function} func The function to associate metadata with.
	     * @param {*} data The metadata.
	     * @returns {Function} Returns `func`.
	     */
	    var setData = (function() {
	      var count = 0,
	          lastCalled = 0;
	
	      return function(key, value) {
	        var stamp = now(),
	            remaining = HOT_SPAN - (stamp - lastCalled);
	
	        lastCalled = stamp;
	        if (remaining > 0) {
	          if (++count >= HOT_COUNT) {
	            return key;
	          }
	        } else {
	          count = 0;
	        }
	        return baseSetData(key, value);
	      };
	    }());
	
	    /**
	     * A fallback implementation of `Object.keys` which creates an array of the
	     * own enumerable property names of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */
	    function shimKeys(object) {
	      var props = keysIn(object),
	          propsLength = props.length,
	          length = propsLength && object.length;
	
	      var allowIndexes = !!length && isLength(length) &&
	        (isArray(object) || isArguments(object));
	
	      var index = -1,
	          result = [];
	
	      while (++index < propsLength) {
	        var key = props[index];
	        if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
	          result.push(key);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * Converts `value` to an array-like object if it's not one.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {Array|Object} Returns the array-like object.
	     */
	    function toIterable(value) {
	      if (value == null) {
	        return [];
	      }
	      if (!isArrayLike(value)) {
	        return values(value);
	      }
	      return isObject(value) ? value : Object(value);
	    }
	
	    /**
	     * Converts `value` to an object if it's not one.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {Object} Returns the object.
	     */
	    function toObject(value) {
	      return isObject(value) ? value : Object(value);
	    }
	
	    /**
	     * Converts `value` to property path array if it's not one.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {Array} Returns the property path array.
	     */
	    function toPath(value) {
	      if (isArray(value)) {
	        return value;
	      }
	      var result = [];
	      baseToString(value).replace(rePropName, function(match, number, quote, string) {
	        result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
	      });
	      return result;
	    }
	
	    /**
	     * Creates a clone of `wrapper`.
	     *
	     * @private
	     * @param {Object} wrapper The wrapper to clone.
	     * @returns {Object} Returns the cloned wrapper.
	     */
	    function wrapperClone(wrapper) {
	      return wrapper instanceof LazyWrapper
	        ? wrapper.clone()
	        : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates an array of elements split into groups the length of `size`.
	     * If `collection` can't be split evenly, the final chunk will be the remaining
	     * elements.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to process.
	     * @param {number} [size=1] The length of each chunk.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the new array containing chunks.
	     * @example
	     *
	     * _.chunk(['a', 'b', 'c', 'd'], 2);
	     * // => [['a', 'b'], ['c', 'd']]
	     *
	     * _.chunk(['a', 'b', 'c', 'd'], 3);
	     * // => [['a', 'b', 'c'], ['d']]
	     */
	    function chunk(array, size, guard) {
	      if (guard ? isIterateeCall(array, size, guard) : size == null) {
	        size = 1;
	      } else {
	        size = nativeMax(nativeFloor(size) || 1, 1);
	      }
	      var index = 0,
	          length = array ? array.length : 0,
	          resIndex = -1,
	          result = Array(nativeCeil(length / size));
	
	      while (index < length) {
	        result[++resIndex] = baseSlice(array, index, (index += size));
	      }
	      return result;
	    }
	
	    /**
	     * Creates an array with all falsey values removed. The values `false`, `null`,
	     * `0`, `""`, `undefined`, and `NaN` are falsey.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to compact.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.compact([0, 1, false, 2, '', 3]);
	     * // => [1, 2, 3]
	     */
	    function compact(array) {
	      var index = -1,
	          length = array ? array.length : 0,
	          resIndex = -1,
	          result = [];
	
	      while (++index < length) {
	        var value = array[index];
	        if (value) {
	          result[++resIndex] = value;
	        }
	      }
	      return result;
	    }
	
	    /**
	     * Creates an array of unique `array` values not included in the other
	     * provided arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The arrays of values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.difference([1, 2, 3], [4, 2]);
	     * // => [1, 3]
	     */
	    var difference = restParam(function(array, values) {
	      return (isObjectLike(array) && isArrayLike(array))
	        ? baseDifference(array, baseFlatten(values, false, true))
	        : [];
	    });
	
	    /**
	     * Creates a slice of `array` with `n` elements dropped from the beginning.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to drop.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.drop([1, 2, 3]);
	     * // => [2, 3]
	     *
	     * _.drop([1, 2, 3], 2);
	     * // => [3]
	     *
	     * _.drop([1, 2, 3], 5);
	     * // => []
	     *
	     * _.drop([1, 2, 3], 0);
	     * // => [1, 2, 3]
	     */
	    function drop(array, n, guard) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (guard ? isIterateeCall(array, n, guard) : n == null) {
	        n = 1;
	      }
	      return baseSlice(array, n < 0 ? 0 : n);
	    }
	
	    /**
	     * Creates a slice of `array` with `n` elements dropped from the end.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to drop.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.dropRight([1, 2, 3]);
	     * // => [1, 2]
	     *
	     * _.dropRight([1, 2, 3], 2);
	     * // => [1]
	     *
	     * _.dropRight([1, 2, 3], 5);
	     * // => []
	     *
	     * _.dropRight([1, 2, 3], 0);
	     * // => [1, 2, 3]
	     */
	    function dropRight(array, n, guard) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (guard ? isIterateeCall(array, n, guard) : n == null) {
	        n = 1;
	      }
	      n = length - (+n || 0);
	      return baseSlice(array, 0, n < 0 ? 0 : n);
	    }
	
	    /**
	     * Creates a slice of `array` excluding elements dropped from the end.
	     * Elements are dropped until `predicate` returns falsey. The predicate is
	     * bound to `thisArg` and invoked with three arguments: (value, index, array).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that match the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.dropRightWhile([1, 2, 3], function(n) {
	     *   return n > 1;
	     * });
	     * // => [1]
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.pluck(_.dropRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
	     * // => ['barney', 'fred']
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.pluck(_.dropRightWhile(users, 'active', false), 'user');
	     * // => ['barney']
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.dropRightWhile(users, 'active'), 'user');
	     * // => ['barney', 'fred', 'pebbles']
	     */
	    function dropRightWhile(array, predicate, thisArg) {
	      return (array && array.length)
	        ? baseWhile(array, getCallback(predicate, thisArg, 3), true, true)
	        : [];
	    }
	
	    /**
	     * Creates a slice of `array` excluding elements dropped from the beginning.
	     * Elements are dropped until `predicate` returns falsey. The predicate is
	     * bound to `thisArg` and invoked with three arguments: (value, index, array).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.dropWhile([1, 2, 3], function(n) {
	     *   return n < 3;
	     * });
	     * // => [3]
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.pluck(_.dropWhile(users, { 'user': 'barney', 'active': false }), 'user');
	     * // => ['fred', 'pebbles']
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.pluck(_.dropWhile(users, 'active', false), 'user');
	     * // => ['pebbles']
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.dropWhile(users, 'active'), 'user');
	     * // => ['barney', 'fred', 'pebbles']
	     */
	    function dropWhile(array, predicate, thisArg) {
	      return (array && array.length)
	        ? baseWhile(array, getCallback(predicate, thisArg, 3), true)
	        : [];
	    }
	
	    /**
	     * Fills elements of `array` with `value` from `start` up to, but not
	     * including, `end`.
	     *
	     * **Note:** This method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to fill.
	     * @param {*} value The value to fill `array` with.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _.fill(array, 'a');
	     * console.log(array);
	     * // => ['a', 'a', 'a']
	     *
	     * _.fill(Array(3), 2);
	     * // => [2, 2, 2]
	     *
	     * _.fill([4, 6, 8], '*', 1, 2);
	     * // => [4, '*', 8]
	     */
	    function fill(array, value, start, end) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
	        start = 0;
	        end = length;
	      }
	      return baseFill(array, value, start, end);
	    }
	
	    /**
	     * This method is like `_.find` except that it returns the index of the first
	     * element `predicate` returns truthy for instead of the element itself.
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.findIndex(users, function(chr) {
	     *   return chr.user == 'barney';
	     * });
	     * // => 0
	     *
	     * // using the `_.matches` callback shorthand
	     * _.findIndex(users, { 'user': 'fred', 'active': false });
	     * // => 1
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.findIndex(users, 'active', false);
	     * // => 0
	     *
	     * // using the `_.property` callback shorthand
	     * _.findIndex(users, 'active');
	     * // => 2
	     */
	    var findIndex = createFindIndex();
	
	    /**
	     * This method is like `_.findIndex` except that it iterates over elements
	     * of `collection` from right to left.
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.findLastIndex(users, function(chr) {
	     *   return chr.user == 'pebbles';
	     * });
	     * // => 2
	     *
	     * // using the `_.matches` callback shorthand
	     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
	     * // => 0
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.findLastIndex(users, 'active', false);
	     * // => 2
	     *
	     * // using the `_.property` callback shorthand
	     * _.findLastIndex(users, 'active');
	     * // => 0
	     */
	    var findLastIndex = createFindIndex(true);
	
	    /**
	     * Gets the first element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @alias head
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {*} Returns the first element of `array`.
	     * @example
	     *
	     * _.first([1, 2, 3]);
	     * // => 1
	     *
	     * _.first([]);
	     * // => undefined
	     */
	    function first(array) {
	      return array ? array[0] : undefined;
	    }
	
	    /**
	     * Flattens a nested array. If `isDeep` is `true` the array is recursively
	     * flattened, otherwise it is only flattened a single level.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @param {boolean} [isDeep] Specify a deep flatten.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * _.flatten([1, [2, 3, [4]]]);
	     * // => [1, 2, 3, [4]]
	     *
	     * // using `isDeep`
	     * _.flatten([1, [2, 3, [4]]], true);
	     * // => [1, 2, 3, 4]
	     */
	    function flatten(array, isDeep, guard) {
	      var length = array ? array.length : 0;
	      if (guard && isIterateeCall(array, isDeep, guard)) {
	        isDeep = false;
	      }
	      return length ? baseFlatten(array, isDeep) : [];
	    }
	
	    /**
	     * Recursively flattens a nested array.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to recursively flatten.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * _.flattenDeep([1, [2, 3, [4]]]);
	     * // => [1, 2, 3, 4]
	     */
	    function flattenDeep(array) {
	      var length = array ? array.length : 0;
	      return length ? baseFlatten(array, true) : [];
	    }
	
	    /**
	     * Gets the index at which the first occurrence of `value` is found in `array`
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons. If `fromIndex` is negative, it is used as the offset
	     * from the end of `array`. If `array` is sorted providing `true` for `fromIndex`
	     * performs a faster binary search.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {*} value The value to search for.
	     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
	     *  to perform a binary search on a sorted array.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.indexOf([1, 2, 1, 2], 2);
	     * // => 1
	     *
	     * // using `fromIndex`
	     * _.indexOf([1, 2, 1, 2], 2, 2);
	     * // => 3
	     *
	     * // performing a binary search
	     * _.indexOf([1, 1, 2, 2], 2, true);
	     * // => 2
	     */
	    function indexOf(array, value, fromIndex) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return -1;
	      }
	      if (typeof fromIndex == 'number') {
	        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
	      } else if (fromIndex) {
	        var index = binaryIndex(array, value);
	        if (index < length &&
	            (value === value ? (value === array[index]) : (array[index] !== array[index]))) {
	          return index;
	        }
	        return -1;
	      }
	      return baseIndexOf(array, value, fromIndex || 0);
	    }
	
	    /**
	     * Gets all but the last element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.initial([1, 2, 3]);
	     * // => [1, 2]
	     */
	    function initial(array) {
	      return dropRight(array, 1);
	    }
	
	    /**
	     * Creates an array of unique values that are included in all of the provided
	     * arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of shared values.
	     * @example
	     * _.intersection([1, 2], [4, 2], [2, 1]);
	     * // => [2]
	     */
	    var intersection = restParam(function(arrays) {
	      var othLength = arrays.length,
	          othIndex = othLength,
	          caches = Array(length),
	          indexOf = getIndexOf(),
	          isCommon = indexOf == baseIndexOf,
	          result = [];
	
	      while (othIndex--) {
	        var value = arrays[othIndex] = isArrayLike(value = arrays[othIndex]) ? value : [];
	        caches[othIndex] = (isCommon && value.length >= 120) ? createCache(othIndex && value) : null;
	      }
	      var array = arrays[0],
	          index = -1,
	          length = array ? array.length : 0,
	          seen = caches[0];
	
	      outer:
	      while (++index < length) {
	        value = array[index];
	        if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
	          var othIndex = othLength;
	          while (--othIndex) {
	            var cache = caches[othIndex];
	            if ((cache ? cacheIndexOf(cache, value) : indexOf(arrays[othIndex], value, 0)) < 0) {
	              continue outer;
	            }
	          }
	          if (seen) {
	            seen.push(value);
	          }
	          result.push(value);
	        }
	      }
	      return result;
	    });
	
	    /**
	     * Gets the last element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {*} Returns the last element of `array`.
	     * @example
	     *
	     * _.last([1, 2, 3]);
	     * // => 3
	     */
	    function last(array) {
	      var length = array ? array.length : 0;
	      return length ? array[length - 1] : undefined;
	    }
	
	    /**
	     * This method is like `_.indexOf` except that it iterates over elements of
	     * `array` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {*} value The value to search for.
	     * @param {boolean|number} [fromIndex=array.length-1] The index to search from
	     *  or `true` to perform a binary search on a sorted array.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.lastIndexOf([1, 2, 1, 2], 2);
	     * // => 3
	     *
	     * // using `fromIndex`
	     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
	     * // => 1
	     *
	     * // performing a binary search
	     * _.lastIndexOf([1, 1, 2, 2], 2, true);
	     * // => 3
	     */
	    function lastIndexOf(array, value, fromIndex) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return -1;
	      }
	      var index = length;
	      if (typeof fromIndex == 'number') {
	        index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
	      } else if (fromIndex) {
	        index = binaryIndex(array, value, true) - 1;
	        var other = array[index];
	        if (value === value ? (value === other) : (other !== other)) {
	          return index;
	        }
	        return -1;
	      }
	      if (value !== value) {
	        return indexOfNaN(array, index, true);
	      }
	      while (index--) {
	        if (array[index] === value) {
	          return index;
	        }
	      }
	      return -1;
	    }
	
	    /**
	     * Removes all provided values from `array` using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * **Note:** Unlike `_.without`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {...*} [values] The values to remove.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3, 1, 2, 3];
	     *
	     * _.pull(array, 2, 3);
	     * console.log(array);
	     * // => [1, 1]
	     */
	    function pull() {
	      var args = arguments,
	          array = args[0];
	
	      if (!(array && array.length)) {
	        return array;
	      }
	      var index = 0,
	          indexOf = getIndexOf(),
	          length = args.length;
	
	      while (++index < length) {
	        var fromIndex = 0,
	            value = args[index];
	
	        while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
	          splice.call(array, fromIndex, 1);
	        }
	      }
	      return array;
	    }
	
	    /**
	     * Removes elements from `array` corresponding to the given indexes and returns
	     * an array of the removed elements. Indexes may be specified as an array of
	     * indexes or as individual arguments.
	     *
	     * **Note:** Unlike `_.at`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {...(number|number[])} [indexes] The indexes of elements to remove,
	     *  specified as individual indexes or arrays of indexes.
	     * @returns {Array} Returns the new array of removed elements.
	     * @example
	     *
	     * var array = [5, 10, 15, 20];
	     * var evens = _.pullAt(array, 1, 3);
	     *
	     * console.log(array);
	     * // => [5, 15]
	     *
	     * console.log(evens);
	     * // => [10, 20]
	     */
	    var pullAt = restParam(function(array, indexes) {
	      indexes = baseFlatten(indexes);
	
	      var result = baseAt(array, indexes);
	      basePullAt(array, indexes.sort(baseCompareAscending));
	      return result;
	    });
	
	    /**
	     * Removes all elements from `array` that `predicate` returns truthy for
	     * and returns an array of the removed elements. The predicate is bound to
	     * `thisArg` and invoked with three arguments: (value, index, array).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * **Note:** Unlike `_.filter`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the new array of removed elements.
	     * @example
	     *
	     * var array = [1, 2, 3, 4];
	     * var evens = _.remove(array, function(n) {
	     *   return n % 2 == 0;
	     * });
	     *
	     * console.log(array);
	     * // => [1, 3]
	     *
	     * console.log(evens);
	     * // => [2, 4]
	     */
	    function remove(array, predicate, thisArg) {
	      var result = [];
	      if (!(array && array.length)) {
	        return result;
	      }
	      var index = -1,
	          indexes = [],
	          length = array.length;
	
	      predicate = getCallback(predicate, thisArg, 3);
	      while (++index < length) {
	        var value = array[index];
	        if (predicate(value, index, array)) {
	          result.push(value);
	          indexes.push(index);
	        }
	      }
	      basePullAt(array, indexes);
	      return result;
	    }
	
	    /**
	     * Gets all but the first element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @alias tail
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.rest([1, 2, 3]);
	     * // => [2, 3]
	     */
	    function rest(array) {
	      return drop(array, 1);
	    }
	
	    /**
	     * Creates a slice of `array` from `start` up to, but not including, `end`.
	     *
	     * **Note:** This method is used instead of `Array#slice` to support node
	     * lists in IE < 9 and to ensure dense arrays are returned.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to slice.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function slice(array, start, end) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
	        start = 0;
	        end = length;
	      }
	      return baseSlice(array, start, end);
	    }
	
	    /**
	     * Uses a binary search to determine the lowest index at which `value` should
	     * be inserted into `array` in order to maintain its sort order. If an iteratee
	     * function is provided it is invoked for `value` and each element of `array`
	     * to compute their sort ranking. The iteratee is bound to `thisArg` and
	     * invoked with one argument; (value).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedIndex([30, 50], 40);
	     * // => 1
	     *
	     * _.sortedIndex([4, 4, 5, 5], 5);
	     * // => 2
	     *
	     * var dict = { 'data': { 'thirty': 30, 'forty': 40, 'fifty': 50 } };
	     *
	     * // using an iteratee function
	     * _.sortedIndex(['thirty', 'fifty'], 'forty', function(word) {
	     *   return this.data[word];
	     * }, dict);
	     * // => 1
	     *
	     * // using the `_.property` callback shorthand
	     * _.sortedIndex([{ 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
	     * // => 1
	     */
	    var sortedIndex = createSortedIndex();
	
	    /**
	     * This method is like `_.sortedIndex` except that it returns the highest
	     * index at which `value` should be inserted into `array` in order to
	     * maintain its sort order.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedLastIndex([4, 4, 5, 5], 5);
	     * // => 4
	     */
	    var sortedLastIndex = createSortedIndex(true);
	
	    /**
	     * Creates a slice of `array` with `n` elements taken from the beginning.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to take.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.take([1, 2, 3]);
	     * // => [1]
	     *
	     * _.take([1, 2, 3], 2);
	     * // => [1, 2]
	     *
	     * _.take([1, 2, 3], 5);
	     * // => [1, 2, 3]
	     *
	     * _.take([1, 2, 3], 0);
	     * // => []
	     */
	    function take(array, n, guard) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (guard ? isIterateeCall(array, n, guard) : n == null) {
	        n = 1;
	      }
	      return baseSlice(array, 0, n < 0 ? 0 : n);
	    }
	
	    /**
	     * Creates a slice of `array` with `n` elements taken from the end.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to take.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.takeRight([1, 2, 3]);
	     * // => [3]
	     *
	     * _.takeRight([1, 2, 3], 2);
	     * // => [2, 3]
	     *
	     * _.takeRight([1, 2, 3], 5);
	     * // => [1, 2, 3]
	     *
	     * _.takeRight([1, 2, 3], 0);
	     * // => []
	     */
	    function takeRight(array, n, guard) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (guard ? isIterateeCall(array, n, guard) : n == null) {
	        n = 1;
	      }
	      n = length - (+n || 0);
	      return baseSlice(array, n < 0 ? 0 : n);
	    }
	
	    /**
	     * Creates a slice of `array` with elements taken from the end. Elements are
	     * taken until `predicate` returns falsey. The predicate is bound to `thisArg`
	     * and invoked with three arguments: (value, index, array).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.takeRightWhile([1, 2, 3], function(n) {
	     *   return n > 1;
	     * });
	     * // => [2, 3]
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.pluck(_.takeRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
	     * // => ['pebbles']
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.pluck(_.takeRightWhile(users, 'active', false), 'user');
	     * // => ['fred', 'pebbles']
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.takeRightWhile(users, 'active'), 'user');
	     * // => []
	     */
	    function takeRightWhile(array, predicate, thisArg) {
	      return (array && array.length)
	        ? baseWhile(array, getCallback(predicate, thisArg, 3), false, true)
	        : [];
	    }
	
	    /**
	     * Creates a slice of `array` with elements taken from the beginning. Elements
	     * are taken until `predicate` returns falsey. The predicate is bound to
	     * `thisArg` and invoked with three arguments: (value, index, array).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.takeWhile([1, 2, 3], function(n) {
	     *   return n < 3;
	     * });
	     * // => [1, 2]
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false},
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.pluck(_.takeWhile(users, { 'user': 'barney', 'active': false }), 'user');
	     * // => ['barney']
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.pluck(_.takeWhile(users, 'active', false), 'user');
	     * // => ['barney', 'fred']
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.takeWhile(users, 'active'), 'user');
	     * // => []
	     */
	    function takeWhile(array, predicate, thisArg) {
	      return (array && array.length)
	        ? baseWhile(array, getCallback(predicate, thisArg, 3))
	        : [];
	    }
	
	    /**
	     * Creates an array of unique values, in order, from all of the provided arrays
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * _.union([1, 2], [4, 2], [2, 1]);
	     * // => [1, 2, 4]
	     */
	    var union = restParam(function(arrays) {
	      return baseUniq(baseFlatten(arrays, false, true));
	    });
	
	    /**
	     * Creates a duplicate-free version of an array, using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons, in which only the first occurence of each element
	     * is kept. Providing `true` for `isSorted` performs a faster search algorithm
	     * for sorted arrays. If an iteratee function is provided it is invoked for
	     * each element in the array to generate the criterion by which uniqueness
	     * is computed. The `iteratee` is bound to `thisArg` and invoked with three
	     * arguments: (value, index, array).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias unique
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {boolean} [isSorted] Specify the array is sorted.
	     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the new duplicate-value-free array.
	     * @example
	     *
	     * _.uniq([2, 1, 2]);
	     * // => [2, 1]
	     *
	     * // using `isSorted`
	     * _.uniq([1, 1, 2], true);
	     * // => [1, 2]
	     *
	     * // using an iteratee function
	     * _.uniq([1, 2.5, 1.5, 2], function(n) {
	     *   return this.floor(n);
	     * }, Math);
	     * // => [1, 2.5]
	     *
	     * // using the `_.property` callback shorthand
	     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }, { 'x': 2 }]
	     */
	    function uniq(array, isSorted, iteratee, thisArg) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (isSorted != null && typeof isSorted != 'boolean') {
	        thisArg = iteratee;
	        iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;
	        isSorted = false;
	      }
	      var callback = getCallback();
	      if (!(iteratee == null && callback === baseCallback)) {
	        iteratee = callback(iteratee, thisArg, 3);
	      }
	      return (isSorted && getIndexOf() == baseIndexOf)
	        ? sortedUniq(array, iteratee)
	        : baseUniq(array, iteratee);
	    }
	
	    /**
	     * This method is like `_.zip` except that it accepts an array of grouped
	     * elements and creates an array regrouping the elements to their pre-zip
	     * configuration.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array of grouped elements to process.
	     * @returns {Array} Returns the new array of regrouped elements.
	     * @example
	     *
	     * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
	     * // => [['fred', 30, true], ['barney', 40, false]]
	     *
	     * _.unzip(zipped);
	     * // => [['fred', 'barney'], [30, 40], [true, false]]
	     */
	    function unzip(array) {
	      if (!(array && array.length)) {
	        return [];
	      }
	      var index = -1,
	          length = 0;
	
	      array = arrayFilter(array, function(group) {
	        if (isArrayLike(group)) {
	          length = nativeMax(group.length, length);
	          return true;
	        }
	      });
	      var result = Array(length);
	      while (++index < length) {
	        result[index] = arrayMap(array, baseProperty(index));
	      }
	      return result;
	    }
	
	    /**
	     * This method is like `_.unzip` except that it accepts an iteratee to specify
	     * how regrouped values should be combined. The `iteratee` is bound to `thisArg`
	     * and invoked with four arguments: (accumulator, value, index, group).
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array of grouped elements to process.
	     * @param {Function} [iteratee] The function to combine regrouped values.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the new array of regrouped elements.
	     * @example
	     *
	     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
	     * // => [[1, 10, 100], [2, 20, 200]]
	     *
	     * _.unzipWith(zipped, _.add);
	     * // => [3, 30, 300]
	     */
	    function unzipWith(array, iteratee, thisArg) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      var result = unzip(array);
	      if (iteratee == null) {
	        return result;
	      }
	      iteratee = bindCallback(iteratee, thisArg, 4);
	      return arrayMap(result, function(group) {
	        return arrayReduce(group, iteratee, undefined, true);
	      });
	    }
	
	    /**
	     * Creates an array excluding all provided values using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to filter.
	     * @param {...*} [values] The values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.without([1, 2, 1, 3], 1, 2);
	     * // => [3]
	     */
	    var without = restParam(function(array, values) {
	      return isArrayLike(array)
	        ? baseDifference(array, values)
	        : [];
	    });
	
	    /**
	     * Creates an array of unique values that is the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
	     * of the provided arrays.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of values.
	     * @example
	     *
	     * _.xor([1, 2], [4, 2]);
	     * // => [1, 4]
	     */
	    function xor() {
	      var index = -1,
	          length = arguments.length;
	
	      while (++index < length) {
	        var array = arguments[index];
	        if (isArrayLike(array)) {
	          var result = result
	            ? arrayPush(baseDifference(result, array), baseDifference(array, result))
	            : array;
	        }
	      }
	      return result ? baseUniq(result) : [];
	    }
	
	    /**
	     * Creates an array of grouped elements, the first of which contains the first
	     * elements of the given arrays, the second of which contains the second elements
	     * of the given arrays, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to process.
	     * @returns {Array} Returns the new array of grouped elements.
	     * @example
	     *
	     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
	     * // => [['fred', 30, true], ['barney', 40, false]]
	     */
	    var zip = restParam(unzip);
	
	    /**
	     * The inverse of `_.pairs`; this method returns an object composed from arrays
	     * of property names and values. Provide either a single two dimensional array,
	     * e.g. `[[key1, value1], [key2, value2]]` or two arrays, one of property names
	     * and one of corresponding values.
	     *
	     * @static
	     * @memberOf _
	     * @alias object
	     * @category Array
	     * @param {Array} props The property names.
	     * @param {Array} [values=[]] The property values.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.zipObject([['fred', 30], ['barney', 40]]);
	     * // => { 'fred': 30, 'barney': 40 }
	     *
	     * _.zipObject(['fred', 'barney'], [30, 40]);
	     * // => { 'fred': 30, 'barney': 40 }
	     */
	    function zipObject(props, values) {
	      var index = -1,
	          length = props ? props.length : 0,
	          result = {};
	
	      if (length && !values && !isArray(props[0])) {
	        values = [];
	      }
	      while (++index < length) {
	        var key = props[index];
	        if (values) {
	          result[key] = values[index];
	        } else if (key) {
	          result[key[0]] = key[1];
	        }
	      }
	      return result;
	    }
	
	    /**
	     * This method is like `_.zip` except that it accepts an iteratee to specify
	     * how grouped values should be combined. The `iteratee` is bound to `thisArg`
	     * and invoked with four arguments: (accumulator, value, index, group).
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to process.
	     * @param {Function} [iteratee] The function to combine grouped values.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the new array of grouped elements.
	     * @example
	     *
	     * _.zipWith([1, 2], [10, 20], [100, 200], _.add);
	     * // => [111, 222]
	     */
	    var zipWith = restParam(function(arrays) {
	      var length = arrays.length,
	          iteratee = length > 2 ? arrays[length - 2] : undefined,
	          thisArg = length > 1 ? arrays[length - 1] : undefined;
	
	      if (length > 2 && typeof iteratee == 'function') {
	        length -= 2;
	      } else {
	        iteratee = (length > 1 && typeof thisArg == 'function') ? (--length, thisArg) : undefined;
	        thisArg = undefined;
	      }
	      arrays.length = length;
	      return unzipWith(arrays, iteratee, thisArg);
	    });
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates a `lodash` object that wraps `value` with explicit method
	     * chaining enabled.
	     *
	     * @static
	     * @memberOf _
	     * @category Chain
	     * @param {*} value The value to wrap.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36 },
	     *   { 'user': 'fred',    'age': 40 },
	     *   { 'user': 'pebbles', 'age': 1 }
	     * ];
	     *
	     * var youngest = _.chain(users)
	     *   .sortBy('age')
	     *   .map(function(chr) {
	     *     return chr.user + ' is ' + chr.age;
	     *   })
	     *   .first()
	     *   .value();
	     * // => 'pebbles is 1'
	     */
	    function chain(value) {
	      var result = lodash(value);
	      result.__chain__ = true;
	      return result;
	    }
	
	    /**
	     * This method invokes `interceptor` and returns `value`. The interceptor is
	     * bound to `thisArg` and invoked with one argument; (value). The purpose of
	     * this method is to "tap into" a method chain in order to perform operations
	     * on intermediate results within the chain.
	     *
	     * @static
	     * @memberOf _
	     * @category Chain
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @param {*} [thisArg] The `this` binding of `interceptor`.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * _([1, 2, 3])
	     *  .tap(function(array) {
	     *    array.pop();
	     *  })
	     *  .reverse()
	     *  .value();
	     * // => [2, 1]
	     */
	    function tap(value, interceptor, thisArg) {
	      interceptor.call(thisArg, value);
	      return value;
	    }
	
	    /**
	     * This method is like `_.tap` except that it returns the result of `interceptor`.
	     *
	     * @static
	     * @memberOf _
	     * @category Chain
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @param {*} [thisArg] The `this` binding of `interceptor`.
	     * @returns {*} Returns the result of `interceptor`.
	     * @example
	     *
	     * _('  abc  ')
	     *  .chain()
	     *  .trim()
	     *  .thru(function(value) {
	     *    return [value];
	     *  })
	     *  .value();
	     * // => ['abc']
	     */
	    function thru(value, interceptor, thisArg) {
	      return interceptor.call(thisArg, value);
	    }
	
	    /**
	     * Enables explicit method chaining on the wrapper object.
	     *
	     * @name chain
	     * @memberOf _
	     * @category Chain
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * // without explicit chaining
	     * _(users).first();
	     * // => { 'user': 'barney', 'age': 36 }
	     *
	     * // with explicit chaining
	     * _(users).chain()
	     *   .first()
	     *   .pick('user')
	     *   .value();
	     * // => { 'user': 'barney' }
	     */
	    function wrapperChain() {
	      return chain(this);
	    }
	
	    /**
	     * Executes the chained sequence and returns the wrapped result.
	     *
	     * @name commit
	     * @memberOf _
	     * @category Chain
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2];
	     * var wrapped = _(array).push(3);
	     *
	     * console.log(array);
	     * // => [1, 2]
	     *
	     * wrapped = wrapped.commit();
	     * console.log(array);
	     * // => [1, 2, 3]
	     *
	     * wrapped.last();
	     * // => 3
	     *
	     * console.log(array);
	     * // => [1, 2, 3]
	     */
	    function wrapperCommit() {
	      return new LodashWrapper(this.value(), this.__chain__);
	    }
	
	    /**
	     * Creates a new array joining a wrapped array with any additional arrays
	     * and/or values.
	     *
	     * @name concat
	     * @memberOf _
	     * @category Chain
	     * @param {...*} [values] The values to concatenate.
	     * @returns {Array} Returns the new concatenated array.
	     * @example
	     *
	     * var array = [1];
	     * var wrapped = _(array).concat(2, [3], [[4]]);
	     *
	     * console.log(wrapped.value());
	     * // => [1, 2, 3, [4]]
	     *
	     * console.log(array);
	     * // => [1]
	     */
	    var wrapperConcat = restParam(function(values) {
	      values = baseFlatten(values);
	      return this.thru(function(array) {
	        return arrayConcat(isArray(array) ? array : [toObject(array)], values);
	      });
	    });
	
	    /**
	     * Creates a clone of the chained sequence planting `value` as the wrapped value.
	     *
	     * @name plant
	     * @memberOf _
	     * @category Chain
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2];
	     * var wrapped = _(array).map(function(value) {
	     *   return Math.pow(value, 2);
	     * });
	     *
	     * var other = [3, 4];
	     * var otherWrapped = wrapped.plant(other);
	     *
	     * otherWrapped.value();
	     * // => [9, 16]
	     *
	     * wrapped.value();
	     * // => [1, 4]
	     */
	    function wrapperPlant(value) {
	      var result,
	          parent = this;
	
	      while (parent instanceof baseLodash) {
	        var clone = wrapperClone(parent);
	        if (result) {
	          previous.__wrapped__ = clone;
	        } else {
	          result = clone;
	        }
	        var previous = clone;
	        parent = parent.__wrapped__;
	      }
	      previous.__wrapped__ = value;
	      return result;
	    }
	
	    /**
	     * Reverses the wrapped array so the first element becomes the last, the
	     * second element becomes the second to last, and so on.
	     *
	     * **Note:** This method mutates the wrapped array.
	     *
	     * @name reverse
	     * @memberOf _
	     * @category Chain
	     * @returns {Object} Returns the new reversed `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _(array).reverse().value()
	     * // => [3, 2, 1]
	     *
	     * console.log(array);
	     * // => [3, 2, 1]
	     */
	    function wrapperReverse() {
	      var value = this.__wrapped__;
	
	      var interceptor = function(value) {
	        return (wrapped && wrapped.__dir__ < 0) ? value : value.reverse();
	      };
	      if (value instanceof LazyWrapper) {
	        var wrapped = value;
	        if (this.__actions__.length) {
	          wrapped = new LazyWrapper(this);
	        }
	        wrapped = wrapped.reverse();
	        wrapped.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
	        return new LodashWrapper(wrapped, this.__chain__);
	      }
	      return this.thru(interceptor);
	    }
	
	    /**
	     * Produces the result of coercing the unwrapped value to a string.
	     *
	     * @name toString
	     * @memberOf _
	     * @category Chain
	     * @returns {string} Returns the coerced string value.
	     * @example
	     *
	     * _([1, 2, 3]).toString();
	     * // => '1,2,3'
	     */
	    function wrapperToString() {
	      return (this.value() + '');
	    }
	
	    /**
	     * Executes the chained sequence to extract the unwrapped value.
	     *
	     * @name value
	     * @memberOf _
	     * @alias run, toJSON, valueOf
	     * @category Chain
	     * @returns {*} Returns the resolved unwrapped value.
	     * @example
	     *
	     * _([1, 2, 3]).value();
	     * // => [1, 2, 3]
	     */
	    function wrapperValue() {
	      return baseWrapperValue(this.__wrapped__, this.__actions__);
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates an array of elements corresponding to the given keys, or indexes,
	     * of `collection`. Keys may be specified as individual arguments or as arrays
	     * of keys.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {...(number|number[]|string|string[])} [props] The property names
	     *  or indexes of elements to pick, specified individually or in arrays.
	     * @returns {Array} Returns the new array of picked elements.
	     * @example
	     *
	     * _.at(['a', 'b', 'c'], [0, 2]);
	     * // => ['a', 'c']
	     *
	     * _.at(['barney', 'fred', 'pebbles'], 0, 2);
	     * // => ['barney', 'pebbles']
	     */
	    var at = restParam(function(collection, props) {
	      return baseAt(collection, baseFlatten(props));
	    });
	
	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` through `iteratee`. The corresponding value
	     * of each key is the number of times the key was returned by `iteratee`.
	     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.countBy([4.3, 6.1, 6.4], function(n) {
	     *   return Math.floor(n);
	     * });
	     * // => { '4': 1, '6': 2 }
	     *
	     * _.countBy([4.3, 6.1, 6.4], function(n) {
	     *   return this.floor(n);
	     * }, Math);
	     * // => { '4': 1, '6': 2 }
	     *
	     * _.countBy(['one', 'two', 'three'], 'length');
	     * // => { '3': 2, '5': 1 }
	     */
	    var countBy = createAggregator(function(result, value, key) {
	      hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
	    });
	
	    /**
	     * Checks if `predicate` returns truthy for **all** elements of `collection`.
	     * The predicate is bound to `thisArg` and invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias all
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`.
	     * @example
	     *
	     * _.every([true, 1, null, 'yes'], Boolean);
	     * // => false
	     *
	     * var users = [
	     *   { 'user': 'barney', 'active': false },
	     *   { 'user': 'fred',   'active': false }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.every(users, { 'user': 'barney', 'active': false });
	     * // => false
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.every(users, 'active', false);
	     * // => true
	     *
	     * // using the `_.property` callback shorthand
	     * _.every(users, 'active');
	     * // => false
	     */
	    function every(collection, predicate, thisArg) {
	      var func = isArray(collection) ? arrayEvery : baseEvery;
	      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
	        predicate = undefined;
	      }
	      if (typeof predicate != 'function' || thisArg !== undefined) {
	        predicate = getCallback(predicate, thisArg, 3);
	      }
	      return func(collection, predicate);
	    }
	
	    /**
	     * Iterates over elements of `collection`, returning an array of all elements
	     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
	     * invoked with three arguments: (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias select
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the new filtered array.
	     * @example
	     *
	     * _.filter([4, 5, 6], function(n) {
	     *   return n % 2 == 0;
	     * });
	     * // => [4, 6]
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');
	     * // => ['barney']
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.pluck(_.filter(users, 'active', false), 'user');
	     * // => ['fred']
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.filter(users, 'active'), 'user');
	     * // => ['barney']
	     */
	    function filter(collection, predicate, thisArg) {
	      var func = isArray(collection) ? arrayFilter : baseFilter;
	      predicate = getCallback(predicate, thisArg, 3);
	      return func(collection, predicate);
	    }
	
	    /**
	     * Iterates over elements of `collection`, returning the first element
	     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
	     * invoked with three arguments: (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias detect
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': true },
	     *   { 'user': 'fred',    'age': 40, 'active': false },
	     *   { 'user': 'pebbles', 'age': 1,  'active': true }
	     * ];
	     *
	     * _.result(_.find(users, function(chr) {
	     *   return chr.age < 40;
	     * }), 'user');
	     * // => 'barney'
	     *
	     * // using the `_.matches` callback shorthand
	     * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');
	     * // => 'pebbles'
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.result(_.find(users, 'active', false), 'user');
	     * // => 'fred'
	     *
	     * // using the `_.property` callback shorthand
	     * _.result(_.find(users, 'active'), 'user');
	     * // => 'barney'
	     */
	    var find = createFind(baseEach);
	
	    /**
	     * This method is like `_.find` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * _.findLast([1, 2, 3, 4], function(n) {
	     *   return n % 2 == 1;
	     * });
	     * // => 3
	     */
	    var findLast = createFind(baseEachRight, true);
	
	    /**
	     * Performs a deep comparison between each element in `collection` and the
	     * source object, returning the first element that has equivalent property
	     * values.
	     *
	     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
	     * numbers, `Object` objects, regexes, and strings. Objects are compared by
	     * their own, not inherited, enumerable properties. For comparing a single
	     * own or inherited property value see `_.matchesProperty`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {Object} source The object of property values to match.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * _.result(_.findWhere(users, { 'age': 36, 'active': true }), 'user');
	     * // => 'barney'
	     *
	     * _.result(_.findWhere(users, { 'age': 40, 'active': false }), 'user');
	     * // => 'fred'
	     */
	    function findWhere(collection, source) {
	      return find(collection, baseMatches(source));
	    }
	
	    /**
	     * Iterates over elements of `collection` invoking `iteratee` for each element.
	     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
	     * (value, index|key, collection). Iteratee functions may exit iteration early
	     * by explicitly returning `false`.
	     *
	     * **Note:** As with other "Collections" methods, objects with a "length" property
	     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
	     * may be used for object iteration.
	     *
	     * @static
	     * @memberOf _
	     * @alias each
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array|Object|string} Returns `collection`.
	     * @example
	     *
	     * _([1, 2]).forEach(function(n) {
	     *   console.log(n);
	     * }).value();
	     * // => logs each value from left to right and returns the array
	     *
	     * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
	     *   console.log(n, key);
	     * });
	     * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
	     */
	    var forEach = createForEach(arrayEach, baseEach);
	
	    /**
	     * This method is like `_.forEach` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @alias eachRight
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array|Object|string} Returns `collection`.
	     * @example
	     *
	     * _([1, 2]).forEachRight(function(n) {
	     *   console.log(n);
	     * }).value();
	     * // => logs each value from right to left and returns the array
	     */
	    var forEachRight = createForEach(arrayEachRight, baseEachRight);
	
	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` through `iteratee`. The corresponding value
	     * of each key is an array of the elements responsible for generating the key.
	     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.groupBy([4.2, 6.1, 6.4], function(n) {
	     *   return Math.floor(n);
	     * });
	     * // => { '4': [4.2], '6': [6.1, 6.4] }
	     *
	     * _.groupBy([4.2, 6.1, 6.4], function(n) {
	     *   return this.floor(n);
	     * }, Math);
	     * // => { '4': [4.2], '6': [6.1, 6.4] }
	     *
	     * // using the `_.property` callback shorthand
	     * _.groupBy(['one', 'two', 'three'], 'length');
	     * // => { '3': ['one', 'two'], '5': ['three'] }
	     */
	    var groupBy = createAggregator(function(result, value, key) {
	      if (hasOwnProperty.call(result, key)) {
	        result[key].push(value);
	      } else {
	        result[key] = [value];
	      }
	    });
	
	    /**
	     * Checks if `value` is in `collection` using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons. If `fromIndex` is negative, it is used as the offset
	     * from the end of `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @alias contains, include
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {*} target The value to search for.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
	     * @returns {boolean} Returns `true` if a matching element is found, else `false`.
	     * @example
	     *
	     * _.includes([1, 2, 3], 1);
	     * // => true
	     *
	     * _.includes([1, 2, 3], 1, 2);
	     * // => false
	     *
	     * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
	     * // => true
	     *
	     * _.includes('pebbles', 'eb');
	     * // => true
	     */
	    function includes(collection, target, fromIndex, guard) {
	      var length = collection ? getLength(collection) : 0;
	      if (!isLength(length)) {
	        collection = values(collection);
	        length = collection.length;
	      }
	      if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {
	        fromIndex = 0;
	      } else {
	        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
	      }
	      return (typeof collection == 'string' || !isArray(collection) && isString(collection))
	        ? (fromIndex <= length && collection.indexOf(target, fromIndex) > -1)
	        : (!!length && getIndexOf(collection, target, fromIndex) > -1);
	    }
	
	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` through `iteratee`. The corresponding value
	     * of each key is the last element responsible for generating the key. The
	     * iteratee function is bound to `thisArg` and invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * var keyData = [
	     *   { 'dir': 'left', 'code': 97 },
	     *   { 'dir': 'right', 'code': 100 }
	     * ];
	     *
	     * _.indexBy(keyData, 'dir');
	     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
	     *
	     * _.indexBy(keyData, function(object) {
	     *   return String.fromCharCode(object.code);
	     * });
	     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
	     *
	     * _.indexBy(keyData, function(object) {
	     *   return this.fromCharCode(object.code);
	     * }, String);
	     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
	     */
	    var indexBy = createAggregator(function(result, value, key) {
	      result[key] = value;
	    });
	
	    /**
	     * Invokes the method at `path` of each element in `collection`, returning
	     * an array of the results of each invoked method. Any additional arguments
	     * are provided to each invoked method. If `methodName` is a function it is
	     * invoked for, and `this` bound to, each element in `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Array|Function|string} path The path of the method to invoke or
	     *  the function invoked per iteration.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Array} Returns the array of results.
	     * @example
	     *
	     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
	     * // => [[1, 5, 7], [1, 2, 3]]
	     *
	     * _.invoke([123, 456], String.prototype.split, '');
	     * // => [['1', '2', '3'], ['4', '5', '6']]
	     */
	    var invoke = restParam(function(collection, path, args) {
	      var index = -1,
	          isFunc = typeof path == 'function',
	          isProp = isKey(path),
	          result = isArrayLike(collection) ? Array(collection.length) : [];
	
	      baseEach(collection, function(value) {
	        var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);
	        result[++index] = func ? func.apply(value, args) : invokePath(value, path, args);
	      });
	      return result;
	    });
	
	    /**
	     * Creates an array of values by running each element in `collection` through
	     * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
	     * arguments: (value, index|key, collection).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * Many lodash methods are guarded to work as iteratees for methods like
	     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
	     *
	     * The guarded methods are:
	     * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`,
	     * `drop`, `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`,
	     * `parseInt`, `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`,
	     * `trimLeft`, `trimRight`, `trunc`, `random`, `range`, `sample`, `some`,
	     * `sum`, `uniq`, and `words`
	     *
	     * @static
	     * @memberOf _
	     * @alias collect
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the new mapped array.
	     * @example
	     *
	     * function timesThree(n) {
	     *   return n * 3;
	     * }
	     *
	     * _.map([1, 2], timesThree);
	     * // => [3, 6]
	     *
	     * _.map({ 'a': 1, 'b': 2 }, timesThree);
	     * // => [3, 6] (iteration order is not guaranteed)
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * // using the `_.property` callback shorthand
	     * _.map(users, 'user');
	     * // => ['barney', 'fred']
	     */
	    function map(collection, iteratee, thisArg) {
	      var func = isArray(collection) ? arrayMap : baseMap;
	      iteratee = getCallback(iteratee, thisArg, 3);
	      return func(collection, iteratee);
	    }
	
	    /**
	     * Creates an array of elements split into two groups, the first of which
	     * contains elements `predicate` returns truthy for, while the second of which
	     * contains elements `predicate` returns falsey for. The predicate is bound
	     * to `thisArg` and invoked with three arguments: (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the array of grouped elements.
	     * @example
	     *
	     * _.partition([1, 2, 3], function(n) {
	     *   return n % 2;
	     * });
	     * // => [[1, 3], [2]]
	     *
	     * _.partition([1.2, 2.3, 3.4], function(n) {
	     *   return this.floor(n) % 2;
	     * }, Math);
	     * // => [[1.2, 3.4], [2.3]]
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': false },
	     *   { 'user': 'fred',    'age': 40, 'active': true },
	     *   { 'user': 'pebbles', 'age': 1,  'active': false }
	     * ];
	     *
	     * var mapper = function(array) {
	     *   return _.pluck(array, 'user');
	     * };
	     *
	     * // using the `_.matches` callback shorthand
	     * _.map(_.partition(users, { 'age': 1, 'active': false }), mapper);
	     * // => [['pebbles'], ['barney', 'fred']]
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.map(_.partition(users, 'active', false), mapper);
	     * // => [['barney', 'pebbles'], ['fred']]
	     *
	     * // using the `_.property` callback shorthand
	     * _.map(_.partition(users, 'active'), mapper);
	     * // => [['fred'], ['barney', 'pebbles']]
	     */
	    var partition = createAggregator(function(result, value, key) {
	      result[key ? 0 : 1].push(value);
	    }, function() { return [[], []]; });
	
	    /**
	     * Gets the property value of `path` from all elements in `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Array|string} path The path of the property to pluck.
	     * @returns {Array} Returns the property values.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * _.pluck(users, 'user');
	     * // => ['barney', 'fred']
	     *
	     * var userIndex = _.indexBy(users, 'user');
	     * _.pluck(userIndex, 'age');
	     * // => [36, 40] (iteration order is not guaranteed)
	     */
	    function pluck(collection, path) {
	      return map(collection, property(path));
	    }
	
	    /**
	     * Reduces `collection` to a value which is the accumulated result of running
	     * each element in `collection` through `iteratee`, where each successive
	     * invocation is supplied the return value of the previous. If `accumulator`
	     * is not provided the first element of `collection` is used as the initial
	     * value. The `iteratee` is bound to `thisArg` and invoked with four arguments:
	     * (accumulator, value, index|key, collection).
	     *
	     * Many lodash methods are guarded to work as iteratees for methods like
	     * `_.reduce`, `_.reduceRight`, and `_.transform`.
	     *
	     * The guarded methods are:
	     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `sortByAll`,
	     * and `sortByOrder`
	     *
	     * @static
	     * @memberOf _
	     * @alias foldl, inject
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * _.reduce([1, 2], function(total, n) {
	     *   return total + n;
	     * });
	     * // => 3
	     *
	     * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {
	     *   result[key] = n * 3;
	     *   return result;
	     * }, {});
	     * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)
	     */
	    var reduce = createReduce(arrayReduce, baseEach);
	
	    /**
	     * This method is like `_.reduce` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @alias foldr
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * var array = [[0, 1], [2, 3], [4, 5]];
	     *
	     * _.reduceRight(array, function(flattened, other) {
	     *   return flattened.concat(other);
	     * }, []);
	     * // => [4, 5, 2, 3, 0, 1]
	     */
	    var reduceRight = createReduce(arrayReduceRight, baseEachRight);
	
	    /**
	     * The opposite of `_.filter`; this method returns the elements of `collection`
	     * that `predicate` does **not** return truthy for.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the new filtered array.
	     * @example
	     *
	     * _.reject([1, 2, 3, 4], function(n) {
	     *   return n % 2 == 0;
	     * });
	     * // => [1, 3]
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': false },
	     *   { 'user': 'fred',   'age': 40, 'active': true }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.pluck(_.reject(users, { 'age': 40, 'active': true }), 'user');
	     * // => ['barney']
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.pluck(_.reject(users, 'active', false), 'user');
	     * // => ['fred']
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.reject(users, 'active'), 'user');
	     * // => ['barney']
	     */
	    function reject(collection, predicate, thisArg) {
	      var func = isArray(collection) ? arrayFilter : baseFilter;
	      predicate = getCallback(predicate, thisArg, 3);
	      return func(collection, function(value, index, collection) {
	        return !predicate(value, index, collection);
	      });
	    }
	
	    /**
	     * Gets a random element or `n` random elements from a collection.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to sample.
	     * @param {number} [n] The number of elements to sample.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {*} Returns the random sample(s).
	     * @example
	     *
	     * _.sample([1, 2, 3, 4]);
	     * // => 2
	     *
	     * _.sample([1, 2, 3, 4], 2);
	     * // => [3, 1]
	     */
	    function sample(collection, n, guard) {
	      if (guard ? isIterateeCall(collection, n, guard) : n == null) {
	        collection = toIterable(collection);
	        var length = collection.length;
	        return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
	      }
	      var index = -1,
	          result = toArray(collection),
	          length = result.length,
	          lastIndex = length - 1;
	
	      n = nativeMin(n < 0 ? 0 : (+n || 0), length);
	      while (++index < n) {
	        var rand = baseRandom(index, lastIndex),
	            value = result[rand];
	
	        result[rand] = result[index];
	        result[index] = value;
	      }
	      result.length = n;
	      return result;
	    }
	
	    /**
	     * Creates an array of shuffled values, using a version of the
	     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     * @example
	     *
	     * _.shuffle([1, 2, 3, 4]);
	     * // => [4, 1, 3, 2]
	     */
	    function shuffle(collection) {
	      return sample(collection, POSITIVE_INFINITY);
	    }
	
	    /**
	     * Gets the size of `collection` by returning its length for array-like
	     * values or the number of own enumerable properties for objects.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to inspect.
	     * @returns {number} Returns the size of `collection`.
	     * @example
	     *
	     * _.size([1, 2, 3]);
	     * // => 3
	     *
	     * _.size({ 'a': 1, 'b': 2 });
	     * // => 2
	     *
	     * _.size('pebbles');
	     * // => 7
	     */
	    function size(collection) {
	      var length = collection ? getLength(collection) : 0;
	      return isLength(length) ? length : keys(collection).length;
	    }
	
	    /**
	     * Checks if `predicate` returns truthy for **any** element of `collection`.
	     * The function returns as soon as it finds a passing value and does not iterate
	     * over the entire collection. The predicate is bound to `thisArg` and invoked
	     * with three arguments: (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias any
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     * @example
	     *
	     * _.some([null, 0, 'yes', false], Boolean);
	     * // => true
	     *
	     * var users = [
	     *   { 'user': 'barney', 'active': true },
	     *   { 'user': 'fred',   'active': false }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.some(users, { 'user': 'barney', 'active': false });
	     * // => false
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.some(users, 'active', false);
	     * // => true
	     *
	     * // using the `_.property` callback shorthand
	     * _.some(users, 'active');
	     * // => true
	     */
	    function some(collection, predicate, thisArg) {
	      var func = isArray(collection) ? arraySome : baseSome;
	      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
	        predicate = undefined;
	      }
	      if (typeof predicate != 'function' || thisArg !== undefined) {
	        predicate = getCallback(predicate, thisArg, 3);
	      }
	      return func(collection, predicate);
	    }
	
	    /**
	     * Creates an array of elements, sorted in ascending order by the results of
	     * running each element in a collection through `iteratee`. This method performs
	     * a stable sort, that is, it preserves the original sort order of equal elements.
	     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * _.sortBy([1, 2, 3], function(n) {
	     *   return Math.sin(n);
	     * });
	     * // => [3, 1, 2]
	     *
	     * _.sortBy([1, 2, 3], function(n) {
	     *   return this.sin(n);
	     * }, Math);
	     * // => [3, 1, 2]
	     *
	     * var users = [
	     *   { 'user': 'fred' },
	     *   { 'user': 'pebbles' },
	     *   { 'user': 'barney' }
	     * ];
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.sortBy(users, 'user'), 'user');
	     * // => ['barney', 'fred', 'pebbles']
	     */
	    function sortBy(collection, iteratee, thisArg) {
	      if (collection == null) {
	        return [];
	      }
	      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
	        iteratee = undefined;
	      }
	      var index = -1;
	      iteratee = getCallback(iteratee, thisArg, 3);
	
	      var result = baseMap(collection, function(value, key, collection) {
	        return { 'criteria': iteratee(value, key, collection), 'index': ++index, 'value': value };
	      });
	      return baseSortBy(result, compareAscending);
	    }
	
	    /**
	     * This method is like `_.sortBy` except that it can sort by multiple iteratees
	     * or property names.
	     *
	     * If a property name is provided for an iteratee the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If an object is provided for an iteratee the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {...(Function|Function[]|Object|Object[]|string|string[])} iteratees
	     *  The iteratees to sort by, specified as individual values or arrays of values.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'fred',   'age': 48 },
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 42 },
	     *   { 'user': 'barney', 'age': 34 }
	     * ];
	     *
	     * _.map(_.sortByAll(users, ['user', 'age']), _.values);
	     * // => [['barney', 34], ['barney', 36], ['fred', 42], ['fred', 48]]
	     *
	     * _.map(_.sortByAll(users, 'user', function(chr) {
	     *   return Math.floor(chr.age / 10);
	     * }), _.values);
	     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
	     */
	    var sortByAll = restParam(function(collection, iteratees) {
	      if (collection == null) {
	        return [];
	      }
	      var guard = iteratees[2];
	      if (guard && isIterateeCall(iteratees[0], iteratees[1], guard)) {
	        iteratees.length = 1;
	      }
	      return baseSortByOrder(collection, baseFlatten(iteratees), []);
	    });
	
	    /**
	     * This method is like `_.sortByAll` except that it allows specifying the
	     * sort orders of the iteratees to sort by. If `orders` is unspecified, all
	     * values are sorted in ascending order. Otherwise, a value is sorted in
	     * ascending order if its corresponding order is "asc", and descending if "desc".
	     *
	     * If a property name is provided for an iteratee the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If an object is provided for an iteratee the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
	     * @param {boolean[]} [orders] The sort orders of `iteratees`.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'fred',   'age': 48 },
	     *   { 'user': 'barney', 'age': 34 },
	     *   { 'user': 'fred',   'age': 42 },
	     *   { 'user': 'barney', 'age': 36 }
	     * ];
	     *
	     * // sort by `user` in ascending order and by `age` in descending order
	     * _.map(_.sortByOrder(users, ['user', 'age'], ['asc', 'desc']), _.values);
	     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
	     */
	    function sortByOrder(collection, iteratees, orders, guard) {
	      if (collection == null) {
	        return [];
	      }
	      if (guard && isIterateeCall(iteratees, orders, guard)) {
	        orders = undefined;
	      }
	      if (!isArray(iteratees)) {
	        iteratees = iteratees == null ? [] : [iteratees];
	      }
	      if (!isArray(orders)) {
	        orders = orders == null ? [] : [orders];
	      }
	      return baseSortByOrder(collection, iteratees, orders);
	    }
	
	    /**
	     * Performs a deep comparison between each element in `collection` and the
	     * source object, returning an array of all elements that have equivalent
	     * property values.
	     *
	     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
	     * numbers, `Object` objects, regexes, and strings. Objects are compared by
	     * their own, not inherited, enumerable properties. For comparing a single
	     * own or inherited property value see `_.matchesProperty`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {Object} source The object of property values to match.
	     * @returns {Array} Returns the new filtered array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': false, 'pets': ['hoppy'] },
	     *   { 'user': 'fred',   'age': 40, 'active': true, 'pets': ['baby puss', 'dino'] }
	     * ];
	     *
	     * _.pluck(_.where(users, { 'age': 36, 'active': false }), 'user');
	     * // => ['barney']
	     *
	     * _.pluck(_.where(users, { 'pets': ['dino'] }), 'user');
	     * // => ['fred']
	     */
	    function where(collection, source) {
	      return filter(collection, baseMatches(source));
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Gets the number of milliseconds that have elapsed since the Unix epoch
	     * (1 January 1970 00:00:00 UTC).
	     *
	     * @static
	     * @memberOf _
	     * @category Date
	     * @example
	     *
	     * _.defer(function(stamp) {
	     *   console.log(_.now() - stamp);
	     * }, _.now());
	     * // => logs the number of milliseconds it took for the deferred function to be invoked
	     */
	    var now = nativeNow || function() {
	      return new Date().getTime();
	    };
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * The opposite of `_.before`; this method creates a function that invokes
	     * `func` once it is called `n` or more times.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {number} n The number of calls before `func` is invoked.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var saves = ['profile', 'settings'];
	     *
	     * var done = _.after(saves.length, function() {
	     *   console.log('done saving!');
	     * });
	     *
	     * _.forEach(saves, function(type) {
	     *   asyncSave({ 'type': type, 'complete': done });
	     * });
	     * // => logs 'done saving!' after the two async saves have completed
	     */
	    function after(n, func) {
	      if (typeof func != 'function') {
	        if (typeof n == 'function') {
	          var temp = n;
	          n = func;
	          func = temp;
	        } else {
	          throw new TypeError(FUNC_ERROR_TEXT);
	        }
	      }
	      n = nativeIsFinite(n = +n) ? n : 0;
	      return function() {
	        if (--n < 1) {
	          return func.apply(this, arguments);
	        }
	      };
	    }
	
	    /**
	     * Creates a function that accepts up to `n` arguments ignoring any
	     * additional arguments.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to cap arguments for.
	     * @param {number} [n=func.length] The arity cap.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
	     * // => [6, 8, 10]
	     */
	    function ary(func, n, guard) {
	      if (guard && isIterateeCall(func, n, guard)) {
	        n = undefined;
	      }
	      n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
	      return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);
	    }
	
	    /**
	     * Creates a function that invokes `func`, with the `this` binding and arguments
	     * of the created function, while it is called less than `n` times. Subsequent
	     * calls to the created function return the result of the last `func` invocation.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {number} n The number of calls at which `func` is no longer invoked.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * jQuery('#add').on('click', _.before(5, addContactToList));
	     * // => allows adding up to 4 contacts to the list
	     */
	    function before(n, func) {
	      var result;
	      if (typeof func != 'function') {
	        if (typeof n == 'function') {
	          var temp = n;
	          n = func;
	          func = temp;
	        } else {
	          throw new TypeError(FUNC_ERROR_TEXT);
	        }
	      }
	      return function() {
	        if (--n > 0) {
	          result = func.apply(this, arguments);
	        }
	        if (n <= 1) {
	          func = undefined;
	        }
	        return result;
	      };
	    }
	
	    /**
	     * Creates a function that invokes `func` with the `this` binding of `thisArg`
	     * and prepends any additional `_.bind` arguments to those provided to the
	     * bound function.
	     *
	     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
	     * may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** Unlike native `Function#bind` this method does not set the "length"
	     * property of bound functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to bind.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * var greet = function(greeting, punctuation) {
	     *   return greeting + ' ' + this.user + punctuation;
	     * };
	     *
	     * var object = { 'user': 'fred' };
	     *
	     * var bound = _.bind(greet, object, 'hi');
	     * bound('!');
	     * // => 'hi fred!'
	     *
	     * // using placeholders
	     * var bound = _.bind(greet, object, _, '!');
	     * bound('hi');
	     * // => 'hi fred!'
	     */
	    var bind = restParam(function(func, thisArg, partials) {
	      var bitmask = BIND_FLAG;
	      if (partials.length) {
	        var holders = replaceHolders(partials, bind.placeholder);
	        bitmask |= PARTIAL_FLAG;
	      }
	      return createWrapper(func, bitmask, thisArg, partials, holders);
	    });
	
	    /**
	     * Binds methods of an object to the object itself, overwriting the existing
	     * method. Method names may be specified as individual arguments or as arrays
	     * of method names. If no method names are provided all enumerable function
	     * properties, own and inherited, of `object` are bound.
	     *
	     * **Note:** This method does not set the "length" property of bound functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Object} object The object to bind and assign the bound methods to.
	     * @param {...(string|string[])} [methodNames] The object method names to bind,
	     *  specified as individual method names or arrays of method names.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var view = {
	     *   'label': 'docs',
	     *   'onClick': function() {
	     *     console.log('clicked ' + this.label);
	     *   }
	     * };
	     *
	     * _.bindAll(view);
	     * jQuery('#docs').on('click', view.onClick);
	     * // => logs 'clicked docs' when the element is clicked
	     */
	    var bindAll = restParam(function(object, methodNames) {
	      methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);
	
	      var index = -1,
	          length = methodNames.length;
	
	      while (++index < length) {
	        var key = methodNames[index];
	        object[key] = createWrapper(object[key], BIND_FLAG, object);
	      }
	      return object;
	    });
	
	    /**
	     * Creates a function that invokes the method at `object[key]` and prepends
	     * any additional `_.bindKey` arguments to those provided to the bound function.
	     *
	     * This method differs from `_.bind` by allowing bound functions to reference
	     * methods that may be redefined or don't yet exist.
	     * See [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
	     * for more details.
	     *
	     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Object} object The object the method belongs to.
	     * @param {string} key The key of the method.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * var object = {
	     *   'user': 'fred',
	     *   'greet': function(greeting, punctuation) {
	     *     return greeting + ' ' + this.user + punctuation;
	     *   }
	     * };
	     *
	     * var bound = _.bindKey(object, 'greet', 'hi');
	     * bound('!');
	     * // => 'hi fred!'
	     *
	     * object.greet = function(greeting, punctuation) {
	     *   return greeting + 'ya ' + this.user + punctuation;
	     * };
	     *
	     * bound('!');
	     * // => 'hiya fred!'
	     *
	     * // using placeholders
	     * var bound = _.bindKey(object, 'greet', _, '!');
	     * bound('hi');
	     * // => 'hiya fred!'
	     */
	    var bindKey = restParam(function(object, key, partials) {
	      var bitmask = BIND_FLAG | BIND_KEY_FLAG;
	      if (partials.length) {
	        var holders = replaceHolders(partials, bindKey.placeholder);
	        bitmask |= PARTIAL_FLAG;
	      }
	      return createWrapper(key, bitmask, object, partials, holders);
	    });
	
	    /**
	     * Creates a function that accepts one or more arguments of `func` that when
	     * called either invokes `func` returning its result, if all `func` arguments
	     * have been provided, or returns a function that accepts one or more of the
	     * remaining `func` arguments, and so on. The arity of `func` may be specified
	     * if `func.length` is not sufficient.
	     *
	     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
	     * may be used as a placeholder for provided arguments.
	     *
	     * **Note:** This method does not set the "length" property of curried functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var abc = function(a, b, c) {
	     *   return [a, b, c];
	     * };
	     *
	     * var curried = _.curry(abc);
	     *
	     * curried(1)(2)(3);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2)(3);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2, 3);
	     * // => [1, 2, 3]
	     *
	     * // using placeholders
	     * curried(1)(_, 3)(2);
	     * // => [1, 2, 3]
	     */
	    var curry = createCurry(CURRY_FLAG);
	
	    /**
	     * This method is like `_.curry` except that arguments are applied to `func`
	     * in the manner of `_.partialRight` instead of `_.partial`.
	     *
	     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for provided arguments.
	     *
	     * **Note:** This method does not set the "length" property of curried functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var abc = function(a, b, c) {
	     *   return [a, b, c];
	     * };
	     *
	     * var curried = _.curryRight(abc);
	     *
	     * curried(3)(2)(1);
	     * // => [1, 2, 3]
	     *
	     * curried(2, 3)(1);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2, 3);
	     * // => [1, 2, 3]
	     *
	     * // using placeholders
	     * curried(3)(1, _)(2);
	     * // => [1, 2, 3]
	     */
	    var curryRight = createCurry(CURRY_RIGHT_FLAG);
	
	    /**
	     * Creates a debounced function that delays invoking `func` until after `wait`
	     * milliseconds have elapsed since the last time the debounced function was
	     * invoked. The debounced function comes with a `cancel` method to cancel
	     * delayed invocations. Provide an options object to indicate that `func`
	     * should be invoked on the leading and/or trailing edge of the `wait` timeout.
	     * Subsequent calls to the debounced function return the result of the last
	     * `func` invocation.
	     *
	     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
	     * on the trailing edge of the timeout only if the the debounced function is
	     * invoked more than once during the `wait` timeout.
	     *
	     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
	     * for details over the differences between `_.debounce` and `_.throttle`.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to debounce.
	     * @param {number} [wait=0] The number of milliseconds to delay.
	     * @param {Object} [options] The options object.
	     * @param {boolean} [options.leading=false] Specify invoking on the leading
	     *  edge of the timeout.
	     * @param {number} [options.maxWait] The maximum time `func` is allowed to be
	     *  delayed before it is invoked.
	     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
	     *  edge of the timeout.
	     * @returns {Function} Returns the new debounced function.
	     * @example
	     *
	     * // avoid costly calculations while the window size is in flux
	     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	     *
	     * // invoke `sendMail` when the click event is fired, debouncing subsequent calls
	     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
	     *   'leading': true,
	     *   'trailing': false
	     * }));
	     *
	     * // ensure `batchLog` is invoked once after 1 second of debounced calls
	     * var source = new EventSource('/stream');
	     * jQuery(source).on('message', _.debounce(batchLog, 250, {
	     *   'maxWait': 1000
	     * }));
	     *
	     * // cancel a debounced call
	     * var todoChanges = _.debounce(batchLog, 1000);
	     * Object.observe(models.todo, todoChanges);
	     *
	     * Object.observe(models, function(changes) {
	     *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {
	     *     todoChanges.cancel();
	     *   }
	     * }, ['delete']);
	     *
	     * // ...at some point `models.todo` is changed
	     * models.todo.completed = true;
	     *
	     * // ...before 1 second has passed `models.todo` is deleted
	     * // which cancels the debounced `todoChanges` call
	     * delete models.todo;
	     */
	    function debounce(func, wait, options) {
	      var args,
	          maxTimeoutId,
	          result,
	          stamp,
	          thisArg,
	          timeoutId,
	          trailingCall,
	          lastCalled = 0,
	          maxWait = false,
	          trailing = true;
	
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      wait = wait < 0 ? 0 : (+wait || 0);
	      if (options === true) {
	        var leading = true;
	        trailing = false;
	      } else if (isObject(options)) {
	        leading = !!options.leading;
	        maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
	        trailing = 'trailing' in options ? !!options.trailing : trailing;
	      }
	
	      function cancel() {
	        if (timeoutId) {
	          clearTimeout(timeoutId);
	        }
	        if (maxTimeoutId) {
	          clearTimeout(maxTimeoutId);
	        }
	        lastCalled = 0;
	        maxTimeoutId = timeoutId = trailingCall = undefined;
	      }
	
	      function complete(isCalled, id) {
	        if (id) {
	          clearTimeout(id);
	        }
	        maxTimeoutId = timeoutId = trailingCall = undefined;
	        if (isCalled) {
	          lastCalled = now();
	          result = func.apply(thisArg, args);
	          if (!timeoutId && !maxTimeoutId) {
	            args = thisArg = undefined;
	          }
	        }
	      }
	
	      function delayed() {
	        var remaining = wait - (now() - stamp);
	        if (remaining <= 0 || remaining > wait) {
	          complete(trailingCall, maxTimeoutId);
	        } else {
	          timeoutId = setTimeout(delayed, remaining);
	        }
	      }
	
	      function maxDelayed() {
	        complete(trailing, timeoutId);
	      }
	
	      function debounced() {
	        args = arguments;
	        stamp = now();
	        thisArg = this;
	        trailingCall = trailing && (timeoutId || !leading);
	
	        if (maxWait === false) {
	          var leadingCall = leading && !timeoutId;
	        } else {
	          if (!maxTimeoutId && !leading) {
	            lastCalled = stamp;
	          }
	          var remaining = maxWait - (stamp - lastCalled),
	              isCalled = remaining <= 0 || remaining > maxWait;
	
	          if (isCalled) {
	            if (maxTimeoutId) {
	              maxTimeoutId = clearTimeout(maxTimeoutId);
	            }
	            lastCalled = stamp;
	            result = func.apply(thisArg, args);
	          }
	          else if (!maxTimeoutId) {
	            maxTimeoutId = setTimeout(maxDelayed, remaining);
	          }
	        }
	        if (isCalled && timeoutId) {
	          timeoutId = clearTimeout(timeoutId);
	        }
	        else if (!timeoutId && wait !== maxWait) {
	          timeoutId = setTimeout(delayed, wait);
	        }
	        if (leadingCall) {
	          isCalled = true;
	          result = func.apply(thisArg, args);
	        }
	        if (isCalled && !timeoutId && !maxTimeoutId) {
	          args = thisArg = undefined;
	        }
	        return result;
	      }
	      debounced.cancel = cancel;
	      return debounced;
	    }
	
	    /**
	     * Defers invoking the `func` until the current call stack has cleared. Any
	     * additional arguments are provided to `func` when it is invoked.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to defer.
	     * @param {...*} [args] The arguments to invoke the function with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.defer(function(text) {
	     *   console.log(text);
	     * }, 'deferred');
	     * // logs 'deferred' after one or more milliseconds
	     */
	    var defer = restParam(function(func, args) {
	      return baseDelay(func, 1, args);
	    });
	
	    /**
	     * Invokes `func` after `wait` milliseconds. Any additional arguments are
	     * provided to `func` when it is invoked.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @param {...*} [args] The arguments to invoke the function with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.delay(function(text) {
	     *   console.log(text);
	     * }, 1000, 'later');
	     * // => logs 'later' after one second
	     */
	    var delay = restParam(function(func, wait, args) {
	      return baseDelay(func, wait, args);
	    });
	
	    /**
	     * Creates a function that returns the result of invoking the provided
	     * functions with the `this` binding of the created function, where each
	     * successive invocation is supplied the return value of the previous.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {...Function} [funcs] Functions to invoke.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var addSquare = _.flow(_.add, square);
	     * addSquare(1, 2);
	     * // => 9
	     */
	    var flow = createFlow();
	
	    /**
	     * This method is like `_.flow` except that it creates a function that
	     * invokes the provided functions from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @alias backflow, compose
	     * @category Function
	     * @param {...Function} [funcs] Functions to invoke.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var addSquare = _.flowRight(square, _.add);
	     * addSquare(1, 2);
	     * // => 9
	     */
	    var flowRight = createFlow(true);
	
	    /**
	     * Creates a function that memoizes the result of `func`. If `resolver` is
	     * provided it determines the cache key for storing the result based on the
	     * arguments provided to the memoized function. By default, the first argument
	     * provided to the memoized function is coerced to a string and used as the
	     * cache key. The `func` is invoked with the `this` binding of the memoized
	     * function.
	     *
	     * **Note:** The cache is exposed as the `cache` property on the memoized
	     * function. Its creation may be customized by replacing the `_.memoize.Cache`
	     * constructor with one whose instances implement the [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)
	     * method interface of `get`, `has`, and `set`.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to have its output memoized.
	     * @param {Function} [resolver] The function to resolve the cache key.
	     * @returns {Function} Returns the new memoizing function.
	     * @example
	     *
	     * var upperCase = _.memoize(function(string) {
	     *   return string.toUpperCase();
	     * });
	     *
	     * upperCase('fred');
	     * // => 'FRED'
	     *
	     * // modifying the result cache
	     * upperCase.cache.set('fred', 'BARNEY');
	     * upperCase('fred');
	     * // => 'BARNEY'
	     *
	     * // replacing `_.memoize.Cache`
	     * var object = { 'user': 'fred' };
	     * var other = { 'user': 'barney' };
	     * var identity = _.memoize(_.identity);
	     *
	     * identity(object);
	     * // => { 'user': 'fred' }
	     * identity(other);
	     * // => { 'user': 'fred' }
	     *
	     * _.memoize.Cache = WeakMap;
	     * var identity = _.memoize(_.identity);
	     *
	     * identity(object);
	     * // => { 'user': 'fred' }
	     * identity(other);
	     * // => { 'user': 'barney' }
	     */
	    function memoize(func, resolver) {
	      if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var memoized = function() {
	        var args = arguments,
	            key = resolver ? resolver.apply(this, args) : args[0],
	            cache = memoized.cache;
	
	        if (cache.has(key)) {
	          return cache.get(key);
	        }
	        var result = func.apply(this, args);
	        memoized.cache = cache.set(key, result);
	        return result;
	      };
	      memoized.cache = new memoize.Cache;
	      return memoized;
	    }
	
	    /**
	     * Creates a function that runs each argument through a corresponding
	     * transform function.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to wrap.
	     * @param {...(Function|Function[])} [transforms] The functions to transform
	     * arguments, specified as individual functions or arrays of functions.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function doubled(n) {
	     *   return n * 2;
	     * }
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var modded = _.modArgs(function(x, y) {
	     *   return [x, y];
	     * }, square, doubled);
	     *
	     * modded(1, 2);
	     * // => [1, 4]
	     *
	     * modded(5, 10);
	     * // => [25, 20]
	     */
	    var modArgs = restParam(function(func, transforms) {
	      transforms = baseFlatten(transforms);
	      if (typeof func != 'function' || !arrayEvery(transforms, baseIsFunction)) {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var length = transforms.length;
	      return restParam(function(args) {
	        var index = nativeMin(args.length, length);
	        while (index--) {
	          args[index] = transforms[index](args[index]);
	        }
	        return func.apply(this, args);
	      });
	    });
	
	    /**
	     * Creates a function that negates the result of the predicate `func`. The
	     * `func` predicate is invoked with the `this` binding and arguments of the
	     * created function.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} predicate The predicate to negate.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function isEven(n) {
	     *   return n % 2 == 0;
	     * }
	     *
	     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
	     * // => [1, 3, 5]
	     */
	    function negate(predicate) {
	      if (typeof predicate != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return function() {
	        return !predicate.apply(this, arguments);
	      };
	    }
	
	    /**
	     * Creates a function that is restricted to invoking `func` once. Repeat calls
	     * to the function return the value of the first call. The `func` is invoked
	     * with the `this` binding and arguments of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var initialize = _.once(createApplication);
	     * initialize();
	     * initialize();
	     * // `initialize` invokes `createApplication` once
	     */
	    function once(func) {
	      return before(2, func);
	    }
	
	    /**
	     * Creates a function that invokes `func` with `partial` arguments prepended
	     * to those provided to the new function. This method is like `_.bind` except
	     * it does **not** alter the `this` binding.
	     *
	     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** This method does not set the "length" property of partially
	     * applied functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * var greet = function(greeting, name) {
	     *   return greeting + ' ' + name;
	     * };
	     *
	     * var sayHelloTo = _.partial(greet, 'hello');
	     * sayHelloTo('fred');
	     * // => 'hello fred'
	     *
	     * // using placeholders
	     * var greetFred = _.partial(greet, _, 'fred');
	     * greetFred('hi');
	     * // => 'hi fred'
	     */
	    var partial = createPartial(PARTIAL_FLAG);
	
	    /**
	     * This method is like `_.partial` except that partially applied arguments
	     * are appended to those provided to the new function.
	     *
	     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** This method does not set the "length" property of partially
	     * applied functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * var greet = function(greeting, name) {
	     *   return greeting + ' ' + name;
	     * };
	     *
	     * var greetFred = _.partialRight(greet, 'fred');
	     * greetFred('hi');
	     * // => 'hi fred'
	     *
	     * // using placeholders
	     * var sayHelloTo = _.partialRight(greet, 'hello', _);
	     * sayHelloTo('fred');
	     * // => 'hello fred'
	     */
	    var partialRight = createPartial(PARTIAL_RIGHT_FLAG);
	
	    /**
	     * Creates a function that invokes `func` with arguments arranged according
	     * to the specified indexes where the argument value at the first index is
	     * provided as the first argument, the argument value at the second index is
	     * provided as the second argument, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to rearrange arguments for.
	     * @param {...(number|number[])} indexes The arranged argument indexes,
	     *  specified as individual indexes or arrays of indexes.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var rearged = _.rearg(function(a, b, c) {
	     *   return [a, b, c];
	     * }, 2, 0, 1);
	     *
	     * rearged('b', 'c', 'a')
	     * // => ['a', 'b', 'c']
	     *
	     * var map = _.rearg(_.map, [1, 0]);
	     * map(function(n) {
	     *   return n * 3;
	     * }, [1, 2, 3]);
	     * // => [3, 6, 9]
	     */
	    var rearg = restParam(function(func, indexes) {
	      return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes));
	    });
	
	    /**
	     * Creates a function that invokes `func` with the `this` binding of the
	     * created function and arguments from `start` and beyond provided as an array.
	     *
	     * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to apply a rest parameter to.
	     * @param {number} [start=func.length-1] The start position of the rest parameter.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var say = _.restParam(function(what, names) {
	     *   return what + ' ' + _.initial(names).join(', ') +
	     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
	     * });
	     *
	     * say('hello', 'fred', 'barney', 'pebbles');
	     * // => 'hello fred, barney, & pebbles'
	     */
	    function restParam(func, start) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
	      return function() {
	        var args = arguments,
	            index = -1,
	            length = nativeMax(args.length - start, 0),
	            rest = Array(length);
	
	        while (++index < length) {
	          rest[index] = args[start + index];
	        }
	        switch (start) {
	          case 0: return func.call(this, rest);
	          case 1: return func.call(this, args[0], rest);
	          case 2: return func.call(this, args[0], args[1], rest);
	        }
	        var otherArgs = Array(start + 1);
	        index = -1;
	        while (++index < start) {
	          otherArgs[index] = args[index];
	        }
	        otherArgs[start] = rest;
	        return func.apply(this, otherArgs);
	      };
	    }
	
	    /**
	     * Creates a function that invokes `func` with the `this` binding of the created
	     * function and an array of arguments much like [`Function#apply`](https://es5.github.io/#x15.3.4.3).
	     *
	     * **Note:** This method is based on the [spread operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator).
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to spread arguments over.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var say = _.spread(function(who, what) {
	     *   return who + ' says ' + what;
	     * });
	     *
	     * say(['fred', 'hello']);
	     * // => 'fred says hello'
	     *
	     * // with a Promise
	     * var numbers = Promise.all([
	     *   Promise.resolve(40),
	     *   Promise.resolve(36)
	     * ]);
	     *
	     * numbers.then(_.spread(function(x, y) {
	     *   return x + y;
	     * }));
	     * // => a Promise of 76
	     */
	    function spread(func) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return function(array) {
	        return func.apply(this, array);
	      };
	    }
	
	    /**
	     * Creates a throttled function that only invokes `func` at most once per
	     * every `wait` milliseconds. The throttled function comes with a `cancel`
	     * method to cancel delayed invocations. Provide an options object to indicate
	     * that `func` should be invoked on the leading and/or trailing edge of the
	     * `wait` timeout. Subsequent calls to the throttled function return the
	     * result of the last `func` call.
	     *
	     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
	     * on the trailing edge of the timeout only if the the throttled function is
	     * invoked more than once during the `wait` timeout.
	     *
	     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
	     * for details over the differences between `_.throttle` and `_.debounce`.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to throttle.
	     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
	     * @param {Object} [options] The options object.
	     * @param {boolean} [options.leading=true] Specify invoking on the leading
	     *  edge of the timeout.
	     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
	     *  edge of the timeout.
	     * @returns {Function} Returns the new throttled function.
	     * @example
	     *
	     * // avoid excessively updating the position while scrolling
	     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
	     *
	     * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes
	     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
	     *   'trailing': false
	     * }));
	     *
	     * // cancel a trailing throttled call
	     * jQuery(window).on('popstate', throttled.cancel);
	     */
	    function throttle(func, wait, options) {
	      var leading = true,
	          trailing = true;
	
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      if (options === false) {
	        leading = false;
	      } else if (isObject(options)) {
	        leading = 'leading' in options ? !!options.leading : leading;
	        trailing = 'trailing' in options ? !!options.trailing : trailing;
	      }
	      return debounce(func, wait, { 'leading': leading, 'maxWait': +wait, 'trailing': trailing });
	    }
	
	    /**
	     * Creates a function that provides `value` to the wrapper function as its
	     * first argument. Any additional arguments provided to the function are
	     * appended to those provided to the wrapper function. The wrapper is invoked
	     * with the `this` binding of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {*} value The value to wrap.
	     * @param {Function} wrapper The wrapper function.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var p = _.wrap(_.escape, function(func, text) {
	     *   return '<p>' + func(text) + '</p>';
	     * });
	     *
	     * p('fred, barney, & pebbles');
	     * // => '<p>fred, barney, &amp; pebbles</p>'
	     */
	    function wrap(value, wrapper) {
	      wrapper = wrapper == null ? identity : wrapper;
	      return createWrapper(wrapper, PARTIAL_FLAG, undefined, [value], []);
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,
	     * otherwise they are assigned by reference. If `customizer` is provided it is
	     * invoked to produce the cloned values. If `customizer` returns `undefined`
	     * cloning is handled by the method instead. The `customizer` is bound to
	     * `thisArg` and invoked with two argument; (value [, index|key, object]).
	     *
	     * **Note:** This method is loosely based on the
	     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
	     * The enumerable properties of `arguments` objects and objects created by
	     * constructors other than `Object` are cloned to plain `Object` objects. An
	     * empty object is returned for uncloneable values such as functions, DOM nodes,
	     * Maps, Sets, and WeakMaps.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @param {Function} [customizer] The function to customize cloning values.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {*} Returns the cloned value.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * var shallow = _.clone(users);
	     * shallow[0] === users[0];
	     * // => true
	     *
	     * var deep = _.clone(users, true);
	     * deep[0] === users[0];
	     * // => false
	     *
	     * // using a customizer callback
	     * var el = _.clone(document.body, function(value) {
	     *   if (_.isElement(value)) {
	     *     return value.cloneNode(false);
	     *   }
	     * });
	     *
	     * el === document.body
	     * // => false
	     * el.nodeName
	     * // => BODY
	     * el.childNodes.length;
	     * // => 0
	     */
	    function clone(value, isDeep, customizer, thisArg) {
	      if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
	        isDeep = false;
	      }
	      else if (typeof isDeep == 'function') {
	        thisArg = customizer;
	        customizer = isDeep;
	        isDeep = false;
	      }
	      return typeof customizer == 'function'
	        ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 1))
	        : baseClone(value, isDeep);
	    }
	
	    /**
	     * Creates a deep clone of `value`. If `customizer` is provided it is invoked
	     * to produce the cloned values. If `customizer` returns `undefined` cloning
	     * is handled by the method instead. The `customizer` is bound to `thisArg`
	     * and invoked with two argument; (value [, index|key, object]).
	     *
	     * **Note:** This method is loosely based on the
	     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
	     * The enumerable properties of `arguments` objects and objects created by
	     * constructors other than `Object` are cloned to plain `Object` objects. An
	     * empty object is returned for uncloneable values such as functions, DOM nodes,
	     * Maps, Sets, and WeakMaps.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to deep clone.
	     * @param {Function} [customizer] The function to customize cloning values.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {*} Returns the deep cloned value.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * var deep = _.cloneDeep(users);
	     * deep[0] === users[0];
	     * // => false
	     *
	     * // using a customizer callback
	     * var el = _.cloneDeep(document.body, function(value) {
	     *   if (_.isElement(value)) {
	     *     return value.cloneNode(true);
	     *   }
	     * });
	     *
	     * el === document.body
	     * // => false
	     * el.nodeName
	     * // => BODY
	     * el.childNodes.length;
	     * // => 20
	     */
	    function cloneDeep(value, customizer, thisArg) {
	      return typeof customizer == 'function'
	        ? baseClone(value, true, bindCallback(customizer, thisArg, 1))
	        : baseClone(value, true);
	    }
	
	    /**
	     * Checks if `value` is greater than `other`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than `other`, else `false`.
	     * @example
	     *
	     * _.gt(3, 1);
	     * // => true
	     *
	     * _.gt(3, 3);
	     * // => false
	     *
	     * _.gt(1, 3);
	     * // => false
	     */
	    function gt(value, other) {
	      return value > other;
	    }
	
	    /**
	     * Checks if `value` is greater than or equal to `other`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than or equal to `other`, else `false`.
	     * @example
	     *
	     * _.gte(3, 1);
	     * // => true
	     *
	     * _.gte(3, 3);
	     * // => true
	     *
	     * _.gte(1, 3);
	     * // => false
	     */
	    function gte(value, other) {
	      return value >= other;
	    }
	
	    /**
	     * Checks if `value` is classified as an `arguments` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isArguments(function() { return arguments; }());
	     * // => true
	     *
	     * _.isArguments([1, 2, 3]);
	     * // => false
	     */
	    function isArguments(value) {
	      return isObjectLike(value) && isArrayLike(value) &&
	        hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
	    }
	
	    /**
	     * Checks if `value` is classified as an `Array` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isArray([1, 2, 3]);
	     * // => true
	     *
	     * _.isArray(function() { return arguments; }());
	     * // => false
	     */
	    var isArray = nativeIsArray || function(value) {
	      return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
	    };
	
	    /**
	     * Checks if `value` is classified as a boolean primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isBoolean(false);
	     * // => true
	     *
	     * _.isBoolean(null);
	     * // => false
	     */
	    function isBoolean(value) {
	      return value === true || value === false || (isObjectLike(value) && objToString.call(value) == boolTag);
	    }
	
	    /**
	     * Checks if `value` is classified as a `Date` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isDate(new Date);
	     * // => true
	     *
	     * _.isDate('Mon April 23 2012');
	     * // => false
	     */
	    function isDate(value) {
	      return isObjectLike(value) && objToString.call(value) == dateTag;
	    }
	
	    /**
	     * Checks if `value` is a DOM element.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
	     * @example
	     *
	     * _.isElement(document.body);
	     * // => true
	     *
	     * _.isElement('<body>');
	     * // => false
	     */
	    function isElement(value) {
	      return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
	    }
	
	    /**
	     * Checks if `value` is empty. A value is considered empty unless it is an
	     * `arguments` object, array, string, or jQuery-like collection with a length
	     * greater than `0` or an object with own enumerable properties.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {Array|Object|string} value The value to inspect.
	     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
	     * @example
	     *
	     * _.isEmpty(null);
	     * // => true
	     *
	     * _.isEmpty(true);
	     * // => true
	     *
	     * _.isEmpty(1);
	     * // => true
	     *
	     * _.isEmpty([1, 2, 3]);
	     * // => false
	     *
	     * _.isEmpty({ 'a': 1 });
	     * // => false
	     */
	    function isEmpty(value) {
	      if (value == null) {
	        return true;
	      }
	      if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) ||
	          (isObjectLike(value) && isFunction(value.splice)))) {
	        return !value.length;
	      }
	      return !keys(value).length;
	    }
	
	    /**
	     * Performs a deep comparison between two values to determine if they are
	     * equivalent. If `customizer` is provided it is invoked to compare values.
	     * If `customizer` returns `undefined` comparisons are handled by the method
	     * instead. The `customizer` is bound to `thisArg` and invoked with three
	     * arguments: (value, other [, index|key]).
	     *
	     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
	     * numbers, `Object` objects, regexes, and strings. Objects are compared by
	     * their own, not inherited, enumerable properties. Functions and DOM nodes
	     * are **not** supported. Provide a customizer function to extend support
	     * for comparing other values.
	     *
	     * @static
	     * @memberOf _
	     * @alias eq
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @param {Function} [customizer] The function to customize value comparisons.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * var object = { 'user': 'fred' };
	     * var other = { 'user': 'fred' };
	     *
	     * object == other;
	     * // => false
	     *
	     * _.isEqual(object, other);
	     * // => true
	     *
	     * // using a customizer callback
	     * var array = ['hello', 'goodbye'];
	     * var other = ['hi', 'goodbye'];
	     *
	     * _.isEqual(array, other, function(value, other) {
	     *   if (_.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/)) {
	     *     return true;
	     *   }
	     * });
	     * // => true
	     */
	    function isEqual(value, other, customizer, thisArg) {
	      customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
	      var result = customizer ? customizer(value, other) : undefined;
	      return  result === undefined ? baseIsEqual(value, other, customizer) : !!result;
	    }
	
	    /**
	     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
	     * `SyntaxError`, `TypeError`, or `URIError` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
	     * @example
	     *
	     * _.isError(new Error);
	     * // => true
	     *
	     * _.isError(Error);
	     * // => false
	     */
	    function isError(value) {
	      return isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;
	    }
	
	    /**
	     * Checks if `value` is a finite primitive number.
	     *
	     * **Note:** This method is based on [`Number.isFinite`](http://ecma-international.org/ecma-262/6.0/#sec-number.isfinite).
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
	     * @example
	     *
	     * _.isFinite(10);
	     * // => true
	     *
	     * _.isFinite('10');
	     * // => false
	     *
	     * _.isFinite(true);
	     * // => false
	     *
	     * _.isFinite(Object(10));
	     * // => false
	     *
	     * _.isFinite(Infinity);
	     * // => false
	     */
	    function isFinite(value) {
	      return typeof value == 'number' && nativeIsFinite(value);
	    }
	
	    /**
	     * Checks if `value` is classified as a `Function` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isFunction(_);
	     * // => true
	     *
	     * _.isFunction(/abc/);
	     * // => false
	     */
	    function isFunction(value) {
	      // The use of `Object#toString` avoids issues with the `typeof` operator
	      // in older versions of Chrome and Safari which return 'function' for regexes
	      // and Safari 8 equivalents which return 'object' for typed array constructors.
	      return isObject(value) && objToString.call(value) == funcTag;
	    }
	
	    /**
	     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	     * @example
	     *
	     * _.isObject({});
	     * // => true
	     *
	     * _.isObject([1, 2, 3]);
	     * // => true
	     *
	     * _.isObject(1);
	     * // => false
	     */
	    function isObject(value) {
	      // Avoid a V8 JIT bug in Chrome 19-20.
	      // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	      var type = typeof value;
	      return !!value && (type == 'object' || type == 'function');
	    }
	
	    /**
	     * Performs a deep comparison between `object` and `source` to determine if
	     * `object` contains equivalent property values. If `customizer` is provided
	     * it is invoked to compare values. If `customizer` returns `undefined`
	     * comparisons are handled by the method instead. The `customizer` is bound
	     * to `thisArg` and invoked with three arguments: (value, other, index|key).
	     *
	     * **Note:** This method supports comparing properties of arrays, booleans,
	     * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions
	     * and DOM nodes are **not** supported. Provide a customizer function to extend
	     * support for comparing other values.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @param {Function} [customizer] The function to customize value comparisons.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     * @example
	     *
	     * var object = { 'user': 'fred', 'age': 40 };
	     *
	     * _.isMatch(object, { 'age': 40 });
	     * // => true
	     *
	     * _.isMatch(object, { 'age': 36 });
	     * // => false
	     *
	     * // using a customizer callback
	     * var object = { 'greeting': 'hello' };
	     * var source = { 'greeting': 'hi' };
	     *
	     * _.isMatch(object, source, function(value, other) {
	     *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;
	     * });
	     * // => true
	     */
	    function isMatch(object, source, customizer, thisArg) {
	      customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
	      return baseIsMatch(object, getMatchData(source), customizer);
	    }
	
	    /**
	     * Checks if `value` is `NaN`.
	     *
	     * **Note:** This method is not the same as [`isNaN`](https://es5.github.io/#x15.1.2.4)
	     * which returns `true` for `undefined` and other non-numeric values.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	     * @example
	     *
	     * _.isNaN(NaN);
	     * // => true
	     *
	     * _.isNaN(new Number(NaN));
	     * // => true
	     *
	     * isNaN(undefined);
	     * // => true
	     *
	     * _.isNaN(undefined);
	     * // => false
	     */
	    function isNaN(value) {
	      // An `NaN` primitive is the only value that is not equal to itself.
	      // Perform the `toStringTag` check first to avoid errors with some host objects in IE.
	      return isNumber(value) && value != +value;
	    }
	
	    /**
	     * Checks if `value` is a native function.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
	     * @example
	     *
	     * _.isNative(Array.prototype.push);
	     * // => true
	     *
	     * _.isNative(_);
	     * // => false
	     */
	    function isNative(value) {
	      if (value == null) {
	        return false;
	      }
	      if (isFunction(value)) {
	        return reIsNative.test(fnToString.call(value));
	      }
	      return isObjectLike(value) && reIsHostCtor.test(value);
	    }
	
	    /**
	     * Checks if `value` is `null`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
	     * @example
	     *
	     * _.isNull(null);
	     * // => true
	     *
	     * _.isNull(void 0);
	     * // => false
	     */
	    function isNull(value) {
	      return value === null;
	    }
	
	    /**
	     * Checks if `value` is classified as a `Number` primitive or object.
	     *
	     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
	     * as numbers, use the `_.isFinite` method.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isNumber(8.4);
	     * // => true
	     *
	     * _.isNumber(NaN);
	     * // => true
	     *
	     * _.isNumber('8.4');
	     * // => false
	     */
	    function isNumber(value) {
	      return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);
	    }
	
	    /**
	     * Checks if `value` is a plain object, that is, an object created by the
	     * `Object` constructor or one with a `[[Prototype]]` of `null`.
	     *
	     * **Note:** This method assumes objects created by the `Object` constructor
	     * have no inherited enumerable properties.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * _.isPlainObject(new Foo);
	     * // => false
	     *
	     * _.isPlainObject([1, 2, 3]);
	     * // => false
	     *
	     * _.isPlainObject({ 'x': 0, 'y': 0 });
	     * // => true
	     *
	     * _.isPlainObject(Object.create(null));
	     * // => true
	     */
	    function isPlainObject(value) {
	      var Ctor;
	
	      // Exit early for non `Object` objects.
	      if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isArguments(value)) ||
	          (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
	        return false;
	      }
	      // IE < 9 iterates inherited properties before own properties. If the first
	      // iterated property is an object's own property then there are no inherited
	      // enumerable properties.
	      var result;
	      // In most environments an object's own properties are iterated before
	      // its inherited properties. If the last iterated property is an object's
	      // own property then there are no inherited enumerable properties.
	      baseForIn(value, function(subValue, key) {
	        result = key;
	      });
	      return result === undefined || hasOwnProperty.call(value, result);
	    }
	
	    /**
	     * Checks if `value` is classified as a `RegExp` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isRegExp(/abc/);
	     * // => true
	     *
	     * _.isRegExp('/abc/');
	     * // => false
	     */
	    function isRegExp(value) {
	      return isObject(value) && objToString.call(value) == regexpTag;
	    }
	
	    /**
	     * Checks if `value` is classified as a `String` primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isString('abc');
	     * // => true
	     *
	     * _.isString(1);
	     * // => false
	     */
	    function isString(value) {
	      return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
	    }
	
	    /**
	     * Checks if `value` is classified as a typed array.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isTypedArray(new Uint8Array);
	     * // => true
	     *
	     * _.isTypedArray([]);
	     * // => false
	     */
	    function isTypedArray(value) {
	      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
	    }
	
	    /**
	     * Checks if `value` is `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
	     * @example
	     *
	     * _.isUndefined(void 0);
	     * // => true
	     *
	     * _.isUndefined(null);
	     * // => false
	     */
	    function isUndefined(value) {
	      return value === undefined;
	    }
	
	    /**
	     * Checks if `value` is less than `other`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than `other`, else `false`.
	     * @example
	     *
	     * _.lt(1, 3);
	     * // => true
	     *
	     * _.lt(3, 3);
	     * // => false
	     *
	     * _.lt(3, 1);
	     * // => false
	     */
	    function lt(value, other) {
	      return value < other;
	    }
	
	    /**
	     * Checks if `value` is less than or equal to `other`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than or equal to `other`, else `false`.
	     * @example
	     *
	     * _.lte(1, 3);
	     * // => true
	     *
	     * _.lte(3, 3);
	     * // => true
	     *
	     * _.lte(3, 1);
	     * // => false
	     */
	    function lte(value, other) {
	      return value <= other;
	    }
	
	    /**
	     * Converts `value` to an array.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {Array} Returns the converted array.
	     * @example
	     *
	     * (function() {
	     *   return _.toArray(arguments).slice(1);
	     * }(1, 2, 3));
	     * // => [2, 3]
	     */
	    function toArray(value) {
	      var length = value ? getLength(value) : 0;
	      if (!isLength(length)) {
	        return values(value);
	      }
	      if (!length) {
	        return [];
	      }
	      return arrayCopy(value);
	    }
	
	    /**
	     * Converts `value` to a plain object flattening inherited enumerable
	     * properties of `value` to own properties of the plain object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {Object} Returns the converted plain object.
	     * @example
	     *
	     * function Foo() {
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.assign({ 'a': 1 }, new Foo);
	     * // => { 'a': 1, 'b': 2 }
	     *
	     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	     * // => { 'a': 1, 'b': 2, 'c': 3 }
	     */
	    function toPlainObject(value) {
	      return baseCopy(value, keysIn(value));
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Recursively merges own enumerable properties of the source object(s), that
	     * don't resolve to `undefined` into the destination object. Subsequent sources
	     * overwrite property assignments of previous sources. If `customizer` is
	     * provided it is invoked to produce the merged values of the destination and
	     * source properties. If `customizer` returns `undefined` merging is handled
	     * by the method instead. The `customizer` is bound to `thisArg` and invoked
	     * with five arguments: (objectValue, sourceValue, key, object, source).
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var users = {
	     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
	     * };
	     *
	     * var ages = {
	     *   'data': [{ 'age': 36 }, { 'age': 40 }]
	     * };
	     *
	     * _.merge(users, ages);
	     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
	     *
	     * // using a customizer callback
	     * var object = {
	     *   'fruits': ['apple'],
	     *   'vegetables': ['beet']
	     * };
	     *
	     * var other = {
	     *   'fruits': ['banana'],
	     *   'vegetables': ['carrot']
	     * };
	     *
	     * _.merge(object, other, function(a, b) {
	     *   if (_.isArray(a)) {
	     *     return a.concat(b);
	     *   }
	     * });
	     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
	     */
	    var merge = createAssigner(baseMerge);
	
	    /**
	     * Assigns own enumerable properties of source object(s) to the destination
	     * object. Subsequent sources overwrite property assignments of previous sources.
	     * If `customizer` is provided it is invoked to produce the assigned values.
	     * The `customizer` is bound to `thisArg` and invoked with five arguments:
	     * (objectValue, sourceValue, key, object, source).
	     *
	     * **Note:** This method mutates `object` and is based on
	     * [`Object.assign`](http://ecma-international.org/ecma-262/6.0/#sec-object.assign).
	     *
	     * @static
	     * @memberOf _
	     * @alias extend
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
	     * // => { 'user': 'fred', 'age': 40 }
	     *
	     * // using a customizer callback
	     * var defaults = _.partialRight(_.assign, function(value, other) {
	     *   return _.isUndefined(value) ? other : value;
	     * });
	     *
	     * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
	     * // => { 'user': 'barney', 'age': 36 }
	     */
	    var assign = createAssigner(function(object, source, customizer) {
	      return customizer
	        ? assignWith(object, source, customizer)
	        : baseAssign(object, source);
	    });
	
	    /**
	     * Creates an object that inherits from the given `prototype` object. If a
	     * `properties` object is provided its own enumerable properties are assigned
	     * to the created object.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} prototype The object to inherit from.
	     * @param {Object} [properties] The properties to assign to the object.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * function Shape() {
	     *   this.x = 0;
	     *   this.y = 0;
	     * }
	     *
	     * function Circle() {
	     *   Shape.call(this);
	     * }
	     *
	     * Circle.prototype = _.create(Shape.prototype, {
	     *   'constructor': Circle
	     * });
	     *
	     * var circle = new Circle;
	     * circle instanceof Circle;
	     * // => true
	     *
	     * circle instanceof Shape;
	     * // => true
	     */
	    function create(prototype, properties, guard) {
	      var result = baseCreate(prototype);
	      if (guard && isIterateeCall(prototype, properties, guard)) {
	        properties = undefined;
	      }
	      return properties ? baseAssign(result, properties) : result;
	    }
	
	    /**
	     * Assigns own enumerable properties of source object(s) to the destination
	     * object for all destination properties that resolve to `undefined`. Once a
	     * property is set, additional values of the same property are ignored.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
	     * // => { 'user': 'barney', 'age': 36 }
	     */
	    var defaults = createDefaults(assign, assignDefaults);
	
	    /**
	     * This method is like `_.defaults` except that it recursively assigns
	     * default properties.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * _.defaultsDeep({ 'user': { 'name': 'barney' } }, { 'user': { 'name': 'fred', 'age': 36 } });
	     * // => { 'user': { 'name': 'barney', 'age': 36 } }
	     *
	     */
	    var defaultsDeep = createDefaults(merge, mergeDefaults);
	
	    /**
	     * This method is like `_.find` except that it returns the key of the first
	     * element `predicate` returns truthy for instead of the element itself.
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
	     * @example
	     *
	     * var users = {
	     *   'barney':  { 'age': 36, 'active': true },
	     *   'fred':    { 'age': 40, 'active': false },
	     *   'pebbles': { 'age': 1,  'active': true }
	     * };
	     *
	     * _.findKey(users, function(chr) {
	     *   return chr.age < 40;
	     * });
	     * // => 'barney' (iteration order is not guaranteed)
	     *
	     * // using the `_.matches` callback shorthand
	     * _.findKey(users, { 'age': 1, 'active': true });
	     * // => 'pebbles'
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.findKey(users, 'active', false);
	     * // => 'fred'
	     *
	     * // using the `_.property` callback shorthand
	     * _.findKey(users, 'active');
	     * // => 'barney'
	     */
	    var findKey = createFindKey(baseForOwn);
	
	    /**
	     * This method is like `_.findKey` except that it iterates over elements of
	     * a collection in the opposite order.
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
	     * @example
	     *
	     * var users = {
	     *   'barney':  { 'age': 36, 'active': true },
	     *   'fred':    { 'age': 40, 'active': false },
	     *   'pebbles': { 'age': 1,  'active': true }
	     * };
	     *
	     * _.findLastKey(users, function(chr) {
	     *   return chr.age < 40;
	     * });
	     * // => returns `pebbles` assuming `_.findKey` returns `barney`
	     *
	     * // using the `_.matches` callback shorthand
	     * _.findLastKey(users, { 'age': 36, 'active': true });
	     * // => 'barney'
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.findLastKey(users, 'active', false);
	     * // => 'fred'
	     *
	     * // using the `_.property` callback shorthand
	     * _.findLastKey(users, 'active');
	     * // => 'pebbles'
	     */
	    var findLastKey = createFindKey(baseForOwnRight);
	
	    /**
	     * Iterates over own and inherited enumerable properties of an object invoking
	     * `iteratee` for each property. The `iteratee` is bound to `thisArg` and invoked
	     * with three arguments: (value, key, object). Iteratee functions may exit
	     * iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forIn(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'a', 'b', and 'c' (iteration order is not guaranteed)
	     */
	    var forIn = createForIn(baseFor);
	
	    /**
	     * This method is like `_.forIn` except that it iterates over properties of
	     * `object` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forInRight(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'c', 'b', and 'a' assuming `_.forIn ` logs 'a', 'b', and 'c'
	     */
	    var forInRight = createForIn(baseForRight);
	
	    /**
	     * Iterates over own enumerable properties of an object invoking `iteratee`
	     * for each property. The `iteratee` is bound to `thisArg` and invoked with
	     * three arguments: (value, key, object). Iteratee functions may exit iteration
	     * early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forOwn(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'a' and 'b' (iteration order is not guaranteed)
	     */
	    var forOwn = createForOwn(baseForOwn);
	
	    /**
	     * This method is like `_.forOwn` except that it iterates over properties of
	     * `object` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forOwnRight(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'b' and 'a' assuming `_.forOwn` logs 'a' and 'b'
	     */
	    var forOwnRight = createForOwn(baseForOwnRight);
	
	    /**
	     * Creates an array of function property names from all enumerable properties,
	     * own and inherited, of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @alias methods
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns the new array of property names.
	     * @example
	     *
	     * _.functions(_);
	     * // => ['after', 'ary', 'assign', ...]
	     */
	    function functions(object) {
	      return baseFunctions(object, keysIn(object));
	    }
	
	    /**
	     * Gets the property value at `path` of `object`. If the resolved value is
	     * `undefined` the `defaultValue` is used in its place.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to get.
	     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.get(object, 'a[0].b.c');
	     * // => 3
	     *
	     * _.get(object, ['a', '0', 'b', 'c']);
	     * // => 3
	     *
	     * _.get(object, 'a.b.c', 'default');
	     * // => 'default'
	     */
	    function get(object, path, defaultValue) {
	      var result = object == null ? undefined : baseGet(object, toPath(path), path + '');
	      return result === undefined ? defaultValue : result;
	    }
	
	    /**
	     * Checks if `path` is a direct property.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @returns {boolean} Returns `true` if `path` is a direct property, else `false`.
	     * @example
	     *
	     * var object = { 'a': { 'b': { 'c': 3 } } };
	     *
	     * _.has(object, 'a');
	     * // => true
	     *
	     * _.has(object, 'a.b.c');
	     * // => true
	     *
	     * _.has(object, ['a', 'b', 'c']);
	     * // => true
	     */
	    function has(object, path) {
	      if (object == null) {
	        return false;
	      }
	      var result = hasOwnProperty.call(object, path);
	      if (!result && !isKey(path)) {
	        path = toPath(path);
	        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
	        if (object == null) {
	          return false;
	        }
	        path = last(path);
	        result = hasOwnProperty.call(object, path);
	      }
	      return result || (isLength(object.length) && isIndex(path, object.length) &&
	        (isArray(object) || isArguments(object)));
	    }
	
	    /**
	     * Creates an object composed of the inverted keys and values of `object`.
	     * If `object` contains duplicate values, subsequent values overwrite property
	     * assignments of previous values unless `multiValue` is `true`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to invert.
	     * @param {boolean} [multiValue] Allow multiple values per key.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Object} Returns the new inverted object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2, 'c': 1 };
	     *
	     * _.invert(object);
	     * // => { '1': 'c', '2': 'b' }
	     *
	     * // with `multiValue`
	     * _.invert(object, true);
	     * // => { '1': ['a', 'c'], '2': ['b'] }
	     */
	    function invert(object, multiValue, guard) {
	      if (guard && isIterateeCall(object, multiValue, guard)) {
	        multiValue = undefined;
	      }
	      var index = -1,
	          props = keys(object),
	          length = props.length,
	          result = {};
	
	      while (++index < length) {
	        var key = props[index],
	            value = object[key];
	
	        if (multiValue) {
	          if (hasOwnProperty.call(result, value)) {
	            result[value].push(key);
	          } else {
	            result[value] = [key];
	          }
	        }
	        else {
	          result[value] = key;
	        }
	      }
	      return result;
	    }
	
	    /**
	     * Creates an array of the own enumerable property names of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects. See the
	     * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
	     * for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.keys(new Foo);
	     * // => ['a', 'b'] (iteration order is not guaranteed)
	     *
	     * _.keys('hi');
	     * // => ['0', '1']
	     */
	    var keys = !nativeKeys ? shimKeys : function(object) {
	      var Ctor = object == null ? undefined : object.constructor;
	      if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
	          (typeof object != 'function' && isArrayLike(object))) {
	        return shimKeys(object);
	      }
	      return isObject(object) ? nativeKeys(object) : [];
	    };
	
	    /**
	     * Creates an array of the own and inherited enumerable property names of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.keysIn(new Foo);
	     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	     */
	    function keysIn(object) {
	      if (object == null) {
	        return [];
	      }
	      if (!isObject(object)) {
	        object = Object(object);
	      }
	      var length = object.length;
	      length = (length && isLength(length) &&
	        (isArray(object) || isArguments(object)) && length) || 0;
	
	      var Ctor = object.constructor,
	          index = -1,
	          isProto = typeof Ctor == 'function' && Ctor.prototype === object,
	          result = Array(length),
	          skipIndexes = length > 0;
	
	      while (++index < length) {
	        result[index] = (index + '');
	      }
	      for (var key in object) {
	        if (!(skipIndexes && isIndex(key, length)) &&
	            !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	          result.push(key);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The opposite of `_.mapValues`; this method creates an object with the
	     * same values as `object` and keys generated by running each own enumerable
	     * property of `object` through `iteratee`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns the new mapped object.
	     * @example
	     *
	     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
	     *   return key + value;
	     * });
	     * // => { 'a1': 1, 'b2': 2 }
	     */
	    var mapKeys = createObjectMapper(true);
	
	    /**
	     * Creates an object with the same keys as `object` and values generated by
	     * running each own enumerable property of `object` through `iteratee`. The
	     * iteratee function is bound to `thisArg` and invoked with three arguments:
	     * (value, key, object).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns the new mapped object.
	     * @example
	     *
	     * _.mapValues({ 'a': 1, 'b': 2 }, function(n) {
	     *   return n * 3;
	     * });
	     * // => { 'a': 3, 'b': 6 }
	     *
	     * var users = {
	     *   'fred':    { 'user': 'fred',    'age': 40 },
	     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
	     * };
	     *
	     * // using the `_.property` callback shorthand
	     * _.mapValues(users, 'age');
	     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	     */
	    var mapValues = createObjectMapper();
	
	    /**
	     * The opposite of `_.pick`; this method creates an object composed of the
	     * own and inherited enumerable properties of `object` that are not omitted.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {Function|...(string|string[])} [predicate] The function invoked per
	     *  iteration or property names to omit, specified as individual property
	     *  names or arrays of property names.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'user': 'fred', 'age': 40 };
	     *
	     * _.omit(object, 'age');
	     * // => { 'user': 'fred' }
	     *
	     * _.omit(object, _.isNumber);
	     * // => { 'user': 'fred' }
	     */
	    var omit = restParam(function(object, props) {
	      if (object == null) {
	        return {};
	      }
	      if (typeof props[0] != 'function') {
	        var props = arrayMap(baseFlatten(props), String);
	        return pickByArray(object, baseDifference(keysIn(object), props));
	      }
	      var predicate = bindCallback(props[0], props[1], 3);
	      return pickByCallback(object, function(value, key, object) {
	        return !predicate(value, key, object);
	      });
	    });
	
	    /**
	     * Creates a two dimensional array of the key-value pairs for `object`,
	     * e.g. `[[key1, value1], [key2, value2]]`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the new array of key-value pairs.
	     * @example
	     *
	     * _.pairs({ 'barney': 36, 'fred': 40 });
	     * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
	     */
	    function pairs(object) {
	      object = toObject(object);
	
	      var index = -1,
	          props = keys(object),
	          length = props.length,
	          result = Array(length);
	
	      while (++index < length) {
	        var key = props[index];
	        result[index] = [key, object[key]];
	      }
	      return result;
	    }
	
	    /**
	     * Creates an object composed of the picked `object` properties. Property
	     * names may be specified as individual arguments or as arrays of property
	     * names. If `predicate` is provided it is invoked for each property of `object`
	     * picking the properties `predicate` returns truthy for. The predicate is
	     * bound to `thisArg` and invoked with three arguments: (value, key, object).
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {Function|...(string|string[])} [predicate] The function invoked per
	     *  iteration or property names to pick, specified as individual property
	     *  names or arrays of property names.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'user': 'fred', 'age': 40 };
	     *
	     * _.pick(object, 'user');
	     * // => { 'user': 'fred' }
	     *
	     * _.pick(object, _.isString);
	     * // => { 'user': 'fred' }
	     */
	    var pick = restParam(function(object, props) {
	      if (object == null) {
	        return {};
	      }
	      return typeof props[0] == 'function'
	        ? pickByCallback(object, bindCallback(props[0], props[1], 3))
	        : pickByArray(object, baseFlatten(props));
	    });
	
	    /**
	     * This method is like `_.get` except that if the resolved value is a function
	     * it is invoked with the `this` binding of its parent object and its result
	     * is returned.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to resolve.
	     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
	     *
	     * _.result(object, 'a[0].b.c1');
	     * // => 3
	     *
	     * _.result(object, 'a[0].b.c2');
	     * // => 4
	     *
	     * _.result(object, 'a.b.c', 'default');
	     * // => 'default'
	     *
	     * _.result(object, 'a.b.c', _.constant('default'));
	     * // => 'default'
	     */
	    function result(object, path, defaultValue) {
	      var result = object == null ? undefined : object[path];
	      if (result === undefined) {
	        if (object != null && !isKey(path, object)) {
	          path = toPath(path);
	          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
	          result = object == null ? undefined : object[last(path)];
	        }
	        result = result === undefined ? defaultValue : result;
	      }
	      return isFunction(result) ? result.call(object) : result;
	    }
	
	    /**
	     * Sets the property value of `path` on `object`. If a portion of `path`
	     * does not exist it is created.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to augment.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.set(object, 'a[0].b.c', 4);
	     * console.log(object.a[0].b.c);
	     * // => 4
	     *
	     * _.set(object, 'x[0].y.z', 5);
	     * console.log(object.x[0].y.z);
	     * // => 5
	     */
	    function set(object, path, value) {
	      if (object == null) {
	        return object;
	      }
	      var pathKey = (path + '');
	      path = (object[pathKey] != null || isKey(path, object)) ? [pathKey] : toPath(path);
	
	      var index = -1,
	          length = path.length,
	          lastIndex = length - 1,
	          nested = object;
	
	      while (nested != null && ++index < length) {
	        var key = path[index];
	        if (isObject(nested)) {
	          if (index == lastIndex) {
	            nested[key] = value;
	          } else if (nested[key] == null) {
	            nested[key] = isIndex(path[index + 1]) ? [] : {};
	          }
	        }
	        nested = nested[key];
	      }
	      return object;
	    }
	
	    /**
	     * An alternative to `_.reduce`; this method transforms `object` to a new
	     * `accumulator` object which is the result of running each of its own enumerable
	     * properties through `iteratee`, with each invocation potentially mutating
	     * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked
	     * with four arguments: (accumulator, value, key, object). Iteratee functions
	     * may exit iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Array|Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The custom accumulator value.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * _.transform([2, 3, 4], function(result, n) {
	     *   result.push(n *= n);
	     *   return n % 2 == 0;
	     * });
	     * // => [4, 9]
	     *
	     * _.transform({ 'a': 1, 'b': 2 }, function(result, n, key) {
	     *   result[key] = n * 3;
	     * });
	     * // => { 'a': 3, 'b': 6 }
	     */
	    function transform(object, iteratee, accumulator, thisArg) {
	      var isArr = isArray(object) || isTypedArray(object);
	      iteratee = getCallback(iteratee, thisArg, 4);
	
	      if (accumulator == null) {
	        if (isArr || isObject(object)) {
	          var Ctor = object.constructor;
	          if (isArr) {
	            accumulator = isArray(object) ? new Ctor : [];
	          } else {
	            accumulator = baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);
	          }
	        } else {
	          accumulator = {};
	        }
	      }
	      (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
	        return iteratee(accumulator, value, index, object);
	      });
	      return accumulator;
	    }
	
	    /**
	     * Creates an array of the own enumerable property values of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property values.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.values(new Foo);
	     * // => [1, 2] (iteration order is not guaranteed)
	     *
	     * _.values('hi');
	     * // => ['h', 'i']
	     */
	    function values(object) {
	      return baseValues(object, keys(object));
	    }
	
	    /**
	     * Creates an array of the own and inherited enumerable property values
	     * of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property values.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.valuesIn(new Foo);
	     * // => [1, 2, 3] (iteration order is not guaranteed)
	     */
	    function valuesIn(object) {
	      return baseValues(object, keysIn(object));
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Checks if `n` is between `start` and up to but not including, `end`. If
	     * `end` is not specified it is set to `start` with `start` then set to `0`.
	     *
	     * @static
	     * @memberOf _
	     * @category Number
	     * @param {number} n The number to check.
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @returns {boolean} Returns `true` if `n` is in the range, else `false`.
	     * @example
	     *
	     * _.inRange(3, 2, 4);
	     * // => true
	     *
	     * _.inRange(4, 8);
	     * // => true
	     *
	     * _.inRange(4, 2);
	     * // => false
	     *
	     * _.inRange(2, 2);
	     * // => false
	     *
	     * _.inRange(1.2, 2);
	     * // => true
	     *
	     * _.inRange(5.2, 4);
	     * // => false
	     */
	    function inRange(value, start, end) {
	      start = +start || 0;
	      if (end === undefined) {
	        end = start;
	        start = 0;
	      } else {
	        end = +end || 0;
	      }
	      return value >= nativeMin(start, end) && value < nativeMax(start, end);
	    }
	
	    /**
	     * Produces a random number between `min` and `max` (inclusive). If only one
	     * argument is provided a number between `0` and the given number is returned.
	     * If `floating` is `true`, or either `min` or `max` are floats, a floating-point
	     * number is returned instead of an integer.
	     *
	     * @static
	     * @memberOf _
	     * @category Number
	     * @param {number} [min=0] The minimum possible value.
	     * @param {number} [max=1] The maximum possible value.
	     * @param {boolean} [floating] Specify returning a floating-point number.
	     * @returns {number} Returns the random number.
	     * @example
	     *
	     * _.random(0, 5);
	     * // => an integer between 0 and 5
	     *
	     * _.random(5);
	     * // => also an integer between 0 and 5
	     *
	     * _.random(5, true);
	     * // => a floating-point number between 0 and 5
	     *
	     * _.random(1.2, 5.2);
	     * // => a floating-point number between 1.2 and 5.2
	     */
	    function random(min, max, floating) {
	      if (floating && isIterateeCall(min, max, floating)) {
	        max = floating = undefined;
	      }
	      var noMin = min == null,
	          noMax = max == null;
	
	      if (floating == null) {
	        if (noMax && typeof min == 'boolean') {
	          floating = min;
	          min = 1;
	        }
	        else if (typeof max == 'boolean') {
	          floating = max;
	          noMax = true;
	        }
	      }
	      if (noMin && noMax) {
	        max = 1;
	        noMax = false;
	      }
	      min = +min || 0;
	      if (noMax) {
	        max = min;
	        min = 0;
	      } else {
	        max = +max || 0;
	      }
	      if (floating || min % 1 || max % 1) {
	        var rand = nativeRandom();
	        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
	      }
	      return baseRandom(min, max);
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the camel cased string.
	     * @example
	     *
	     * _.camelCase('Foo Bar');
	     * // => 'fooBar'
	     *
	     * _.camelCase('--foo-bar');
	     * // => 'fooBar'
	     *
	     * _.camelCase('__foo_bar__');
	     * // => 'fooBar'
	     */
	    var camelCase = createCompounder(function(result, word, index) {
	      word = word.toLowerCase();
	      return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
	    });
	
	    /**
	     * Capitalizes the first character of `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to capitalize.
	     * @returns {string} Returns the capitalized string.
	     * @example
	     *
	     * _.capitalize('fred');
	     * // => 'Fred'
	     */
	    function capitalize(string) {
	      string = baseToString(string);
	      return string && (string.charAt(0).toUpperCase() + string.slice(1));
	    }
	
	    /**
	     * Deburrs `string` by converting [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
	     * to basic latin letters and removing [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to deburr.
	     * @returns {string} Returns the deburred string.
	     * @example
	     *
	     * _.deburr('déjà vu');
	     * // => 'deja vu'
	     */
	    function deburr(string) {
	      string = baseToString(string);
	      return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
	    }
	
	    /**
	     * Checks if `string` ends with the given target string.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to search.
	     * @param {string} [target] The string to search for.
	     * @param {number} [position=string.length] The position to search from.
	     * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.
	     * @example
	     *
	     * _.endsWith('abc', 'c');
	     * // => true
	     *
	     * _.endsWith('abc', 'b');
	     * // => false
	     *
	     * _.endsWith('abc', 'b', 2);
	     * // => true
	     */
	    function endsWith(string, target, position) {
	      string = baseToString(string);
	      target = (target + '');
	
	      var length = string.length;
	      position = position === undefined
	        ? length
	        : nativeMin(position < 0 ? 0 : (+position || 0), length);
	
	      position -= target.length;
	      return position >= 0 && string.indexOf(target, position) == position;
	    }
	
	    /**
	     * Converts the characters "&", "<", ">", '"', "'", and "\`", in `string` to
	     * their corresponding HTML entities.
	     *
	     * **Note:** No other characters are escaped. To escape additional characters
	     * use a third-party library like [_he_](https://mths.be/he).
	     *
	     * Though the ">" character is escaped for symmetry, characters like
	     * ">" and "/" don't need escaping in HTML and have no special meaning
	     * unless they're part of a tag or unquoted attribute value.
	     * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
	     * (under "semi-related fun fact") for more details.
	     *
	     * Backticks are escaped because in Internet Explorer < 9, they can break out
	     * of attribute values or HTML comments. See [#59](https://html5sec.org/#59),
	     * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
	     * [#133](https://html5sec.org/#133) of the [HTML5 Security Cheatsheet](https://html5sec.org/)
	     * for more details.
	     *
	     * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)
	     * to reduce XSS vectors.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escape('fred, barney, & pebbles');
	     * // => 'fred, barney, &amp; pebbles'
	     */
	    function escape(string) {
	      // Reset `lastIndex` because in IE < 9 `String#replace` does not.
	      string = baseToString(string);
	      return (string && reHasUnescapedHtml.test(string))
	        ? string.replace(reUnescapedHtml, escapeHtmlChar)
	        : string;
	    }
	
	    /**
	     * Escapes the `RegExp` special characters "\", "/", "^", "$", ".", "|", "?",
	     * "*", "+", "(", ")", "[", "]", "{" and "}" in `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escapeRegExp('[lodash](https://lodash.com/)');
	     * // => '\[lodash\]\(https:\/\/lodash\.com\/\)'
	     */
	    function escapeRegExp(string) {
	      string = baseToString(string);
	      return (string && reHasRegExpChars.test(string))
	        ? string.replace(reRegExpChars, escapeRegExpChar)
	        : (string || '(?:)');
	    }
	
	    /**
	     * Converts `string` to [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the kebab cased string.
	     * @example
	     *
	     * _.kebabCase('Foo Bar');
	     * // => 'foo-bar'
	     *
	     * _.kebabCase('fooBar');
	     * // => 'foo-bar'
	     *
	     * _.kebabCase('__foo_bar__');
	     * // => 'foo-bar'
	     */
	    var kebabCase = createCompounder(function(result, word, index) {
	      return result + (index ? '-' : '') + word.toLowerCase();
	    });
	
	    /**
	     * Pads `string` on the left and right sides if it's shorter than `length`.
	     * Padding characters are truncated if they can't be evenly divided by `length`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.pad('abc', 8);
	     * // => '  abc   '
	     *
	     * _.pad('abc', 8, '_-');
	     * // => '_-abc_-_'
	     *
	     * _.pad('abc', 3);
	     * // => 'abc'
	     */
	    function pad(string, length, chars) {
	      string = baseToString(string);
	      length = +length;
	
	      var strLength = string.length;
	      if (strLength >= length || !nativeIsFinite(length)) {
	        return string;
	      }
	      var mid = (length - strLength) / 2,
	          leftLength = nativeFloor(mid),
	          rightLength = nativeCeil(mid);
	
	      chars = createPadding('', rightLength, chars);
	      return chars.slice(0, leftLength) + string + chars;
	    }
	
	    /**
	     * Pads `string` on the left side if it's shorter than `length`. Padding
	     * characters are truncated if they exceed `length`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.padLeft('abc', 6);
	     * // => '   abc'
	     *
	     * _.padLeft('abc', 6, '_-');
	     * // => '_-_abc'
	     *
	     * _.padLeft('abc', 3);
	     * // => 'abc'
	     */
	    var padLeft = createPadDir();
	
	    /**
	     * Pads `string` on the right side if it's shorter than `length`. Padding
	     * characters are truncated if they exceed `length`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.padRight('abc', 6);
	     * // => 'abc   '
	     *
	     * _.padRight('abc', 6, '_-');
	     * // => 'abc_-_'
	     *
	     * _.padRight('abc', 3);
	     * // => 'abc'
	     */
	    var padRight = createPadDir(true);
	
	    /**
	     * Converts `string` to an integer of the specified radix. If `radix` is
	     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,
	     * in which case a `radix` of `16` is used.
	     *
	     * **Note:** This method aligns with the [ES5 implementation](https://es5.github.io/#E)
	     * of `parseInt`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} string The string to convert.
	     * @param {number} [radix] The radix to interpret `value` by.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.parseInt('08');
	     * // => 8
	     *
	     * _.map(['6', '08', '10'], _.parseInt);
	     * // => [6, 8, 10]
	     */
	    function parseInt(string, radix, guard) {
	      // Firefox < 21 and Opera < 15 follow ES3 for `parseInt`.
	      // Chrome fails to trim leading <BOM> whitespace characters.
	      // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.
	      if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
	        radix = 0;
	      } else if (radix) {
	        radix = +radix;
	      }
	      string = trim(string);
	      return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
	    }
	
	    /**
	     * Repeats the given string `n` times.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to repeat.
	     * @param {number} [n=0] The number of times to repeat the string.
	     * @returns {string} Returns the repeated string.
	     * @example
	     *
	     * _.repeat('*', 3);
	     * // => '***'
	     *
	     * _.repeat('abc', 2);
	     * // => 'abcabc'
	     *
	     * _.repeat('abc', 0);
	     * // => ''
	     */
	    function repeat(string, n) {
	      var result = '';
	      string = baseToString(string);
	      n = +n;
	      if (n < 1 || !string || !nativeIsFinite(n)) {
	        return result;
	      }
	      // Leverage the exponentiation by squaring algorithm for a faster repeat.
	      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
	      do {
	        if (n % 2) {
	          result += string;
	        }
	        n = nativeFloor(n / 2);
	        string += string;
	      } while (n);
	
	      return result;
	    }
	
	    /**
	     * Converts `string` to [snake case](https://en.wikipedia.org/wiki/Snake_case).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the snake cased string.
	     * @example
	     *
	     * _.snakeCase('Foo Bar');
	     * // => 'foo_bar'
	     *
	     * _.snakeCase('fooBar');
	     * // => 'foo_bar'
	     *
	     * _.snakeCase('--foo-bar');
	     * // => 'foo_bar'
	     */
	    var snakeCase = createCompounder(function(result, word, index) {
	      return result + (index ? '_' : '') + word.toLowerCase();
	    });
	
	    /**
	     * Converts `string` to [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the start cased string.
	     * @example
	     *
	     * _.startCase('--foo-bar');
	     * // => 'Foo Bar'
	     *
	     * _.startCase('fooBar');
	     * // => 'Foo Bar'
	     *
	     * _.startCase('__foo_bar__');
	     * // => 'Foo Bar'
	     */
	    var startCase = createCompounder(function(result, word, index) {
	      return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
	    });
	
	    /**
	     * Checks if `string` starts with the given target string.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to search.
	     * @param {string} [target] The string to search for.
	     * @param {number} [position=0] The position to search from.
	     * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.
	     * @example
	     *
	     * _.startsWith('abc', 'a');
	     * // => true
	     *
	     * _.startsWith('abc', 'b');
	     * // => false
	     *
	     * _.startsWith('abc', 'b', 1);
	     * // => true
	     */
	    function startsWith(string, target, position) {
	      string = baseToString(string);
	      position = position == null
	        ? 0
	        : nativeMin(position < 0 ? 0 : (+position || 0), string.length);
	
	      return string.lastIndexOf(target, position) == position;
	    }
	
	    /**
	     * Creates a compiled template function that can interpolate data properties
	     * in "interpolate" delimiters, HTML-escape interpolated data properties in
	     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
	     * properties may be accessed as free variables in the template. If a setting
	     * object is provided it takes precedence over `_.templateSettings` values.
	     *
	     * **Note:** In the development build `_.template` utilizes
	     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
	     * for easier debugging.
	     *
	     * For more information on precompiling templates see
	     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
	     *
	     * For more information on Chrome extension sandboxes see
	     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The template string.
	     * @param {Object} [options] The options object.
	     * @param {RegExp} [options.escape] The HTML "escape" delimiter.
	     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
	     * @param {Object} [options.imports] An object to import into the template as free variables.
	     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
	     * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.
	     * @param {string} [options.variable] The data object variable name.
	     * @param- {Object} [otherOptions] Enables the legacy `options` param signature.
	     * @returns {Function} Returns the compiled template function.
	     * @example
	     *
	     * // using the "interpolate" delimiter to create a compiled template
	     * var compiled = _.template('hello <%= user %>!');
	     * compiled({ 'user': 'fred' });
	     * // => 'hello fred!'
	     *
	     * // using the HTML "escape" delimiter to escape data property values
	     * var compiled = _.template('<b><%- value %></b>');
	     * compiled({ 'value': '<script>' });
	     * // => '<b>&lt;script&gt;</b>'
	     *
	     * // using the "evaluate" delimiter to execute JavaScript and generate HTML
	     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
	     * compiled({ 'users': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // using the internal `print` function in "evaluate" delimiters
	     * var compiled = _.template('<% print("hello " + user); %>!');
	     * compiled({ 'user': 'barney' });
	     * // => 'hello barney!'
	     *
	     * // using the ES delimiter as an alternative to the default "interpolate" delimiter
	     * var compiled = _.template('hello ${ user }!');
	     * compiled({ 'user': 'pebbles' });
	     * // => 'hello pebbles!'
	     *
	     * // using custom template delimiters
	     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
	     * var compiled = _.template('hello {{ user }}!');
	     * compiled({ 'user': 'mustache' });
	     * // => 'hello mustache!'
	     *
	     * // using backslashes to treat delimiters as plain text
	     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
	     * compiled({ 'value': 'ignored' });
	     * // => '<%- value %>'
	     *
	     * // using the `imports` option to import `jQuery` as `jq`
	     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
	     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
	     * compiled({ 'users': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // using the `sourceURL` option to specify a custom sourceURL for the template
	     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
	     * compiled(data);
	     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
	     *
	     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
	     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
	     * compiled.source;
	     * // => function(data) {
	     * //   var __t, __p = '';
	     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
	     * //   return __p;
	     * // }
	     *
	     * // using the `source` property to inline compiled templates for meaningful
	     * // line numbers in error messages and a stack trace
	     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
	     *   var JST = {\
	     *     "main": ' + _.template(mainText).source + '\
	     *   };\
	     * ');
	     */
	    function template(string, options, otherOptions) {
	      // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)
	      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
	      var settings = lodash.templateSettings;
	
	      if (otherOptions && isIterateeCall(string, options, otherOptions)) {
	        options = otherOptions = undefined;
	      }
	      string = baseToString(string);
	      options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);
	
	      var imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
	          importsKeys = keys(imports),
	          importsValues = baseValues(imports, importsKeys);
	
	      var isEscaping,
	          isEvaluating,
	          index = 0,
	          interpolate = options.interpolate || reNoMatch,
	          source = "__p += '";
	
	      // Compile the regexp to match each delimiter.
	      var reDelimiters = RegExp(
	        (options.escape || reNoMatch).source + '|' +
	        interpolate.source + '|' +
	        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
	        (options.evaluate || reNoMatch).source + '|$'
	      , 'g');
	
	      // Use a sourceURL for easier debugging.
	      var sourceURL = '//# sourceURL=' +
	        ('sourceURL' in options
	          ? options.sourceURL
	          : ('lodash.templateSources[' + (++templateCounter) + ']')
	        ) + '\n';
	
	      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
	        interpolateValue || (interpolateValue = esTemplateValue);
	
	        // Escape characters that can't be included in string literals.
	        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
	
	        // Replace delimiters with snippets.
	        if (escapeValue) {
	          isEscaping = true;
	          source += "' +\n__e(" + escapeValue + ") +\n'";
	        }
	        if (evaluateValue) {
	          isEvaluating = true;
	          source += "';\n" + evaluateValue + ";\n__p += '";
	        }
	        if (interpolateValue) {
	          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
	        }
	        index = offset + match.length;
	
	        // The JS engine embedded in Adobe products requires returning the `match`
	        // string in order to produce the correct `offset` value.
	        return match;
	      });
	
	      source += "';\n";
	
	      // If `variable` is not specified wrap a with-statement around the generated
	      // code to add the data object to the top of the scope chain.
	      var variable = options.variable;
	      if (!variable) {
	        source = 'with (obj) {\n' + source + '\n}\n';
	      }
	      // Cleanup code by stripping empty strings.
	      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
	        .replace(reEmptyStringMiddle, '$1')
	        .replace(reEmptyStringTrailing, '$1;');
	
	      // Frame code as the function body.
	      source = 'function(' + (variable || 'obj') + ') {\n' +
	        (variable
	          ? ''
	          : 'obj || (obj = {});\n'
	        ) +
	        "var __t, __p = ''" +
	        (isEscaping
	           ? ', __e = _.escape'
	           : ''
	        ) +
	        (isEvaluating
	          ? ', __j = Array.prototype.join;\n' +
	            "function print() { __p += __j.call(arguments, '') }\n"
	          : ';\n'
	        ) +
	        source +
	        'return __p\n}';
	
	      var result = attempt(function() {
	        return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
	      });
	
	      // Provide the compiled function's source by its `toString` method or
	      // the `source` property as a convenience for inlining compiled templates.
	      result.source = source;
	      if (isError(result)) {
	        throw result;
	      }
	      return result;
	    }
	
	    /**
	     * Removes leading and trailing whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trim('  abc  ');
	     * // => 'abc'
	     *
	     * _.trim('-_-abc-_-', '_-');
	     * // => 'abc'
	     *
	     * _.map(['  foo  ', '  bar  '], _.trim);
	     * // => ['foo', 'bar']
	     */
	    function trim(string, chars, guard) {
	      var value = string;
	      string = baseToString(string);
	      if (!string) {
	        return string;
	      }
	      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
	        return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
	      }
	      chars = (chars + '');
	      return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
	    }
	
	    /**
	     * Removes leading whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trimLeft('  abc  ');
	     * // => 'abc  '
	     *
	     * _.trimLeft('-_-abc-_-', '_-');
	     * // => 'abc-_-'
	     */
	    function trimLeft(string, chars, guard) {
	      var value = string;
	      string = baseToString(string);
	      if (!string) {
	        return string;
	      }
	      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
	        return string.slice(trimmedLeftIndex(string));
	      }
	      return string.slice(charsLeftIndex(string, (chars + '')));
	    }
	
	    /**
	     * Removes trailing whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trimRight('  abc  ');
	     * // => '  abc'
	     *
	     * _.trimRight('-_-abc-_-', '_-');
	     * // => '-_-abc'
	     */
	    function trimRight(string, chars, guard) {
	      var value = string;
	      string = baseToString(string);
	      if (!string) {
	        return string;
	      }
	      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
	        return string.slice(0, trimmedRightIndex(string) + 1);
	      }
	      return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
	    }
	
	    /**
	     * Truncates `string` if it's longer than the given maximum string length.
	     * The last characters of the truncated string are replaced with the omission
	     * string which defaults to "...".
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to truncate.
	     * @param {Object|number} [options] The options object or maximum string length.
	     * @param {number} [options.length=30] The maximum string length.
	     * @param {string} [options.omission='...'] The string to indicate text is omitted.
	     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {string} Returns the truncated string.
	     * @example
	     *
	     * _.trunc('hi-diddly-ho there, neighborino');
	     * // => 'hi-diddly-ho there, neighbo...'
	     *
	     * _.trunc('hi-diddly-ho there, neighborino', 24);
	     * // => 'hi-diddly-ho there, n...'
	     *
	     * _.trunc('hi-diddly-ho there, neighborino', {
	     *   'length': 24,
	     *   'separator': ' '
	     * });
	     * // => 'hi-diddly-ho there,...'
	     *
	     * _.trunc('hi-diddly-ho there, neighborino', {
	     *   'length': 24,
	     *   'separator': /,? +/
	     * });
	     * // => 'hi-diddly-ho there...'
	     *
	     * _.trunc('hi-diddly-ho there, neighborino', {
	     *   'omission': ' [...]'
	     * });
	     * // => 'hi-diddly-ho there, neig [...]'
	     */
	    function trunc(string, options, guard) {
	      if (guard && isIterateeCall(string, options, guard)) {
	        options = undefined;
	      }
	      var length = DEFAULT_TRUNC_LENGTH,
	          omission = DEFAULT_TRUNC_OMISSION;
	
	      if (options != null) {
	        if (isObject(options)) {
	          var separator = 'separator' in options ? options.separator : separator;
	          length = 'length' in options ? (+options.length || 0) : length;
	          omission = 'omission' in options ? baseToString(options.omission) : omission;
	        } else {
	          length = +options || 0;
	        }
	      }
	      string = baseToString(string);
	      if (length >= string.length) {
	        return string;
	      }
	      var end = length - omission.length;
	      if (end < 1) {
	        return omission;
	      }
	      var result = string.slice(0, end);
	      if (separator == null) {
	        return result + omission;
	      }
	      if (isRegExp(separator)) {
	        if (string.slice(end).search(separator)) {
	          var match,
	              newEnd,
	              substring = string.slice(0, end);
	
	          if (!separator.global) {
	            separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
	          }
	          separator.lastIndex = 0;
	          while ((match = separator.exec(substring))) {
	            newEnd = match.index;
	          }
	          result = result.slice(0, newEnd == null ? end : newEnd);
	        }
	      } else if (string.indexOf(separator, end) != end) {
	        var index = result.lastIndexOf(separator);
	        if (index > -1) {
	          result = result.slice(0, index);
	        }
	      }
	      return result + omission;
	    }
	
	    /**
	     * The inverse of `_.escape`; this method converts the HTML entities
	     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their
	     * corresponding characters.
	     *
	     * **Note:** No other HTML entities are unescaped. To unescape additional HTML
	     * entities use a third-party library like [_he_](https://mths.be/he).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to unescape.
	     * @returns {string} Returns the unescaped string.
	     * @example
	     *
	     * _.unescape('fred, barney, &amp; pebbles');
	     * // => 'fred, barney, & pebbles'
	     */
	    function unescape(string) {
	      string = baseToString(string);
	      return (string && reHasEscapedHtml.test(string))
	        ? string.replace(reEscapedHtml, unescapeHtmlChar)
	        : string;
	    }
	
	    /**
	     * Splits `string` into an array of its words.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {RegExp|string} [pattern] The pattern to match words.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the words of `string`.
	     * @example
	     *
	     * _.words('fred, barney, & pebbles');
	     * // => ['fred', 'barney', 'pebbles']
	     *
	     * _.words('fred, barney, & pebbles', /[^, ]+/g);
	     * // => ['fred', 'barney', '&', 'pebbles']
	     */
	    function words(string, pattern, guard) {
	      if (guard && isIterateeCall(string, pattern, guard)) {
	        pattern = undefined;
	      }
	      string = baseToString(string);
	      return string.match(pattern || reWords) || [];
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Attempts to invoke `func`, returning either the result or the caught error
	     * object. Any additional arguments are provided to `func` when it is invoked.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Function} func The function to attempt.
	     * @returns {*} Returns the `func` result or error object.
	     * @example
	     *
	     * // avoid throwing errors for invalid selectors
	     * var elements = _.attempt(function(selector) {
	     *   return document.querySelectorAll(selector);
	     * }, '>_>');
	     *
	     * if (_.isError(elements)) {
	     *   elements = [];
	     * }
	     */
	    var attempt = restParam(function(func, args) {
	      try {
	        return func.apply(undefined, args);
	      } catch(e) {
	        return isError(e) ? e : new Error(e);
	      }
	    });
	
	    /**
	     * Creates a function that invokes `func` with the `this` binding of `thisArg`
	     * and arguments of the created function. If `func` is a property name the
	     * created callback returns the property value for a given element. If `func`
	     * is an object the created callback returns `true` for elements that contain
	     * the equivalent object properties, otherwise it returns `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias iteratee
	     * @category Utility
	     * @param {*} [func=_.identity] The value to convert to a callback.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Function} Returns the callback.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * // wrap to create custom callback shorthands
	     * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {
	     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);
	     *   if (!match) {
	     *     return callback(func, thisArg);
	     *   }
	     *   return function(object) {
	     *     return match[2] == 'gt'
	     *       ? object[match[1]] > match[3]
	     *       : object[match[1]] < match[3];
	     *   };
	     * });
	     *
	     * _.filter(users, 'age__gt36');
	     * // => [{ 'user': 'fred', 'age': 40 }]
	     */
	    function callback(func, thisArg, guard) {
	      if (guard && isIterateeCall(func, thisArg, guard)) {
	        thisArg = undefined;
	      }
	      return isObjectLike(func)
	        ? matches(func)
	        : baseCallback(func, thisArg);
	    }
	
	    /**
	     * Creates a function that returns `value`.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {*} value The value to return from the new function.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var object = { 'user': 'fred' };
	     * var getter = _.constant(object);
	     *
	     * getter() === object;
	     * // => true
	     */
	    function constant(value) {
	      return function() {
	        return value;
	      };
	    }
	
	    /**
	     * This method returns the first argument provided to it.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {*} value Any value.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * var object = { 'user': 'fred' };
	     *
	     * _.identity(object) === object;
	     * // => true
	     */
	    function identity(value) {
	      return value;
	    }
	
	    /**
	     * Creates a function that performs a deep comparison between a given object
	     * and `source`, returning `true` if the given object has equivalent property
	     * values, else `false`.
	     *
	     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
	     * numbers, `Object` objects, regexes, and strings. Objects are compared by
	     * their own, not inherited, enumerable properties. For comparing a single
	     * own or inherited property value see `_.matchesProperty`.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Object} source The object of property values to match.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * _.filter(users, _.matches({ 'age': 40, 'active': false }));
	     * // => [{ 'user': 'fred', 'age': 40, 'active': false }]
	     */
	    function matches(source) {
	      return baseMatches(baseClone(source, true));
	    }
	
	    /**
	     * Creates a function that compares the property value of `path` on a given
	     * object to `value`.
	     *
	     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
	     * numbers, `Object` objects, regexes, and strings. Objects are compared by
	     * their own, not inherited, enumerable properties.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Array|string} path The path of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * _.find(users, _.matchesProperty('user', 'fred'));
	     * // => { 'user': 'fred' }
	     */
	    function matchesProperty(path, srcValue) {
	      return baseMatchesProperty(path, baseClone(srcValue, true));
	    }
	
	    /**
	     * Creates a function that invokes the method at `path` on a given object.
	     * Any additional arguments are provided to the invoked method.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': { 'b': { 'c': _.constant(2) } } },
	     *   { 'a': { 'b': { 'c': _.constant(1) } } }
	     * ];
	     *
	     * _.map(objects, _.method('a.b.c'));
	     * // => [2, 1]
	     *
	     * _.invoke(_.sortBy(objects, _.method(['a', 'b', 'c'])), 'a.b.c');
	     * // => [1, 2]
	     */
	    var method = restParam(function(path, args) {
	      return function(object) {
	        return invokePath(object, path, args);
	      };
	    });
	
	    /**
	     * The opposite of `_.method`; this method creates a function that invokes
	     * the method at a given path on `object`. Any additional arguments are
	     * provided to the invoked method.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Object} object The object to query.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var array = _.times(3, _.constant),
	     *     object = { 'a': array, 'b': array, 'c': array };
	     *
	     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
	     * // => [2, 0]
	     *
	     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
	     * // => [2, 0]
	     */
	    var methodOf = restParam(function(object, args) {
	      return function(path) {
	        return invokePath(object, path, args);
	      };
	    });
	
	    /**
	     * Adds all own enumerable function properties of a source object to the
	     * destination object. If `object` is a function then methods are added to
	     * its prototype as well.
	     *
	     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
	     * avoid conflicts caused by modifying the original.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Function|Object} [object=lodash] The destination object.
	     * @param {Object} source The object of functions to add.
	     * @param {Object} [options] The options object.
	     * @param {boolean} [options.chain=true] Specify whether the functions added
	     *  are chainable.
	     * @returns {Function|Object} Returns `object`.
	     * @example
	     *
	     * function vowels(string) {
	     *   return _.filter(string, function(v) {
	     *     return /[aeiou]/i.test(v);
	     *   });
	     * }
	     *
	     * _.mixin({ 'vowels': vowels });
	     * _.vowels('fred');
	     * // => ['e']
	     *
	     * _('fred').vowels().value();
	     * // => ['e']
	     *
	     * _.mixin({ 'vowels': vowels }, { 'chain': false });
	     * _('fred').vowels();
	     * // => ['e']
	     */
	    function mixin(object, source, options) {
	      if (options == null) {
	        var isObj = isObject(source),
	            props = isObj ? keys(source) : undefined,
	            methodNames = (props && props.length) ? baseFunctions(source, props) : undefined;
	
	        if (!(methodNames ? methodNames.length : isObj)) {
	          methodNames = false;
	          options = source;
	          source = object;
	          object = this;
	        }
	      }
	      if (!methodNames) {
	        methodNames = baseFunctions(source, keys(source));
	      }
	      var chain = true,
	          index = -1,
	          isFunc = isFunction(object),
	          length = methodNames.length;
	
	      if (options === false) {
	        chain = false;
	      } else if (isObject(options) && 'chain' in options) {
	        chain = options.chain;
	      }
	      while (++index < length) {
	        var methodName = methodNames[index],
	            func = source[methodName];
	
	        object[methodName] = func;
	        if (isFunc) {
	          object.prototype[methodName] = (function(func) {
	            return function() {
	              var chainAll = this.__chain__;
	              if (chain || chainAll) {
	                var result = object(this.__wrapped__),
	                    actions = result.__actions__ = arrayCopy(this.__actions__);
	
	                actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
	                result.__chain__ = chainAll;
	                return result;
	              }
	              return func.apply(object, arrayPush([this.value()], arguments));
	            };
	          }(func));
	        }
	      }
	      return object;
	    }
	
	    /**
	     * Reverts the `_` variable to its previous value and returns a reference to
	     * the `lodash` function.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @returns {Function} Returns the `lodash` function.
	     * @example
	     *
	     * var lodash = _.noConflict();
	     */
	    function noConflict() {
	      root._ = oldDash;
	      return this;
	    }
	
	    /**
	     * A no-operation function that returns `undefined` regardless of the
	     * arguments it receives.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @example
	     *
	     * var object = { 'user': 'fred' };
	     *
	     * _.noop(object) === undefined;
	     * // => true
	     */
	    function noop() {
	      // No operation performed.
	    }
	
	    /**
	     * Creates a function that returns the property value at `path` on a
	     * given object.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Array|string} path The path of the property to get.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': { 'b': { 'c': 2 } } },
	     *   { 'a': { 'b': { 'c': 1 } } }
	     * ];
	     *
	     * _.map(objects, _.property('a.b.c'));
	     * // => [2, 1]
	     *
	     * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
	     * // => [1, 2]
	     */
	    function property(path) {
	      return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
	    }
	
	    /**
	     * The opposite of `_.property`; this method creates a function that returns
	     * the property value at a given path on `object`.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Object} object The object to query.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var array = [0, 1, 2],
	     *     object = { 'a': array, 'b': array, 'c': array };
	     *
	     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
	     * // => [2, 0]
	     *
	     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
	     * // => [2, 0]
	     */
	    function propertyOf(object) {
	      return function(path) {
	        return baseGet(object, toPath(path), path + '');
	      };
	    }
	
	    /**
	     * Creates an array of numbers (positive and/or negative) progressing from
	     * `start` up to, but not including, `end`. If `end` is not specified it is
	     * set to `start` with `start` then set to `0`. If `end` is less than `start`
	     * a zero-length range is created unless a negative `step` is specified.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} [step=1] The value to increment or decrement by.
	     * @returns {Array} Returns the new array of numbers.
	     * @example
	     *
	     * _.range(4);
	     * // => [0, 1, 2, 3]
	     *
	     * _.range(1, 5);
	     * // => [1, 2, 3, 4]
	     *
	     * _.range(0, 20, 5);
	     * // => [0, 5, 10, 15]
	     *
	     * _.range(0, -4, -1);
	     * // => [0, -1, -2, -3]
	     *
	     * _.range(1, 4, 0);
	     * // => [1, 1, 1]
	     *
	     * _.range(0);
	     * // => []
	     */
	    function range(start, end, step) {
	      if (step && isIterateeCall(start, end, step)) {
	        end = step = undefined;
	      }
	      start = +start || 0;
	      step = step == null ? 1 : (+step || 0);
	
	      if (end == null) {
	        end = start;
	        start = 0;
	      } else {
	        end = +end || 0;
	      }
	      // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.
	      // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.
	      var index = -1,
	          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
	          result = Array(length);
	
	      while (++index < length) {
	        result[index] = start;
	        start += step;
	      }
	      return result;
	    }
	
	    /**
	     * Invokes the iteratee function `n` times, returning an array of the results
	     * of each invocation. The `iteratee` is bound to `thisArg` and invoked with
	     * one argument; (index).
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {number} n The number of times to invoke `iteratee`.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the array of results.
	     * @example
	     *
	     * var diceRolls = _.times(3, _.partial(_.random, 1, 6, false));
	     * // => [3, 6, 4]
	     *
	     * _.times(3, function(n) {
	     *   mage.castSpell(n);
	     * });
	     * // => invokes `mage.castSpell(n)` three times with `n` of `0`, `1`, and `2`
	     *
	     * _.times(3, function(n) {
	     *   this.cast(n);
	     * }, mage);
	     * // => also invokes `mage.castSpell(n)` three times
	     */
	    function times(n, iteratee, thisArg) {
	      n = nativeFloor(n);
	
	      // Exit early to avoid a JSC JIT bug in Safari 8
	      // where `Array(0)` is treated as `Array(1)`.
	      if (n < 1 || !nativeIsFinite(n)) {
	        return [];
	      }
	      var index = -1,
	          result = Array(nativeMin(n, MAX_ARRAY_LENGTH));
	
	      iteratee = bindCallback(iteratee, thisArg, 1);
	      while (++index < n) {
	        if (index < MAX_ARRAY_LENGTH) {
	          result[index] = iteratee(index);
	        } else {
	          iteratee(index);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * Generates a unique ID. If `prefix` is provided the ID is appended to it.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {string} [prefix] The value to prefix the ID with.
	     * @returns {string} Returns the unique ID.
	     * @example
	     *
	     * _.uniqueId('contact_');
	     * // => 'contact_104'
	     *
	     * _.uniqueId();
	     * // => '105'
	     */
	    function uniqueId(prefix) {
	      var id = ++idCounter;
	      return baseToString(prefix) + id;
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Adds two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {number} augend The first number to add.
	     * @param {number} addend The second number to add.
	     * @returns {number} Returns the sum.
	     * @example
	     *
	     * _.add(6, 4);
	     * // => 10
	     */
	    function add(augend, addend) {
	      return (+augend || 0) + (+addend || 0);
	    }
	
	    /**
	     * Calculates `n` rounded up to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {number} n The number to round up.
	     * @param {number} [precision=0] The precision to round up to.
	     * @returns {number} Returns the rounded up number.
	     * @example
	     *
	     * _.ceil(4.006);
	     * // => 5
	     *
	     * _.ceil(6.004, 2);
	     * // => 6.01
	     *
	     * _.ceil(6040, -2);
	     * // => 6100
	     */
	    var ceil = createRound('ceil');
	
	    /**
	     * Calculates `n` rounded down to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {number} n The number to round down.
	     * @param {number} [precision=0] The precision to round down to.
	     * @returns {number} Returns the rounded down number.
	     * @example
	     *
	     * _.floor(4.006);
	     * // => 4
	     *
	     * _.floor(0.046, 2);
	     * // => 0.04
	     *
	     * _.floor(4060, -2);
	     * // => 4000
	     */
	    var floor = createRound('floor');
	
	    /**
	     * Gets the maximum value of `collection`. If `collection` is empty or falsey
	     * `-Infinity` is returned. If an iteratee function is provided it is invoked
	     * for each value in `collection` to generate the criterion by which the value
	     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
	     * arguments: (value, index, collection).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {*} Returns the maximum value.
	     * @example
	     *
	     * _.max([4, 2, 8, 6]);
	     * // => 8
	     *
	     * _.max([]);
	     * // => -Infinity
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * _.max(users, function(chr) {
	     *   return chr.age;
	     * });
	     * // => { 'user': 'fred', 'age': 40 }
	     *
	     * // using the `_.property` callback shorthand
	     * _.max(users, 'age');
	     * // => { 'user': 'fred', 'age': 40 }
	     */
	    var max = createExtremum(gt, NEGATIVE_INFINITY);
	
	    /**
	     * Gets the minimum value of `collection`. If `collection` is empty or falsey
	     * `Infinity` is returned. If an iteratee function is provided it is invoked
	     * for each value in `collection` to generate the criterion by which the value
	     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
	     * arguments: (value, index, collection).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {*} Returns the minimum value.
	     * @example
	     *
	     * _.min([4, 2, 8, 6]);
	     * // => 2
	     *
	     * _.min([]);
	     * // => Infinity
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * _.min(users, function(chr) {
	     *   return chr.age;
	     * });
	     * // => { 'user': 'barney', 'age': 36 }
	     *
	     * // using the `_.property` callback shorthand
	     * _.min(users, 'age');
	     * // => { 'user': 'barney', 'age': 36 }
	     */
	    var min = createExtremum(lt, POSITIVE_INFINITY);
	
	    /**
	     * Calculates `n` rounded to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {number} n The number to round.
	     * @param {number} [precision=0] The precision to round to.
	     * @returns {number} Returns the rounded number.
	     * @example
	     *
	     * _.round(4.006);
	     * // => 4
	     *
	     * _.round(4.006, 2);
	     * // => 4.01
	     *
	     * _.round(4060, -2);
	     * // => 4100
	     */
	    var round = createRound('round');
	
	    /**
	     * Gets the sum of the values in `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {number} Returns the sum.
	     * @example
	     *
	     * _.sum([4, 6]);
	     * // => 10
	     *
	     * _.sum({ 'a': 4, 'b': 6 });
	     * // => 10
	     *
	     * var objects = [
	     *   { 'n': 4 },
	     *   { 'n': 6 }
	     * ];
	     *
	     * _.sum(objects, function(object) {
	     *   return object.n;
	     * });
	     * // => 10
	     *
	     * // using the `_.property` callback shorthand
	     * _.sum(objects, 'n');
	     * // => 10
	     */
	    function sum(collection, iteratee, thisArg) {
	      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
	        iteratee = undefined;
	      }
	      iteratee = getCallback(iteratee, thisArg, 3);
	      return iteratee.length == 1
	        ? arraySum(isArray(collection) ? collection : toIterable(collection), iteratee)
	        : baseSum(collection, iteratee);
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    // Ensure wrappers are instances of `baseLodash`.
	    lodash.prototype = baseLodash.prototype;
	
	    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
	    LodashWrapper.prototype.constructor = LodashWrapper;
	
	    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
	    LazyWrapper.prototype.constructor = LazyWrapper;
	
	    // Add functions to the `Map` cache.
	    MapCache.prototype['delete'] = mapDelete;
	    MapCache.prototype.get = mapGet;
	    MapCache.prototype.has = mapHas;
	    MapCache.prototype.set = mapSet;
	
	    // Add functions to the `Set` cache.
	    SetCache.prototype.push = cachePush;
	
	    // Assign cache to `_.memoize`.
	    memoize.Cache = MapCache;
	
	    // Add functions that return wrapped values when chaining.
	    lodash.after = after;
	    lodash.ary = ary;
	    lodash.assign = assign;
	    lodash.at = at;
	    lodash.before = before;
	    lodash.bind = bind;
	    lodash.bindAll = bindAll;
	    lodash.bindKey = bindKey;
	    lodash.callback = callback;
	    lodash.chain = chain;
	    lodash.chunk = chunk;
	    lodash.compact = compact;
	    lodash.constant = constant;
	    lodash.countBy = countBy;
	    lodash.create = create;
	    lodash.curry = curry;
	    lodash.curryRight = curryRight;
	    lodash.debounce = debounce;
	    lodash.defaults = defaults;
	    lodash.defaultsDeep = defaultsDeep;
	    lodash.defer = defer;
	    lodash.delay = delay;
	    lodash.difference = difference;
	    lodash.drop = drop;
	    lodash.dropRight = dropRight;
	    lodash.dropRightWhile = dropRightWhile;
	    lodash.dropWhile = dropWhile;
	    lodash.fill = fill;
	    lodash.filter = filter;
	    lodash.flatten = flatten;
	    lodash.flattenDeep = flattenDeep;
	    lodash.flow = flow;
	    lodash.flowRight = flowRight;
	    lodash.forEach = forEach;
	    lodash.forEachRight = forEachRight;
	    lodash.forIn = forIn;
	    lodash.forInRight = forInRight;
	    lodash.forOwn = forOwn;
	    lodash.forOwnRight = forOwnRight;
	    lodash.functions = functions;
	    lodash.groupBy = groupBy;
	    lodash.indexBy = indexBy;
	    lodash.initial = initial;
	    lodash.intersection = intersection;
	    lodash.invert = invert;
	    lodash.invoke = invoke;
	    lodash.keys = keys;
	    lodash.keysIn = keysIn;
	    lodash.map = map;
	    lodash.mapKeys = mapKeys;
	    lodash.mapValues = mapValues;
	    lodash.matches = matches;
	    lodash.matchesProperty = matchesProperty;
	    lodash.memoize = memoize;
	    lodash.merge = merge;
	    lodash.method = method;
	    lodash.methodOf = methodOf;
	    lodash.mixin = mixin;
	    lodash.modArgs = modArgs;
	    lodash.negate = negate;
	    lodash.omit = omit;
	    lodash.once = once;
	    lodash.pairs = pairs;
	    lodash.partial = partial;
	    lodash.partialRight = partialRight;
	    lodash.partition = partition;
	    lodash.pick = pick;
	    lodash.pluck = pluck;
	    lodash.property = property;
	    lodash.propertyOf = propertyOf;
	    lodash.pull = pull;
	    lodash.pullAt = pullAt;
	    lodash.range = range;
	    lodash.rearg = rearg;
	    lodash.reject = reject;
	    lodash.remove = remove;
	    lodash.rest = rest;
	    lodash.restParam = restParam;
	    lodash.set = set;
	    lodash.shuffle = shuffle;
	    lodash.slice = slice;
	    lodash.sortBy = sortBy;
	    lodash.sortByAll = sortByAll;
	    lodash.sortByOrder = sortByOrder;
	    lodash.spread = spread;
	    lodash.take = take;
	    lodash.takeRight = takeRight;
	    lodash.takeRightWhile = takeRightWhile;
	    lodash.takeWhile = takeWhile;
	    lodash.tap = tap;
	    lodash.throttle = throttle;
	    lodash.thru = thru;
	    lodash.times = times;
	    lodash.toArray = toArray;
	    lodash.toPlainObject = toPlainObject;
	    lodash.transform = transform;
	    lodash.union = union;
	    lodash.uniq = uniq;
	    lodash.unzip = unzip;
	    lodash.unzipWith = unzipWith;
	    lodash.values = values;
	    lodash.valuesIn = valuesIn;
	    lodash.where = where;
	    lodash.without = without;
	    lodash.wrap = wrap;
	    lodash.xor = xor;
	    lodash.zip = zip;
	    lodash.zipObject = zipObject;
	    lodash.zipWith = zipWith;
	
	    // Add aliases.
	    lodash.backflow = flowRight;
	    lodash.collect = map;
	    lodash.compose = flowRight;
	    lodash.each = forEach;
	    lodash.eachRight = forEachRight;
	    lodash.extend = assign;
	    lodash.iteratee = callback;
	    lodash.methods = functions;
	    lodash.object = zipObject;
	    lodash.select = filter;
	    lodash.tail = rest;
	    lodash.unique = uniq;
	
	    // Add functions to `lodash.prototype`.
	    mixin(lodash, lodash);
	
	    /*------------------------------------------------------------------------*/
	
	    // Add functions that return unwrapped values when chaining.
	    lodash.add = add;
	    lodash.attempt = attempt;
	    lodash.camelCase = camelCase;
	    lodash.capitalize = capitalize;
	    lodash.ceil = ceil;
	    lodash.clone = clone;
	    lodash.cloneDeep = cloneDeep;
	    lodash.deburr = deburr;
	    lodash.endsWith = endsWith;
	    lodash.escape = escape;
	    lodash.escapeRegExp = escapeRegExp;
	    lodash.every = every;
	    lodash.find = find;
	    lodash.findIndex = findIndex;
	    lodash.findKey = findKey;
	    lodash.findLast = findLast;
	    lodash.findLastIndex = findLastIndex;
	    lodash.findLastKey = findLastKey;
	    lodash.findWhere = findWhere;
	    lodash.first = first;
	    lodash.floor = floor;
	    lodash.get = get;
	    lodash.gt = gt;
	    lodash.gte = gte;
	    lodash.has = has;
	    lodash.identity = identity;
	    lodash.includes = includes;
	    lodash.indexOf = indexOf;
	    lodash.inRange = inRange;
	    lodash.isArguments = isArguments;
	    lodash.isArray = isArray;
	    lodash.isBoolean = isBoolean;
	    lodash.isDate = isDate;
	    lodash.isElement = isElement;
	    lodash.isEmpty = isEmpty;
	    lodash.isEqual = isEqual;
	    lodash.isError = isError;
	    lodash.isFinite = isFinite;
	    lodash.isFunction = isFunction;
	    lodash.isMatch = isMatch;
	    lodash.isNaN = isNaN;
	    lodash.isNative = isNative;
	    lodash.isNull = isNull;
	    lodash.isNumber = isNumber;
	    lodash.isObject = isObject;
	    lodash.isPlainObject = isPlainObject;
	    lodash.isRegExp = isRegExp;
	    lodash.isString = isString;
	    lodash.isTypedArray = isTypedArray;
	    lodash.isUndefined = isUndefined;
	    lodash.kebabCase = kebabCase;
	    lodash.last = last;
	    lodash.lastIndexOf = lastIndexOf;
	    lodash.lt = lt;
	    lodash.lte = lte;
	    lodash.max = max;
	    lodash.min = min;
	    lodash.noConflict = noConflict;
	    lodash.noop = noop;
	    lodash.now = now;
	    lodash.pad = pad;
	    lodash.padLeft = padLeft;
	    lodash.padRight = padRight;
	    lodash.parseInt = parseInt;
	    lodash.random = random;
	    lodash.reduce = reduce;
	    lodash.reduceRight = reduceRight;
	    lodash.repeat = repeat;
	    lodash.result = result;
	    lodash.round = round;
	    lodash.runInContext = runInContext;
	    lodash.size = size;
	    lodash.snakeCase = snakeCase;
	    lodash.some = some;
	    lodash.sortedIndex = sortedIndex;
	    lodash.sortedLastIndex = sortedLastIndex;
	    lodash.startCase = startCase;
	    lodash.startsWith = startsWith;
	    lodash.sum = sum;
	    lodash.template = template;
	    lodash.trim = trim;
	    lodash.trimLeft = trimLeft;
	    lodash.trimRight = trimRight;
	    lodash.trunc = trunc;
	    lodash.unescape = unescape;
	    lodash.uniqueId = uniqueId;
	    lodash.words = words;
	
	    // Add aliases.
	    lodash.all = every;
	    lodash.any = some;
	    lodash.contains = includes;
	    lodash.eq = isEqual;
	    lodash.detect = find;
	    lodash.foldl = reduce;
	    lodash.foldr = reduceRight;
	    lodash.head = first;
	    lodash.include = includes;
	    lodash.inject = reduce;
	
	    mixin(lodash, (function() {
	      var source = {};
	      baseForOwn(lodash, function(func, methodName) {
	        if (!lodash.prototype[methodName]) {
	          source[methodName] = func;
	        }
	      });
	      return source;
	    }()), false);
	
	    /*------------------------------------------------------------------------*/
	
	    // Add functions capable of returning wrapped and unwrapped values when chaining.
	    lodash.sample = sample;
	
	    lodash.prototype.sample = function(n) {
	      if (!this.__chain__ && n == null) {
	        return sample(this.value());
	      }
	      return this.thru(function(value) {
	        return sample(value, n);
	      });
	    };
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * The semantic version number.
	     *
	     * @static
	     * @memberOf _
	     * @type string
	     */
	    lodash.VERSION = VERSION;
	
	    // Assign default placeholders.
	    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
	      lodash[methodName].placeholder = lodash;
	    });
	
	    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
	    arrayEach(['drop', 'take'], function(methodName, index) {
	      LazyWrapper.prototype[methodName] = function(n) {
	        var filtered = this.__filtered__;
	        if (filtered && !index) {
	          return new LazyWrapper(this);
	        }
	        n = n == null ? 1 : nativeMax(nativeFloor(n) || 0, 0);
	
	        var result = this.clone();
	        if (filtered) {
	          result.__takeCount__ = nativeMin(result.__takeCount__, n);
	        } else {
	          result.__views__.push({ 'size': n, 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') });
	        }
	        return result;
	      };
	
	      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
	        return this.reverse()[methodName](n).reverse();
	      };
	    });
	
	    // Add `LazyWrapper` methods that accept an `iteratee` value.
	    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
	      var type = index + 1,
	          isFilter = type != LAZY_MAP_FLAG;
	
	      LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {
	        var result = this.clone();
	        result.__iteratees__.push({ 'iteratee': getCallback(iteratee, thisArg, 1), 'type': type });
	        result.__filtered__ = result.__filtered__ || isFilter;
	        return result;
	      };
	    });
	
	    // Add `LazyWrapper` methods for `_.first` and `_.last`.
	    arrayEach(['first', 'last'], function(methodName, index) {
	      var takeName = 'take' + (index ? 'Right' : '');
	
	      LazyWrapper.prototype[methodName] = function() {
	        return this[takeName](1).value()[0];
	      };
	    });
	
	    // Add `LazyWrapper` methods for `_.initial` and `_.rest`.
	    arrayEach(['initial', 'rest'], function(methodName, index) {
	      var dropName = 'drop' + (index ? '' : 'Right');
	
	      LazyWrapper.prototype[methodName] = function() {
	        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
	      };
	    });
	
	    // Add `LazyWrapper` methods for `_.pluck` and `_.where`.
	    arrayEach(['pluck', 'where'], function(methodName, index) {
	      var operationName = index ? 'filter' : 'map',
	          createCallback = index ? baseMatches : property;
	
	      LazyWrapper.prototype[methodName] = function(value) {
	        return this[operationName](createCallback(value));
	      };
	    });
	
	    LazyWrapper.prototype.compact = function() {
	      return this.filter(identity);
	    };
	
	    LazyWrapper.prototype.reject = function(predicate, thisArg) {
	      predicate = getCallback(predicate, thisArg, 1);
	      return this.filter(function(value) {
	        return !predicate(value);
	      });
	    };
	
	    LazyWrapper.prototype.slice = function(start, end) {
	      start = start == null ? 0 : (+start || 0);
	
	      var result = this;
	      if (result.__filtered__ && (start > 0 || end < 0)) {
	        return new LazyWrapper(result);
	      }
	      if (start < 0) {
	        result = result.takeRight(-start);
	      } else if (start) {
	        result = result.drop(start);
	      }
	      if (end !== undefined) {
	        end = (+end || 0);
	        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
	      }
	      return result;
	    };
	
	    LazyWrapper.prototype.takeRightWhile = function(predicate, thisArg) {
	      return this.reverse().takeWhile(predicate, thisArg).reverse();
	    };
	
	    LazyWrapper.prototype.toArray = function() {
	      return this.take(POSITIVE_INFINITY);
	    };
	
	    // Add `LazyWrapper` methods to `lodash.prototype`.
	    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
	      var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName),
	          retUnwrapped = /^(?:first|last)$/.test(methodName),
	          lodashFunc = lodash[retUnwrapped ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName];
	
	      if (!lodashFunc) {
	        return;
	      }
	      lodash.prototype[methodName] = function() {
	        var args = retUnwrapped ? [1] : arguments,
	            chainAll = this.__chain__,
	            value = this.__wrapped__,
	            isHybrid = !!this.__actions__.length,
	            isLazy = value instanceof LazyWrapper,
	            iteratee = args[0],
	            useLazy = isLazy || isArray(value);
	
	        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
	          // Avoid lazy use if the iteratee has a "length" value other than `1`.
	          isLazy = useLazy = false;
	        }
	        var interceptor = function(value) {
	          return (retUnwrapped && chainAll)
	            ? lodashFunc(value, 1)[0]
	            : lodashFunc.apply(undefined, arrayPush([value], args));
	        };
	
	        var action = { 'func': thru, 'args': [interceptor], 'thisArg': undefined },
	            onlyLazy = isLazy && !isHybrid;
	
	        if (retUnwrapped && !chainAll) {
	          if (onlyLazy) {
	            value = value.clone();
	            value.__actions__.push(action);
	            return func.call(value);
	          }
	          return lodashFunc.call(undefined, this.value())[0];
	        }
	        if (!retUnwrapped && useLazy) {
	          value = onlyLazy ? value : new LazyWrapper(this);
	          var result = func.apply(value, args);
	          result.__actions__.push(action);
	          return new LodashWrapper(result, chainAll);
	        }
	        return this.thru(interceptor);
	      };
	    });
	
	    // Add `Array` and `String` methods to `lodash.prototype`.
	    arrayEach(['join', 'pop', 'push', 'replace', 'shift', 'sort', 'splice', 'split', 'unshift'], function(methodName) {
	      var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName],
	          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
	          retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);
	
	      lodash.prototype[methodName] = function() {
	        var args = arguments;
	        if (retUnwrapped && !this.__chain__) {
	          return func.apply(this.value(), args);
	        }
	        return this[chainName](function(value) {
	          return func.apply(value, args);
	        });
	      };
	    });
	
	    // Map minified function names to their real names.
	    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
	      var lodashFunc = lodash[methodName];
	      if (lodashFunc) {
	        var key = lodashFunc.name,
	            names = realNames[key] || (realNames[key] = []);
	
	        names.push({ 'name': methodName, 'func': lodashFunc });
	      }
	    });
	
	    realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{ 'name': 'wrapper', 'func': undefined }];
	
	    // Add functions to the lazy wrapper.
	    LazyWrapper.prototype.clone = lazyClone;
	    LazyWrapper.prototype.reverse = lazyReverse;
	    LazyWrapper.prototype.value = lazyValue;
	
	    // Add chaining functions to the `lodash` wrapper.
	    lodash.prototype.chain = wrapperChain;
	    lodash.prototype.commit = wrapperCommit;
	    lodash.prototype.concat = wrapperConcat;
	    lodash.prototype.plant = wrapperPlant;
	    lodash.prototype.reverse = wrapperReverse;
	    lodash.prototype.toString = wrapperToString;
	    lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
	
	    // Add function aliases to the `lodash` wrapper.
	    lodash.prototype.collect = lodash.prototype.map;
	    lodash.prototype.head = lodash.prototype.first;
	    lodash.prototype.select = lodash.prototype.filter;
	    lodash.prototype.tail = lodash.prototype.rest;
	
	    return lodash;
	  }
	
	  /*--------------------------------------------------------------------------*/
	
	  // Export lodash.
	  var _ = runInContext();
	
	  // Some AMD build optimizers like r.js check for condition patterns like the following:
	  if (true) {
	    // Expose lodash to the global object when an AMD loader is present to avoid
	    // errors in cases where lodash is loaded by a script tag and not intended
	    // as an AMD module. See http://requirejs.org/docs/errors.html#mismatch for
	    // more details.
	    root._ = _;
	
	    // Define as an anonymous module so, through path mapping, it can be
	    // referenced as the "underscore" module.
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return _;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
	  else if (freeExports && freeModule) {
	    // Export for Node.js or RingoJS.
	    if (moduleExports) {
	      (freeModule.exports = _)._ = _;
	    }
	    // Export for Rhino with CommonJS support.
	    else {
	      freeExports._ = _;
	    }
	  }
	  else {
	    // Export for a browser or Rhino.
	    root._ = _;
	  }
	}.call(this));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)(module), (function() { return this; }())))

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var Matrix, Screen, Utils, _, __domComplete, __domCompleteState, __domReady, _textSizeNode,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
	  slice = [].slice;
	
	_ = __webpack_require__(1)._;
	
	Screen = __webpack_require__(5).Screen;
	
	Matrix = __webpack_require__(9).Matrix;
	
	Utils = {};
	
	Utils.reset = function() {
	  return Framer.CurrentContext.reset();
	};
	
	Utils.getValue = function(value) {
	  if (_.isFunction(value)) {
	    return value();
	  }
	  return value;
	};
	
	Utils.getValueForKeyPath = function(obj, key) {
	  var len, o, ref, ref1, result;
	  result = obj;
	  if (ref = !".", indexOf.call(key, ref) >= 0) {
	    return obj[key];
	  }
	  ref1 = key.split(".");
	  for (o = 0, len = ref1.length; o < len; o++) {
	    key = ref1[o];
	    result = result[key];
	  }
	  return result;
	};
	
	Utils.setValueForKeyPath = function(obj, path, val) {
	  var field, fields, i, n, result;
	  fields = path.split('.');
	  result = obj;
	  i = 0;
	  n = fields.length;
	  while (i < n && result !== void 0) {
	    field = fields[i];
	    if (i === n - 1) {
	      result[field] = val;
	    } else {
	      if (typeof result[field] === 'undefined' || !_.isObject(result[field])) {
	        result[field] = {};
	      }
	      result = result[field];
	    }
	    i++;
	  }
	};
	
	Utils.valueOrDefault = function(value, defaultValue) {
	  if (value === (void 0) || value === null) {
	    value = defaultValue;
	  }
	  return value;
	};
	
	Utils.arrayNext = function(arr, item) {
	  return arr[arr.indexOf(item) + 1] || _.first(arr);
	};
	
	Utils.arrayPrev = function(arr, item) {
	  return arr[arr.indexOf(item) - 1] || _.last(arr);
	};
	
	Utils.sum = function(arr) {
	  return _.reduce(arr, function(a, b) {
	    return a + b;
	  });
	};
	
	Utils.average = function(arr) {
	  return Utils.sum(arr) / arr.length;
	};
	
	Utils.mean = Utils.average;
	
	Utils.median = function(x) {
	  var sorted;
	  if (x.length === 0) {
	    return null;
	  }
	  sorted = x.slice().sort(function(a, b) {
	    return a - b;
	  });
	  if (sorted.length % 2 === 1) {
	    return sorted[(sorted.length - 1) / 2];
	  } else {
	    return (sorted[(sorted.length / 2) - 1] + sorted[sorted.length / 2]) / 2;
	  }
	};
	
	Utils.nearestIncrement = function(x, increment) {
	  if (!increment) {
	    return x;
	  }
	  return Math.round(x * (1 / increment)) / (1 / increment);
	};
	
	if (window.requestAnimationFrame == null) {
	  window.requestAnimationFrame = window.webkitRequestAnimationFrame;
	}
	
	if (window.requestAnimationFrame == null) {
	  window.requestAnimationFrame = function(f) {
	    return Utils.delay(1 / 60, f);
	  };
	}
	
	if (window.performance) {
	  Utils.getTime = function() {
	    return window.performance.now() / 1000;
	  };
	} else {
	  Utils.getTime = function() {
	    return Date.now() / 1000;
	  };
	}
	
	Utils.delay = function(time, f) {
	  var timer;
	  timer = setTimeout(f, time * 1000);
	  Framer.CurrentContext.addTimer(timer);
	  return timer;
	};
	
	Utils.interval = function(time, f) {
	  var timer;
	  timer = setInterval(f, time * 1000);
	  Framer.CurrentContext.addInterval(timer);
	  return timer;
	};
	
	Utils.debounce = function(threshold, fn, immediate) {
	  var timeout;
	  if (threshold == null) {
	    threshold = 0.1;
	  }
	  timeout = null;
	  threshold *= 1000;
	  return function() {
	    var args, delayed, obj;
	    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
	    obj = this;
	    delayed = function() {
	      if (!immediate) {
	        fn.apply(obj, args);
	      }
	      return timeout = null;
	    };
	    if (timeout) {
	      clearTimeout(timeout);
	    } else if (immediate) {
	      fn.apply(obj, args);
	    }
	    return timeout = setTimeout(delayed, threshold);
	  };
	};
	
	Utils.throttle = function(delay, fn) {
	  var timer;
	  if (delay === 0) {
	    return fn;
	  }
	  delay *= 1000;
	  timer = false;
	  return function() {
	    if (timer) {
	      return;
	    }
	    timer = true;
	    if (delay !== -1) {
	      setTimeout((function() {
	        return timer = false;
	      }), delay);
	    }
	    return fn.apply(null, arguments);
	  };
	};
	
	Utils.memoize = function(fn) {
	  return function() {
	    var args, currentArg, hash, i;
	    args = Array.prototype.slice.call(arguments);
	    hash = "";
	    i = args.length;
	    currentArg = null;
	    while (i--) {
	      currentArg = args[i];
	      hash += (currentArg === Object(currentArg) ? JSON.stringify(currentArg) : currentArg);
	      fn.memoize || (fn.memoize = {});
	    }
	    if (hash in fn.memoize) {
	      return fn.memoize[hash];
	    } else {
	      return fn.memoize[hash] = fn.apply(this, args);
	    }
	  };
	};
	
	Utils.randomColor = function(alpha) {
	  if (alpha == null) {
	    alpha = 1.0;
	  }
	  return Color.random(alpha);
	};
	
	Utils.randomChoice = function(arr) {
	  return arr[Math.floor(Math.random() * arr.length)];
	};
	
	Utils.randomNumber = function(a, b) {
	  if (a == null) {
	    a = 0;
	  }
	  if (b == null) {
	    b = 1;
	  }
	  return Utils.mapRange(Math.random(), 0, 1, a, b);
	};
	
	Utils.defineEnum = function(names, offset, geometric) {
	  var Enum, i, j, len, name, o;
	  if (names == null) {
	    names = [];
	  }
	  if (offset == null) {
	    offset = 0;
	  }
	  if (geometric == null) {
	    geometric = 0;
	  }
	  Enum = {};
	  for (i = o = 0, len = names.length; o < len; i = ++o) {
	    name = names[i];
	    j = i;
	    j = !offset ? j : j + offset;
	    j = !geometric ? j : Math.pow(geometric, j);
	    Enum[Enum[name] = j] = name;
	  }
	  return Enum;
	};
	
	Utils.labelLayer = function(layer, text, style) {
	  if (style == null) {
	    style = {};
	  }
	  style = _.extend({
	    font: "10px/1em Menlo",
	    lineHeight: layer.height + "px",
	    textAlign: "center",
	    color: "#fff"
	  }, style);
	  layer.style = style;
	  return layer.html = text;
	};
	
	Utils.stringify = function(obj) {
	  var error;
	  try {
	    if (_.isObject(obj)) {
	      return JSON.stringify(obj);
	    }
	  } catch (error) {
	    "";
	  }
	  if (obj === null) {
	    return "null";
	  }
	  if (obj === void 0) {
	    return "undefined";
	  }
	  if (obj.toString) {
	    return obj.toString();
	  }
	  return obj;
	};
	
	Utils.inspectObjectType = function(item) {
	  var className, extract, ref, ref1, ref2, ref3;
	  if ((((ref = item.constructor) != null ? ref.name : void 0) != null) && ((ref1 = item.constructor) != null ? ref1.name : void 0) !== "Object") {
	    return item.constructor.name;
	  }
	  extract = function(str) {
	    var match, regex;
	    if (!str) {
	      return null;
	    }
	    regex = /\[object (\w+)\]/;
	    match = regex.exec(str);
	    if (match) {
	      return match[1];
	    }
	    return null;
	  };
	  if (item.toString) {
	    className = extract(item.toString());
	    if (className) {
	      return className;
	    }
	  }
	  if ((ref2 = item.constructor) != null ? ref2.toString : void 0) {
	    className = extract((ref3 = item.constructor) != null ? ref3.toString() : void 0);
	    if (className) {
	      return className.replace("Constructor", "");
	    }
	  }
	  return "Object";
	};
	
	Utils.inspect = function(item, max, l) {
	  var code, limit, objectInfo, objectType;
	  if (max == null) {
	    max = 5;
	  }
	  if (l == null) {
	    l = 0;
	  }
	  if (item === null) {
	    return "null";
	  }
	  if (item === void 0) {
	    return "undefined";
	  }
	  if (_.isFunction(item.toInspect)) {
	    return item.toInspect();
	  }
	  if (_.isString(item)) {
	    return "\"" + item + "\"";
	  }
	  if (_.isNumber(item)) {
	    return "" + item;
	  }
	  if (_.isFunction(item)) {
	    code = item.toString().slice("function ".length).replace(/\n/g, "").replace(/\s+/g, " ");
	    limit = 50;
	    if (code.length > limit && l > 0) {
	      code = (_.trimRight(code.slice(0, +limit + 1 || 9e9))) + "… }";
	    }
	    return "<Function " + code + ">";
	  }
	  if (_.isArray(item)) {
	    if (l > max) {
	      return "[...]";
	    }
	    return "[" + _.map(item, function(i) {
	      return Utils.inspect(i, max, l + 1);
	    }).join(", ") + "]";
	  }
	  if (_.isObject(item)) {
	    objectType = Utils.inspectObjectType(item);
	    if (/HTML\w+?Element/.test(objectType)) {
	      return "<" + objectType + ">";
	    }
	    if (l > max) {
	      objectInfo = "{...}";
	    } else {
	      objectInfo = "{" + _.map(item, function(v, k) {
	        return k + ":" + (Utils.inspect(v, max, l + 1));
	      }).join(", ") + "}";
	    }
	    if (objectType === "Object") {
	      return objectInfo;
	    }
	    return "<" + objectType + " " + objectInfo + ">";
	  }
	  return "" + item;
	};
	
	Utils.uuid = function() {
	  var chars, digit, o, output, r, random;
	  chars = "0123456789abcdefghijklmnopqrstuvwxyz".split("");
	  output = new Array(36);
	  random = 0;
	  for (digit = o = 1; o <= 32; digit = ++o) {
	    if (random <= 0x02) {
	      random = 0x2000000 + (Math.random() * 0x1000000) | 0;
	    }
	    r = random & 0xf;
	    random = random >> 4;
	    output[digit] = chars[digit === 19 ? (r & 0x3) | 0x8 : r];
	  }
	  return output.join("");
	};
	
	Utils.arrayFromArguments = function(args) {
	  if (_.isArray(args[0])) {
	    return args[0];
	  }
	  return Array.prototype.slice.call(args);
	};
	
	Utils.cycle = function() {
	  var args, curr;
	  args = Utils.arrayFromArguments(arguments);
	  curr = -1;
	  return function() {
	    curr++;
	    if (curr >= args.length) {
	      curr = 0;
	    }
	    return args[curr];
	  };
	};
	
	Utils.toggle = Utils.cycle;
	
	Utils.isWebKit = function() {
	  return window.WebKitCSSMatrix !== void 0;
	};
	
	Utils.webkitVersion = function() {
	  var regexp, result, version;
	  version = -1;
	  regexp = /AppleWebKit\/([\d.]+)/;
	  result = regexp.exec(navigator.userAgent);
	  if (result) {
	    version = parseFloat(result[1]);
	  }
	  return version;
	};
	
	Utils.isChrome = function() {
	  return /chrome/.test(navigator.userAgent.toLowerCase());
	};
	
	Utils.isSafari = function() {
	  return /safari/.test(navigator.userAgent.toLowerCase());
	};
	
	Utils.isTouch = function() {
	  return window.ontouchstart === null && window.ontouchmove === null && window.ontouchend === null;
	};
	
	Utils.isDesktop = function() {
	  return Utils.deviceType() === "desktop";
	};
	
	Utils.isPhone = function() {
	  return Utils.deviceType() === "phone";
	};
	
	Utils.isTablet = function() {
	  return Utils.deviceType() === "tablet";
	};
	
	Utils.isMobile = function() {
	  return Utils.isPhone() || Utils.isTablet();
	};
	
	Utils.isFileUrl = function(url) {
	  return _.startsWith(url, "file://");
	};
	
	Utils.isRelativeUrl = function(url) {
	  return !/^([a-zA-Z]{1,8}:\/\/).*$/.test(url);
	};
	
	Utils.isLocalServerUrl = function(url) {
	  return url.indexOf("127.0.0.1") !== -1 || url.indexOf("localhost") !== -1;
	};
	
	Utils.isLocalUrl = function(url) {
	  if (Utils.isFileUrl(url)) {
	    return true;
	  }
	  if (Utils.isLocalServerUrl(url)) {
	    return true;
	  }
	  return false;
	};
	
	Utils.isLocalAssetUrl = function(url, baseUrl) {
	  if (baseUrl == null) {
	    baseUrl = window.location.href;
	  }
	  if (Utils.isLocalUrl(url)) {
	    return true;
	  }
	  if (Utils.isRelativeUrl(url) && Utils.isLocalUrl(baseUrl)) {
	    return true;
	  }
	  return false;
	};
	
	Utils.isFramerStudio = function() {
	  return navigator.userAgent.indexOf("FramerStudio") !== -1;
	};
	
	Utils.framerStudioVersion = function() {
	  var isBeta, isFuture, isLocal, matches, version;
	  if (Utils.isFramerStudio()) {
	    isBeta = navigator.userAgent.indexOf("FramerStudio/beta") >= 0;
	    isLocal = navigator.userAgent.indexOf("FramerStudio/local") >= 0;
	    isFuture = navigator.userAgent.indexOf("FramerStudio/future") >= 0;
	    if (isBeta || isLocal || isFuture) {
	      return Number.MAX_VALUE;
	    }
	    matches = navigator.userAgent.match(/\d+$/);
	    if (matches && matches.length > 0) {
	      version = parseInt(matches[0]);
	    }
	    if (_.isNumber(version)) {
	      return version;
	    }
	  }
	  return Number.MAX_VALUE;
	};
	
	Utils.devicePixelRatio = function() {
	  return window.devicePixelRatio;
	};
	
	Utils.isJP2Supported = function() {
	  return Utils.isWebKit() && !Utils.isChrome();
	};
	
	Utils.deviceType = function() {
	  if (/(tablet)|(iPad)|(Nexus 9)/i.test(navigator.userAgent)) {
	    return "tablet";
	  }
	  if (/(mobi)/i.test(navigator.userAgent)) {
	    return "phone";
	  }
	  return "desktop";
	};
	
	Utils.pathJoin = function() {
	  return Utils.arrayFromArguments(arguments).join("/");
	};
	
	Utils.round = function(value, decimals) {
	  var d;
	  if (decimals == null) {
	    decimals = 0;
	  }
	  d = Math.pow(10, decimals);
	  return Math.round(value * d) / d;
	};
	
	Utils.clamp = function(value, a, b) {
	  var max, min;
	  min = Math.min(a, b);
	  max = Math.max(a, b);
	  if (value < min) {
	    value = min;
	  }
	  if (value > max) {
	    value = max;
	  }
	  return value;
	};
	
	Utils.mapRange = function(value, fromLow, fromHigh, toLow, toHigh) {
	  return toLow + (((value - fromLow) / (fromHigh - fromLow)) * (toHigh - toLow));
	};
	
	Utils.modulate = function(value, rangeA, rangeB, limit) {
	  var fromHigh, fromLow, result, toHigh, toLow;
	  if (limit == null) {
	    limit = false;
	  }
	  fromLow = rangeA[0], fromHigh = rangeA[1];
	  toLow = rangeB[0], toHigh = rangeB[1];
	  result = toLow + (((value - fromLow) / (fromHigh - fromLow)) * (toHigh - toLow));
	  if (limit === true) {
	    if (toLow < toHigh) {
	      if (result < toLow) {
	        return toLow;
	      }
	      if (result > toHigh) {
	        return toHigh;
	      }
	    } else {
	      if (result > toLow) {
	        return toLow;
	      }
	      if (result < toHigh) {
	        return toHigh;
	      }
	    }
	  }
	  return result;
	};
	
	Utils.parseFunction = function(str) {
	  var result;
	  result = {
	    name: "",
	    args: []
	  };
	  if (_.endsWith(str, ")")) {
	    result.name = str.split("(")[0];
	    result.args = str.split("(")[1].split(",").map(function(a) {
	      return _.trim(_.trimRight(a, ")"));
	    });
	  } else {
	    result.name = str;
	  }
	  return result;
	};
	
	__domCompleteState = "interactive";
	
	__domComplete = [];
	
	__domReady = false;
	
	if (typeof document !== "undefined" && document !== null) {
	  document.onreadystatechange = function(event) {
	    var f, results;
	    if (document.readyState === __domCompleteState) {
	      __domReady = true;
	      results = [];
	      while (__domComplete.length) {
	        results.push(f = __domComplete.shift()());
	      }
	      return results;
	    }
	  };
	}
	
	Utils.domComplete = function(f) {
	  if (__domReady) {
	    return f();
	  } else {
	    return __domComplete.push(f);
	  }
	};
	
	Utils.domCompleteCancel = function(f) {
	  return __domComplete = _.without(__domComplete, f);
	};
	
	Utils.domValidEvent = function(element, eventName) {
	  if (!eventName) {
	    return;
	  }
	  if (eventName === "touchstart" || eventName === "touchmove" || eventName === "touchend") {
	    return true;
	  }
	  return typeof element["on" + (eventName.toLowerCase())] !== "undefined";
	};
	
	Utils.domLoadScript = function(url, callback) {
	  var head, script;
	  script = document.createElement("script");
	  script.type = "text/javascript";
	  script.src = url;
	  script.onload = callback;
	  head = document.getElementsByTagName("head")[0];
	  head.appendChild(script);
	  return script;
	};
	
	Utils.domLoadData = function(path, callback) {
	  var request;
	  request = new XMLHttpRequest();
	  request.addEventListener("load", function() {
	    return callback(null, request.responseText);
	  }, false);
	  request.addEventListener("error", function() {
	    return callback(true, null);
	  }, false);
	  request.open("GET", path, true);
	  return request.send(null);
	};
	
	Utils.domLoadJSON = function(path, callback) {
	  return Utils.domLoadData(path, function(err, data) {
	    return callback(err, JSON.parse(data));
	  });
	};
	
	Utils.domLoadDataSync = function(path) {
	  var e, error, handleError, ref, request;
	  request = new XMLHttpRequest();
	  request.open("GET", path, false);
	  try {
	    request.send(null);
	  } catch (error) {
	    e = error;
	    console.debug("XMLHttpRequest.error", e);
	  }
	  handleError = function() {
	    throw Error("Utils.domLoadDataSync: " + path + " -> [" + request.status + " " + request.statusText + "]");
	  };
	  request.onerror = handleError;
	  if ((ref = request.status) !== 200 && ref !== 0) {
	    handleError();
	  }
	  if (!request.responseText) {
	    handleError();
	  }
	  return request.responseText;
	};
	
	Utils.domLoadJSONSync = function(path) {
	  return JSON.parse(Utils.domLoadDataSync(path));
	};
	
	Utils.domLoadScriptSync = function(path) {
	  var scriptData;
	  scriptData = Utils.domLoadDataSync(path);
	  eval(scriptData);
	  return scriptData;
	};
	
	Utils.insertCSS = function(css) {
	  var styleElement;
	  styleElement = document.createElement("style");
	  styleElement.type = "text/css";
	  styleElement.innerHTML = css;
	  return Utils.domComplete(function() {
	    return document.body.appendChild(styleElement);
	  });
	};
	
	Utils.loadImage = function(url, callback, context) {
	  var element;
	  element = new Image;
	  if (context == null) {
	    context = Framer.CurrentContext;
	  }
	  context.domEventManager.wrap(element).addEventListener("load", function(event) {
	    return callback();
	  });
	  context.domEventManager.wrap(element).addEventListener("error", function(event) {
	    return callback(true);
	  });
	  return element.src = url;
	};
	
	Utils.pointDivide = function(point, fraction) {
	  return point = {
	    x: point.x / fraction,
	    y: point.y / fraction
	  };
	};
	
	Utils.pointAdd = function(pointA, pointB) {
	  var point;
	  return point = {
	    x: pointA.x + pointB.x,
	    y: pointA.y + pointB.y
	  };
	};
	
	Utils.pointSubtract = function(pointA, pointB) {
	  var point;
	  return point = {
	    x: pointA.x - pointB.x,
	    y: pointA.y - pointB.y
	  };
	};
	
	Utils.pointZero = function(args) {
	  if (args == null) {
	    args = {};
	  }
	  return _.defaults(args, {
	    x: 0,
	    y: 0
	  });
	};
	
	Utils.pointMin = function() {
	  var point, points;
	  points = Utils.arrayFromArguments(arguments);
	  return point = {
	    x: _.min(points.map(function(size) {
	      return size.x;
	    })),
	    y: _.min(points.map(function(size) {
	      return size.y;
	    }))
	  };
	};
	
	Utils.pointMax = function() {
	  var point, points;
	  points = Utils.arrayFromArguments(arguments);
	  return point = {
	    x: _.max(points.map(function(size) {
	      return size.x;
	    })),
	    y: _.max(points.map(function(size) {
	      return size.y;
	    }))
	  };
	};
	
	Utils.pointDelta = function(pointA, pointB) {
	  var delta;
	  return delta = {
	    x: pointB.x - pointA.x,
	    y: pointB.y - pointA.y
	  };
	};
	
	Utils.pointDistance = function(pointA, pointB) {
	  var a, b;
	  a = pointA.x - pointB.x;
	  b = pointA.y - pointB.y;
	  return Math.sqrt((a * a) + (b * b));
	};
	
	Utils.pointInvert = function(point) {
	  return point = {
	    x: 0 - point.x,
	    y: 0 - point.y
	  };
	};
	
	Utils.pointTotal = function(point) {
	  return point.x + point.y;
	};
	
	Utils.pointAbs = function(point) {
	  return point = {
	    x: Math.abs(point.x),
	    y: Math.abs(point.y)
	  };
	};
	
	Utils.pointInFrame = function(point, frame) {
	  if (point.x < Utils.frameGetMinX(frame) || point.x > Utils.frameGetMaxX(frame)) {
	    return false;
	  }
	  if (point.y < Utils.frameGetMinY(frame) || point.y > Utils.frameGetMaxY(frame)) {
	    return false;
	  }
	  return true;
	};
	
	Utils.pointCenter = function(pointA, pointB) {
	  var point;
	  return point = {
	    x: (pointA.x + pointB.x) / 2,
	    y: (pointA.y + pointB.y) / 2
	  };
	};
	
	Utils.pointAngle = function(pointA, pointB) {
	  return Math.atan2(pointB.y - pointA.y, pointB.x - pointA.x) * 180 / Math.PI;
	};
	
	Utils.sizeZero = function(args) {
	  if (args == null) {
	    args = {};
	  }
	  return _.defaults(args, {
	    width: 0,
	    height: 0
	  });
	};
	
	Utils.sizeMin = function() {
	  var size, sizes;
	  sizes = Utils.arrayFromArguments(arguments);
	  return size = {
	    width: _.min(sizes.map(function(size) {
	      return size.width;
	    })),
	    height: _.min(sizes.map(function(size) {
	      return size.height;
	    }))
	  };
	};
	
	Utils.sizeMax = function() {
	  var size, sizes;
	  sizes = Utils.arrayFromArguments(arguments);
	  return size = {
	    width: _.max(sizes.map(function(size) {
	      return size.width;
	    })),
	    height: _.max(sizes.map(function(size) {
	      return size.height;
	    }))
	  };
	};
	
	Utils.rectZero = function(args) {
	  if (args == null) {
	    args = {};
	  }
	  return _.defaults(args, {
	    top: 0,
	    right: 0,
	    bottom: 0,
	    left: 0
	  });
	};
	
	Utils.parseRect = function(args) {
	  if (_.isArray(args) && _.isNumber(args[0])) {
	    if (args.length === 1) {
	      return Utils.parseRect({
	        top: args[0]
	      });
	    }
	    if (args.length === 2) {
	      return Utils.parseRect({
	        top: args[0],
	        right: args[1]
	      });
	    }
	    if (args.length === 3) {
	      return Utils.parseRect({
	        top: args[0],
	        right: args[1],
	        bottom: args[2]
	      });
	    }
	    if (args.length === 4) {
	      return Utils.parseRect({
	        top: args[0],
	        right: args[1],
	        bottom: args[2],
	        left: args[3]
	      });
	    }
	  }
	  if (_.isArray(args) && _.isObject(args[0])) {
	    return args[0];
	  }
	  if (_.isObject(args)) {
	    return args;
	  }
	  return {};
	};
	
	Utils.frameGetMinX = function(frame) {
	  return frame.x;
	};
	
	Utils.frameSetMinX = function(frame, value) {
	  return frame.x = value;
	};
	
	Utils.frameGetMidX = function(frame) {
	  if (frame.width === 0) {
	    return 0;
	  } else {
	    return frame.x + (frame.width / 2.0);
	  }
	};
	
	Utils.frameSetMidX = function(frame, value) {
	  return frame.x = frame.width === 0 ? 0 : value - (frame.width / 2.0);
	};
	
	Utils.frameGetMaxX = function(frame) {
	  if (frame.width === 0) {
	    return 0;
	  } else {
	    return frame.x + frame.width;
	  }
	};
	
	Utils.frameSetMaxX = function(frame, value) {
	  return frame.x = frame.width === 0 ? 0 : value - frame.width;
	};
	
	Utils.frameGetMinY = function(frame) {
	  return frame.y;
	};
	
	Utils.frameSetMinY = function(frame, value) {
	  return frame.y = value;
	};
	
	Utils.frameGetMidY = function(frame) {
	  if (frame.height === 0) {
	    return 0;
	  } else {
	    return frame.y + (frame.height / 2.0);
	  }
	};
	
	Utils.frameSetMidY = function(frame, value) {
	  return frame.y = frame.height === 0 ? 0 : value - (frame.height / 2.0);
	};
	
	Utils.frameGetMaxY = function(frame) {
	  if (frame.height === 0) {
	    return 0;
	  } else {
	    return frame.y + frame.height;
	  }
	};
	
	Utils.frameSetMaxY = function(frame, value) {
	  return frame.y = frame.height === 0 ? 0 : value - frame.height;
	};
	
	Utils.frameZero = function(args) {
	  if (args == null) {
	    args = {};
	  }
	  return _.defaults(args, {
	    top: 0,
	    right: 0,
	    bottom: 0,
	    left: 0
	  });
	};
	
	Utils.frameSize = function(frame) {
	  var size;
	  return size = {
	    width: frame.width,
	    height: frame.height
	  };
	};
	
	Utils.framePoint = function(frame) {
	  var point;
	  return point = {
	    x: frame.x,
	    y: frame.y
	  };
	};
	
	Utils.pointsFromFrame = function(frame) {
	  var corner1, corner2, corner3, corner4, maxX, maxY, minX, minY;
	  minX = Utils.frameGetMinX(frame);
	  maxX = Utils.frameGetMaxX(frame);
	  minY = Utils.frameGetMinY(frame);
	  maxY = Utils.frameGetMaxY(frame);
	  corner1 = {
	    x: minX,
	    y: minY
	  };
	  corner2 = {
	    x: minX,
	    y: maxY
	  };
	  corner3 = {
	    x: maxX,
	    y: maxY
	  };
	  corner4 = {
	    x: maxX,
	    y: minY
	  };
	  return [corner1, corner2, corner3, corner4];
	};
	
	Utils.frameFromPoints = function(points) {
	  var frame, maxX, maxY, minX, minY, xValues, yValues;
	  xValues = _.pluck(points, "x");
	  yValues = _.pluck(points, "y");
	  minX = _.min(xValues);
	  maxX = _.max(xValues);
	  minY = _.min(yValues);
	  maxY = _.max(yValues);
	  return frame = {
	    x: minX,
	    y: minY,
	    width: maxX - minX,
	    height: maxY - minY
	  };
	};
	
	Utils.pixelAlignedFrame = function(frame) {
	  var result;
	  return result = {
	    width: Math.round(frame.width + (frame.x % 1)),
	    height: Math.round(frame.height + (frame.y % 1)),
	    x: Math.round(frame.x),
	    y: Math.round(frame.y)
	  };
	};
	
	Utils.frameMerge = function() {
	  var frame, frames;
	  frames = Utils.arrayFromArguments(arguments);
	  frame = {
	    x: _.min(frames.map(Utils.frameGetMinX)),
	    y: _.min(frames.map(Utils.frameGetMinY))
	  };
	  frame.width = _.max(frames.map(Utils.frameGetMaxX)) - frame.x;
	  frame.height = _.max(frames.map(Utils.frameGetMaxY)) - frame.y;
	  return frame;
	};
	
	Utils.framePointForOrigin = function(frame, originX, originY) {
	  return frame = {
	    x: frame.x + (originX * frame.width),
	    y: frame.y + (originY * frame.height),
	    width: frame.width,
	    height: frame.height
	  };
	};
	
	Utils.frameInset = function(frame, inset) {
	  if (_.isNumber(inset)) {
	    inset = {
	      top: inset,
	      right: inset,
	      bottom: inset,
	      left: inset
	    };
	  }
	  return frame = {
	    x: frame.x + inset.left,
	    y: frame.y + inset.top,
	    width: frame.width - inset.left - inset.right,
	    height: frame.height - inset.top - inset.bottom
	  };
	};
	
	Utils.frameSortByAbsoluteDistance = function(point, frames, originX, originY) {
	  var distance;
	  if (originX == null) {
	    originX = 0;
	  }
	  if (originY == null) {
	    originY = 0;
	  }
	  distance = function(frame) {
	    var result;
	    result = Utils.pointDelta(point, Utils.framePointForOrigin(frame, originX, originY));
	    result = Utils.pointAbs(result);
	    result = Utils.pointTotal(result);
	    return result;
	  };
	  return frames.sort(function(a, b) {
	    return distance(a) - distance(b);
	  });
	};
	
	Utils.pointInPolygon = function(point, vs) {
	  var i, inside, intersect, j, x, xi, xj, y, yi, yj;
	  x = point[0];
	  y = point[1];
	  inside = false;
	  i = 0;
	  j = vs.length - 1;
	  while (i < vs.length) {
	    xi = vs[i][0];
	    yi = vs[i][1];
	    xj = vs[j][0];
	    yj = vs[j][1];
	    intersect = ((yi > y && y !== yj) && yj > y) && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
	    if (intersect) {
	      inside = !inside;
	    }
	    j = i++;
	  }
	  return inside;
	};
	
	Utils.frameCenterPoint = function(frame) {
	  var point;
	  return point = {
	    x: Utils.frameGetMidX(frame),
	    y: Utils.frameGetMidY(frame)
	  };
	};
	
	Utils.rotationNormalizer = function() {
	  var lastValue;
	  lastValue = null;
	  return (function(_this) {
	    return function(value) {
	      var diff, maxDiff, nTimes;
	      if (lastValue == null) {
	        lastValue = value;
	      }
	      diff = lastValue - value;
	      maxDiff = Math.abs(diff) + 180;
	      nTimes = Math.floor(maxDiff / 360);
	      if (diff < 180) {
	        value -= nTimes * 360;
	      }
	      if (diff > 180) {
	        value += nTimes * 360;
	      }
	      lastValue = value;
	      return value;
	    };
	  })(this);
	};
	
	Utils.convertPointToContext = function(point, layer, rootContext, includeLayer) {
	  var ancestor, ancestors, len, o;
	  if (point == null) {
	    point = {};
	  }
	  if (rootContext == null) {
	    rootContext = false;
	  }
	  if (includeLayer == null) {
	    includeLayer = true;
	  }
	  point = _.defaults(point, {
	    x: 0,
	    y: 0,
	    z: 0
	  });
	  ancestors = layer.ancestors(rootContext);
	  if (includeLayer) {
	    ancestors.unshift(layer);
	  }
	  for (o = 0, len = ancestors.length; o < len; o++) {
	    ancestor = ancestors[o];
	    if (ancestor.flat || ancestor.clip) {
	      point.z = 0;
	    }
	    point = ancestor.matrix3d.point(point);
	    if (!ancestor.parent) {
	      point.z = 0;
	    }
	  }
	  return point;
	};
	
	Utils.convertFrameToContext = function(frame, layer, rootContext, includeLayer) {
	  var convertedCorners, corners;
	  if (frame == null) {
	    frame = {};
	  }
	  if (rootContext == null) {
	    rootContext = false;
	  }
	  if (includeLayer == null) {
	    includeLayer = true;
	  }
	  frame = _.defaults(frame, {
	    x: 0,
	    y: 0,
	    width: 100,
	    height: 100
	  });
	  corners = Utils.pointsFromFrame(frame);
	  convertedCorners = corners.map((function(_this) {
	    return function(point) {
	      return Utils.convertPointToContext(point, layer, rootContext, includeLayer);
	    };
	  })(this));
	  return Utils.frameFromPoints(convertedCorners);
	};
	
	Utils.convertPointFromContext = function(point, layer, rootContext, includeLayer) {
	  var ancestor, ancestors, len, node, o, parent;
	  if (point == null) {
	    point = {};
	  }
	  if (rootContext == null) {
	    rootContext = false;
	  }
	  if (includeLayer == null) {
	    includeLayer = true;
	  }
	  point = _.defaults(point, {
	    x: 0,
	    y: 0,
	    z: 0
	  });
	  if (rootContext && (typeof webkitConvertPointFromPageToNode !== "undefined" && webkitConvertPointFromPageToNode !== null)) {
	    if (includeLayer) {
	      node = layer._element;
	    } else {
	      parent = layer.parent || layer.context;
	      node = parent._element;
	    }
	    return webkitConvertPointFromPageToNode(node, new WebKitPoint(point.x, point.y));
	  }
	  ancestors = layer.ancestors(rootContext);
	  ancestors.reverse();
	  if (includeLayer) {
	    ancestors.push(layer);
	  }
	  for (o = 0, len = ancestors.length; o < len; o++) {
	    ancestor = ancestors[o];
	    point = ancestor.matrix3d.inverse().point(point);
	  }
	  return point;
	};
	
	Utils.convertFrameFromContext = function(frame, layer, rootContext, includeLayer) {
	  var convertedCorners, corners;
	  if (frame == null) {
	    frame = {};
	  }
	  if (rootContext == null) {
	    rootContext = false;
	  }
	  if (includeLayer == null) {
	    includeLayer = true;
	  }
	  frame = _.defaults(frame, {
	    x: 0,
	    y: 0,
	    width: 100,
	    height: 100
	  });
	  corners = Utils.pointsFromFrame(frame);
	  convertedCorners = corners.map((function(_this) {
	    return function(point) {
	      return Utils.convertPointFromContext(point, layer, rootContext, includeLayer);
	    };
	  })(this));
	  return Utils.frameFromPoints(convertedCorners);
	};
	
	Utils.convertPoint = function(input, layerA, layerB, rootContext) {
	  var node, point;
	  if (rootContext == null) {
	    rootContext = false;
	  }
	  point = _.defaults(input, {
	    x: 0,
	    y: 0,
	    z: 0
	  });
	  if (layerA) {
	    point = Utils.convertPointToContext(point, layerA, rootContext);
	  }
	  if (layerB != null) {
	    return Utils.convertPointFromContext(point, layerB, rootContext);
	  } else if ((layerA != null) && rootContext && (typeof webkitConvertPointFromPageToNode !== "undefined" && webkitConvertPointFromPageToNode !== null)) {
	    node = layerA.context._element;
	    return webkitConvertPointFromPageToNode(node, new WebKitPoint(point.x, point.y));
	  } else {
	    return point;
	  }
	};
	
	Utils.boundingFrame = function(layer, rootContext) {
	  var boundingFrame, contextCornerPoints, cornerPoints, frame;
	  if (rootContext == null) {
	    rootContext = true;
	  }
	  frame = {
	    x: 0,
	    y: 0,
	    width: layer.width,
	    height: layer.height
	  };
	  cornerPoints = Utils.pointsFromFrame(frame);
	  contextCornerPoints = cornerPoints.map(function(point) {
	    return Utils.convertPointToContext(point, layer, rootContext);
	  });
	  boundingFrame = Utils.frameFromPoints(contextCornerPoints);
	  return Utils.pixelAlignedFrame(boundingFrame);
	};
	
	Utils.perspectiveProjectionMatrix = function(element) {
	  var m, p;
	  p = element.perspective;
	  m = new Matrix();
	  if ((p != null) && p !== 0) {
	    m.m34 = -1 / p;
	  }
	  return m;
	};
	
	Utils.perspectiveMatrix = function(element) {
	  var ox, oy, ppm;
	  ox = element.perspectiveOriginX * element.width;
	  oy = element.perspectiveOriginY * element.height;
	  ppm = Utils.perspectiveProjectionMatrix(element);
	  return new Matrix().translate(ox, oy).multiply(ppm).translate(-ox, -oy);
	};
	
	Utils.globalLayers = function(importedLayers) {
	  var layer, layerName;
	  for (layerName in importedLayers) {
	    layer = importedLayers[layerName];
	    layerName = layerName.replace(/\s/g, "");
	    if (window.hasOwnProperty(layerName) && !window.Framer._globalWarningGiven) {
	      print("Warning: Cannot make layer '" + layerName + "' a global, a variable with that name already exists");
	    } else {
	      window[layerName] = layer;
	    }
	  }
	  return window.Framer._globalWarningGiven = true;
	};
	
	_textSizeNode = null;
	
	Utils.textSize = function(text, style, constraints) {
	  var frame, rect, shouldCreateNode;
	  if (style == null) {
	    style = {};
	  }
	  if (constraints == null) {
	    constraints = {};
	  }
	  shouldCreateNode = !_textSizeNode;
	  if (shouldCreateNode) {
	    _textSizeNode = document.createElement("div");
	    _textSizeNode.id = "_textSizeNode";
	  }
	  _textSizeNode.removeAttribute("style");
	  _textSizeNode.innerHTML = text;
	  style = _.extend(_.clone(style), {
	    position: "fixed",
	    display: "inline",
	    visibility: "hidden",
	    top: "-10000px",
	    left: "-10000px"
	  });
	  delete style.width;
	  delete style.height;
	  delete style.bottom;
	  delete style.right;
	  if (constraints.width) {
	    style.width = constraints.width + "px";
	  }
	  if (constraints.height) {
	    style.height = constraints.height + "px";
	  }
	  _.extend(_textSizeNode.style, style);
	  if (shouldCreateNode) {
	    if (!window.document.body) {
	      document.write(_textSizeNode.outerHTML);
	      _textSizeNode = document.getElementById("_textSizeNode");
	    } else {
	      window.document.body.appendChild(_textSizeNode);
	    }
	  }
	  rect = _textSizeNode.getBoundingClientRect();
	  return frame = {
	    width: rect.right - rect.left,
	    height: rect.bottom - rect.top
	  };
	};
	
	_.extend(exports, Utils);


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	var BaseClass, ScreenClass,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	BaseClass = __webpack_require__(6).BaseClass;
	
	ScreenClass = (function(superClass) {
	  extend(ScreenClass, superClass);
	
	  function ScreenClass() {
	    return ScreenClass.__super__.constructor.apply(this, arguments);
	  }
	
	  ScreenClass.define("width", {
	    get: function() {
	      return Framer.CurrentContext.width;
	    }
	  });
	
	  ScreenClass.define("height", {
	    get: function() {
	      return Framer.CurrentContext.height;
	    }
	  });
	
	  ScreenClass.define("size", {
	    get: function() {
	      return Framer.CurrentContext.size;
	    }
	  });
	
	  ScreenClass.define("frame", {
	    get: function() {
	      return Framer.CurrentContext.frame;
	    }
	  });
	
	  ScreenClass.define("canvasFrame", {
	    get: function() {
	      return Framer.CurrentContext.canvasFrame;
	    }
	  });
	
	  ScreenClass.define("backgroundColor", {
	    importable: false,
	    exportable: false,
	    get: function() {
	      return Framer.Device.screen.backgroundColor;
	    },
	    set: function(value) {
	      return Framer.Device.screen.backgroundColor = value;
	    }
	  });
	
	  ScreenClass.define("perspective", {
	    importable: false,
	    exportable: false,
	    get: function() {
	      return Framer.CurrentContext.perspective;
	    },
	    set: function(value) {
	      return Framer.CurrentContext.perspective = value;
	    }
	  });
	
	  ScreenClass.define("perspectiveOriginX", {
	    importable: false,
	    exportable: false,
	    get: function() {
	      return Framer.CurrentContext.perspectiveOriginX;
	    },
	    set: function(value) {
	      return Framer.CurrentContext.perspectiveOriginX = value;
	    }
	  });
	
	  ScreenClass.define("perspectiveOriginY", {
	    importable: false,
	    exportable: false,
	    get: function() {
	      return Framer.CurrentContext.perspectiveOriginY;
	    },
	    set: function(value) {
	      return Framer.CurrentContext.perspectiveOriginY = value;
	    }
	  });
	
	  ScreenClass.prototype.toInspect = function() {
	    var round;
	    round = function(value) {
	      if (parseInt(value) === value) {
	        return parseInt(value);
	      }
	      return Utils.round(value, 1);
	    };
	    return "<Screen " + (round(this.width)) + "x" + (round(this.height)) + ">";
	  };
	
	  ScreenClass.prototype.onEdgeSwipe = function(cb) {
	    return this.on(Events.EdgeSwipe, cb);
	  };
	
	  ScreenClass.prototype.onEdgeSwipeStart = function(cb) {
	    return this.on(Events.EdgeSwipeStart, cb);
	  };
	
	  ScreenClass.prototype.onEdgeSwipeEnd = function(cb) {
	    return this.on(Events.EdgeSwipeEnd, cb);
	  };
	
	  ScreenClass.prototype.onEdgeSwipeTop = function(cb) {
	    return this.on(Events.EdgeSwipeTop, cb);
	  };
	
	  ScreenClass.prototype.onEdgeSwipeTopStart = function(cb) {
	    return this.on(Events.EdgeSwipeTopStart, cb);
	  };
	
	  ScreenClass.prototype.onEdgeSwipeTopEnd = function(cb) {
	    return this.on(Events.EdgeSwipeTopEnd, cb);
	  };
	
	  ScreenClass.prototype.onEdgeSwipeRight = function(cb) {
	    return this.on(Events.EdgeSwipeRight, cb);
	  };
	
	  ScreenClass.prototype.onEdgeSwipeRightStart = function(cb) {
	    return this.on(Events.EdgeSwipeRightStart, cb);
	  };
	
	  ScreenClass.prototype.onEdgeSwipeRightEnd = function(cb) {
	    return this.on(Events.EdgeSwipeRightEnd, cb);
	  };
	
	  ScreenClass.prototype.onEdgeSwipeBottom = function(cb) {
	    return this.on(Events.EdgeSwipeBottom, cb);
	  };
	
	  ScreenClass.prototype.onEdgeSwipeBottomStart = function(cb) {
	    return this.on(Events.EdgeSwipeBottomStart, cb);
	  };
	
	  ScreenClass.prototype.onEdgeSwipeBottomEnd = function(cb) {
	    return this.on(Events.EdgeSwipeBottomEnd, cb);
	  };
	
	  ScreenClass.prototype.onEdgeSwipeLeft = function(cb) {
	    return this.on(Events.EdgeSwipeLeft, cb);
	  };
	
	  ScreenClass.prototype.onEdgeSwipeLeftStart = function(cb) {
	    return this.on(Events.EdgeSwipeLeftStart, cb);
	  };
	
	  ScreenClass.prototype.onEdgeSwipeLeftEnd = function(cb) {
	    return this.on(Events.EdgeSwipeLeftEnd, cb);
	  };
	
	  return ScreenClass;
	
	})(BaseClass);
	
	exports.Screen = new ScreenClass;


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var CounterKey, DefinedPropertiesKey, DefinedPropertiesValuesKey, EventEmitter, Utils, _, capitalizeFirstLetter,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	_ = __webpack_require__(1)._;
	
	Utils = __webpack_require__(4);
	
	EventEmitter = __webpack_require__(7).EventEmitter;
	
	CounterKey = "_ObjectCounter";
	
	DefinedPropertiesKey = "_DefinedPropertiesKey";
	
	DefinedPropertiesValuesKey = "_DefinedPropertiesValuesKey";
	
	capitalizeFirstLetter = function(string) {
	  return string.charAt(0).toUpperCase() + string.slice(1);
	};
	
	exports.BaseClass = (function(superClass) {
	  extend(BaseClass, superClass);
	
	  BaseClass.define = function(propertyName, descriptor) {
	    var getName, i, j, len, ref, setName;
	    ref = ["enumerable", "exportable", "importable"];
	    for (j = 0, len = ref.length; j < len; j++) {
	      i = ref[j];
	      if (descriptor.hasOwnProperty(i)) {
	        if (!_.isBoolean(descriptor[i])) {
	          throw Error("woops " + propertyName + " " + descriptor[i]);
	        }
	      }
	    }
	    if (this !== BaseClass) {
	      descriptor.propertyName = propertyName;
	      if (descriptor.enumerable == null) {
	        descriptor.enumerable = true;
	      }
	      if (descriptor.exportable == null) {
	        descriptor.exportable = true;
	      }
	      if (descriptor.importable == null) {
	        descriptor.importable = true;
	      }
	      descriptor.importable = descriptor.importable && descriptor.set;
	      if (descriptor.exportable || descriptor.importable) {
	        if (this[DefinedPropertiesKey] == null) {
	          this[DefinedPropertiesKey] = {};
	        }
	        this[DefinedPropertiesKey][propertyName] = descriptor;
	      }
	    }
	    getName = "get" + (capitalizeFirstLetter(propertyName));
	    this.prototype[getName] = descriptor.get;
	    descriptor.get = this.prototype[getName];
	    if (descriptor.set) {
	      setName = "set" + (capitalizeFirstLetter(propertyName));
	      this.prototype[setName] = descriptor.set;
	      descriptor.set = this.prototype[setName];
	    }
	    return Object.defineProperty(this.prototype, propertyName, descriptor);
	  };
	
	  BaseClass.simpleProperty = function(name, fallback, options) {
	    if (options == null) {
	      options = {};
	    }
	    return _.extend(options, {
	      "default": fallback,
	      get: function() {
	        return this._getPropertyValue(name);
	      },
	      set: function(value) {
	        return this._setPropertyValue(name, value);
	      }
	    });
	  };
	
	  BaseClass.proxyProperty = function(keyPath, options) {
	    var objectKey;
	    if (options == null) {
	      options = {};
	    }
	    objectKey = keyPath.split(".")[0];
	    return _.extend(options, {
	      get: function() {
	        if (!_.isObject(this[objectKey])) {
	          return;
	        }
	        return Utils.getValueForKeyPath(this, keyPath);
	      },
	      set: function(value) {
	        if (!_.isObject(this[objectKey])) {
	          return;
	        }
	        return Utils.setValueForKeyPath(this, keyPath, value);
	      }
	    });
	  };
	
	  BaseClass.prototype._setPropertyValue = function(k, v) {
	    return this[DefinedPropertiesValuesKey][k] = v;
	  };
	
	  BaseClass.prototype._getPropertyValue = function(k) {
	    return Utils.valueOrDefault(this[DefinedPropertiesValuesKey][k], this._getPropertyDefaultValue(k));
	  };
	
	  BaseClass.prototype._getPropertyDefaultValue = function(k) {
	    return this._propertyList()[k]["default"];
	  };
	
	  BaseClass.prototype._propertyList = function() {
	    return this.constructor[DefinedPropertiesKey];
	  };
	
	  BaseClass.prototype.keys = function() {
	    return _.keys(this.props);
	  };
	
	  BaseClass.define("props", {
	    importable: false,
	    exportable: false,
	    get: function() {
	      var descriptor, key, keys, propertyList;
	      keys = [];
	      propertyList = this._propertyList();
	      for (key in propertyList) {
	        descriptor = propertyList[key];
	        if (descriptor.exportable) {
	          keys.push(key);
	        }
	      }
	      return _.pick(this, keys);
	    },
	    set: function(value) {
	      var k, propertyList, ref, results, v;
	      propertyList = this._propertyList();
	      results = [];
	      for (k in value) {
	        v = value[k];
	        if ((ref = propertyList[k]) != null ? ref.importable : void 0) {
	          results.push(this[k] = v);
	        } else {
	          results.push(void 0);
	        }
	      }
	      return results;
	    }
	  });
	
	  BaseClass.define("id", {
	    get: function() {
	      return this._id;
	    }
	  });
	
	  BaseClass.prototype.toInspect = function() {
	    return "<" + this.constructor.name + " id:" + (this.id || null) + ">";
	  };
	
	  BaseClass.prototype.onChange = function(name, cb) {
	    return this.on("change:" + name, cb);
	  };
	
	  function BaseClass(options) {
	    this.toInspect = bind(this.toInspect, this);
	    this._getPropertyValue = bind(this._getPropertyValue, this);
	    this._setPropertyValue = bind(this._setPropertyValue, this);
	    var base;
	    BaseClass.__super__.constructor.apply(this, arguments);
	    this._context = typeof Framer !== "undefined" && Framer !== null ? Framer.CurrentContext : void 0;
	    this[DefinedPropertiesValuesKey] = {};
	    if ((base = this.constructor)[CounterKey] == null) {
	      base[CounterKey] = 0;
	    }
	    this.constructor[CounterKey] += 1;
	    this._id = this.constructor[CounterKey];
	    this._applyOptionsAndDefaults(options);
	  }
	
	  BaseClass.prototype._applyOptionsAndDefaults = function(options) {
	    var descriptor, key, ref, results, value;
	    ref = this._propertyList();
	    results = [];
	    for (key in ref) {
	      descriptor = ref[key];
	      if (descriptor.set) {
	        value = Utils.valueOrDefault((descriptor.importable ? options != null ? options[key] : void 0 : void 0), this._getPropertyDefaultValue(key));
	        if (!(value === null || value === (void 0))) {
	          results.push(this[key] = value);
	        } else {
	          results.push(void 0);
	        }
	      } else {
	        results.push(void 0);
	      }
	    }
	    return results;
	  };
	
	  return BaseClass;
	
	})(EventEmitter);


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var EventEmitter3, EventKey, _,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	_ = __webpack_require__(1)._;
	
	EventEmitter3 = __webpack_require__(8);
	
	EventKey = "_events";
	
	exports.EventEmitter = (function(superClass) {
	  extend(EventEmitter, superClass);
	
	  function EventEmitter() {
	    return EventEmitter.__super__.constructor.apply(this, arguments);
	  }
	
	  EventEmitter.prototype.listenerEvents = function() {
	    return _.keys(this[EventKey]);
	  };
	
	  EventEmitter.prototype.removeAllListeners = function(eventName) {
	    var eventNames, i, len, listener, results;
	    if (eventName) {
	      eventNames = [eventName];
	    } else {
	      eventNames = this.listenerEvents();
	    }
	    results = [];
	    for (i = 0, len = eventNames.length; i < len; i++) {
	      eventName = eventNames[i];
	      results.push((function() {
	        var j, len1, ref, results1;
	        ref = this.listeners(eventName);
	        results1 = [];
	        for (j = 0, len1 = ref.length; j < len1; j++) {
	          listener = ref[j];
	          results1.push(this.removeListener(eventName, listener));
	        }
	        return results1;
	      }).call(this));
	    }
	    return results;
	  };
	
	  return EventEmitter;
	
	})(EventEmitter3);


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	//
	// We store our EE objects in a plain object whose properties are event names.
	// If `Object.create(null)` is not supported we prefix the event names with a
	// `~` to make sure that the built-in object properties are not overridden or
	// used as an attack vector.
	// We also assume that `Object.create(null)` is available when the event name
	// is an ES6 Symbol.
	//
	var prefix = typeof Object.create !== 'function' ? '~' : false;
	
	/**
	 * Representation of a single EventEmitter function.
	 *
	 * @param {Function} fn Event handler to be called.
	 * @param {Mixed} context Context for function execution.
	 * @param {Boolean} once Only emit once
	 * @api private
	 */
	function EE(fn, context, once) {
	  this.fn = fn;
	  this.context = context;
	  this.once = once || false;
	}
	
	/**
	 * Minimal EventEmitter interface that is molded against the Node.js
	 * EventEmitter interface.
	 *
	 * @constructor
	 * @api public
	 */
	function EventEmitter() { /* Nothing to set */ }
	
	/**
	 * Holds the assigned EventEmitters by name.
	 *
	 * @type {Object}
	 * @private
	 */
	EventEmitter.prototype._events = undefined;
	
	/**
	 * Return a list of assigned event listeners.
	 *
	 * @param {String} event The events that should be listed.
	 * @param {Boolean} exists We only need to know if there are listeners.
	 * @returns {Array|Boolean}
	 * @api public
	 */
	EventEmitter.prototype.listeners = function listeners(event, exists) {
	  var evt = prefix ? prefix + event : event
	    , available = this._events && this._events[evt];
	
	  if (exists) return !!available;
	  if (!available) return [];
	  if (available.fn) return [available.fn];
	
	  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {
	    ee[i] = available[i].fn;
	  }
	
	  return ee;
	};
	
	/**
	 * Emit an event to all registered event listeners.
	 *
	 * @param {String} event The name of the event.
	 * @returns {Boolean} Indication if we've emitted an event.
	 * @api public
	 */
	EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
	  var evt = prefix ? prefix + event : event;
	
	  if (!this._events || !this._events[evt]) return false;
	
	  var listeners = this._events[evt]
	    , len = arguments.length
	    , args
	    , i;
	
	  if ('function' === typeof listeners.fn) {
	    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
	
	    switch (len) {
	      case 1: return listeners.fn.call(listeners.context), true;
	      case 2: return listeners.fn.call(listeners.context, a1), true;
	      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
	      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
	      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
	      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
	    }
	
	    for (i = 1, args = new Array(len -1); i < len; i++) {
	      args[i - 1] = arguments[i];
	    }
	
	    listeners.fn.apply(listeners.context, args);
	  } else {
	    var length = listeners.length
	      , j;
	
	    for (i = 0; i < length; i++) {
	      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
	
	      switch (len) {
	        case 1: listeners[i].fn.call(listeners[i].context); break;
	        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
	        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
	        default:
	          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
	            args[j - 1] = arguments[j];
	          }
	
	          listeners[i].fn.apply(listeners[i].context, args);
	      }
	    }
	  }
	
	  return true;
	};
	
	/**
	 * Register a new EventListener for the given event.
	 *
	 * @param {String} event Name of the event.
	 * @param {Functon} fn Callback function.
	 * @param {Mixed} context The context of the function.
	 * @api public
	 */
	EventEmitter.prototype.on = function on(event, fn, context) {
	  var listener = new EE(fn, context || this)
	    , evt = prefix ? prefix + event : event;
	
	  if (!this._events) this._events = prefix ? {} : Object.create(null);
	  if (!this._events[evt]) this._events[evt] = listener;
	  else {
	    if (!this._events[evt].fn) this._events[evt].push(listener);
	    else this._events[evt] = [
	      this._events[evt], listener
	    ];
	  }
	
	  return this;
	};
	
	/**
	 * Add an EventListener that's only called once.
	 *
	 * @param {String} event Name of the event.
	 * @param {Function} fn Callback function.
	 * @param {Mixed} context The context of the function.
	 * @api public
	 */
	EventEmitter.prototype.once = function once(event, fn, context) {
	  var listener = new EE(fn, context || this, true)
	    , evt = prefix ? prefix + event : event;
	
	  if (!this._events) this._events = prefix ? {} : Object.create(null);
	  if (!this._events[evt]) this._events[evt] = listener;
	  else {
	    if (!this._events[evt].fn) this._events[evt].push(listener);
	    else this._events[evt] = [
	      this._events[evt], listener
	    ];
	  }
	
	  return this;
	};
	
	/**
	 * Remove event listeners.
	 *
	 * @param {String} event The event we want to remove.
	 * @param {Function} fn The listener that we need to find.
	 * @param {Mixed} context Only remove listeners matching this context.
	 * @param {Boolean} once Only remove once listeners.
	 * @api public
	 */
	EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
	  var evt = prefix ? prefix + event : event;
	
	  if (!this._events || !this._events[evt]) return this;
	
	  var listeners = this._events[evt]
	    , events = [];
	
	  if (fn) {
	    if (listeners.fn) {
	      if (
	           listeners.fn !== fn
	        || (once && !listeners.once)
	        || (context && listeners.context !== context)
	      ) {
	        events.push(listeners);
	      }
	    } else {
	      for (var i = 0, length = listeners.length; i < length; i++) {
	        if (
	             listeners[i].fn !== fn
	          || (once && !listeners[i].once)
	          || (context && listeners[i].context !== context)
	        ) {
	          events.push(listeners[i]);
	        }
	      }
	    }
	  }
	
	  //
	  // Reset the array, or remove it completely if we have no more listeners.
	  //
	  if (events.length) {
	    this._events[evt] = events.length === 1 ? events[0] : events;
	  } else {
	    delete this._events[evt];
	  }
	
	  return this;
	};
	
	/**
	 * Remove all listeners or only the listeners for the specified event.
	 *
	 * @param {String} event The event want to remove all listeners for.
	 * @api public
	 */
	EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
	  if (!this._events) return this;
	
	  if (event) delete this._events[prefix ? prefix + event : event];
	  else this._events = prefix ? {} : Object.create(null);
	
	  return this;
	};
	
	//
	// Alias methods names because people roll like that.
	//
	EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
	EventEmitter.prototype.addListener = EventEmitter.prototype.on;
	
	//
	// This function doesn't apply anymore.
	//
	EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
	  return this;
	};
	
	//
	// Expose the prefix.
	//
	EventEmitter.prefixed = prefix;
	
	//
	// Expose the module.
	//
	if (true) {
	  module.exports = EventEmitter;
	}


/***/ },
/* 9 */
/***/ function(module, exports) {

	WebKitCSSMatrix.prototype.skew = function(skew) {
	  var m, rad, value;
	  if (!skew) {
	    return this;
	  }
	  rad = skew * Math.PI / 180;
	  value = Math.tan(rad);
	  m = new WebKitCSSMatrix();
	  m.m12 = value;
	  m.m21 = value;
	  return this.multiply(m);
	};
	
	WebKitCSSMatrix.prototype.point = function(point) {
	  var ref, w, x, y, z;
	  if (point == null) {
	    point = {};
	  }
	  ref = _.defaults(point, {
	    x: 0,
	    y: 0,
	    z: 0
	  }), x = ref.x, y = ref.y, z = ref.z;
	  w = this.m14 * x + this.m24 * y + this.m34 * z + this.m44;
	  w = w || 1;
	  return point = {
	    x: (this.m11 * x + this.m21 * y + this.m31 * z + this.m41) / w,
	    y: (this.m12 * x + this.m22 * y + this.m32 * z + this.m42) / w,
	    z: (this.m13 * x + this.m23 * y + this.m33 * z + this.m43) / w
	  };
	};
	
	exports.Matrix = WebKitCSSMatrix;


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var BaseClass, ColorModel, ColorType, _, bound01, convertToPercentage, correctAlpha, cssNames, hslToRgb, inputData, isNumeric, isOnePointZero, isPercentage, libhusl, matchers, numberFromString, pad2, percentToFraction, rgbToHex, rgbToHsl, rgbToRgb, rgbaFromHusl, stringToObject,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	_ = __webpack_require__(1)._;
	
	BaseClass = __webpack_require__(6).BaseClass;
	
	libhusl = __webpack_require__(11);
	
	ColorType = {
	  RGB: "rgb",
	  HSL: "hsl",
	  HEX: "hex",
	  NAME: "name"
	};
	
	exports.Color = (function(superClass) {
	  extend(Color, superClass);
	
	  function Color(color1, r, g, b) {
	    var color, input;
	    this.color = color1;
	    this.toInspect = bind(this.toInspect, this);
	    if (this.color === "") {
	      this.color = null;
	    }
	    color = this.color;
	    if (Color.isColorObject(color)) {
	      return color;
	    }
	    input = inputData(color, r, g, b);
	    this._type = input.type;
	    this._r = input.r;
	    this._g = input.g;
	    this._b = input.b;
	    this._a = input.a;
	    this._h = input.h;
	    this._s = input.s;
	    this._l = input.l;
	    this._roundA = Math.round(100 * this._a) / 100;
	  }
	
	  Color.define("r", {
	    get: function() {
	      return this._r;
	    }
	  });
	
	  Color.define("g", {
	    get: function() {
	      return this._g;
	    }
	  });
	
	  Color.define("b", {
	    get: function() {
	      return this._b;
	    }
	  });
	
	  Color.define("a", {
	    get: function() {
	      return this._a;
	    }
	  });
	
	  Color.define("h", {
	    get: function() {
	      return this._h;
	    }
	  });
	
	  Color.define("s", {
	    get: function() {
	      return this._s;
	    }
	  });
	
	  Color.define("l", {
	    get: function() {
	      return this._l;
	    }
	  });
	
	  Color.prototype.toHex = function(allow3Char) {
	    return rgbToHex(this._r, this._g, this._b, allow3Char);
	  };
	
	  Color.prototype.toHexString = function(allow3Char) {
	    return "#" + this.toHex(allow3Char);
	  };
	
	  Color.prototype.toRgb = function() {
	    if (this._rgb === void 0) {
	      this._rgb = {
	        r: Math.round(this._r),
	        g: Math.round(this._g),
	        b: Math.round(this._b),
	        a: this._a
	      };
	    }
	    return _.clone(this._rgb);
	  };
	
	  Color.prototype.toRgbString = function() {
	    if (this._a === 1) {
	      return "rgb(" + (Utils.round(this._r, 0)) + ", " + (Utils.round(this._g, 0)) + ", " + (Utils.round(this._b, 0)) + ")";
	    } else {
	      return "rgba(" + (Utils.round(this._r, 0)) + ", " + (Utils.round(this._g, 0)) + ", " + (Utils.round(this._b, 0)) + ", " + this._roundA + ")";
	    }
	  };
	
	  Color.prototype.toHsl = function() {
	    if (this._hsl === void 0) {
	      this._hsl = {
	        h: this.h,
	        s: this.s,
	        l: this.l,
	        a: this.a
	      };
	    }
	    return _.clone(this._hsl);
	  };
	
	  Color.prototype.toHusl = function() {
	    var c, husl;
	    if (this._husl === void 0) {
	      c = libhusl._conv;
	      husl = c.lch.husl(c.luv.lch(c.xyz.luv(c.rgb.xyz([this.r / 255, this.g / 255, this.b / 255]))));
	      this._husl = {
	        h: husl[0],
	        s: husl[1],
	        l: husl[2]
	      };
	    }
	    return _.clone(this._husl);
	  };
	
	  Color.prototype.toHslString = function() {
	    var h, hsl, l, s;
	    if (this._hslString === void 0) {
	      hsl = this.toHsl();
	      h = Math.round(hsl.h);
	      s = Math.round(hsl.s * 100);
	      l = Math.round(hsl.l * 100);
	      if (this._a === 1) {
	        this._hslString = "hsl(" + h + ", " + s + "%, " + l + "%)";
	      } else {
	        this._hslString = "hsla(" + h + ", " + s + "%, " + l + "%, " + this._roundA + ")";
	      }
	    }
	    return this._hslString;
	  };
	
	  Color.prototype.toName = function() {
	    var hex, i, key, len, ref, value;
	    if (this._a === 0) {
	      return "transparent";
	    }
	    if (this._a < 1) {
	      return false;
	    }
	    hex = rgbToHex(this._r, this._g, this._b, true);
	    ref = _.keys(cssNames);
	    for (i = 0, len = ref.length; i < len; i++) {
	      key = ref[i];
	      value = cssNames[key];
	      if (value === hex) {
	        return key;
	      }
	    }
	    return false;
	  };
	
	  Color.prototype.lighten = function(amount) {
	    var hsl;
	    if (amount == null) {
	      amount = 10;
	    }
	    hsl = this.toHsl();
	    hsl.l += amount / 100;
	    hsl.l = Math.min(1, Math.max(0, hsl.l));
	    return new Color(hsl);
	  };
	
	  Color.prototype.brighten = function(amount) {
	    var rgb;
	    if (amount == null) {
	      amount = 10;
	    }
	    rgb = this.toRgb();
	    rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
	    rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
	    rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
	    return new Color(rgb);
	  };
	
	  Color.prototype.darken = function(amount) {
	    var hsl;
	    if (amount == null) {
	      amount = 10;
	    }
	    hsl = this.toHsl();
	    hsl.l -= amount / 100;
	    hsl.l = Math.min(1, Math.max(0, hsl.l));
	    return new Color(hsl);
	  };
	
	  Color.prototype.desaturate = function(amount) {
	    var hsl;
	    if (amount == null) {
	      amount = 10;
	    }
	    hsl = this.toHsl();
	    hsl.s -= amount / 100;
	    hsl.s = Math.min(1, Math.max(0, hsl.s));
	    return new Color(hsl);
	  };
	
	  Color.prototype.saturate = function(amount) {
	    var hsl;
	    if (amount == null) {
	      amount = 10;
	    }
	    hsl = this.toHsl();
	    hsl.s += amount / 100;
	    hsl.s = Math.min(1, Math.max(0, hsl.s));
	    return new Color(hsl);
	  };
	
	  Color.prototype.grayscale = function() {
	    var hsl;
	    hsl = this.toHsl();
	    return new Color(hsl).desaturate(100);
	  };
	
	  Color.prototype.toString = function() {
	    return this.toRgbString();
	  };
	
	  Color.prototype.transparent = function() {
	    var result;
	    return result = new Color({
	      r: this.r,
	      g: this.g,
	      b: this.b,
	      a: 0
	    });
	  };
	
	  Color.prototype.mix = function(colorB, fraction, limit, model) {
	    if (limit == null) {
	      limit = false;
	    }
	    return Color.mix(this, colorB, fraction, limit, model);
	  };
	
	  Color.prototype.isEqual = function(colorB) {
	    return Color.equal(this, colorB);
	  };
	
	  Color.prototype.toInspect = function() {
	    if (this._type === ColorType.HSL) {
	      return "<" + this.constructor.name + " h:" + this.h + " s:" + this.s + " l:" + this.l + " a:" + this.a + ">";
	    } else if (this._type === ColorType.HEX || this._type === ColorType.NAME) {
	      return "<" + this.constructor.name + " \"" + this.color + "\">";
	    } else {
	      return "<" + this.constructor.name + " r:" + this.r + " g:" + this.g + " b:" + this.b + " a:" + this.a + ">";
	    }
	  };
	
	  Color.mix = function(colorA, colorB, fraction, limit, model) {
	    var deltaH, fromH, hslA, hslB, result, toH, tween;
	    if (fraction == null) {
	      fraction = .5;
	    }
	    if (limit == null) {
	      limit = false;
	    }
	    result = null;
	    if (typeof colorA === "string" && this.isColorString(colorA)) {
	      colorA = new Color(colorA);
	    }
	    if (typeof colorB === "string" && this.isColorString(colorB)) {
	      colorB = new Color(colorB);
	    }
	    if (!(colorA instanceof Color) && colorB instanceof Color) {
	      colorA = colorB.transparent();
	    } else if (colorA instanceof Color && colorA._a === 0 && colorB instanceof Color && colorB._a !== 0) {
	      colorA = colorB.transparent();
	    } else if (!(colorB instanceof Color) && colorA instanceof Color) {
	      colorB = colorA.transparent();
	    } else if (colorB instanceof Color && colorB._a === 0 && colorA instanceof Color && colorA._a !== 0) {
	      colorB = colorA.transparent();
	    }
	    if (colorB instanceof Color) {
	      if (ColorModel.isRGB(model)) {
	        result = new Color({
	          r: Utils.modulate(fraction, [0, 1], [colorA._r, colorB._r], limit),
	          g: Utils.modulate(fraction, [0, 1], [colorA._g, colorB._g], limit),
	          b: Utils.modulate(fraction, [0, 1], [colorA._b, colorB._b], limit),
	          a: Utils.modulate(fraction, [0, 1], [colorA._a, colorB._a], limit)
	        });
	      } else {
	        hslA;
	        hslB;
	        if (ColorModel.isHSL(model)) {
	          hslA = colorA.toHsl();
	          hslB = colorB.toHsl();
	        } else {
	          hslA = colorA.toHusl();
	          hslB = colorB.toHusl();
	        }
	        if (hslA.s === 0) {
	          hslA.h = hslB.h;
	        } else if (hslB.s === 0) {
	          hslB.h = hslA.h;
	        }
	        fromH = hslA.h;
	        toH = hslB.h;
	        deltaH = toH - fromH;
	        if (deltaH > 180) {
	          deltaH = (toH - 360) - fromH;
	        } else if (deltaH < -180) {
	          deltaH = (toH + 360) - fromH;
	        }
	        tween = {
	          h: Utils.modulate(fraction, [0, 1], [fromH, fromH + deltaH], limit),
	          s: Utils.modulate(fraction, [0, 1], [hslA.s, hslB.s], limit),
	          l: Utils.modulate(fraction, [0, 1], [hslA.l, hslB.l], limit),
	          a: Utils.modulate(fraction, [0, 1], [colorA.a, colorB.a], limit)
	        };
	        if (ColorModel.isHSL(model)) {
	          result = new Color(tween);
	        } else {
	          result = new Color(rgbaFromHusl(tween));
	        }
	      }
	    }
	    return result;
	  };
	
	  Color.random = function(alpha) {
	    var c;
	    if (alpha == null) {
	      alpha = 1.0;
	    }
	    c = function() {
	      return parseInt(Math.random() * 255);
	    };
	    return new Color("rgba(" + (c()) + ", " + (c()) + ", " + (c()) + ", " + alpha + ")");
	  };
	
	  Color.toColor = function(color) {
	    return new Color(color);
	  };
	
	  Color.validColorValue = function(color) {
	    return color instanceof Color || color === null;
	  };
	
	  Color.isColor = function(color) {
	    if (_.isString(color)) {
	      return this.isColorString(color);
	    } else {
	      return this.isColorObject(color);
	    }
	  };
	
	  Color.isColorObject = function(color) {
	    return color instanceof Color;
	  };
	
	  Color.isColorString = function(colorString) {
	    if (_.isString(colorString)) {
	      return stringToObject(colorString) !== false;
	    }
	    return false;
	  };
	
	  Color.equal = function(colorA, colorB) {
	    if (!this.validColorValue(colorA)) {
	      if (!Color.isColorString(colorA)) {
	        return false;
	      }
	    }
	    if (!this.validColorValue(colorB)) {
	      if (!Color.isColorString(colorB)) {
	        return false;
	      }
	    }
	    colorA = new Color(colorA);
	    colorB = new Color(colorB);
	    if (colorA.r !== colorB.r) {
	      return false;
	    }
	    if (colorA.g !== colorB.g) {
	      return false;
	    }
	    if (colorA.b !== colorB.b) {
	      return false;
	    }
	    if (colorA.a !== colorB.a) {
	      return false;
	    }
	    return true;
	  };
	
	  Color.rgbToHsl = function(a, b, c) {
	    return rgbToHsl(a, b, c);
	  };
	
	  return Color;
	
	})(BaseClass);
	
	ColorModel = {
	  RGB: "rgb",
	  RGBA: "rgba",
	  HSL: "hsl",
	  HSLA: "hsla"
	};
	
	ColorModel.isRGB = function(colorModel) {
	  var ref;
	  if (_.isString(colorModel)) {
	    return (ref = colorModel.toLowerCase()) === ColorModel.RGB || ref === ColorModel.RGBA;
	  }
	  return false;
	};
	
	ColorModel.isHSL = function(colorModel) {
	  var ref;
	  if (_.isString(colorModel)) {
	    return (ref = colorModel.toLowerCase()) === ColorModel.HSL || ref === ColorModel.HSLA;
	  }
	  return false;
	};
	
	rgbaFromHusl = function(husl) {
	  var c, rgb, rgba;
	  c = libhusl._conv;
	  rgb = c.xyz.rgb(c.luv.xyz(c.lch.luv(c.husl.lch([husl.h, husl.s, husl.l]))));
	  rgba = {
	    r: rgb[0] * 255,
	    g: rgb[1] * 255,
	    b: rgb[2] * 255,
	    a: husl.a
	  };
	  return rgba;
	};
	
	inputData = function(color, g, b, alpha) {
	  var a, h, hsl, l, ok, rgb, s, type;
	  rgb = {
	    r: 0,
	    g: 0,
	    b: 0
	  };
	  hsl = {
	    h: 0,
	    s: 0,
	    l: 0
	  };
	  a = 1;
	  ok = false;
	  type = ColorType.RGB;
	  if (color === null) {
	    a = 0;
	  } else if (_.isNumber(color)) {
	    rgb.r = color;
	    if (_.isNumber(g)) {
	      rgb.g = g;
	    }
	    if (_.isNumber(b)) {
	      rgb.b = b;
	    }
	    if (_.isNumber(alpha)) {
	      a = alpha;
	    }
	  } else {
	    if (typeof color === "string") {
	      color = stringToObject(color);
	      if (!color) {
	        color = {
	          r: 0,
	          g: 0,
	          b: 0,
	          a: 0
	        };
	      }
	      if (color.hasOwnProperty("type")) {
	        type = color.type;
	      }
	    }
	    if (typeof color === "object") {
	      if (color.hasOwnProperty("r") || color.hasOwnProperty("g") || color.hasOwnProperty("b")) {
	        rgb = rgbToRgb(color.r, color.g, color.b);
	      } else if (color.hasOwnProperty("h") || color.hasOwnProperty("s") || color.hasOwnProperty("l")) {
	        h = isNumeric(color.h) ? parseFloat(color.h) : 0;
	        h = (h + 360) % 360;
	        s = isNumeric(color.s) ? color.s : 1;
	        if (_.isString(color.s)) {
	          s = numberFromString(color.s);
	        }
	        l = isNumeric(color.l) ? color.l : 0.5;
	        if (_.isString(color.l)) {
	          l = numberFromString(color.l);
	        }
	        rgb = hslToRgb(h, s, l);
	        type = ColorType.HSL;
	        hsl = {
	          h: h,
	          s: s,
	          l: l
	        };
	      }
	      if (color.hasOwnProperty("a")) {
	        a = color.a;
	      }
	    }
	  }
	  a = correctAlpha(a);
	  if (type !== ColorType.HSL) {
	    hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
	  }
	  return {
	    type: type,
	    r: Math.min(255, Math.max(rgb.r, 0)),
	    g: Math.min(255, Math.max(rgb.g, 0)),
	    b: Math.min(255, Math.max(rgb.b, 0)),
	    h: Utils.clamp(hsl.h, 0, 360),
	    s: Utils.clamp(hsl.s, 0, 1),
	    l: Utils.clamp(hsl.l, 0, 1),
	    a: a
	  };
	};
	
	numberFromString = function(string) {
	  return string.match(/\d+/)[0];
	};
	
	rgbToRgb = function(r, g, b) {
	  return {
	    r: isNumeric(r) ? bound01(r, 255) * 255 : 0,
	    g: isNumeric(g) ? bound01(g, 255) * 255 : 0,
	    b: isNumeric(b) ? bound01(b, 255) * 255 : 0
	  };
	};
	
	rgbToHex = function(r, g, b, allow3Char) {
	  var hex;
	  hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];
	  if (allow3Char && hex[0].charAt(0) === hex[0].charAt(1) && hex[1].charAt(0) === hex[1].charAt(1) && hex[2].charAt(0) === hex[2].charAt(1)) {
	    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
	  }
	  return hex.join("");
	};
	
	rgbToHsl = function(r, g, b) {
	  var d, h, l, max, min, s;
	  r = bound01(r, 255);
	  g = bound01(g, 255);
	  b = bound01(b, 255);
	  max = Math.max(r, g, b);
	  min = Math.min(r, g, b);
	  h = s = l = (max + min) / 2;
	  if (max === min) {
	    h = s = 0;
	  } else {
	    d = max - min;
	    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
	    switch (max) {
	      case r:
	        h = (g - b) / d + (g < b ? 6 : 0);
	        break;
	      case g:
	        h = (b - r) / d + 2;
	        break;
	      case b:
	        h = (r - g) / d + 4;
	    }
	    h /= 6;
	  }
	  return {
	    h: h * 360,
	    s: s,
	    l: l
	  };
	};
	
	hslToRgb = function(h, s, l) {
	  var b, g, hue2rgb, p, q, r;
	  r = void 0;
	  g = void 0;
	  b = void 0;
	  h = bound01(h, 360);
	  s = bound01(s * 100, 100);
	  l = bound01(l * 100, 100);
	  hue2rgb = function(p, q, t) {
	    if (t < 0) {
	      t += 1;
	    }
	    if (t > 1) {
	      t -= 1;
	    }
	    if (t < 1 / 6) {
	      return p + (q - p) * 6 * t;
	    }
	    if (t < 1 / 2) {
	      return q;
	    }
	    if (t < 2 / 3) {
	      return p + (q - p) * (2 / 3 - t) * 6;
	    }
	    return p;
	  };
	  if (s === 0) {
	    r = g = b = l;
	  } else {
	    q = l < 0.5 ? l * (1 + s) : l + s - l * s;
	    p = 2 * l - q;
	    r = hue2rgb(p, q, h + 1 / 3);
	    g = hue2rgb(p, q, h);
	    b = hue2rgb(p, q, h - (1 / 3));
	  }
	  return {
	    r: r * 255,
	    g: g * 255,
	    b: b * 255
	  };
	};
	
	convertToPercentage = function(n) {
	  if (n <= 1) {
	    n = n * 100 + "%";
	  }
	  return n;
	};
	
	correctAlpha = function(a) {
	  a = parseFloat(a);
	  if (a < 0) {
	    a = 0;
	  }
	  if (isNaN(a) || a > 1) {
	    a = 1;
	  }
	  return a;
	};
	
	bound01 = function(n, max) {
	  var processPercent;
	  if (isOnePointZero(n)) {
	    n = "100%";
	  }
	  processPercent = isPercentage(n);
	  n = Math.min(max, Math.max(0, parseFloat(n)));
	  if (processPercent) {
	    n = parseInt(n * max, 10) / 100;
	  }
	  if (Math.abs(n - max) < 0.000001) {
	    return 1;
	  }
	  return n % max / parseFloat(max);
	};
	
	isOnePointZero = function(n) {
	  return typeof n === "string" && n.indexOf(".") !== -1 && parseFloat(n) === 1;
	};
	
	isPercentage = function(n) {
	  return typeof n === "string" && n.indexOf("%") !== -1;
	};
	
	pad2 = function(char) {
	  if (char.length === 1) {
	    return "0" + char;
	  } else {
	    return "" + char;
	  }
	};
	
	matchers = (function() {
	  var css_integer, css_number, css_unit, permissive_match3, permissive_match4;
	  css_integer = '[-\\+]?\\d+%?';
	  css_number = "[-\\+]?\\d*\\.\\d+%?";
	  css_unit = "(?:" + css_number + ")|(?:" + css_integer + ")";
	  permissive_match3 = '[\\s|\\(]+(' + css_unit + ')[,|\\s]+(' + css_unit + ')[,|\\s]+(' + css_unit + ')\\s*\\)?';
	  permissive_match4 = '[\\s|\\(]+(' + css_unit + ')[,|\\s]+(' + css_unit + ')[,|\\s]+(' + css_unit + ')[,|\\s]+(' + css_unit + ')\\s*\\)?';
	  return {
	    rgb: new RegExp('rgb' + permissive_match3),
	    rgba: new RegExp('rgba' + permissive_match4),
	    hsl: new RegExp('hsl' + permissive_match3),
	    hsla: new RegExp('hsla' + permissive_match4),
	    hex3: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
	    hex6: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
	  };
	})();
	
	isNumeric = function(value) {
	  return !isNaN(value) && isFinite(value);
	};
	
	percentToFraction = function(percentage) {
	  return numberFromString(percentage) / 100;
	};
	
	stringToObject = function(color) {
	  var match, named, trimLeft, trimRight;
	  trimLeft = /^[\s,#]+/;
	  trimRight = /\s+$/;
	  color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
	  named = false;
	  if (cssNames[color]) {
	    color = cssNames[color];
	    named = true;
	    ({
	      type: ColorType.NAME
	    });
	  } else if (color === "transparent") {
	    return {
	      r: 0,
	      g: 0,
	      b: 0,
	      a: 0,
	      type: ColorType.NAME
	    };
	  }
	  match = void 0;
	  if (match = matchers.rgb.exec(color)) {
	    return {
	      r: match[1],
	      g: match[2],
	      b: match[3]
	    };
	  }
	  if (match = matchers.rgba.exec(color)) {
	    return {
	      r: match[1],
	      g: match[2],
	      b: match[3],
	      a: match[4]
	    };
	  }
	  if (match = matchers.hsl.exec(color)) {
	    return {
	      h: match[1],
	      s: percentToFraction(match[2]),
	      l: percentToFraction(match[3])
	    };
	  }
	  if (match = matchers.hsla.exec(color)) {
	    return {
	      h: match[1],
	      s: percentToFraction(match[2]),
	      l: percentToFraction(match[3]),
	      a: match[4]
	    };
	  }
	  if (match = matchers.hex6.exec(color) || (match = matchers.hex6.exec(cssNames[color]))) {
	    return {
	      r: parseInt(match[1], 16),
	      g: parseInt(match[2], 16),
	      b: parseInt(match[3], 16),
	      a: 1,
	      type: ColorType.HEX
	    };
	  }
	  if (match = matchers.hex3.exec(color) || (match = matchers.hex3.exec(cssNames[color]))) {
	    return {
	      r: parseInt(match[1] + "" + match[1], 16),
	      g: parseInt(match[2] + "" + match[2], 16),
	      b: parseInt(match[3] + "" + match[3], 16),
	      type: ColorType.HEX
	    };
	  } else {
	    return false;
	  }
	};
	
	cssNames = {
	  aliceblue: "f0f8ff",
	  antiquewhite: "faebd7",
	  aqua: "0ff",
	  aquamarine: "7fffd4",
	  azure: "f0ffff",
	  beige: "f5f5dc",
	  bisque: "ffe4c4",
	  black: "000",
	  blanchedalmond: "ffebcd",
	  blue: "00f",
	  blueviolet: "8a2be2",
	  brown: "a52a2a",
	  burlywood: "deb887",
	  burntsienna: "ea7e5d",
	  cadetblue: "5f9ea0",
	  chartreuse: "7fff00",
	  chocolate: "d2691e",
	  coral: "ff7f50",
	  cornflowerblue: "6495ed",
	  cornsilk: "fff8dc",
	  crimson: "dc143c",
	  cyan: "0ff",
	  darkblue: "00008b",
	  darkcyan: "008b8b",
	  darkgoldenrod: "b8860b",
	  darkgray: "a9a9a9",
	  darkgreen: "006400",
	  darkgrey: "a9a9a9",
	  darkkhaki: "bdb76b",
	  darkmagenta: "8b008b",
	  darkolivegreen: "556b2f",
	  darkorange: "ff8c00",
	  darkorchid: "9932cc",
	  darkred: "8b0000",
	  darksalmon: "e9967a",
	  darkseagreen: "8fbc8f",
	  darkslateblue: "483d8b",
	  darkslategray: "2f4f4f",
	  darkslategrey: "2f4f4f",
	  darkturquoise: "00ced1",
	  darkviolet: "9400d3",
	  deeppink: "ff1493",
	  deepskyblue: "00bfff",
	  dimgray: "696969",
	  dimgrey: "696969",
	  dodgerblue: "1e90ff",
	  firebrick: "b22222",
	  floralwhite: "fffaf0",
	  forestgreen: "228b22",
	  fuchsia: "f0f",
	  gainsboro: "dcdcdc",
	  ghostwhite: "f8f8ff",
	  gold: "ffd700",
	  goldenrod: "daa520",
	  gray: "808080",
	  green: "008000",
	  greenyellow: "adff2f",
	  grey: "808080",
	  honeydew: "f0fff0",
	  hotpink: "ff69b4",
	  indianred: "cd5c5c",
	  indigo: "4b0082",
	  ivory: "fffff0",
	  khaki: "f0e68c",
	  lavender: "e6e6fa",
	  lavenderblush: "fff0f5",
	  lawngreen: "7cfc00",
	  lemonchiffon: "fffacd",
	  lightblue: "add8e6",
	  lightcoral: "f08080",
	  lightcyan: "e0ffff",
	  lightgoldenrodyellow: "fafad2",
	  lightgray: "d3d3d3",
	  lightgreen: "90ee90",
	  lightgrey: "d3d3d3",
	  lightpink: "ffb6c1",
	  lightsalmon: "ffa07a",
	  lightseagreen: "20b2aa",
	  lightskyblue: "87cefa",
	  lightslategray: "789",
	  lightslategrey: "789",
	  lightsteelblue: "b0c4de",
	  lightyellow: "ffffe0",
	  lime: "0f0",
	  limegreen: "32cd32",
	  linen: "faf0e6",
	  magenta: "f0f",
	  maroon: "800000",
	  mediumaquamarine: "66cdaa",
	  mediumblue: "0000cd",
	  mediumorchid: "ba55d3",
	  mediumpurple: "9370db",
	  mediumseagreen: "3cb371",
	  mediumslateblue: "7b68ee",
	  mediumspringgreen: "00fa9a",
	  mediumturquoise: "48d1cc",
	  mediumvioletred: "c71585",
	  midnightblue: "191970",
	  mintcream: "f5fffa",
	  mistyrose: "ffe4e1",
	  moccasin: "ffe4b5",
	  navajowhite: "ffdead",
	  navy: "000080",
	  oldlace: "fdf5e6",
	  olive: "808000",
	  olivedrab: "6b8e23",
	  orange: "ffa500",
	  orangered: "ff4500",
	  orchid: "da70d6",
	  palegoldenrod: "eee8aa",
	  palegreen: "98fb98",
	  paleturquoise: "afeeee",
	  palevioletred: "db7093",
	  papayawhip: "ffefd5",
	  peachpuff: "ffdab9",
	  peru: "cd853f",
	  pink: "ffc0cb",
	  plum: "dda0dd",
	  powderblue: "b0e0e6",
	  purple: "800080",
	  rebeccapurple: "663399",
	  red: "f00",
	  rosybrown: "bc8f8f",
	  royalblue: "4169e1",
	  saddlebrown: "8b4513",
	  salmon: "fa8072",
	  sandybrown: "f4a460",
	  seagreen: "2e8b57",
	  seashell: "fff5ee",
	  sienna: "a0522d",
	  silver: "c0c0c0",
	  skyblue: "87ceeb",
	  slateblue: "6a5acd",
	  slategray: "708090",
	  slategrey: "708090",
	  snow: "fffafa",
	  springgreen: "00ff7f",
	  steelblue: "4682b4",
	  tan: "d2b48c",
	  teal: "008080",
	  thistle: "d8bfd8",
	  tomato: "ff6347",
	  turquoise: "40e0d0",
	  violet: "ee82ee",
	  wheat: "f5deb3",
	  white: "fff",
	  whitesmoke: "f5f5f5",
	  yellow: "ff0",
	  yellowgreen: "9acd32"
	};


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {// Generated by CoffeeScript 1.9.3
	(function() {
	  var L_to_Y, Y_to_L, conv, distanceFromPole, dotProduct, epsilon, fromLinear, getBounds, intersectLineLine, kappa, lengthOfRayUntilIntersect, m, m_inv, maxChromaForLH, maxSafeChromaForL, refU, refV, root, toLinear;
	
	  m = {
	    R: [3.2409699419045214, -1.5373831775700935, -0.49861076029300328],
	    G: [-0.96924363628087983, 1.8759675015077207, 0.041555057407175613],
	    B: [0.055630079696993609, -0.20397695888897657, 1.0569715142428786]
	  };
	
	  m_inv = {
	    X: [0.41239079926595948, 0.35758433938387796, 0.18048078840183429],
	    Y: [0.21263900587151036, 0.71516867876775593, 0.072192315360733715],
	    Z: [0.019330818715591851, 0.11919477979462599, 0.95053215224966058]
	  };
	
	  refU = 0.19783000664283681;
	
	  refV = 0.468319994938791;
	
	  kappa = 903.2962962962963;
	
	  epsilon = 0.0088564516790356308;
	
	  getBounds = function(L) {
	    var bottom, channel, j, k, len1, len2, m1, m2, m3, ref, ref1, ref2, ret, sub1, sub2, t, top1, top2;
	    sub1 = Math.pow(L + 16, 3) / 1560896;
	    sub2 = sub1 > epsilon ? sub1 : L / kappa;
	    ret = [];
	    ref = ['R', 'G', 'B'];
	    for (j = 0, len1 = ref.length; j < len1; j++) {
	      channel = ref[j];
	      ref1 = m[channel], m1 = ref1[0], m2 = ref1[1], m3 = ref1[2];
	      ref2 = [0, 1];
	      for (k = 0, len2 = ref2.length; k < len2; k++) {
	        t = ref2[k];
	        top1 = (284517 * m1 - 94839 * m3) * sub2;
	        top2 = (838422 * m3 + 769860 * m2 + 731718 * m1) * L * sub2 - 769860 * t * L;
	        bottom = (632260 * m3 - 126452 * m2) * sub2 + 126452 * t;
	        ret.push([top1 / bottom, top2 / bottom]);
	      }
	    }
	    return ret;
	  };
	
	  intersectLineLine = function(line1, line2) {
	    return (line1[1] - line2[1]) / (line2[0] - line1[0]);
	  };
	
	  distanceFromPole = function(point) {
	    return Math.sqrt(Math.pow(point[0], 2) + Math.pow(point[1], 2));
	  };
	
	  lengthOfRayUntilIntersect = function(theta, line) {
	    var b1, len, m1;
	    m1 = line[0], b1 = line[1];
	    len = b1 / (Math.sin(theta) - m1 * Math.cos(theta));
	    if (len < 0) {
	      return null;
	    }
	    return len;
	  };
	
	  maxSafeChromaForL = function(L) {
	    var b1, j, len1, lengths, m1, ref, ref1, x;
	    lengths = [];
	    ref = getBounds(L);
	    for (j = 0, len1 = ref.length; j < len1; j++) {
	      ref1 = ref[j], m1 = ref1[0], b1 = ref1[1];
	      x = intersectLineLine([m1, b1], [-1 / m1, 0]);
	      lengths.push(distanceFromPole([x, b1 + x * m1]));
	    }
	    return Math.min.apply(Math, lengths);
	  };
	
	  maxChromaForLH = function(L, H) {
	    var hrad, j, l, len1, lengths, line, ref;
	    hrad = H / 360 * Math.PI * 2;
	    lengths = [];
	    ref = getBounds(L);
	    for (j = 0, len1 = ref.length; j < len1; j++) {
	      line = ref[j];
	      l = lengthOfRayUntilIntersect(hrad, line);
	      if (l !== null) {
	        lengths.push(l);
	      }
	    }
	    return Math.min.apply(Math, lengths);
	  };
	
	  dotProduct = function(a, b) {
	    var i, j, ref, ret;
	    ret = 0;
	    for (i = j = 0, ref = a.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
	      ret += a[i] * b[i];
	    }
	    return ret;
	  };
	
	  fromLinear = function(c) {
	    if (c <= 0.0031308) {
	      return 12.92 * c;
	    } else {
	      return 1.055 * Math.pow(c, 1 / 2.4) - 0.055;
	    }
	  };
	
	  toLinear = function(c) {
	    var a;
	    a = 0.055;
	    if (c > 0.04045) {
	      return Math.pow((c + a) / (1 + a), 2.4);
	    } else {
	      return c / 12.92;
	    }
	  };
	
	  conv = {
	    'xyz': {},
	    'luv': {},
	    'lch': {},
	    'husl': {},
	    'huslp': {},
	    'rgb': {},
	    'hex': {}
	  };
	
	  conv.xyz.rgb = function(tuple) {
	    var B, G, R;
	    R = fromLinear(dotProduct(m.R, tuple));
	    G = fromLinear(dotProduct(m.G, tuple));
	    B = fromLinear(dotProduct(m.B, tuple));
	    return [R, G, B];
	  };
	
	  conv.rgb.xyz = function(tuple) {
	    var B, G, R, X, Y, Z, rgbl;
	    R = tuple[0], G = tuple[1], B = tuple[2];
	    rgbl = [toLinear(R), toLinear(G), toLinear(B)];
	    X = dotProduct(m_inv.X, rgbl);
	    Y = dotProduct(m_inv.Y, rgbl);
	    Z = dotProduct(m_inv.Z, rgbl);
	    return [X, Y, Z];
	  };
	
	  Y_to_L = function(Y) {
	    if (Y <= epsilon) {
	      return Y * kappa;
	    } else {
	      return 116 * Math.pow(Y, 1 / 3) - 16;
	    }
	  };
	
	  L_to_Y = function(L) {
	    if (L <= 8) {
	      return L / kappa;
	    } else {
	      return Math.pow((L + 16) / 116, 3);
	    }
	  };
	
	  conv.xyz.luv = function(tuple) {
	    var L, U, V, X, Y, Z, varU, varV;
	    X = tuple[0], Y = tuple[1], Z = tuple[2];
	    if (Y === 0) {
	      return [0, 0, 0];
	    }
	    L = Y_to_L(Y);
	    varU = (4 * X) / (X + (15 * Y) + (3 * Z));
	    varV = (9 * Y) / (X + (15 * Y) + (3 * Z));
	    U = 13 * L * (varU - refU);
	    V = 13 * L * (varV - refV);
	    return [L, U, V];
	  };
	
	  conv.luv.xyz = function(tuple) {
	    var L, U, V, X, Y, Z, varU, varV;
	    L = tuple[0], U = tuple[1], V = tuple[2];
	    if (L === 0) {
	      return [0, 0, 0];
	    }
	    varU = U / (13 * L) + refU;
	    varV = V / (13 * L) + refV;
	    Y = L_to_Y(L);
	    X = 0 - (9 * Y * varU) / ((varU - 4) * varV - varU * varV);
	    Z = (9 * Y - (15 * varV * Y) - (varV * X)) / (3 * varV);
	    return [X, Y, Z];
	  };
	
	  conv.luv.lch = function(tuple) {
	    var C, H, Hrad, L, U, V;
	    L = tuple[0], U = tuple[1], V = tuple[2];
	    C = Math.sqrt(Math.pow(U, 2) + Math.pow(V, 2));
	    if (C < 0.00000001) {
	      H = 0;
	    } else {
	      Hrad = Math.atan2(V, U);
	      H = Hrad * 360 / 2 / Math.PI;
	      if (H < 0) {
	        H = 360 + H;
	      }
	    }
	    return [L, C, H];
	  };
	
	  conv.lch.luv = function(tuple) {
	    var C, H, Hrad, L, U, V;
	    L = tuple[0], C = tuple[1], H = tuple[2];
	    Hrad = H / 360 * 2 * Math.PI;
	    U = Math.cos(Hrad) * C;
	    V = Math.sin(Hrad) * C;
	    return [L, U, V];
	  };
	
	  conv.husl.lch = function(tuple) {
	    var C, H, L, S, max;
	    H = tuple[0], S = tuple[1], L = tuple[2];
	    if (L > 99.9999999 || L < 0.00000001) {
	      C = 0;
	    } else {
	      max = maxChromaForLH(L, H);
	      C = max / 100 * S;
	    }
	    return [L, C, H];
	  };
	
	  conv.lch.husl = function(tuple) {
	    var C, H, L, S, max;
	    L = tuple[0], C = tuple[1], H = tuple[2];
	    if (L > 99.9999999 || L < 0.00000001) {
	      S = 0;
	    } else {
	      max = maxChromaForLH(L, H);
	      S = C / max * 100;
	    }
	    return [H, S, L];
	  };
	
	  conv.huslp.lch = function(tuple) {
	    var C, H, L, S, max;
	    H = tuple[0], S = tuple[1], L = tuple[2];
	    if (L > 99.9999999 || L < 0.00000001) {
	      C = 0;
	    } else {
	      max = maxSafeChromaForL(L);
	      C = max / 100 * S;
	    }
	    return [L, C, H];
	  };
	
	  conv.lch.huslp = function(tuple) {
	    var C, H, L, S, max;
	    L = tuple[0], C = tuple[1], H = tuple[2];
	    if (L > 99.9999999 || L < 0.00000001) {
	      S = 0;
	    } else {
	      max = maxSafeChromaForL(L);
	      S = C / max * 100;
	    }
	    return [H, S, L];
	  };
	
	  conv.rgb.hex = function(tuple) {
	    var ch, hex, j, len1;
	    hex = "#";
	    for (j = 0, len1 = tuple.length; j < len1; j++) {
	      ch = tuple[j];
	      ch = Math.round(ch * 1e6) / 1e6;
	      if (ch < 0 || ch > 1) {
	        throw new Error("Illegal rgb value: " + ch);
	      }
	      ch = Math.round(ch * 255).toString(16);
	      if (ch.length === 1) {
	        ch = "0" + ch;
	      }
	      hex += ch;
	    }
	    return hex;
	  };
	
	  conv.hex.rgb = function(hex) {
	    var b, g, j, len1, n, r, ref, results;
	    if (hex.charAt(0) === "#") {
	      hex = hex.substring(1, 7);
	    }
	    r = hex.substring(0, 2);
	    g = hex.substring(2, 4);
	    b = hex.substring(4, 6);
	    ref = [r, g, b];
	    results = [];
	    for (j = 0, len1 = ref.length; j < len1; j++) {
	      n = ref[j];
	      results.push(parseInt(n, 16) / 255);
	    }
	    return results;
	  };
	
	  conv.lch.rgb = function(tuple) {
	    return conv.xyz.rgb(conv.luv.xyz(conv.lch.luv(tuple)));
	  };
	
	  conv.rgb.lch = function(tuple) {
	    return conv.luv.lch(conv.xyz.luv(conv.rgb.xyz(tuple)));
	  };
	
	  conv.husl.rgb = function(tuple) {
	    return conv.lch.rgb(conv.husl.lch(tuple));
	  };
	
	  conv.rgb.husl = function(tuple) {
	    return conv.lch.husl(conv.rgb.lch(tuple));
	  };
	
	  conv.huslp.rgb = function(tuple) {
	    return conv.lch.rgb(conv.huslp.lch(tuple));
	  };
	
	  conv.rgb.huslp = function(tuple) {
	    return conv.lch.huslp(conv.rgb.lch(tuple));
	  };
	
	  root = {};
	
	  root.fromRGB = function(R, G, B) {
	    return conv.rgb.husl([R, G, B]);
	  };
	
	  root.fromHex = function(hex) {
	    return conv.rgb.husl(conv.hex.rgb(hex));
	  };
	
	  root.toRGB = function(H, S, L) {
	    return conv.husl.rgb([H, S, L]);
	  };
	
	  root.toHex = function(H, S, L) {
	    return conv.rgb.hex(conv.husl.rgb([H, S, L]));
	  };
	
	  root.p = {};
	
	  root.p.toRGB = function(H, S, L) {
	    return conv.xyz.rgb(conv.luv.xyz(conv.lch.luv(conv.huslp.lch([H, S, L]))));
	  };
	
	  root.p.toHex = function(H, S, L) {
	    return conv.rgb.hex(conv.xyz.rgb(conv.luv.xyz(conv.lch.luv(conv.huslp.lch([H, S, L])))));
	  };
	
	  root.p.fromRGB = function(R, G, B) {
	    return conv.lch.huslp(conv.luv.lch(conv.xyz.luv(conv.rgb.xyz([R, G, B]))));
	  };
	
	  root.p.fromHex = function(hex) {
	    return conv.lch.huslp(conv.luv.lch(conv.xyz.luv(conv.rgb.xyz(conv.hex.rgb(hex)))));
	  };
	
	  root._conv = conv;
	
	  root._getBounds = getBounds;
	
	  root._maxChromaForLH = maxChromaForLH;
	
	  root._maxSafeChromaForL = maxSafeChromaForL;
	
	  if (!((typeof module !== "undefined" && module !== null) || (typeof jQuery !== "undefined" && jQuery !== null) || (typeof requirejs !== "undefined" && requirejs !== null))) {
	    this.HUSL = root;
	  }
	
	  if (typeof module !== "undefined" && module !== null) {
	    module.exports = root;
	  }
	
	  if (typeof jQuery !== "undefined" && jQuery !== null) {
	    jQuery.husl = root;
	  }
	
	  if ((typeof requirejs !== "undefined" && requirejs !== null) && ("function" !== "undefined" && __webpack_require__(12) !== null)) {
	    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (root), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	
	}).call(this);
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)(module)))

/***/ },
/* 12 */
/***/ function(module, exports) {

	module.exports = function() { throw new Error("define cannot be used indirect"); };


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var Animation, BaseClass, Color, Config, Defaults, EventEmitter, Events, Gestures, LayerDraggable, LayerPinchable, LayerStates, LayerStyle, Matrix, NoCacheDateKey, Utils, _, layerProperty, layerPropertyPointTransformer, layerValueTypeError,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
	  slice = [].slice;
	
	_ = __webpack_require__(1)._;
	
	Utils = __webpack_require__(4);
	
	Config = __webpack_require__(14).Config;
	
	Events = __webpack_require__(15).Events;
	
	Defaults = __webpack_require__(17).Defaults;
	
	BaseClass = __webpack_require__(6).BaseClass;
	
	EventEmitter = __webpack_require__(7).EventEmitter;
	
	Color = __webpack_require__(10).Color;
	
	Matrix = __webpack_require__(9).Matrix;
	
	Animation = __webpack_require__(18).Animation;
	
	LayerStyle = __webpack_require__(25).LayerStyle;
	
	LayerStates = __webpack_require__(26).LayerStates;
	
	LayerDraggable = __webpack_require__(27).LayerDraggable;
	
	LayerPinchable = __webpack_require__(34).LayerPinchable;
	
	Gestures = __webpack_require__(16).Gestures;
	
	NoCacheDateKey = Date.now();
	
	layerValueTypeError = function(name, value) {
	  throw new Error("Layer." + name + ": value '" + value + "' of type '" + (typeof value) + "'' is not valid");
	};
	
	layerProperty = function(obj, name, cssProperty, fallback, validator, transformer, options, set) {
	  var result;
	  if (options == null) {
	    options = {};
	  }
	  result = {
	    "default": fallback,
	    get: function() {
	      if (this._properties.hasOwnProperty(name)) {
	        return this._properties[name];
	      }
	      return fallback;
	    },
	    set: function(value) {
	      if (transformer) {
	        value = transformer(value, this, name);
	      }
	      if (value === this._properties[name]) {
	        return;
	      }
	      if (value && validator && !validator(value)) {
	        layerValueTypeError(name, value);
	      }
	      this._properties[name] = value;
	      if (cssProperty !== null) {
	        this._element.style[cssProperty] = LayerStyle[cssProperty](this);
	      }
	      if (typeof set === "function") {
	        set(this, value);
	      }
	      this.emit("change:" + name, value);
	      if (name === "x" || name === "y") {
	        this.emit("change:point", value);
	      }
	      if (name === "width" || name === "height") {
	        this.emit("change:size", value);
	      }
	      if (name === "x" || name === "y" || name === "width" || name === "height") {
	        this.emit("change:frame", value);
	      }
	      if (name === "rotationZ") {
	        return this.emit("change:rotation", value);
	      }
	    }
	  };
	  return result = _.extend(result, options);
	};
	
	layerPropertyPointTransformer = function(value, layer, property) {
	  if (_.isFunction(value)) {
	    value = value(layer, property);
	  }
	  return value;
	};
	
	exports.Layer = (function(superClass) {
	  extend(Layer, superClass);
	
	  function Layer(options) {
	    if (options == null) {
	      options = {};
	    }
	    this.addListener = bind(this.addListener, this);
	    this.once = bind(this.once, this);
	    this._properties = {};
	    this._style = {};
	    this._children = [];
	    this._prefer2d = false;
	    this._alwaysUseImageCache = false;
	    this._cancelClickEventInDragSession = true;
	    this._cancelClickEventInDragSessionVelocity = 0.1;
	    this._createElement();
	    if (options.hasOwnProperty("frame")) {
	      options = _.extend(options, options.frame);
	    }
	    options = Defaults.getDefaults("Layer", options);
	    Layer.__super__.constructor.call(this, options);
	    this._context.addLayer(this);
	    this._id = this._context.layerCounter;
	    if (!options.parent && options.hasOwnProperty("superLayer")) {
	      options.parent = options.superLayer;
	    }
	    if (!options.parent) {
	      if (!options.shadow) {
	        this._insertElement();
	      }
	    } else {
	      this.parent = options.parent;
	    }
	    if (options.hasOwnProperty("index")) {
	      this.index = options.index;
	    }
	    if (options.hasOwnProperty("x")) {
	      this.x = options.x;
	    }
	    if (options.hasOwnProperty("y")) {
	      this.y = options.y;
	    }
	    this._context.emit("layer:create", this);
	  }
	
	  Layer.define("context", {
	    get: function() {
	      return this._context;
	    }
	  });
	
	  Layer.define("custom", Layer.simpleProperty("custom", void 0));
	
	  Layer.define("width", layerProperty(Layer, "width", "width", 100, _.isNumber));
	
	  Layer.define("height", layerProperty(Layer, "height", "height", 100, _.isNumber));
	
	  Layer.define("visible", layerProperty(Layer, "visible", "display", true, _.isBoolean));
	
	  Layer.define("opacity", layerProperty(Layer, "opacity", "opacity", 1, _.isNumber));
	
	  Layer.define("index", layerProperty(Layer, "index", "zIndex", 0, _.isNumber, null, {
	    importable: false,
	    exportable: false
	  }));
	
	  Layer.define("clip", layerProperty(Layer, "clip", "overflow", false, _.isBoolean));
	
	  Layer.define("scrollHorizontal", layerProperty(Layer, "scrollHorizontal", "overflowX", false, _.isBoolean, null, {}, function(layer, value) {
	    if (value === true) {
	      return layer.ignoreEvents = false;
	    }
	  }));
	
	  Layer.define("scrollVertical", layerProperty(Layer, "scrollVertical", "overflowY", false, _.isBoolean, null, {}, function(layer, value) {
	    if (value === true) {
	      return layer.ignoreEvents = false;
	    }
	  }));
	
	  Layer.define("scroll", {
	    get: function() {
	      return this.scrollHorizontal === true || this.scrollVertical === true;
	    },
	    set: function(value) {
	      return this.scrollHorizontal = this.scrollVertical = value;
	    }
	  });
	
	  Layer.define("ignoreEvents", layerProperty(Layer, "ignoreEvents", "pointerEvents", true, _.isBoolean));
	
	  Layer.define("x", layerProperty(Layer, "x", "webkitTransform", 0, _.isNumber, layerPropertyPointTransformer));
	
	  Layer.define("y", layerProperty(Layer, "y", "webkitTransform", 0, _.isNumber, layerPropertyPointTransformer));
	
	  Layer.define("z", layerProperty(Layer, "z", "webkitTransform", 0, _.isNumber));
	
	  Layer.define("scaleX", layerProperty(Layer, "scaleX", "webkitTransform", 1, _.isNumber));
	
	  Layer.define("scaleY", layerProperty(Layer, "scaleY", "webkitTransform", 1, _.isNumber));
	
	  Layer.define("scaleZ", layerProperty(Layer, "scaleZ", "webkitTransform", 1, _.isNumber));
	
	  Layer.define("scale", layerProperty(Layer, "scale", "webkitTransform", 1, _.isNumber));
	
	  Layer.define("skewX", layerProperty(Layer, "skewX", "webkitTransform", 0, _.isNumber));
	
	  Layer.define("skewY", layerProperty(Layer, "skewY", "webkitTransform", 0, _.isNumber));
	
	  Layer.define("skew", layerProperty(Layer, "skew", "webkitTransform", 0, _.isNumber));
	
	  Layer.define("originX", layerProperty(Layer, "originX", "webkitTransformOrigin", 0.5, _.isNumber));
	
	  Layer.define("originY", layerProperty(Layer, "originY", "webkitTransformOrigin", 0.5, _.isNumber));
	
	  Layer.define("originZ", layerProperty(Layer, "originZ", null, 0, _.isNumber));
	
	  Layer.define("perspective", layerProperty(Layer, "perspective", "webkitPerspective", 0, _.isNumber));
	
	  Layer.define("perspectiveOriginX", layerProperty(Layer, "perspectiveOriginX", "webkitPerspectiveOrigin", 0.5, _.isNumber));
	
	  Layer.define("perspectiveOriginY", layerProperty(Layer, "perspectiveOriginY", "webkitPerspectiveOrigin", 0.5, _.isNumber));
	
	  Layer.define("rotationX", layerProperty(Layer, "rotationX", "webkitTransform", 0, _.isNumber));
	
	  Layer.define("rotationY", layerProperty(Layer, "rotationY", "webkitTransform", 0, _.isNumber));
	
	  Layer.define("rotationZ", layerProperty(Layer, "rotationZ", "webkitTransform", 0, _.isNumber));
	
	  Layer.define("rotation", {
	    get: function() {
	      return this.rotationZ;
	    },
	    set: function(value) {
	      return this.rotationZ = value;
	    }
	  });
	
	  Layer.define("blur", layerProperty(Layer, "blur", "webkitFilter", 0, _.isNumber));
	
	  Layer.define("brightness", layerProperty(Layer, "brightness", "webkitFilter", 100, _.isNumber));
	
	  Layer.define("saturate", layerProperty(Layer, "saturate", "webkitFilter", 100, _.isNumber));
	
	  Layer.define("hueRotate", layerProperty(Layer, "hueRotate", "webkitFilter", 0, _.isNumber));
	
	  Layer.define("contrast", layerProperty(Layer, "contrast", "webkitFilter", 100, _.isNumber));
	
	  Layer.define("invert", layerProperty(Layer, "invert", "webkitFilter", 0, _.isNumber));
	
	  Layer.define("grayscale", layerProperty(Layer, "grayscale", "webkitFilter", 0, _.isNumber));
	
	  Layer.define("sepia", layerProperty(Layer, "sepia", "webkitFilter", 0, _.isNumber));
	
	  Layer.define("shadowX", layerProperty(Layer, "shadowX", "boxShadow", 0, _.isNumber));
	
	  Layer.define("shadowY", layerProperty(Layer, "shadowY", "boxShadow", 0, _.isNumber));
	
	  Layer.define("shadowBlur", layerProperty(Layer, "shadowBlur", "boxShadow", 0, _.isNumber));
	
	  Layer.define("shadowSpread", layerProperty(Layer, "shadowSpread", "boxShadow", 0, _.isNumber));
	
	  Layer.define("shadowColor", layerProperty(Layer, "shadowColor", "boxShadow", "", Color.validColorValue, Color.toColor));
	
	  Layer.define("backgroundColor", layerProperty(Layer, "backgroundColor", "backgroundColor", null, Color.validColorValue, Color.toColor));
	
	  Layer.define("color", layerProperty(Layer, "color", "color", null, Color.validColorValue, Color.toColor));
	
	  Layer.define("borderColor", layerProperty(Layer, "borderColor", "border", null, Color.validColorValue, Color.toColor));
	
	  Layer.define("borderWidth", layerProperty(Layer, "borderWidth", "border", 0, _.isNumber));
	
	  Layer.define("force2d", layerProperty(Layer, "force2d", "webkitTransform", false, _.isBoolean));
	
	  Layer.define("flat", layerProperty(Layer, "flat", "webkitTransformStyle", false, _.isBoolean));
	
	  Layer.define("backfaceVisible", layerProperty(Layer, "backfaceVisible", "webkitBackfaceVisibility", true, _.isBoolean));
	
	  Layer.define("name", {
	    "default": "",
	    get: function() {
	      return this._getPropertyValue("name");
	    },
	    set: function(value) {
	      this._setPropertyValue("name", value);
	      return this._element.setAttribute("name", value);
	    }
	  });
	
	  Layer.define("matrix", {
	    get: function() {
	      if (this.force2d) {
	        return this._matrix2d;
	      }
	      return new Matrix().translate(this.x, this.y, this.z).scale(this.scale).scale(this.scaleX, this.scaleY, this.scaleZ).skew(this.skew).skewX(this.skewX).skewY(this.skewY).translate(0, 0, this.originZ).rotate(this.rotationX, 0, 0).rotate(0, this.rotationY, 0).rotate(0, 0, this.rotationZ).translate(0, 0, -this.originZ);
	    }
	  });
	
	  Layer.define("_matrix2d", {
	    get: function() {
	      return new Matrix().translate(this.x, this.y).scale(this.scale).skewX(this.skew).skewY(this.skew).rotate(0, 0, this.rotationZ);
	    }
	  });
	
	  Layer.define("transformMatrix", {
	    get: function() {
	      return new Matrix().translate(this.originX * this.width, this.originY * this.height).multiply(this.matrix).translate(-this.originX * this.width, -this.originY * this.height);
	    }
	  });
	
	  Layer.define("matrix3d", {
	    get: function() {
	      var parent, ppm;
	      parent = this.superLayer || this.context;
	      ppm = Utils.perspectiveMatrix(parent);
	      return new Matrix().multiply(ppm).multiply(this.transformMatrix);
	    }
	  });
	
	  Layer.define("borderRadius", {
	    importable: true,
	    exportable: true,
	    "default": 0,
	    get: function() {
	      return this._properties["borderRadius"];
	    },
	    set: function(value) {
	      if (value && !_.isNumber(value)) {
	        console.warn("Layer.borderRadius should be a numeric property, not type " + (typeof value));
	      }
	      this._properties["borderRadius"] = value;
	      this._element.style["borderRadius"] = LayerStyle["borderRadius"](this);
	      return this.emit("change:borderRadius", value);
	    }
	  });
	
	  Layer.define("cornerRadius", {
	    importable: false,
	    exportable: false,
	    get: function() {
	      return this.borderRadius;
	    },
	    set: function(value) {
	      return this.borderRadius = value;
	    }
	  });
	
	  Layer.define("point", {
	    get: function() {
	      return _.pick(this, ["x", "y"]);
	    },
	    set: function(point) {
	      var i, k, len, ref, results;
	      if (!point) {
	        return;
	      }
	      if (_.isNumber(point)) {
	        point = {
	          x: point,
	          y: point
	        };
	      }
	      ref = ["x", "y"];
	      results = [];
	      for (i = 0, len = ref.length; i < len; i++) {
	        k = ref[i];
	        if (point.hasOwnProperty(k)) {
	          results.push(this[k] = point[k]);
	        } else {
	          results.push(void 0);
	        }
	      }
	      return results;
	    }
	  });
	
	  Layer.define("size", {
	    get: function() {
	      return _.pick(this, ["width", "height"]);
	    },
	    set: function(size) {
	      var i, k, len, ref, results;
	      if (!size) {
	        return;
	      }
	      if (_.isNumber(size)) {
	        size = {
	          width: size,
	          height: size
	        };
	      }
	      ref = ["width", "height"];
	      results = [];
	      for (i = 0, len = ref.length; i < len; i++) {
	        k = ref[i];
	        if (size.hasOwnProperty(k)) {
	          results.push(this[k] = size[k]);
	        } else {
	          results.push(void 0);
	        }
	      }
	      return results;
	    }
	  });
	
	  Layer.define("frame", {
	    get: function() {
	      return _.pick(this, ["x", "y", "width", "height"]);
	    },
	    set: function(frame) {
	      var i, k, len, ref, results;
	      if (!frame) {
	        return;
	      }
	      ref = ["x", "y", "width", "height"];
	      results = [];
	      for (i = 0, len = ref.length; i < len; i++) {
	        k = ref[i];
	        if (frame.hasOwnProperty(k)) {
	          results.push(this[k] = frame[k]);
	        } else {
	          results.push(void 0);
	        }
	      }
	      return results;
	    }
	  });
	
	  Layer.define("minX", {
	    importable: true,
	    exportable: false,
	    get: function() {
	      return this.x;
	    },
	    set: function(value) {
	      return this.x = value;
	    }
	  });
	
	  Layer.define("midX", {
	    importable: true,
	    exportable: false,
	    get: function() {
	      return Utils.frameGetMidX(this);
	    },
	    set: function(value) {
	      return Utils.frameSetMidX(this, value);
	    }
	  });
	
	  Layer.define("maxX", {
	    importable: true,
	    exportable: false,
	    get: function() {
	      return Utils.frameGetMaxX(this);
	    },
	    set: function(value) {
	      return Utils.frameSetMaxX(this, value);
	    }
	  });
	
	  Layer.define("minY", {
	    importable: true,
	    exportable: false,
	    get: function() {
	      return this.y;
	    },
	    set: function(value) {
	      return this.y = value;
	    }
	  });
	
	  Layer.define("midY", {
	    importable: true,
	    exportable: false,
	    get: function() {
	      return Utils.frameGetMidY(this);
	    },
	    set: function(value) {
	      return Utils.frameSetMidY(this, value);
	    }
	  });
	
	  Layer.define("maxY", {
	    importable: true,
	    exportable: false,
	    get: function() {
	      return Utils.frameGetMaxY(this);
	    },
	    set: function(value) {
	      return Utils.frameSetMaxY(this, value);
	    }
	  });
	
	  Layer.prototype.convertPointFromScreen = function(point) {
	    return Utils.convertPointFromContext(point, this, false);
	  };
	
	  Layer.prototype.convertPointFromCanvas = function(point) {
	    return Utils.convertPointFromContext(point, this, true);
	  };
	
	  Layer.prototype.convertPointToScreen = function(point) {
	    return Utils.convertPointToContext(point, this, false);
	  };
	
	  Layer.prototype.convertPointToCanvas = function(point) {
	    return Utils.convertPointToContext(point, this, true);
	  };
	
	  Layer.define("canvasFrame", {
	    importable: true,
	    exportable: false,
	    get: function() {
	      return Utils.boundingFrame(this);
	    },
	    set: function(frame) {
	      return this.frame = Utils.convertFrameFromContext(frame, this, true, false);
	    }
	  });
	
	  Layer.define("screenFrame", {
	    importable: true,
	    exportable: false,
	    get: function() {
	      return Utils.boundingFrame(this, false);
	    },
	    set: function(frame) {
	      return this.frame = Utils.convertFrameFromContext(frame, this, false, false);
	    }
	  });
	
	  Layer.prototype.contentFrame = function() {
	    if (!this.children.length) {
	      return {
	        x: 0,
	        y: 0,
	        width: 0,
	        height: 0
	      };
	    }
	    return Utils.frameMerge(_.pluck(this.children, "frame"));
	  };
	
	  Layer.prototype.centerFrame = function() {
	    var frame;
	    if (this.parent) {
	      frame = this.frame;
	      Utils.frameSetMidX(frame, parseInt((this.parent.width / 2.0) - this.superLayer.borderWidth));
	      Utils.frameSetMidY(frame, parseInt((this.parent.height / 2.0) - this.superLayer.borderWidth));
	      return frame;
	    } else {
	      frame = this.frame;
	      Utils.frameSetMidX(frame, parseInt(this._context.width / 2.0));
	      Utils.frameSetMidY(frame, parseInt(this._context.height / 2.0));
	      return frame;
	    }
	  };
	
	  Layer.prototype.center = function() {
	    this.frame = this.centerFrame();
	    return this;
	  };
	
	  Layer.prototype.centerX = function(offset) {
	    if (offset == null) {
	      offset = 0;
	    }
	    this.x = this.centerFrame().x + offset;
	    return this;
	  };
	
	  Layer.prototype.centerY = function(offset) {
	    if (offset == null) {
	      offset = 0;
	    }
	    this.y = this.centerFrame().y + offset;
	    return this;
	  };
	
	  Layer.prototype.pixelAlign = function() {
	    this.x = parseInt(this.x);
	    return this.y = parseInt(this.y);
	  };
	
	  Layer.prototype.canvasScaleX = function() {
	    var context, i, len, parent, ref, scale;
	    scale = this.scale * this.scaleX;
	    ref = this.ancestors(context = true);
	    for (i = 0, len = ref.length; i < len; i++) {
	      parent = ref[i];
	      scale = scale * parent.scale * parent.scaleX;
	    }
	    return scale;
	  };
	
	  Layer.prototype.canvasScaleY = function() {
	    var context, i, len, parent, ref, scale;
	    scale = this.scale * this.scaleY;
	    ref = this.ancestors(context = true);
	    for (i = 0, len = ref.length; i < len; i++) {
	      parent = ref[i];
	      scale = scale * parent.scale * parent.scaleY;
	    }
	    return scale;
	  };
	
	  Layer.prototype.screenScaleX = function() {
	    var context, i, len, parent, ref, scale;
	    scale = this.scale * this.scaleX;
	    ref = this.ancestors(context = false);
	    for (i = 0, len = ref.length; i < len; i++) {
	      parent = ref[i];
	      scale = scale * parent.scale * parent.scaleX;
	    }
	    return scale;
	  };
	
	  Layer.prototype.screenScaleY = function() {
	    var context, i, len, parent, ref, scale;
	    scale = this.scale * this.scaleY;
	    ref = this.ancestors(context = false);
	    for (i = 0, len = ref.length; i < len; i++) {
	      parent = ref[i];
	      scale = scale * parent.scale * parent.scaleY;
	    }
	    return scale;
	  };
	
	  Layer.prototype.screenScaledFrame = function() {
	    var context, factorX, factorY, frame, i, layerScaledFrame, layers, len, parent;
	    frame = {
	      x: 0,
	      y: 0,
	      width: this.width * this.screenScaleX(),
	      height: this.height * this.screenScaleY()
	    };
	    layers = this.ancestors(context = true);
	    layers.push(this);
	    layers.reverse();
	    for (i = 0, len = layers.length; i < len; i++) {
	      parent = layers[i];
	      factorX = parent._parentOrContext() ? parent._parentOrContext().screenScaleX() : 1;
	      factorY = parent._parentOrContext() ? parent._parentOrContext().screenScaleY() : 1;
	      layerScaledFrame = parent.scaledFrame();
	      frame.x += layerScaledFrame.x * factorX;
	      frame.y += layerScaledFrame.y * factorY;
	    }
	    return frame;
	  };
	
	  Layer.prototype.scaledFrame = function() {
	    var frame, scaleX, scaleY;
	    frame = this.frame;
	    scaleX = this.scale * this.scaleX;
	    scaleY = this.scale * this.scaleY;
	    frame.width *= scaleX;
	    frame.height *= scaleY;
	    frame.x += (1 - scaleX) * this.originX * this.width;
	    frame.y += (1 - scaleY) * this.originY * this.height;
	    return frame;
	  };
	
	  Layer.define("style", {
	    importable: true,
	    exportable: false,
	    get: function() {
	      return this._element.style;
	    },
	    set: function(value) {
	      _.extend(this._element.style, value);
	      return this.emit("change:style");
	    }
	  });
	
	  Layer.prototype.computedStyle = function() {
	    var getComputedStyle;
	    getComputedStyle = document.defaultView.getComputedStyle;
	    if (getComputedStyle == null) {
	      getComputedStyle = window.getComputedStyle;
	    }
	    return getComputedStyle(this._element);
	  };
	
	  Layer.define("classList", {
	    importable: true,
	    exportable: false,
	    get: function() {
	      return this._element.classList;
	    }
	  });
	
	  Layer.prototype._createElement = function() {
	    if (this._element != null) {
	      return;
	    }
	    this._element = document.createElement("div");
	    return this._element.classList.add("framerLayer");
	  };
	
	  Layer.prototype._insertElement = function() {
	    this.bringToFront();
	    return this._context.element.appendChild(this._element);
	  };
	
	  Layer.define("html", {
	    get: function() {
	      var ref;
	      return ((ref = this._elementHTML) != null ? ref.innerHTML : void 0) || "";
	    },
	    set: function(value) {
	      if (!this._elementHTML) {
	        this._elementHTML = document.createElement("div");
	        this._element.appendChild(this._elementHTML);
	      }
	      this._elementHTML.innerHTML = value;
	      return this.emit("change:html");
	    }
	  });
	
	  Layer.prototype.querySelector = function(query) {
	    return this._element.querySelector(query);
	  };
	
	  Layer.prototype.querySelectorAll = function(query) {
	    return this._element.querySelectorAll(query);
	  };
	
	  Layer.prototype.destroy = function() {
	    var ref;
	    if (this.parent) {
	      this.parent._children = _.without(this.parent._children, this);
	    }
	    if ((ref = this._element.parentNode) != null) {
	      ref.removeChild(this._element);
	    }
	    this.removeAllListeners();
	    this._context.removeLayer(this);
	    return this._context.emit("layer:destroy", this);
	  };
	
	  Layer.prototype.copy = function() {
	    var child, copiedChild, i, layer, len, ref;
	    layer = this.copySingle();
	    ref = this.children;
	    for (i = 0, len = ref.length; i < len; i++) {
	      child = ref[i];
	      copiedChild = child.copy();
	      copiedChild.parent = layer;
	    }
	    return layer;
	  };
	
	  Layer.prototype.copySingle = function() {
	    var copy;
	    copy = new this.constructor(this.props);
	    return copy;
	  };
	
	  Layer.define("image", {
	    "default": "",
	    get: function() {
	      return this._getPropertyValue("image");
	    },
	    set: function(value) {
	      var currentValue, defaults, imageUrl, loader, ref;
	      if (!(_.isString(value) || value === null)) {
	        layerValueTypeError("image", value);
	      }
	      currentValue = this._getPropertyValue("image");
	      if (currentValue === value) {
	        return this.emit("load");
	      }
	      defaults = Defaults.getDefaults("Layer", {});
	      if ((ref = this.backgroundColor) != null ? ref.isEqual(defaults.backgroundColor) : void 0) {
	        this.backgroundColor = null;
	      }
	      this._setPropertyValue("image", value);
	      if (value === null || value === "") {
	        this.style["background-image"] = null;
	        return;
	      }
	      imageUrl = value;
	      if (this._alwaysUseImageCache === false && Utils.isLocalAssetUrl(imageUrl)) {
	        imageUrl += "?nocache=" + NoCacheDateKey;
	      }
	      if (this._domEventManager.listeners(Events.ImageLoaded) || this._domEventManager.listeners(Events.ImageLoadError)) {
	        loader = new Image();
	        loader.name = imageUrl;
	        loader.src = imageUrl;
	        loader.onload = (function(_this) {
	          return function() {
	            _this.style["background-image"] = "url('" + imageUrl + "')";
	            return _this.emit(Events.ImageLoaded, loader);
	          };
	        })(this);
	        return loader.onerror = (function(_this) {
	          return function() {
	            return _this.emit(Events.ImageLoadError, loader);
	          };
	        })(this);
	      } else {
	        return this.style["background-image"] = "url('" + imageUrl + "')";
	      }
	    }
	  });
	
	  Layer.define("parent", {
	    enumerable: false,
	    exportable: false,
	    importable: true,
	    get: function() {
	      return this._parent || null;
	    },
	    set: function(layer) {
	      if (layer === this._parent) {
	        return;
	      }
	      if (!layer instanceof Layer) {
	        throw Error("Layer.parent needs to be a Layer object");
	      }
	      Utils.domCompleteCancel(this.__insertElement);
	      if (this._parent) {
	        this._parent._children = _.without(this._parent._children, this);
	        this._parent._element.removeChild(this._element);
	        this._parent.emit("change:children", {
	          added: [],
	          removed: [this]
	        });
	        this._parent.emit("change:subLayers", {
	          added: [],
	          removed: [this]
	        });
	      }
	      if (layer) {
	        layer._element.appendChild(this._element);
	        layer._children.push(this);
	        layer.emit("change:children", {
	          added: [this],
	          removed: []
	        });
	        layer.emit("change:subLayers", {
	          added: [this],
	          removed: []
	        });
	      } else {
	        this._insertElement();
	      }
	      this._parent = layer;
	      this.bringToFront();
	      this.emit("change:parent");
	      return this.emit("change:superLayer");
	    }
	  });
	
	  Layer.define("children", {
	    enumerable: false,
	    exportable: false,
	    importable: false,
	    get: function() {
	      return _.clone(this._children);
	    }
	  });
	
	  Layer.define("siblings", {
	    enumerable: false,
	    exportable: false,
	    importable: false,
	    get: function() {
	      if (this.parent === null) {
	        return _.filter(this._context.getLayers(), (function(_this) {
	          return function(layer) {
	            return layer !== _this && layer.parent === null;
	          };
	        })(this));
	      }
	      return _.without(this.parent.children, this);
	    }
	  });
	
	  Layer.define("descendants", {
	    enumerable: false,
	    exportable: false,
	    importable: false,
	    get: function() {
	      var f, result;
	      result = [];
	      f = function(layer) {
	        result.push(layer);
	        return layer.children.map(f);
	      };
	      this.children.map(f);
	      return result;
	    }
	  });
	
	  Layer.prototype.addChild = function(layer) {
	    return layer.parent = this;
	  };
	
	  Layer.prototype.removeChild = function(layer) {
	    if (indexOf.call(this.children, layer) < 0) {
	      return;
	    }
	    return layer.parent = null;
	  };
	
	  Layer.prototype.childrenWithName = function(name) {
	    return _.filter(this.children, function(layer) {
	      return layer.name === name;
	    });
	  };
	
	  Layer.prototype.siblingsWithName = function(name) {
	    return _.filter(this.siblingLayers, function(layer) {
	      return layer.name === name;
	    });
	  };
	
	  Layer.prototype.ancestors = function(context) {
	    var currentLayer, parents;
	    if (context == null) {
	      context = false;
	    }
	    parents = [];
	    currentLayer = this;
	    if (context === false) {
	      while (currentLayer.parent) {
	        parents.push(currentLayer.parent);
	        currentLayer = currentLayer.parent;
	      }
	    } else {
	      while (currentLayer._parentOrContext()) {
	        parents.push(currentLayer._parentOrContext());
	        currentLayer = currentLayer._parentOrContext();
	      }
	    }
	    return parents;
	  };
	
	  Layer.prototype.childrenAbove = function(point, originX, originY) {
	    if (originX == null) {
	      originX = 0;
	    }
	    if (originY == null) {
	      originY = 0;
	    }
	    return _.filter(this.children, function(layer) {
	      return Utils.framePointForOrigin(layer.frame, originX, originY).y < point.y;
	    });
	  };
	
	  Layer.prototype.childrenBelow = function(point, originX, originY) {
	    if (originX == null) {
	      originX = 0;
	    }
	    if (originY == null) {
	      originY = 0;
	    }
	    return _.filter(this.children, function(layer) {
	      return Utils.framePointForOrigin(layer.frame, originX, originY).y > point.y;
	    });
	  };
	
	  Layer.prototype.childrenLeft = function(point, originX, originY) {
	    if (originX == null) {
	      originX = 0;
	    }
	    if (originY == null) {
	      originY = 0;
	    }
	    return _.filter(this.children, function(layer) {
	      return Utils.framePointForOrigin(layer.frame, originX, originY).x < point.x;
	    });
	  };
	
	  Layer.prototype.childrenRight = function(point, originX, originY) {
	    if (originX == null) {
	      originX = 0;
	    }
	    if (originY == null) {
	      originY = 0;
	    }
	    return _.filter(this.children, function(layer) {
	      return Utils.framePointForOrigin(layer.frame, originX, originY).x > point.x;
	    });
	  };
	
	  Layer.prototype._parentOrContext = function() {
	    if (this.parent) {
	      return this.parent;
	    }
	    if (this._context._parent) {
	      return this._context._parent;
	    }
	  };
	
	  Layer.define("superLayer", {
	    enumerable: false,
	    exportable: false,
	    importable: false,
	    get: function() {
	      return this.parent;
	    },
	    set: function(value) {
	      return this.parent = value;
	    }
	  });
	
	  Layer.define("subLayers", {
	    enumerable: false,
	    exportable: false,
	    importable: false,
	    get: function() {
	      return this.children;
	    }
	  });
	
	  Layer.define("siblingLayers", {
	    enumerable: false,
	    exportable: false,
	    importable: false,
	    get: function() {
	      return this.siblings;
	    }
	  });
	
	  Layer.prototype.superLayers = function(context) {
	    if (context == null) {
	      context = false;
	    }
	    return this.ancestors(context);
	  };
	
	  Layer.prototype.addSubLayer = function(layer) {
	    return this.addChild(layer);
	  };
	
	  Layer.prototype.removeSubLayer = function(layer) {
	    return this.removeChild(layer);
	  };
	
	  Layer.prototype.subLayersByName = function(name) {
	    return this.childrenWithName(name);
	  };
	
	  Layer.prototype.siblingLayersByName = function(name) {
	    return this.siblingsWithName(name);
	  };
	
	  Layer.prototype.subLayersAbove = function(point, originX, originY) {
	    if (originX == null) {
	      originX = 0;
	    }
	    if (originY == null) {
	      originY = 0;
	    }
	    return this.childrenAbove(point, originX, originY);
	  };
	
	  Layer.prototype.subLayersBelow = function(point, originX, originY) {
	    if (originX == null) {
	      originX = 0;
	    }
	    if (originY == null) {
	      originY = 0;
	    }
	    return this.childrenBelow(point, originX, originY);
	  };
	
	  Layer.prototype.subLayersLeft = function(point, originX, originY) {
	    if (originX == null) {
	      originX = 0;
	    }
	    if (originY == null) {
	      originY = 0;
	    }
	    return this.childrenLeft(point, originX, originY);
	  };
	
	  Layer.prototype.subLayersRight = function(point, originX, originY) {
	    if (originX == null) {
	      originX = 0;
	    }
	    if (originY == null) {
	      originY = 0;
	    }
	    return this.childrenRight(point, originX, originY);
	  };
	
	  Layer.prototype._superOrParentLayer = function() {
	    return this._parentOrContext();
	  };
	
	  Layer.prototype.animate = function(options) {
	    var animation, start;
	    start = options.start;
	    if (start == null) {
	      start = true;
	    }
	    delete options.start;
	    options.layer = this;
	    animation = new Animation(options);
	    if (start) {
	      animation.start();
	    }
	    return animation;
	  };
	
	  Layer.prototype.animations = function() {
	    return _.filter(this._context.animations, (function(_this) {
	      return function(animation) {
	        return animation.options.layer === _this;
	      };
	    })(this));
	  };
	
	  Layer.prototype.animatingProperties = function() {
	    var animation, i, j, len, len1, properties, propertyName, ref, ref1;
	    properties = {};
	    ref = this.animations();
	    for (i = 0, len = ref.length; i < len; i++) {
	      animation = ref[i];
	      ref1 = animation.animatingProperties();
	      for (j = 0, len1 = ref1.length; j < len1; j++) {
	        propertyName = ref1[j];
	        properties[propertyName] = animation;
	      }
	    }
	    return properties;
	  };
	
	  Layer.define("isAnimating", {
	    enumerable: false,
	    exportable: false,
	    get: function() {
	      return this.animations().length !== 0;
	    }
	  });
	
	  Layer.prototype.animateStop = function() {
	    var ref;
	    _.invoke(this.animations(), "stop");
	    return (ref = this._draggable) != null ? ref.animateStop() : void 0;
	  };
	
	  Layer.prototype.bringToFront = function() {
	    return this.index = _.max(_.union([0], this.siblingLayers.map(function(layer) {
	      return layer.index;
	    }))) + 1;
	  };
	
	  Layer.prototype.sendToBack = function() {
	    return this.index = _.min(_.union([0], this.siblingLayers.map(function(layer) {
	      return layer.index;
	    }))) - 1;
	  };
	
	  Layer.prototype.placeBefore = function(layer) {
	    var i, l, len, ref;
	    if (indexOf.call(this.siblingLayers, layer) < 0) {
	      return;
	    }
	    ref = this.siblingLayers;
	    for (i = 0, len = ref.length; i < len; i++) {
	      l = ref[i];
	      if (l.index <= layer.index) {
	        l.index -= 1;
	      }
	    }
	    return this.index = layer.index + 1;
	  };
	
	  Layer.prototype.placeBehind = function(layer) {
	    var i, l, len, ref;
	    if (indexOf.call(this.siblingLayers, layer) < 0) {
	      return;
	    }
	    ref = this.siblingLayers;
	    for (i = 0, len = ref.length; i < len; i++) {
	      l = ref[i];
	      if (l.index >= layer.index) {
	        l.index += 1;
	      }
	    }
	    return this.index = layer.index - 1;
	  };
	
	  Layer.define("states", {
	    enumerable: false,
	    exportable: false,
	    importable: false,
	    get: function() {
	      return this._states != null ? this._states : this._states = new LayerStates(this);
	    }
	  });
	
	  Layer.define("draggable", {
	    importable: false,
	    exportable: false,
	    get: function() {
	      return this._draggable != null ? this._draggable : this._draggable = new LayerDraggable(this);
	    },
	    set: function(value) {
	      if (_.isBoolean(value)) {
	        return this.draggable.enabled = value;
	      }
	    }
	  });
	
	  Layer.define("pinchable", {
	    importable: false,
	    exportable: false,
	    get: function() {
	      return this._pinchable != null ? this._pinchable : this._pinchable = new LayerPinchable(this);
	    },
	    set: function(value) {
	      if (_.isBoolean(value)) {
	        return this.pinchable.enabled = value;
	      }
	    }
	  });
	
	  Layer.define("scrollFrame", {
	    importable: false,
	    get: function() {
	      var frame;
	      return frame = {
	        x: this.scrollX,
	        y: this.scrollY,
	        width: this.width,
	        height: this.height
	      };
	    },
	    set: function(frame) {
	      this.scrollX = frame.x;
	      return this.scrollY = frame.y;
	    }
	  });
	
	  Layer.define("scrollX", {
	    get: function() {
	      return this._element.scrollLeft;
	    },
	    set: function(value) {
	      if (!_.isNumber(value)) {
	        layerValueTypeError("scrollX", value);
	      }
	      return this._element.scrollLeft = value;
	    }
	  });
	
	  Layer.define("scrollY", {
	    get: function() {
	      return this._element.scrollTop;
	    },
	    set: function(value) {
	      if (!_.isNumber(value)) {
	        layerValueTypeError("scrollY", value);
	      }
	      return this._element.scrollTop = value;
	    }
	  });
	
	  Layer.define("_domEventManager", {
	    get: function() {
	      return this._context.domEventManager.wrap(this._element);
	    }
	  });
	
	  Layer.prototype.emit = function() {
	    var args, eventName, ref, velocity;
	    eventName = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
	    if (this._cancelClickEventInDragSession) {
	      if (eventName === Events.Click || eventName === Events.Tap || eventName === Events.TapStart || eventName === Events.TapEnd || eventName === Events.LongPress || eventName === Events.LongPressStart || eventName === Events.LongPressEnd) {
	        if (this._parentDraggableLayer()) {
	          velocity = (ref = this._parentDraggableLayer()) != null ? ref.draggable.velocity : void 0;
	          if (Math.abs(velocity.x) > this._cancelClickEventInDragSessionVelocity) {
	            return;
	          }
	          if (Math.abs(velocity.y) > this._cancelClickEventInDragSessionVelocity) {
	            return;
	          }
	        }
	      }
	    }
	    return Layer.__super__.emit.apply(this, [eventName].concat(slice.call(args), [this]));
	  };
	
	  Layer.prototype.once = function(eventName, listener) {
	    Layer.__super__.once.call(this, eventName, listener);
	    return this._addListener(eventName, listener);
	  };
	
	  Layer.prototype.addListener = function(eventName, listener) {
	    if (!eventName) {
	      throw Error("Layer.on needs a valid event name");
	    }
	    if (!listener) {
	      throw Error("Layer.on needs an event listener");
	    }
	    Layer.__super__.addListener.call(this, eventName, listener);
	    return this._addListener(eventName, listener);
	  };
	
	  Layer.prototype.removeListener = function(eventName, listener) {
	    if (!eventName) {
	      throw Error("Layer.off needs a valid event name");
	    }
	    Layer.__super__.removeListener.call(this, eventName, listener);
	    return this._removeListener(eventName, listener);
	  };
	
	  Layer.prototype._addListener = function(eventName, listener) {
	    if (!_.startsWith(eventName, "change:")) {
	      this.ignoreEvents = false;
	    }
	    if (Utils.domValidEvent(this._element, eventName) || indexOf.call(_.values(Gestures), eventName) >= 0) {
	      if (!this._domEventManager.listeners(eventName).length) {
	        return this._domEventManager.addEventListener(eventName, (function(_this) {
	          return function(event) {
	            return _this.emit(eventName, event);
	          };
	        })(this));
	      }
	    }
	  };
	
	  Layer.prototype._removeListener = function(eventName, listener) {
	    if (!this.listeners(eventName).length) {
	      return this._domEventManager.removeAllListeners(eventName);
	    }
	  };
	
	  Layer.prototype._parentDraggableLayer = function() {
	    var i, layer, len, ref, ref1;
	    ref = this.ancestors();
	    for (i = 0, len = ref.length; i < len; i++) {
	      layer = ref[i];
	      if ((ref1 = layer._draggable) != null ? ref1.enabled : void 0) {
	        return layer;
	      }
	    }
	    return null;
	  };
	
	  Layer.prototype.on = Layer.prototype.addListener;
	
	  Layer.prototype.off = Layer.prototype.removeListener;
	
	  Layer.prototype.onClick = function(cb) {
	    return this.on(Events.Click, cb);
	  };
	
	  Layer.prototype.onDoubleClick = function(cb) {
	    return this.on(Events.DoubleClick, cb);
	  };
	
	  Layer.prototype.onScrollStart = function(cb) {
	    return this.on(Events.ScrollStart, cb);
	  };
	
	  Layer.prototype.onScroll = function(cb) {
	    return this.on(Events.Scroll, cb);
	  };
	
	  Layer.prototype.onScrollEnd = function(cb) {
	    return this.on(Events.ScrollEnd, cb);
	  };
	
	  Layer.prototype.onScrollAnimationDidStart = function(cb) {
	    return this.on(Events.ScrollAnimationDidStart, cb);
	  };
	
	  Layer.prototype.onScrollAnimationDidEnd = function(cb) {
	    return this.on(Events.ScrollAnimationDidEnd, cb);
	  };
	
	  Layer.prototype.onTouchStart = function(cb) {
	    return this.on(Events.TouchStart, cb);
	  };
	
	  Layer.prototype.onTouchEnd = function(cb) {
	    return this.on(Events.TouchEnd, cb);
	  };
	
	  Layer.prototype.onTouchMove = function(cb) {
	    return this.on(Events.TouchMove, cb);
	  };
	
	  Layer.prototype.onMouseUp = function(cb) {
	    return this.on(Events.MouseUp, cb);
	  };
	
	  Layer.prototype.onMouseDown = function(cb) {
	    return this.on(Events.MouseDown, cb);
	  };
	
	  Layer.prototype.onMouseOver = function(cb) {
	    return this.on(Events.MouseOver, cb);
	  };
	
	  Layer.prototype.onMouseOut = function(cb) {
	    return this.on(Events.MouseOut, cb);
	  };
	
	  Layer.prototype.onMouseMove = function(cb) {
	    return this.on(Events.MouseMove, cb);
	  };
	
	  Layer.prototype.onMouseWheel = function(cb) {
	    return this.on(Events.MouseWheel, cb);
	  };
	
	  Layer.prototype.onAnimationStart = function(cb) {
	    return this.on(Events.AnimationStart, cb);
	  };
	
	  Layer.prototype.onAnimationStop = function(cb) {
	    return this.on(Events.AnimationStop, cb);
	  };
	
	  Layer.prototype.onAnimationEnd = function(cb) {
	    return this.on(Events.AnimationEnd, cb);
	  };
	
	  Layer.prototype.onAnimationDidStart = function(cb) {
	    return this.on(Events.AnimationDidStart, cb);
	  };
	
	  Layer.prototype.onAnimationDidStop = function(cb) {
	    return this.on(Events.AnimationDidStop, cb);
	  };
	
	  Layer.prototype.onAnimationDidEnd = function(cb) {
	    return this.on(Events.AnimationDidEnd, cb);
	  };
	
	  Layer.prototype.onImageLoaded = function(cb) {
	    return this.on(Events.ImageLoaded, cb);
	  };
	
	  Layer.prototype.onImageLoadError = function(cb) {
	    return this.on(Events.ImageLoadError, cb);
	  };
	
	  Layer.prototype.onMove = function(cb) {
	    return this.on(Events.Move, cb);
	  };
	
	  Layer.prototype.onDragStart = function(cb) {
	    return this.on(Events.DragStart, cb);
	  };
	
	  Layer.prototype.onDragWillMove = function(cb) {
	    return this.on(Events.DragWillMove, cb);
	  };
	
	  Layer.prototype.onDragMove = function(cb) {
	    return this.on(Events.DragMove, cb);
	  };
	
	  Layer.prototype.onDragDidMove = function(cb) {
	    return this.on(Events.DragDidMove, cb);
	  };
	
	  Layer.prototype.onDrag = function(cb) {
	    return this.on(Events.Drag, cb);
	  };
	
	  Layer.prototype.onDragEnd = function(cb) {
	    return this.on(Events.DragEnd, cb);
	  };
	
	  Layer.prototype.onDragAnimationStart = function(cb) {
	    return this.on(Events.DragAnimationStart, cb);
	  };
	
	  Layer.prototype.onDragAnimationEnd = function(cb) {
	    return this.on(Events.DragAnimationEnd, cb);
	  };
	
	  Layer.prototype.onDirectionLockStart = function(cb) {
	    return this.on(Events.DirectionLockStart, cb);
	  };
	
	  Layer.prototype.onStateDidSwitch = function(cb) {
	    return this.on(Events.StateDidSwitch, cb);
	  };
	
	  Layer.prototype.onStateWillSwitch = function(cb) {
	    return this.on(Events.StateWillSwitch, cb);
	  };
	
	  Layer.prototype.onTap = function(cb) {
	    return this.on(Events.Tap, cb);
	  };
	
	  Layer.prototype.onTapStart = function(cb) {
	    return this.on(Events.TapStart, cb);
	  };
	
	  Layer.prototype.onTapEnd = function(cb) {
	    return this.on(Events.TapEnd, cb);
	  };
	
	  Layer.prototype.onDoubleTap = function(cb) {
	    return this.on(Events.DoubleTap, cb);
	  };
	
	  Layer.prototype.onForceTap = function(cb) {
	    return this.on(Events.ForceTap, cb);
	  };
	
	  Layer.prototype.onForceTapChange = function(cb) {
	    return this.on(Events.ForceTapChange, cb);
	  };
	
	  Layer.prototype.onForceTapStart = function(cb) {
	    return this.on(Events.ForceTapStart, cb);
	  };
	
	  Layer.prototype.onForceTapEnd = function(cb) {
	    return this.on(Events.ForceTapEnd, cb);
	  };
	
	  Layer.prototype.onLongPress = function(cb) {
	    return this.on(Events.LongPress, cb);
	  };
	
	  Layer.prototype.onLongPressStart = function(cb) {
	    return this.on(Events.LongPressStart, cb);
	  };
	
	  Layer.prototype.onLongPressEnd = function(cb) {
	    return this.on(Events.LongPressEnd, cb);
	  };
	
	  Layer.prototype.onSwipe = function(cb) {
	    return this.on(Events.Swipe, cb);
	  };
	
	  Layer.prototype.onSwipeStart = function(cb) {
	    return this.on(Events.SwipeStart, cb);
	  };
	
	  Layer.prototype.onSwipeEnd = function(cb) {
	    return this.on(Events.SwipeEnd, cb);
	  };
	
	  Layer.prototype.onSwipeUp = function(cb) {
	    return this.on(Events.SwipeUp, cb);
	  };
	
	  Layer.prototype.onSwipeUpStart = function(cb) {
	    return this.on(Events.SwipeUpStart, cb);
	  };
	
	  Layer.prototype.onSwipeUpEnd = function(cb) {
	    return this.on(Events.SwipeUpEnd, cb);
	  };
	
	  Layer.prototype.onSwipeDown = function(cb) {
	    return this.on(Events.SwipeDown, cb);
	  };
	
	  Layer.prototype.onSwipeDownStart = function(cb) {
	    return this.on(Events.SwipeDownStart, cb);
	  };
	
	  Layer.prototype.onSwipeDownEnd = function(cb) {
	    return this.on(Events.SwipeDownEnd, cb);
	  };
	
	  Layer.prototype.onSwipeLeft = function(cb) {
	    return this.on(Events.SwipeLeft, cb);
	  };
	
	  Layer.prototype.onSwipeLeftStart = function(cb) {
	    return this.on(Events.SwipeLeftStart, cb);
	  };
	
	  Layer.prototype.onSwipeLeftEnd = function(cb) {
	    return this.on(Events.SwipeLeftEnd, cb);
	  };
	
	  Layer.prototype.onSwipeRight = function(cb) {
	    return this.on(Events.SwipeRight, cb);
	  };
	
	  Layer.prototype.onSwipeRightStart = function(cb) {
	    return this.on(Events.SwipeRightStart, cb);
	  };
	
	  Layer.prototype.onSwipeRightEnd = function(cb) {
	    return this.on(Events.SwipeRightEnd, cb);
	  };
	
	  Layer.prototype.onPan = function(cb) {
	    return this.on(Events.Pan, cb);
	  };
	
	  Layer.prototype.onPanStart = function(cb) {
	    return this.on(Events.PanStart, cb);
	  };
	
	  Layer.prototype.onPanEnd = function(cb) {
	    return this.on(Events.PanEnd, cb);
	  };
	
	  Layer.prototype.onPanLeft = function(cb) {
	    return this.on(Events.PanLeft, cb);
	  };
	
	  Layer.prototype.onPanRight = function(cb) {
	    return this.on(Events.PanRight, cb);
	  };
	
	  Layer.prototype.onPanUp = function(cb) {
	    return this.on(Events.PanUp, cb);
	  };
	
	  Layer.prototype.onPanDown = function(cb) {
	    return this.on(Events.PanDown, cb);
	  };
	
	  Layer.prototype.onPinch = function(cb) {
	    return this.on(Events.Pinch, cb);
	  };
	
	  Layer.prototype.onPinchStart = function(cb) {
	    return this.on(Events.PinchStart, cb);
	  };
	
	  Layer.prototype.onPinchEnd = function(cb) {
	    return this.on(Events.PinchEnd, cb);
	  };
	
	  Layer.prototype.onScale = function(cb) {
	    return this.on(Events.Scale, cb);
	  };
	
	  Layer.prototype.onScaleStart = function(cb) {
	    return this.on(Events.ScaleStart, cb);
	  };
	
	  Layer.prototype.onScaleEnd = function(cb) {
	    return this.on(Events.ScaleEnd, cb);
	  };
	
	  Layer.prototype.onRotate = function(cb) {
	    return this.on(Events.Rotate, cb);
	  };
	
	  Layer.prototype.onRotateStart = function(cb) {
	    return this.on(Events.RotateStart, cb);
	  };
	
	  Layer.prototype.onRotateEnd = function(cb) {
	    return this.on(Events.RotateEnd, cb);
	  };
	
	  Layer.prototype.toInspect = function() {
	    var round;
	    round = function(value) {
	      if (parseInt(value) === value) {
	        return parseInt(value);
	      }
	      return Utils.round(value, 1);
	    };
	    if (this.name) {
	      return "<" + this.constructor.name + " id:" + this.id + " name:" + this.name + " (" + (round(this.x)) + "," + (round(this.y)) + ") " + (round(this.width)) + "x" + (round(this.height)) + ">";
	    }
	    return "<" + this.constructor.name + " id:" + this.id + " (" + (round(this.x)) + "," + (round(this.y)) + ") " + (round(this.width)) + "x" + (round(this.height)) + ">";
	  };
	
	  return Layer;
	
	})(BaseClass);


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var FramerCSS, Utils;
	
	Utils = __webpack_require__(4);
	
	FramerCSS = "body {\n	margin: 0;\n}\n\n.framerContext {\n	position: absolute;\n	left: 0;\n	top: 0;\n	right: 0;\n	bottom: 0;\n	pointer-events: none;\n}\n\n.framerLayer {\n	display: block;\n	position: absolute;\n	left: 0;\n	top: 0;\n	background-repeat: no-repeat;\n	background-position: center;\n	background-size: cover;\n	-webkit-overflow-scrolling: touch;\n	-webkit-box-sizing: border-box;\n	-webkit-user-select: none;\n}\n\n.framerLayer input,\n.framerLayer textarea,\n.framerLayer select,\n.framerLayer option,\n.framerLayer div[contenteditable=true]\n{\n	pointer-events: auto;\n	-webkit-user-select: auto;\n}\n\n.framerDebug {\n	padding: 6px;\n	color: #fff;\n	font: 10px/1em Monaco;\n}\n";
	
	Utils.domComplete(function() {
	  return Utils.insertCSS(FramerCSS);
	});


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	var Events, Gestures, Utils, _,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };
	
	Utils = __webpack_require__(4);
	
	_ = __webpack_require__(1)._;
	
	Gestures = __webpack_require__(16).Gestures;
	
	Events = {};
	
	Events.TouchStart = "touchstart";
	
	Events.TouchEnd = "touchend";
	
	Events.TouchMove = "touchmove";
	
	Events.MouseUp = "mouseup";
	
	Events.MouseDown = "mousedown";
	
	Events.MouseOver = "mouseover";
	
	Events.MouseOut = "mouseout";
	
	Events.MouseMove = "mousemove";
	
	Events.MouseWheel = "mousewheel";
	
	Events.DoubleClick = "dblclick";
	
	Events.MouseDoubleClick = "dblclick";
	
	if (!Utils.isTouch()) {
	  Events.TouchStart = Events.MouseDown;
	  Events.TouchEnd = Events.MouseUp;
	  Events.TouchMove = Events.MouseMove;
	}
	
	Events.Click = Events.TouchEnd;
	
	Events.AnimationStart = "start";
	
	Events.AnimationStop = "stop";
	
	Events.AnimationEnd = "end";
	
	Events.AnimationDidStart = "start";
	
	Events.AnimationDidStop = "stop";
	
	Events.AnimationDidEnd = "end";
	
	Events.Scroll = "scroll";
	
	Events.ImageLoaded = "load";
	
	Events.ImageLoadError = "error";
	
	_.extend(Events, Gestures);
	
	Events.touchEvent = function(event) {
	  var ref, ref1, touchEvent;
	  touchEvent = (ref = event.touches) != null ? ref[0] : void 0;
	  if (touchEvent == null) {
	    touchEvent = (ref1 = event.changedTouches) != null ? ref1[0] : void 0;
	  }
	  if (touchEvent == null) {
	    touchEvent = event;
	  }
	  return touchEvent;
	};
	
	Events.wrap = function(element) {
	  return Framer.CurrentContext.domEventManager.wrap(element);
	};
	
	Events.isGesture = function(eventName) {
	  return indexOf.call(Gestures, eventName) >= 0;
	};
	
	exports.Events = Events;


/***/ },
/* 16 */
/***/ function(module, exports) {

	var Gestures;
	
	Gestures = {};
	
	Gestures.Tap = "tap";
	
	Gestures.TapStart = "tapstart";
	
	Gestures.TapEnd = "tapend";
	
	Gestures.DoubleTap = "doubletap";
	
	Gestures.ForceTap = "forcetap";
	
	Gestures.ForceTapChange = "forcetapchange";
	
	Gestures.ForceTapStart = "forcetapstart";
	
	Gestures.ForceTapEnd = "forcetapend";
	
	Gestures.LongPress = "longpress";
	
	Gestures.LongPressStart = "longpressstart";
	
	Gestures.LongPressEnd = "longpressend";
	
	Gestures.Swipe = "swipe";
	
	Gestures.SwipeStart = "swipestart";
	
	Gestures.SwipeEnd = "swipeend";
	
	Gestures.SwipeUp = "swipeup";
	
	Gestures.SwipeUpStart = "swipeupstart";
	
	Gestures.SwipeUpEnd = "swipeupend";
	
	Gestures.SwipeDown = "swipedown";
	
	Gestures.SwipeDownStart = "swipedownstart";
	
	Gestures.SwipeDownEnd = "swipedownend";
	
	Gestures.SwipeLeft = "swipeleft";
	
	Gestures.SwipeLeftStart = "swipeleftstart";
	
	Gestures.SwipeLeftEnd = "swipeleftend";
	
	Gestures.SwipeRight = "swiperight";
	
	Gestures.SwipeRightStart = "swiperightstart";
	
	Gestures.SwipeRightEnd = "swiperightend";
	
	Gestures.EdgeSwipe = "edgeswipe";
	
	Gestures.EdgeSwipeStart = "edgeswipestart";
	
	Gestures.EdgeSwipeEnd = "edgeswipeend";
	
	Gestures.EdgeSwipeTop = "edgeswipetop";
	
	Gestures.EdgeSwipeTopStart = "edgeswipetopstart";
	
	Gestures.EdgeSwipeTopEnd = "edgeswipetopend";
	
	Gestures.EdgeSwipeRight = "edgeswiperight";
	
	Gestures.EdgeSwipeRightStart = "edgeswiperightstart";
	
	Gestures.EdgeSwipeRightEnd = "edgeswiperightend";
	
	Gestures.EdgeSwipeBottom = "edgeswipebottom";
	
	Gestures.EdgeSwipeBottomStart = "edgeswipebottomstart";
	
	Gestures.EdgeSwipeBottomEnd = "edgeswipebottomend";
	
	Gestures.EdgeSwipeLeft = "edgeswipeleft";
	
	Gestures.EdgeSwipeLeftStart = "edgeswipeleftstart";
	
	Gestures.EdgeSwipeLeftEnd = "edgeswipeleftend";
	
	Gestures.Pan = "pan";
	
	Gestures.PanStart = "panstart";
	
	Gestures.PanEnd = "panend";
	
	Gestures.PanLeft = "panleft";
	
	Gestures.PanRight = "panright";
	
	Gestures.PanUp = "panup";
	
	Gestures.PanDown = "pandown";
	
	Gestures.Pinch = "pinch";
	
	Gestures.PinchStart = "pinchstart";
	
	Gestures.PinchEnd = "pinchend";
	
	Gestures.Scale = "scale";
	
	Gestures.ScaleStart = "scalestart";
	
	Gestures.ScaleEnd = "scaleend";
	
	Gestures.Rotate = "rotate";
	
	Gestures.RotateStart = "rotatestart";
	
	Gestures.RotateEnd = "rotateend";
	
	exports.Gestures = Gestures;


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	var Originals, Utils, _;
	
	_ = __webpack_require__(1)._;
	
	Utils = __webpack_require__(4);
	
	Originals = {
	  Layer: {
	    backgroundColor: "rgba(123,123,123,0.5)",
	    color: "white",
	    shadowColor: "rgba(123,123,123,0.5)",
	    borderColor: "rgba(123,123,123,0.5)",
	    width: 200,
	    height: 200
	  },
	  Animation: {
	    curve: "ease",
	    time: 1
	  },
	  Context: {
	    perspective: 0,
	    perspectiveOriginX: 0.5,
	    perspectiveOriginY: 0.5,
	    parent: null,
	    name: null
	  },
	  DeviceComponent: {
	    fullScreen: false,
	    padding: 50,
	    deviceType: "apple-iphone-6s-silver",
	    deviceZoom: "fit",
	    contentZoom: 1,
	    orientation: "portrait",
	    keyboard: false,
	    animationOptions: {
	      time: .3,
	      curve: "ease-in-out"
	    }
	  },
	  LayerDraggable: {
	    momentum: true,
	    momentumOptions: {
	      friction: 2.1,
	      tolerance: 1
	    },
	    bounce: true,
	    bounceOptions: {
	      friction: 40,
	      tension: 200,
	      tolerance: 1
	    },
	    directionLock: false,
	    directionLockThreshold: {
	      x: 10,
	      y: 10
	    },
	    overdrag: true,
	    overdragScale: 0.5,
	    pixelAlign: true,
	    velocityTimeout: 100,
	    velocityScale: 890
	  },
	  FrictionSimulator: {
	    friction: 2,
	    tolerance: 1 / 10
	  },
	  SpringSimulator: {
	    tension: 500,
	    friction: 10,
	    tolerance: 1 / 10000
	  },
	  MomentumBounceSimulator: {
	    momentum: {
	      friction: 2,
	      tolerance: 10
	    },
	    bounce: {
	      tension: 500,
	      friction: 10,
	      tolerance: 1
	    }
	  }
	};
	
	exports.Defaults = {
	  getDefaults: function(className, options) {
	    var defaults, k, ref, v;
	    if (!Originals.hasOwnProperty(className)) {
	      return {};
	    }
	    if (!Framer.Defaults.hasOwnProperty(className)) {
	      return {};
	    }
	    defaults = _.clone(Originals[className]);
	    ref = Framer.Defaults[className];
	    for (k in ref) {
	      v = ref[k];
	      defaults[k] = _.isFunction(v) ? v() : v;
	    }
	    for (k in defaults) {
	      v = defaults[k];
	      if (!options.hasOwnProperty(k)) {
	        options[k] = v;
	      }
	    }
	    return options;
	  },
	  setup: function() {
	    var className, classValues, k, ref, v;
	    if (window.FramerDefaults) {
	      ref = window.FramerDefaults;
	      for (className in ref) {
	        classValues = ref[className];
	        for (k in classValues) {
	          v = classValues[k];
	          Originals[className][k] = v;
	        }
	      }
	    }
	    return exports.Defaults.reset();
	  },
	  reset: function() {
	    return window.Framer.Defaults = _.clone(Originals);
	  }
	};


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var AnimatorClassBezierPresets, AnimatorClasses, BaseClass, BezierCurveAnimator, Config, Defaults, LinearAnimator, SpringDHOAnimator, SpringRK4Animator, Utils, _, evaluateRelativeProperty, isRelativeProperty, numberRE, relativePropertyRE,
	  slice = [].slice,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };
	
	_ = __webpack_require__(1)._;
	
	Utils = __webpack_require__(4);
	
	Config = __webpack_require__(14).Config;
	
	Defaults = __webpack_require__(17).Defaults;
	
	BaseClass = __webpack_require__(6).BaseClass;
	
	LinearAnimator = __webpack_require__(19).LinearAnimator;
	
	BezierCurveAnimator = __webpack_require__(21).BezierCurveAnimator;
	
	SpringRK4Animator = __webpack_require__(22).SpringRK4Animator;
	
	SpringDHOAnimator = __webpack_require__(24).SpringDHOAnimator;
	
	AnimatorClasses = {
	  "linear": LinearAnimator,
	  "bezier-curve": BezierCurveAnimator,
	  "spring-rk4": SpringRK4Animator,
	  "spring-dho": SpringDHOAnimator
	};
	
	AnimatorClasses["spring"] = AnimatorClasses["spring-rk4"];
	
	AnimatorClasses["cubic-bezier"] = AnimatorClasses["bezier-curve"];
	
	AnimatorClassBezierPresets = ["ease", "ease-in", "ease-out", "ease-in-out"];
	
	numberRE = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/;
	
	relativePropertyRE = new RegExp('^(?:([+-])=|)(' + numberRE.source + ')([a-z%]*)$', 'i');
	
	isRelativeProperty = function(v) {
	  return _.isString(v) && relativePropertyRE.test(v);
	};
	
	evaluateRelativeProperty = function(target, k, v) {
	  var match, number, ref, rest, sign, unit;
	  ref = relativePropertyRE.exec(v), match = ref[0], sign = ref[1], number = ref[2], unit = ref[3], rest = 5 <= ref.length ? slice.call(ref, 4) : [];
	  if (sign) {
	    return target[k] + (sign + 1) * number;
	  }
	  return +number;
	};
	
	exports.Animation = (function(superClass) {
	  extend(Animation, superClass);
	
	  function Animation(options) {
	    if (options == null) {
	      options = {};
	    }
	    this._updateColorValue = bind(this._updateColorValue, this);
	    this._updateNumberValue = bind(this._updateNumberValue, this);
	    this._updateValues = bind(this._updateValues, this);
	    this._update = bind(this._update, this);
	    this._start = bind(this._start, this);
	    this.start = bind(this.start, this);
	    options = Defaults.getDefaults("Animation", options);
	    Animation.__super__.constructor.call(this, options);
	    this.options = _.clone(_.defaults(options, {
	      layer: null,
	      properties: {},
	      curve: "linear",
	      curveOptions: {},
	      time: 1,
	      repeat: 0,
	      delay: 0,
	      debug: false,
	      colorModel: "husl"
	    }));
	    if (options.origin) {
	      console.warn("Animation.origin: please use layer.originX and layer.originY");
	    }
	    this.options.properties = Animation.filterAnimatableProperties(this.options.properties);
	    this._parseAnimatorOptions();
	    this._originalState = this._currentState();
	    this._repeatCounter = this.options.repeat;
	  }
	
	  Animation.define("isAnimating", {
	    get: function() {
	      return indexOf.call(this.options.layer.context.animations, this) >= 0;
	    }
	  });
	
	  Animation.prototype.start = function() {
	    var AnimatorClass, animation, k, property, ref, ref1, ref2, v;
	    if (this.options.layer === null) {
	      console.error("Animation: missing layer");
	    }
	    AnimatorClass = this._animatorClass();
	    if (this.options.debug) {
	      console.log("Animation.start " + AnimatorClass.name, this.options.curveOptions);
	    }
	    this._animator = new AnimatorClass(this.options.curveOptions);
	    this._target = this.options.layer;
	    this._stateA = this._currentState();
	    this._stateB = {};
	    ref = this.options.properties;
	    for (k in ref) {
	      v = ref[k];
	      if (_.isFunction(v)) {
	        v = v(this.options.layer, k);
	      } else if (isRelativeProperty(v)) {
	        v = evaluateRelativeProperty(this._target, k, v);
	      }
	      if (this._stateA[k] !== v) {
	        this._stateB[k] = v;
	      }
	    }
	    if (_.keys(this._stateA).length === 0) {
	      console.warn("Animation: nothing to animate, no animatable properties");
	      return false;
	    }
	    if (_.isEqual(this._stateA, this._stateB)) {
	      console.warn("Animation: nothing to animate, all properties are equal to what it is now");
	      return false;
	    }
	    ref1 = this._target.animatingProperties();
	    for (property in ref1) {
	      animation = ref1[property];
	      if (this._stateA.hasOwnProperty(property)) {
	        animation.stop();
	      }
	      if (property === "x" && (this._stateA.hasOwnProperty("minX") || this._stateA.hasOwnProperty("midX") || this._stateA.hasOwnProperty("maxX"))) {
	        animation.stop();
	      }
	      if (property === "y" && (this._stateA.hasOwnProperty("minY") || this._stateA.hasOwnProperty("midY") || this._stateA.hasOwnProperty("maxY"))) {
	        animation.stop();
	      }
	    }
	    if (this.options.debug) {
	      console.log("Animation.start");
	      ref2 = this._stateB;
	      for (k in ref2) {
	        v = ref2[k];
	        console.log("\t" + k + ": " + this._stateA[k] + " -> " + this._stateB[k]);
	      }
	    }
	    if (this._repeatCounter > 0) {
	      this.once("end", (function(_this) {
	        return function() {
	          var ref3;
	          ref3 = _this._stateA;
	          for (k in ref3) {
	            v = ref3[k];
	            _this._target[k] = v;
	          }
	          _this._repeatCounter--;
	          return _this.start();
	        };
	      })(this));
	    }
	    if (this.options.delay) {
	      Utils.delay(this.options.delay, this._start);
	    } else {
	      this._start();
	    }
	    return true;
	  };
	
	  Animation.prototype.stop = function(emit) {
	    if (emit == null) {
	      emit = true;
	    }
	    this.options.layer.context.removeAnimation(this);
	    if (emit) {
	      this.emit("stop");
	    }
	    return Framer.Loop.off("update", this._update);
	  };
	
	  Animation.prototype.reverse = function() {
	    var animation, options;
	    options = _.clone(this.options);
	    options.properties = this._originalState;
	    animation = new Animation(options);
	    return animation;
	  };
	
	  Animation.prototype.copy = function() {
	    return new Animation(_.clone(this.options));
	  };
	
	  Animation.prototype.revert = function() {
	    return this.reverse();
	  };
	
	  Animation.prototype.inverse = function() {
	    return this.reverse();
	  };
	
	  Animation.prototype.invert = function() {
	    return this.reverse();
	  };
	
	  Animation.prototype.emit = function(event) {
	    Animation.__super__.emit.apply(this, arguments);
	    return this.options.layer.emit(event, this);
	  };
	
	  Animation.prototype.animatingProperties = function() {
	    return _.keys(this._stateA);
	  };
	
	  Animation.prototype._start = function() {
	    var k, ref, results, v;
	    this.options.layer.context.addAnimation(this);
	    this.emit("start");
	    Framer.Loop.on("update", this._update);
	    this._valueUpdaters = {};
	    ref = this._stateB;
	    results = [];
	    for (k in ref) {
	      v = ref[k];
	      if (Color.isColorObject(v) || Color.isColorObject(this._stateA[k])) {
	        results.push(this._valueUpdaters[k] = this._updateColorValue);
	      } else {
	        results.push(this._valueUpdaters[k] = this._updateNumberValue);
	      }
	    }
	    return results;
	  };
	
	  Animation.prototype._update = function(delta) {
	    var emit;
	    if (this._animator.finished()) {
	      this._updateValues(1);
	      this.stop(emit = false);
	      this.emit("end");
	      return this.emit("stop");
	    } else {
	      return this._updateValues(this._animator.next(delta));
	    }
	  };
	
	  Animation.prototype._updateValues = function(value) {
	    var k, ref, v;
	    ref = this._stateB;
	    for (k in ref) {
	      v = ref[k];
	      this._valueUpdaters[k](k, value);
	    }
	    return null;
	  };
	
	  Animation.prototype._updateNumberValue = function(key, value) {
	    return this._target[key] = Utils.mapRange(value, 0, 1, this._stateA[key], this._stateB[key]);
	  };
	
	  Animation.prototype._updateColorValue = function(key, value) {
	    return this._target[key] = Color.mix(this._stateA[key], this._stateB[key], value, false, this.options.colorModel);
	  };
	
	  Animation.prototype._currentState = function() {
	    return _.pick(this.options.layer, _.keys(this.options.properties));
	  };
	
	  Animation.prototype._animatorClass = function() {
	    var animatorClassName, parsedCurve;
	    parsedCurve = Utils.parseFunction(this.options.curve);
	    animatorClassName = parsedCurve.name.toLowerCase();
	    if (AnimatorClasses.hasOwnProperty(animatorClassName)) {
	      return AnimatorClasses[animatorClassName];
	    }
	    if (indexOf.call(AnimatorClassBezierPresets, animatorClassName) >= 0) {
	      return BezierCurveAnimator;
	    }
	    return LinearAnimator;
	  };
	
	  Animation.prototype._parseAnimatorOptions = function() {
	    var animatorClass, animatorClassName, base, base1, i, j, k, l, len, len1, parsedCurve, ref, ref1, results, value;
	    animatorClass = this._animatorClass();
	    parsedCurve = Utils.parseFunction(this.options.curve);
	    animatorClassName = parsedCurve.name.toLowerCase();
	    if (animatorClass === LinearAnimator || animatorClass === BezierCurveAnimator) {
	      if (_.isString(this.options.curveOptions) || _.isArray(this.options.curveOptions)) {
	        this.options.curveOptions = {
	          values: this.options.curveOptions
	        };
	      }
	      if ((base = this.options.curveOptions).time == null) {
	        base.time = this.options.time;
	      }
	    }
	    if ((animatorClass === BezierCurveAnimator) && indexOf.call(AnimatorClassBezierPresets, animatorClassName) >= 0) {
	      this.options.curveOptions.values = animatorClassName;
	      if ((base1 = this.options.curveOptions).time == null) {
	        base1.time = this.options.time;
	      }
	    }
	    if (parsedCurve.args.length) {
	      if (animatorClass === BezierCurveAnimator) {
	        this.options.curveOptions.values = parsedCurve.args.map(function(v) {
	          return parseFloat(v) || 0;
	        });
	      }
	      if (animatorClass === SpringRK4Animator) {
	        ref = ["tension", "friction", "velocity", "tolerance"];
	        for (i = j = 0, len = ref.length; j < len; i = ++j) {
	          k = ref[i];
	          value = parseFloat(parsedCurve.args[i]);
	          if (value) {
	            this.options.curveOptions[k] = value;
	          }
	        }
	      }
	      if (animatorClass === SpringDHOAnimator) {
	        ref1 = ["stiffness", "damping", "mass", "tolerance"];
	        results = [];
	        for (i = l = 0, len1 = ref1.length; l < len1; i = ++l) {
	          k = ref1[i];
	          value = parseFloat(parsedCurve.args[i]);
	          if (value) {
	            results.push(this.options.curveOptions[k] = value);
	          } else {
	            results.push(void 0);
	          }
	        }
	        return results;
	      }
	    }
	  };
	
	  Animation.filterAnimatableProperties = function(properties) {
	    var animatableProperties, k, v;
	    animatableProperties = {};
	    for (k in properties) {
	      v = properties[k];
	      if (_.isNumber(v) || _.isFunction(v) || isRelativeProperty(v) || Color.isColorObject(v) || v === null) {
	        animatableProperties[k] = v;
	      } else if (_.isString(v)) {
	        if (Color.isColorString(v)) {
	          animatableProperties[k] = new Color(v);
	        }
	      }
	    }
	    return animatableProperties;
	  };
	
	  Animation.prototype.toInspect = function() {
	    return "<" + this.constructor.name + " id:" + this.id + " isAnimating:" + this.isAnimating + " [" + (_.keys(this.options.properties)) + "]>";
	  };
	
	  Animation.prototype.onAnimationStart = function(cb) {
	    return this.on(Events.AnimationStart, cb);
	  };
	
	  Animation.prototype.onAnimationStop = function(cb) {
	    return this.on(Events.AnimationStop, cb);
	  };
	
	  Animation.prototype.onAnimationEnd = function(cb) {
	    return this.on(Events.AnimationEnd, cb);
	  };
	
	  Animation.prototype.onAnimationDidStart = function(cb) {
	    return this.on(Events.AnimationDidStart, cb);
	  };
	
	  Animation.prototype.onAnimationDidStop = function(cb) {
	    return this.on(Events.AnimationDidStop, cb);
	  };
	
	  Animation.prototype.onAnimationDidEnd = function(cb) {
	    return this.on(Events.AnimationDidEnd, cb);
	  };
	
	  return Animation;
	
	})(BaseClass);


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	var Animator, Utils,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	Utils = __webpack_require__(4);
	
	Animator = __webpack_require__(20).Animator;
	
	exports.LinearAnimator = (function(superClass) {
	  extend(LinearAnimator, superClass);
	
	  function LinearAnimator() {
	    return LinearAnimator.__super__.constructor.apply(this, arguments);
	  }
	
	  LinearAnimator.prototype.setup = function(options) {
	    this.options = _.defaults(options, {
	      time: 1,
	      precision: 1 / 1000
	    });
	    return this._time = 0;
	  };
	
	  LinearAnimator.prototype.next = function(delta) {
	    this._time += delta;
	    if (this.finished()) {
	      return 1;
	    }
	    return this._time / this.options.time;
	  };
	
	  LinearAnimator.prototype.finished = function() {
	    return this._time >= this.options.time - this.options.precision;
	  };
	
	  return LinearAnimator;
	
	})(Animator);


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	var Config, Utils;
	
	Utils = __webpack_require__(4);
	
	Config = __webpack_require__(14).Config;
	
	exports.Animator = (function() {
	  "The animator class is a very simple class that\n	- Takes a set of input values at setup({input values})\n	- Emits an output value for progress (0 -> 1) in value(progress)";
	  function Animator(options) {
	    if (options == null) {
	      options = {};
	    }
	    this.setup(options);
	  }
	
	  Animator.prototype.setup = function(options) {
	    throw Error("Not implemented");
	  };
	
	  Animator.prototype.next = function(delta) {
	    throw Error("Not implemented");
	  };
	
	  Animator.prototype.finished = function() {
	    throw Error("Not implemented");
	  };
	
	  return Animator;

	})();


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	var Animator, BezierCurveDefaults, UnitBezier, Utils, _,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	_ = __webpack_require__(1)._;
	
	Utils = __webpack_require__(4);
	
	Animator = __webpack_require__(20).Animator;
	
	BezierCurveDefaults = {
	  "linear": [0, 0, 1, 1],
	  "ease": [.25, .1, .25, 1],
	  "ease-in": [.42, 0, 1, 1],
	  "ease-out": [0, 0, .58, 1],
	  "ease-in-out": [.42, 0, .58, 1]
	};
	
	exports.BezierCurveAnimator = (function(superClass) {
	  extend(BezierCurveAnimator, superClass);
	
	  function BezierCurveAnimator() {
	    return BezierCurveAnimator.__super__.constructor.apply(this, arguments);
	  }
	
	  BezierCurveAnimator.prototype.setup = function(options) {
	    if (_.isString(options) && BezierCurveDefaults.hasOwnProperty(options.toLowerCase())) {
	      options = {
	        values: BezierCurveDefaults[options.toLowerCase()]
	      };
	    }
	    if (options.values && _.isString(options.values) && BezierCurveDefaults.hasOwnProperty(options.values.toLowerCase())) {
	      options = {
	        values: BezierCurveDefaults[options.values.toLowerCase()],
	        time: options.time
	      };
	    }
	    if (_.isArray(options) && options.length === 4) {
	      options = {
	        values: options
	      };
	    }
	    this.options = _.defaults(options, {
	      values: BezierCurveDefaults["ease-in-out"],
	      time: 1,
	      precision: 1 / 1000
	    });
	    return this._unitBezier = new UnitBezier(this.options.values[0], this.options.values[1], this.options.values[2], this.options.values[3], this._time = 0);
	  };
	
	  BezierCurveAnimator.prototype.next = function(delta) {
	    this._time += delta;
	    if (this.finished()) {
	      return 1;
	    }
	    return this._unitBezier.solve(this._time / this.options.time);
	  };
	
	  BezierCurveAnimator.prototype.finished = function() {
	    return this._time >= this.options.time - this.options.precision;
	  };
	
	  return BezierCurveAnimator;
	
	})(Animator);
	
	UnitBezier = (function() {
	  UnitBezier.prototype.epsilon = 1e-6;
	
	  function UnitBezier(p1x, p1y, p2x, p2y) {
	    this.cx = 3.0 * p1x;
	    this.bx = 3.0 * (p2x - p1x) - this.cx;
	    this.ax = 1.0 - this.cx - this.bx;
	    this.cy = 3.0 * p1y;
	    this.by = 3.0 * (p2y - p1y) - this.cy;
	    this.ay = 1.0 - this.cy - this.by;
	  }
	
	  UnitBezier.prototype.sampleCurveX = function(t) {
	    return ((this.ax * t + this.bx) * t + this.cx) * t;
	  };
	
	  UnitBezier.prototype.sampleCurveY = function(t) {
	    return ((this.ay * t + this.by) * t + this.cy) * t;
	  };
	
	  UnitBezier.prototype.sampleCurveDerivativeX = function(t) {
	    return (3.0 * this.ax * t + 2.0 * this.bx) * t + this.cx;
	  };
	
	  UnitBezier.prototype.solveCurveX = function(x) {
	    var d2, i, t0, t1, t2, x2;
	    t2 = x;
	    i = 0;
	    while (i < 8) {
	      x2 = this.sampleCurveX(t2) - x;
	      if (Math.abs(x2) < this.epsilon) {
	        return t2;
	      }
	      d2 = this.sampleCurveDerivativeX(t2);
	      if (Math.abs(d2) < this.epsilon) {
	        break;
	      }
	      t2 = t2 - x2 / d2;
	      i++;
	    }
	    t0 = 0.0;
	    t1 = 1.0;
	    t2 = x;
	    if (t2 < t0) {
	      return t0;
	    }
	    if (t2 > t1) {
	      return t1;
	    }
	    while (t0 < t1) {
	      x2 = this.sampleCurveX(t2);
	      if (Math.abs(x2 - x) < this.epsilon) {
	        return t2;
	      }
	      if (x > x2) {
	        t0 = t2;
	      } else {
	        t1 = t2;
	      }
	      t2 = (t1 - t0) * .5 + t0;
	    }
	    return t2;
	  };
	
	  UnitBezier.prototype.solve = function(x) {
	    return this.sampleCurveY(this.solveCurveX(x));
	  };
	
	  return UnitBezier;

	})();


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	var Animator, Integrator, Utils,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	Utils = __webpack_require__(4);
	
	Animator = __webpack_require__(20).Animator;
	
	Integrator = __webpack_require__(23).Integrator;
	
	exports.SpringRK4Animator = (function(superClass) {
	  extend(SpringRK4Animator, superClass);
	
	  function SpringRK4Animator() {
	    this.finished = bind(this.finished, this);
	    return SpringRK4Animator.__super__.constructor.apply(this, arguments);
	  }
	
	  SpringRK4Animator.prototype.setup = function(options) {
	    this.options = _.defaults(options, {
	      tension: 250,
	      friction: 25,
	      velocity: 0,
	      tolerance: 1 / 10000,
	      time: null
	    });
	    this._time = 0;
	    this._value = 0;
	    this._velocity = this.options.velocity;
	    this._stopSpring = false;
	    return this._integrator = new Integrator((function(_this) {
	      return function(state) {
	        return -_this.options.tension * state.x - _this.options.friction * state.v;
	      };
	    })(this));
	  };
	
	  SpringRK4Animator.prototype.next = function(delta) {
	    var finalVelocity, net1DVelocity, netFloat, netValueIsLow, netVelocityIsLow, stateAfter, stateBefore;
	    if (this.finished()) {
	      return 1;
	    }
	    this._time += delta;
	    stateBefore = {};
	    stateAfter = {};
	    stateBefore.x = this._value - 1;
	    stateBefore.v = this._velocity;
	    stateAfter = this._integrator.integrateState(stateBefore, delta);
	    this._value = 1 + stateAfter.x;
	    finalVelocity = stateAfter.v;
	    netFloat = stateAfter.x;
	    net1DVelocity = stateAfter.v;
	    netValueIsLow = Math.abs(netFloat) < this.options.tolerance;
	    netVelocityIsLow = Math.abs(net1DVelocity) < this.options.tolerance;
	    this._stopSpring = netValueIsLow && netVelocityIsLow;
	    this._velocity = finalVelocity;
	    return this._value;
	  };
	
	  SpringRK4Animator.prototype.finished = function() {
	    return this._stopSpring;
	  };
	
	  return SpringRK4Animator;
	
	})(Animator);


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	var Config, Utils;
	
	Utils = __webpack_require__(4);
	
	Config = __webpack_require__(14).Config;
	
	exports.Integrator = (function() {
	  "Usage:\n	- Instantiate with a function that takes (state) -> acceleration\n	- Call integrateState with state={x, v} and delta";
	  function Integrator(_accelerationForState) {
	    this._accelerationForState = _accelerationForState;
	    if (!_.isFunction(this._accelerationForState)) {
	      console.warn("Integrator: an integrator must be constructed with an acceleration function");
	      this._accelerationForState = function() {
	        return 0;
	      };
	    }
	  }
	
	  Integrator.prototype.integrateState = function(state, dt) {
	    var a, b, c, d, dvdt, dxdt;
	    a = this._evaluateState(state);
	    b = this._evaluateStateWithDerivative(state, dt * 0.5, a);
	    c = this._evaluateStateWithDerivative(state, dt * 0.5, b);
	    d = this._evaluateStateWithDerivative(state, dt, c);
	    dxdt = 1.0 / 6.0 * (a.dx + 2.0 * (b.dx + c.dx) + d.dx);
	    dvdt = 1.0 / 6.0 * (a.dv + 2.0 * (b.dv + c.dv) + d.dv);
	    state.x = state.x + dxdt * dt;
	    state.v = state.v + dvdt * dt;
	    return state;
	  };
	
	  Integrator.prototype._evaluateState = function(initialState) {
	    var output;
	    output = {};
	    output.dx = initialState.v;
	    output.dv = this._accelerationForState(initialState);
	    return output;
	  };
	
	  Integrator.prototype._evaluateStateWithDerivative = function(initialState, dt, derivative) {
	    var output, state;
	    state = {};
	    state.x = initialState.x + derivative.dx * dt;
	    state.v = initialState.v + derivative.dv * dt;
	    output = {};
	    output.dx = state.v;
	    output.dv = this._accelerationForState(state);
	    return output;
	  };
	
	  return Integrator;

	})();


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	var Animator, Utils,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	Utils = __webpack_require__(4);
	
	Animator = __webpack_require__(20).Animator;
	
	exports.SpringDHOAnimator = (function(superClass) {
	  extend(SpringDHOAnimator, superClass);
	
	  function SpringDHOAnimator() {
	    this.finished = bind(this.finished, this);
	    return SpringDHOAnimator.__super__.constructor.apply(this, arguments);
	  }
	
	  SpringDHOAnimator.prototype.setup = function(options) {
	    this.options = _.defaults(options, {
	      velocity: 0,
	      tolerance: 1 / 10000,
	      stiffness: 50,
	      damping: 2,
	      mass: 0.2,
	      time: null
	    });
	    console.log("SpringDHOAnimator.options", this.options, options);
	    this._time = 0;
	    this._value = 0;
	    return this._velocity = this.options.velocity;
	  };
	
	  SpringDHOAnimator.prototype.next = function(delta) {
	    var F_damper, F_spring, b, k;
	    if (this.finished()) {
	      return 1;
	    }
	    this._time += delta;
	    k = 0 - this.options.stiffness;
	    b = 0 - this.options.damping;
	    F_spring = k * (this._value - 1);
	    F_damper = b * this._velocity;
	    this._velocity += ((F_spring + F_damper) / this.options.mass) * delta;
	    this._value += this._velocity * delta;
	    return this._value;
	  };
	
	  SpringDHOAnimator.prototype.finished = function() {
	    return this._time > 0 && Math.abs(this._velocity) < this.options.tolerance;
	  };
	
	  return SpringDHOAnimator;
	
	})(Animator);


/***/ },
/* 25 */
/***/ function(module, exports) {

	var _Force2DProperties, _WebkitProperties, filterFormat;
	
	filterFormat = function(value, unit) {
	  return "" + (Utils.round(value, 2)) + unit;
	};
	
	_WebkitProperties = [["blur", "blur", 0, "px"], ["brightness", "brightness", 100, "%"], ["saturate", "saturate", 100, "%"], ["hue-rotate", "hueRotate", 0, "deg"], ["contrast", "contrast", 100, "%"], ["invert", "invert", 0, "%"], ["grayscale", "grayscale", 0, "%"], ["sepia", "sepia", 0, "%"]];
	
	_Force2DProperties = {
	  "z": 0,
	  "scaleX": 1,
	  "scaleY": 1,
	  "scaleZ": 1,
	  "skewX": 0,
	  "skewY": 0,
	  "rotationX": 0,
	  "rotationY": 0
	};
	
	exports.LayerStyle = {
	  width: function(layer) {
	    return layer._properties.width + "px";
	  },
	  height: function(layer) {
	    return layer._properties.height + "px";
	  },
	  display: function(layer) {
	    if (layer._properties.visible === true) {
	      return "block";
	    }
	    return "none";
	  },
	  opacity: function(layer) {
	    return layer._properties.opacity;
	  },
	  webkitTransformStyle: function(layer) {
	    if (layer._properties.flat) {
	      return "flat";
	    } else {
	      return "preserve-3d";
	    }
	  },
	  webkitBackfaceVisibility: function(layer) {
	    if (layer._properties.backfaceVisible) {
	      return "visible";
	    } else {
	      return "hidden";
	    }
	  },
	  overflow: function(layer) {
	    if (layer._properties.scrollHorizontal === true || layer._properties.scrollVertical === true) {
	      return "auto";
	    }
	    if (layer._properties.clip === true) {
	      return "hidden";
	    }
	    return "visible";
	  },
	  overflowX: function(layer) {
	    if (layer._properties.scrollHorizontal === true) {
	      return "scroll";
	    }
	    if (layer._properties.clip === true) {
	      return "hidden";
	    }
	    return "visible";
	  },
	  overflowY: function(layer) {
	    if (layer._properties.scrollVertical === true) {
	      return "scroll";
	    }
	    if (layer._properties.clip === true) {
	      return "hidden";
	    }
	    return "visible";
	  },
	  zIndex: function(layer) {
	    return layer._properties.index;
	  },
	  webkitFilter: function(layer) {
	    var css, cssName, fallback, i, layerName, len, ref, unit;
	    css = [];
	    for (i = 0, len = _WebkitProperties.length; i < len; i++) {
	      ref = _WebkitProperties[i], cssName = ref[0], layerName = ref[1], fallback = ref[2], unit = ref[3];
	      if (layer._properties.hasOwnProperty(layerName) && layer[layerName] !== fallback) {
	        css.push(cssName + "(" + (filterFormat(layer[layerName], unit)) + ")");
	      }
	    }
	    return css.join(" ");
	  },
	  webkitTransform: function(layer) {
	    if (layer._prefer2d || layer._properties.force2d) {
	      return exports.LayerStyle.webkitTransformForce2d(layer);
	    }
	    return "translate3d( " + layer._properties.x + "px, " + layer._properties.y + "px, " + layer._properties.z + "px) scale3d( " + (layer._properties.scaleX * layer._properties.scale) + ", " + (layer._properties.scaleY * layer._properties.scale) + ", " + layer._properties.scaleZ + ") skew(" + layer._properties.skew + "deg," + layer._properties.skew + "deg) skewX(" + layer._properties.skewX + "deg) skewY(" + layer._properties.skewY + "deg) translateZ(" + layer._properties.originZ + "px) rotateX(" + layer._properties.rotationX + "deg) rotateY(" + layer._properties.rotationY + "deg) rotateZ(" + layer._properties.rotationZ + "deg) translateZ(" + (-layer._properties.originZ) + "px)";
	  },
	  webkitTransformForce2d: function(layer) {
	    var css, p, v;
	    css = [];
	    for (p in _Force2DProperties) {
	      v = _Force2DProperties[p];
	      if (layer._properties[p] !== v) {
	        console.warn("Layer property '" + p + "'' will be ignored with force2d enabled");
	      }
	    }
	    css.push("translate(" + layer._properties.x + "px," + layer._properties.y + "px)");
	    css.push("scale(" + layer._properties.scale + ")");
	    css.push("skew(" + layer._properties.skew + "deg," + layer._properties.skew + "deg)");
	    css.push("rotate(" + layer._properties.rotationZ + "deg)");
	    return css.join(" ");
	  },
	  webkitTransformOrigin: function(layer) {
	    return (layer._properties.originX * 100) + "% " + (layer._properties.originY * 100) + "%";
	  },
	  webkitPerspective: function(layer) {
	    return "" + layer._properties.perspective;
	  },
	  webkitPerspectiveOrigin: function(layer) {
	    return (layer._properties.perspectiveOriginX * 100) + "% " + (layer._properties.perspectiveOriginY * 100) + "%";
	  },
	  pointerEvents: function(layer) {
	    if (layer._properties.ignoreEvents) {
	      return "none";
	    } else {
	      return "auto";
	    }
	  },
	  boxShadow: function(layer) {
	    var props;
	    props = layer._properties;
	    if (!props.shadowColor) {
	      return "";
	    } else if (props.shadowX === 0 && props.shadowY === 0 && props.shadowBlur === 0 && props.shadowSpread === 0) {
	      return "";
	    }
	    return layer._properties.shadowX + "px " + layer._properties.shadowY + "px " + layer._properties.shadowBlur + "px " + layer._properties.shadowSpread + "px " + layer._properties.shadowColor;
	  },
	  backgroundColor: function(layer) {
	    return layer._properties.backgroundColor;
	  },
	  color: function(layer) {
	    return layer._properties.color;
	  },
	  borderRadius: function(layer) {
	    if (!_.isNumber(layer._properties.borderRadius)) {
	      return layer._properties.borderRadius;
	    }
	    return layer._properties.borderRadius + "px";
	  },
	  border: function(layer) {
	    return layer._properties.borderWidth + "px solid " + layer._properties.borderColor;
	  }
	};


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	var BaseClass, Defaults, Events, LayerStatesIgnoredKeys, _,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
	  slice = [].slice;
	
	_ = __webpack_require__(1)._;
	
	Events = __webpack_require__(15).Events;
	
	BaseClass = __webpack_require__(6).BaseClass;
	
	Defaults = __webpack_require__(17).Defaults;
	
	LayerStatesIgnoredKeys = ["ignoreEvents"];
	
	Events.StateWillSwitch = "willSwitch";
	
	Events.StateDidSwitch = "didSwitch";
	
	exports.LayerStates = (function(superClass) {
	  extend(LayerStates, superClass);
	
	  function LayerStates(layer) {
	    this.layer = layer;
	    this._states = {};
	    this._orderedStates = [];
	    this.animationOptions = {};
	    this.add("default", this.layer.props);
	    this._currentState = "default";
	    this._previousStates = [];
	    LayerStates.__super__.constructor.apply(this, arguments);
	  }
	
	  LayerStates.prototype.add = function(stateName, properties) {
	    var error, k, v;
	    if (_.isObject(stateName)) {
	      for (k in stateName) {
	        v = stateName[k];
	        this.add(k, v);
	      }
	      return;
	    }
	    error = function() {
	      throw Error("Usage example: layer.states.add(\"someName\", {x:500})");
	    };
	    if (!_.isString(stateName)) {
	      error();
	    }
	    if (!_.isObject(properties)) {
	      error();
	    }
	    this._orderedStates.push(stateName);
	    return this._states[stateName] = LayerStates.filterStateProperties(properties);
	  };
	
	  LayerStates.prototype.remove = function(stateName) {
	    if (!this._states.hasOwnProperty(stateName)) {
	      return;
	    }
	    delete this._states[stateName];
	    return this._orderedStates = _.without(this._orderedStates, stateName);
	  };
	
	  LayerStates.prototype["switch"] = function(stateName, animationOptions, instant) {
	    var animatablePropertyKeys, animatingKeys, k, properties, propertyName, ref, ref1, v, value;
	    if (instant == null) {
	      instant = false;
	    }
	    if (!this._states.hasOwnProperty(stateName)) {
	      throw Error("No such state: '" + stateName + "'");
	    }
	    this.emit(Events.StateWillSwitch, this._currentState, stateName, this);
	    this._previousStates.push(this._currentState);
	    this._currentState = stateName;
	    properties = {};
	    animatingKeys = this.animatingKeys();
	    ref = this._states[stateName];
	    for (propertyName in ref) {
	      value = ref[propertyName];
	      if (indexOf.call(LayerStatesIgnoredKeys, propertyName) >= 0) {
	        continue;
	      }
	      if (indexOf.call(animatingKeys, propertyName) < 0) {
	        continue;
	      }
	      if (_.isFunction(value)) {
	        value = value.call(this.layer, this.layer, propertyName, stateName);
	      }
	      properties[propertyName] = value;
	    }
	    animatablePropertyKeys = [];
	    for (k in properties) {
	      v = properties[k];
	      if (_.isNumber(v)) {
	        animatablePropertyKeys.push(k);
	      } else if (Color.isColorObject(v)) {
	        animatablePropertyKeys.push(k);
	      } else if (v === null) {
	        animatablePropertyKeys.push(k);
	      }
	    }
	    if (animatablePropertyKeys.length === 0) {
	      instant = true;
	    }
	    if (instant === true) {
	      this.layer.props = properties;
	      return this.emit(Events.StateDidSwitch, _.last(this._previousStates), this._currentState, this);
	    } else {
	      if (animationOptions == null) {
	        animationOptions = this.animationOptions;
	      }
	      animationOptions.properties = properties;
	      if ((ref1 = this._animation) != null) {
	        ref1.stop();
	      }
	      this._animation = this.layer.animate(animationOptions);
	      return this._animation.once("stop", (function(_this) {
	        return function() {
	          for (k in properties) {
	            v = properties[k];
	            if (!(_.isNumber(v) || Color.isColorObject(v))) {
	              _this.layer[k] = v;
	            }
	          }
	          if (_.last(_this._previousStates) !== stateName) {
	            return _this.emit(Events.StateDidSwitch, _.last(_this._previousStates), _this._currentState, _this);
	          }
	        };
	      })(this));
	    }
	  };
	
	  LayerStates.prototype.switchInstant = function(stateName) {
	    return this["switch"](stateName, null, true);
	  };
	
	  LayerStates.define("state", {
	    get: function() {
	      return this._currentState;
	    }
	  });
	
	  LayerStates.define("current", {
	    get: function() {
	      return this._currentState;
	    }
	  });
	
	  LayerStates.define("all", {
	    get: function() {
	      return _.clone(this._orderedStates);
	    }
	  });
	
	  LayerStates.prototype.states = function() {
	    return _.clone(this._orderedStates);
	  };
	
	  LayerStates.prototype.animatingKeys = function() {
	    var keys, ref, state, stateName;
	    keys = [];
	    ref = this._states;
	    for (stateName in ref) {
	      state = ref[stateName];
	      keys = _.union(keys, _.keys(state));
	    }
	    return keys;
	  };
	
	  LayerStates.prototype.previous = function(states, animationOptions) {
	    if (states == null) {
	      states = this.states();
	    }
	    return this["switch"](Utils.arrayPrev(states, this._currentState), animationOptions);
	  };
	
	  LayerStates.prototype.next = function() {
	    var states;
	    states = Utils.arrayFromArguments(arguments);
	    if (!states.length) {
	      states = this.states();
	    }
	    return this["switch"](Utils.arrayNext(states, this._currentState));
	  };
	
	  LayerStates.prototype.last = function(animationOptions) {
	    return this["switch"](_.last(this._previousStates), animationOptions);
	  };
	
	  LayerStates.prototype.emit = function() {
	    var args, ref;
	    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
	    LayerStates.__super__.emit.apply(this, arguments);
	    return (ref = this.layer).emit.apply(ref, args);
	  };
	
	  LayerStates.filterStateProperties = function(properties) {
	    var k, stateProperties, v;
	    stateProperties = {};
	    for (k in properties) {
	      v = properties[k];
	      if (_.isString(v) && _.endsWith(k.toLowerCase(), "color") && Color.isColorString(v)) {
	        stateProperties[k] = new Color(v);
	      } else if (_.isNumber(v) || _.isFunction(v) || _.isBoolean(v) || _.isString(v) || Color.isColorObject(v) || v === null) {
	        stateProperties[k] = v;
	      }
	    }
	    return stateProperties;
	  };
	
	  return LayerStates;
	
	})(BaseClass);


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	var BaseClass, Defaults, EventBuffer, Events, Gestures, Simulation, Utils, _,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	_ = __webpack_require__(1)._;
	
	Utils = __webpack_require__(4);
	
	BaseClass = __webpack_require__(6).BaseClass;
	
	Events = __webpack_require__(15).Events;
	
	Simulation = __webpack_require__(28).Simulation;
	
	Defaults = __webpack_require__(17).Defaults;
	
	EventBuffer = __webpack_require__(33).EventBuffer;
	
	Gestures = __webpack_require__(16).Gestures;
	
	Events.Move = "move";
	
	Events.DragStart = "dragstart";
	
	Events.DragWillMove = "dragwillmove";
	
	Events.DragMove = "dragmove";
	
	Events.DragDidMove = "dragmove";
	
	Events.Drag = "dragmove";
	
	Events.DragEnd = "dragend";
	
	Events.DragAnimationStart = "draganimationstart";
	
	Events.DragAnimationEnd = "draganimationend";
	
	Events.DirectionLockStart = "directionlockstart";
	
	Events.DragSessionStart = "dragsessionstart";
	
	Events.DragSessionMove = "dragsessionmove";
	
	Events.DragSessionEnd = "dragsessionend";
	
	Events.DragAnimationDidStart = Events.DragAnimationStart;
	
	Events.DragAnimationDidEnd = Events.DragAnimationEnd;
	
	Events.DirectionLockDidStart = Events.DirectionLockStart;
	
	"\n┌──────┐                   │\n│      │\n│      │  ───────────────▶ │ ◀────▶\n│      │\n└──────┘                   │\n\n════════  ═════════════════ ═══════\n\n  Drag         Momentum      Bounce\n";
	
	exports.LayerDraggable = (function(superClass) {
	  extend(LayerDraggable, superClass);
	
	  LayerDraggable.define("speedX", LayerDraggable.simpleProperty("speedX", 1));
	
	  LayerDraggable.define("speedY", LayerDraggable.simpleProperty("speedY", 1));
	
	  LayerDraggable.define("horizontal", LayerDraggable.simpleProperty("horizontal", true));
	
	  LayerDraggable.define("vertical", LayerDraggable.simpleProperty("vertical", true));
	
	  LayerDraggable.define("momentumVelocityMultiplier", LayerDraggable.simpleProperty("momentumVelocityMultiplier", 800));
	
	  LayerDraggable.define("directionLock", LayerDraggable.simpleProperty("directionLock", true));
	
	  LayerDraggable.define("directionLockThreshold", LayerDraggable.simpleProperty("directionLockThreshold", {
	    x: 10,
	    y: 10
	  }));
	
	  LayerDraggable.define("propagateEvents", LayerDraggable.simpleProperty("propagateEvents", true));
	
	  LayerDraggable.define("constraints", {
	    get: function() {
	      return this._constraints;
	    },
	    set: function(value) {
	      if (value && _.isObject(value)) {
	        value = _.pick(value, ["x", "y", "width", "height"]);
	        value = _.defaults(value, {
	          x: 0,
	          y: 0,
	          width: 0,
	          height: 0
	        });
	        this._constraints = value;
	      } else {
	        this._constraints = {
	          x: 0,
	          y: 0,
	          width: 0,
	          height: 0
	        };
	      }
	      if (this._constraints) {
	        return this._updateSimulationConstraints(this._constraints);
	      }
	    }
	  });
	
	  LayerDraggable.define("isDragging", {
	    get: function() {
	      return this._isDragging || false;
	    }
	  });
	
	  LayerDraggable.define("isAnimating", {
	    get: function() {
	      return this._isAnimating || false;
	    }
	  });
	
	  LayerDraggable.define("isMoving", {
	    get: function() {
	      return this._isMoving || false;
	    }
	  });
	
	  LayerDraggable.define("layerStartPoint", {
	    get: function() {
	      return this._layerStartPoint || this.layer.point;
	    }
	  });
	
	  LayerDraggable.define("cursorStartPoint", {
	    get: function() {
	      return this._cursorStartPoint || {
	        x: 0,
	        y: 0
	      };
	    }
	  });
	
	  LayerDraggable.define("layerCursorOffset", {
	    get: function() {
	      return this._layerCursorOffset || {
	        x: 0,
	        y: 0
	      };
	    }
	  });
	
	  LayerDraggable.define("offset", {
	    get: function() {
	      var offset;
	      if (!this._correctedLayerStartPoint) {
	        return {
	          x: 0,
	          y: 0
	        };
	      }
	      return offset = {
	        x: this.layer.x - this._correctedLayerStartPoint.x,
	        y: this.layer.y - this._correctedLayerStartPoint.y
	      };
	    }
	  });
	
	  function LayerDraggable(layer) {
	    var options;
	    this.layer = layer;
	    this._stopSimulation = bind(this._stopSimulation, this);
	    this._onSimulationStop = bind(this._onSimulationStop, this);
	    this._onSimulationStep = bind(this._onSimulationStep, this);
	    this._touchEnd = bind(this._touchEnd, this);
	    this._touchMove = bind(this._touchMove, this);
	    this._touchStart = bind(this._touchStart, this);
	    this._updateLayerPosition = bind(this._updateLayerPosition, this);
	    this.touchStart = bind(this.touchStart, this);
	    options = Defaults.getDefaults("LayerDraggable", {});
	    LayerDraggable.__super__.constructor.call(this, options);
	    _.extend(this, options);
	    this.enabled = true;
	    this._eventBuffer = new EventBuffer;
	    this._constraints = null;
	    this._ignoreUpdateLayerPosition = true;
	    this.attach();
	  }
	
	  LayerDraggable.prototype.attach = function() {
	    this.layer.on(Gestures.TapStart, this.touchStart);
	    this.layer.on("change:x", this._updateLayerPosition);
	    return this.layer.on("change:y", this._updateLayerPosition);
	  };
	
	  LayerDraggable.prototype.remove = function() {
	    this.layer.off(Gestures.TapStart, this.touchStart);
	    this.layer.off(Gestures.Pan, this._touchMove);
	    return this.layer.off(Gestures.PanEnd, this._touchEnd);
	  };
	
	  LayerDraggable.prototype.updatePosition = function(point) {
	    return point;
	  };
	
	  LayerDraggable.prototype.touchStart = function(event) {
	    return this._touchStart(event);
	  };
	
	  LayerDraggable.prototype._updateLayerPosition = function() {
	    if (this._ignoreUpdateLayerPosition === true) {
	      return;
	    }
	    return this._point = this.layer.point;
	  };
	
	  LayerDraggable.prototype._touchStart = function(event) {
	    var animation, i, len, properties, ref, touchEvent;
	    Events.wrap(document).addEventListener(Gestures.Pan, this._touchMove);
	    Events.wrap(document).addEventListener(Gestures.TapEnd, this._touchEnd);
	    this._isMoving = this.isAnimating;
	    ref = this.layer.animations();
	    for (i = 0, len = ref.length; i < len; i++) {
	      animation = ref[i];
	      properties = animation.options.properties;
	      if (properties.hasOwnProperty("x") || properties.hasOwnProperty("y")) {
	        animation.stop();
	      }
	    }
	    this._stopSimulation();
	    this._resetdirectionLock();
	    event.preventDefault();
	    if (this.propagateEvents === false) {
	      event.stopPropagation();
	    }
	    touchEvent = Events.touchEvent(event);
	    this._eventBuffer.push({
	      x: touchEvent.clientX,
	      y: touchEvent.clientY,
	      t: Date.now()
	    });
	    this._layerStartPoint = this.layer.point;
	    this._correctedLayerStartPoint = this.layer.point;
	    if (this.constraints && this.bounce) {
	      this._correctedLayerStartPoint = this._constrainPosition(this._correctedLayerStartPoint, this.constraints, 1 / this.overdragScale);
	    }
	    this._cursorStartPoint = {
	      x: touchEvent.clientX,
	      y: touchEvent.clientY
	    };
	    this._layerCursorOffset = {
	      x: touchEvent.clientX - this._correctedLayerStartPoint.x,
	      y: touchEvent.clientY - this._correctedLayerStartPoint.y
	    };
	    this._point = this._correctedLayerStartPoint;
	    this._ignoreUpdateLayerPosition = false;
	    return this.emit(Events.DragSessionStart, event);
	  };
	
	  LayerDraggable.prototype._touchMove = function(event) {
	    var offset, point, scaleX, scaleY, touchEvent;
	    if (!this.enabled) {
	      return;
	    }
	    if (!this._point) {
	      this.touchStart(event);
	    }
	    this._lastEvent = event;
	    event.preventDefault();
	    if (this.propagateEvents === false) {
	      event.stopPropagation();
	    }
	    touchEvent = Events.touchEvent(event);
	    this._eventBuffer.push({
	      x: touchEvent.clientX,
	      y: touchEvent.clientY,
	      t: Date.now()
	    });
	    point = _.clone(this._point);
	    scaleX = 1 / this.layer.canvasScaleX() * this.layer.scale * this.layer.scaleX;
	    scaleY = 1 / this.layer.canvasScaleY() * this.layer.scale * this.layer.scaleY;
	    if (this.horizontal) {
	      point.x = this._point.x + (event.delta.x * scaleX * this.speedX);
	    }
	    if (this.vertical) {
	      point.y = this._point.y + (event.delta.y * scaleY * this.speedY);
	    }
	    this._point = _.clone(point);
	    if (this._constraints) {
	      point = this._constrainPosition(point, this._constraints, this.overdragScale);
	    }
	    if (this.directionLock) {
	      if (!this._directionLockEnabledX && !this._directionLockEnabledY) {
	        offset = event.offset;
	        offset.x = offset.x * this.speedX * (1 / this.layer.canvasScaleX()) * this.layer.scaleX * this.layer.scale;
	        offset.y = offset.y * this.speedY * (1 / this.layer.canvasScaleY()) * this.layer.scaleY * this.layer.scale;
	        this._updatedirectionLock(offset);
	        return;
	      } else {
	        if (this._directionLockEnabledX) {
	          point.x = this._layerStartPoint.x;
	        }
	        if (this._directionLockEnabledY) {
	          point.y = this._layerStartPoint.y;
	        }
	      }
	    }
	    if (point.x !== this._layerStartPoint.x || point.y !== this._layerStartPoint.y) {
	      if (!this._isDragging) {
	        this._isDragging = true;
	        this._isMoving = true;
	        this.emit(Events.DragStart, event);
	      }
	    }
	    if (this.isDragging) {
	      this.emit(Events.DragWillMove, event);
	    }
	    if (this.pixelAlign) {
	      if (this.horizontal) {
	        point.x = parseInt(point.x);
	      }
	      if (this.vertical) {
	        point.y = parseInt(point.y);
	      }
	    }
	    this._ignoreUpdateLayerPosition = true;
	    this.layer.point = this.updatePosition(point);
	    this._ignoreUpdateLayerPosition = false;
	    if (this.isDragging) {
	      this.emit(Events.Move, this.layer.point);
	      this.emit(Events.DragDidMove, event);
	    }
	    return this.emit(Events.DragSessionMove, event);
	  };
	
	  LayerDraggable.prototype._touchEnd = function(event) {
	    Events.wrap(document).removeEventListener(Gestures.Pan, this._touchMove);
	    Events.wrap(document).removeEventListener(Gestures.TapEnd, this._touchEnd);
	    if (this.propagateEvents === false) {
	      event.stopPropagation();
	    }
	    this._startSimulation();
	    this.emit(Events.DragSessionEnd, event);
	    if (this._isDragging) {
	      this.emit(Events.DragEnd, event);
	    }
	    this._isDragging = false;
	    return this._ignoreUpdateLayerPosition = true;
	  };
	
	  LayerDraggable.define("constraintsOffset", {
	    get: function() {
	      var constrainedPoint, maxX, maxY, minX, minY, offset, point, ref;
	      if (!this.constraints) {
	        return {
	          x: 0,
	          y: 0
	        };
	      }
	      ref = this._calculateConstraints(this.constraints), minX = ref.minX, maxX = ref.maxX, minY = ref.minY, maxY = ref.maxY;
	      point = this.layer.point;
	      constrainedPoint = {
	        x: Utils.clamp(point.x, minX, maxX),
	        y: Utils.clamp(point.y, minY, maxY)
	      };
	      offset = {
	        x: point.x - constrainedPoint.x,
	        y: point.y - constrainedPoint.y
	      };
	      return offset;
	    }
	  });
	
	  LayerDraggable.define("isBeyondConstraints", {
	    get: function() {
	      var constraintsOffset;
	      constraintsOffset = this.constraintsOffset;
	      if (constraintsOffset.x !== 0) {
	        return true;
	      }
	      if (constraintsOffset.y !== 0) {
	        return true;
	      }
	      return false;
	    }
	  });
	
	  LayerDraggable.prototype._clampAndScale = function(value, min, max, scale) {
	    if (value < min) {
	      value = min + (value - min) * scale;
	    }
	    if (value > max) {
	      value = max + (value - max) * scale;
	    }
	    return value;
	  };
	
	  LayerDraggable.prototype._calculateConstraints = function(bounds) {
	    var constraints;
	    if (!bounds) {
	      return constraints = {
	        minX: Infinity,
	        maxX: Infinity,
	        minY: Infinity,
	        maxY: Infinity
	      };
	    }
	    if (bounds.width < this.layer.width) {
	      bounds.width = this.layer.width;
	    }
	    if (bounds.height < this.layer.height) {
	      bounds.height = this.layer.height;
	    }
	    constraints = {
	      minX: Utils.frameGetMinX(bounds),
	      maxX: Utils.frameGetMaxX(bounds),
	      minY: Utils.frameGetMinY(bounds),
	      maxY: Utils.frameGetMaxY(bounds)
	    };
	    constraints.maxX -= this.layer.width;
	    constraints.maxY -= this.layer.height;
	    return constraints;
	  };
	
	  LayerDraggable.prototype._constrainPosition = function(proposedPoint, bounds, scale) {
	    var maxX, maxY, minX, minY, point, ref;
	    ref = this._calculateConstraints(this._constraints), minX = ref.minX, maxX = ref.maxX, minY = ref.minY, maxY = ref.maxY;
	    if (this.overdrag) {
	      point = {
	        x: this._clampAndScale(proposedPoint.x, minX, maxX, scale),
	        y: this._clampAndScale(proposedPoint.y, minY, maxY, scale)
	      };
	    } else {
	      point = {
	        x: Utils.clamp(proposedPoint.x, minX, maxX),
	        y: Utils.clamp(proposedPoint.y, minY, maxY)
	      };
	    }
	    if (this.speedX === 0 || this.horizontal === false) {
	      point.x = proposedPoint.x;
	    }
	    if (this.speedY === 0 || this.vertical === false) {
	      point.y = proposedPoint.y;
	    }
	    return point;
	  };
	
	  LayerDraggable.define("velocity", {
	    get: function() {
	      if (this.isAnimating) {
	        return this._calculateSimulationVelocity();
	      }
	      return this._eventBuffer.velocity;
	      return {
	        x: 0,
	        y: 0
	      };
	    }
	  });
	
	  LayerDraggable.define("angle", {
	    get: function() {
	      return this._eventBuffer.angle;
	    }
	  });
	
	  LayerDraggable.define("direction", {
	    get: function() {
	      var velocity;
	      velocity = this.velocity;
	      if (Math.abs(velocity.x) > Math.abs(velocity.y)) {
	        if (velocity.x > 0) {
	          return "right";
	        }
	        return "left";
	      } else {
	        if (velocity.y > 0) {
	          return "down";
	        }
	        return "up";
	      }
	    }
	  });
	
	  LayerDraggable.prototype.calculateVelocity = function() {
	    return this.velocity;
	  };
	
	  LayerDraggable.prototype._calculateSimulationVelocity = function() {
	    var velocity, xFinished, yFinished;
	    xFinished = this._simulation.x.finished();
	    yFinished = this._simulation.y.finished();
	    velocity = {
	      x: 0,
	      y: 0
	    };
	    if (!xFinished) {
	      velocity.x = this._simulation.x.simulator.state.v / this.momentumVelocityMultiplier;
	    }
	    if (!yFinished) {
	      velocity.y = this._simulation.y.simulator.state.v / this.momentumVelocityMultiplier;
	    }
	    return velocity;
	  };
	
	  LayerDraggable.prototype.emit = function(eventName, event) {
	    this.layer.emit(eventName, event);
	    return LayerDraggable.__super__.emit.call(this, eventName, event);
	  };
	
	  LayerDraggable.prototype._updatedirectionLock = function(correctedDelta) {
	    this._directionLockEnabledX = Math.abs(correctedDelta.y) > this.directionLockThreshold.y;
	    this._directionLockEnabledY = Math.abs(correctedDelta.x) > this.directionLockThreshold.x;
	    if (this._directionLockEnabledX || this._directionLockEnabledY) {
	      return this.emit(Events.DirectionLockStart, {
	        x: this._directionLockEnabledX,
	        y: this._directionLockEnabledY
	      });
	    }
	  };
	
	  LayerDraggable.prototype._resetdirectionLock = function() {
	    this._directionLockEnabledX = false;
	    return this._directionLockEnabledY = false;
	  };
	
	  LayerDraggable.prototype._setupSimulation = function() {
	    if (this._simulation) {
	      return;
	    }
	    this._simulation = {
	      x: this._setupSimulationForAxis("x"),
	      y: this._setupSimulationForAxis("y")
	    };
	    return this._updateSimulationConstraints(this.constraints);
	  };
	
	  LayerDraggable.prototype._setupSimulationForAxis = function(axis) {
	    var properties, simulation;
	    properties = {};
	    properties[axis] = true;
	    simulation = new Simulation({
	      layer: this.layer,
	      properties: properties,
	      model: "inertial-scroll",
	      modelOptions: {
	        momentum: this.momentumOptions,
	        bounce: this.bounceOptions
	      }
	    });
	    simulation.on(Events.SimulationStep, (function(_this) {
	      return function(state) {
	        return _this._onSimulationStep(axis, state);
	      };
	    })(this));
	    simulation.on(Events.SimulationStop, (function(_this) {
	      return function(state) {
	        return _this._onSimulationStop(axis, state);
	      };
	    })(this));
	    return simulation;
	  };
	
	  LayerDraggable.prototype._updateSimulationConstraints = function(constraints) {
	    var maxX, maxY, minX, minY, ref;
	    if (!this._simulation) {
	      return;
	    }
	    if (constraints) {
	      ref = this._calculateConstraints(this._constraints), minX = ref.minX, maxX = ref.maxX, minY = ref.minY, maxY = ref.maxY;
	      this._simulation.x.simulator.options = {
	        min: minX,
	        max: maxX
	      };
	      return this._simulation.y.simulator.options = {
	        min: minY,
	        max: maxY
	      };
	    } else {
	      this._simulation.x.simulator.options = {
	        min: -Infinity,
	        max: +Infinity
	      };
	      return this._simulation.y.simulator.options = {
	        min: -Infinity,
	        max: +Infinity
	      };
	    }
	  };
	
	  LayerDraggable.prototype._onSimulationStep = function(axis, state) {
	    var delta, maxX, maxY, minX, minY, ref, updatePoint;
	    if (axis === "x" && this.horizontal === false) {
	      return;
	    }
	    if (axis === "y" && this.vertical === false) {
	      return;
	    }
	    if (this.constraints) {
	      if (this.bounce) {
	        delta = state.x - this.layer[axis];
	      } else {
	        ref = this._calculateConstraints(this._constraints), minX = ref.minX, maxX = ref.maxX, minY = ref.minY, maxY = ref.maxY;
	        if (axis === "x") {
	          delta = Utils.clamp(state.x, minX, maxX) - this.layer[axis];
	        }
	        if (axis === "y") {
	          delta = Utils.clamp(state.x, minY, maxY) - this.layer[axis];
	        }
	      }
	    } else {
	      delta = state.x - this.layer[axis];
	    }
	    updatePoint = this.layer.point;
	    if (axis === "x") {
	      updatePoint[axis] = updatePoint[axis] + delta;
	    }
	    if (axis === "y") {
	      updatePoint[axis] = updatePoint[axis] + delta;
	    }
	    this.updatePosition(updatePoint);
	    this.layer[axis] = this.updatePosition(updatePoint)[axis];
	    return this.emit(Events.Move, this.layer.point);
	  };
	
	  LayerDraggable.prototype._onSimulationStop = function(axis, state) {
	    if (axis === "x" && this.horizontal === false) {
	      return;
	    }
	    if (axis === "y" && this.vertical === false) {
	      return;
	    }
	    if (!this._simulation) {
	      return;
	    }
	    if (this.pixelAlign) {
	      this.layer[axis] = parseInt(this.layer[axis]);
	    }
	    if (this._simulation.x.finished() && this._simulation.y.finished()) {
	      return this._stopSimulation();
	    }
	  };
	
	  LayerDraggable.prototype._startSimulation = function() {
	    var maxX, maxY, minX, minY, ref, startSimulationX, startSimulationY, velocity, velocityX, velocityY;
	    if (!(this.momentum || this.bounce)) {
	      return;
	    }
	    if (this.isBeyondConstraints === false && this.momentum === false) {
	      return;
	    }
	    if (this.isBeyondConstraints === false && this.isDragging === false) {
	      return;
	    }
	    ref = this._calculateConstraints(this._constraints), minX = ref.minX, maxX = ref.maxX, minY = ref.minY, maxY = ref.maxY;
	    startSimulationX = this.overdrag === true || (this.layer.x > minX && this.layer.x < maxX);
	    startSimulationY = this.overdrag === true || (this.layer.y > minY && this.layer.y < maxY);
	    if ((startSimulationX === startSimulationY && startSimulationY === false)) {
	      return;
	    }
	    velocity = this.velocity;
	    velocityX = velocity.x * this.momentumVelocityMultiplier * this.speedX * (1 / this.layer.canvasScaleX()) * this.layer.scaleX * this.layer.scale;
	    velocityY = velocity.y * this.momentumVelocityMultiplier * this.speedY * (1 / this.layer.canvasScaleY()) * this.layer.scaleY * this.layer.scale;
	    this._setupSimulation();
	    this._isAnimating = true;
	    this._isMoving = true;
	    this._simulation.x.simulator.setState({
	      x: this.layer.x,
	      v: velocityX
	    });
	    if (startSimulationX) {
	      this._simulation.x.start();
	    }
	    this._simulation.y.simulator.setState({
	      x: this.layer.y,
	      v: velocityY
	    });
	    if (startSimulationY) {
	      this._simulation.y.start();
	    }
	    return this.emit(Events.DragAnimationStart);
	  };
	
	  LayerDraggable.prototype._stopSimulation = function() {
	    var ref, ref1;
	    this._isAnimating = false;
	    if (!this._simulation) {
	      return;
	    }
	    if ((ref = this._simulation) != null) {
	      ref.x.stop();
	    }
	    if ((ref1 = this._simulation) != null) {
	      ref1.y.stop();
	    }
	    this._simulation = null;
	    this.emit(Events.Move, this.layer.point);
	    return this.emit(Events.DragAnimationEnd);
	  };
	
	  LayerDraggable.prototype.animateStop = function() {
	    return this._stopSimulation();
	  };
	
	  LayerDraggable.prototype.onMove = function(cb) {
	    return this.on(Events.Move, cb);
	  };
	
	  LayerDraggable.prototype.onDragStart = function(cb) {
	    return this.on(Events.DragStart, cb);
	  };
	
	  LayerDraggable.prototype.onDragWillMove = function(cb) {
	    return this.on(Events.DragWillMove, cb);
	  };
	
	  LayerDraggable.prototype.onDragMove = function(cb) {
	    return this.on(Events.DragMove, cb);
	  };
	
	  LayerDraggable.prototype.onDragDidMove = function(cb) {
	    return this.on(Events.DragDidMove, cb);
	  };
	
	  LayerDraggable.prototype.onDrag = function(cb) {
	    return this.on(Events.Drag, cb);
	  };
	
	  LayerDraggable.prototype.onDragEnd = function(cb) {
	    return this.on(Events.DragEnd, cb);
	  };
	
	  LayerDraggable.prototype.onDragAnimationStart = function(cb) {
	    return this.on(Events.DragAnimationStart, cb);
	  };
	
	  LayerDraggable.prototype.onDragAnimationEnd = function(cb) {
	    return this.on(Events.DragAnimationEnd, cb);
	  };
	
	  LayerDraggable.prototype.onDirectionLockStart = function(cb) {
	    return this.on(Events.DirectionLockStart, cb);
	  };
	
	  return LayerDraggable;
	
	})(BaseClass);


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	var BaseClass, Config, Defaults, Events, FrictionSimulator, MomentumBounceSimulator, SimulatorClasses, SpringSimulator, Utils, _,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };
	
	_ = __webpack_require__(1)._;
	
	Utils = __webpack_require__(4);
	
	Config = __webpack_require__(14).Config;
	
	Defaults = __webpack_require__(17).Defaults;
	
	BaseClass = __webpack_require__(6).BaseClass;
	
	Events = __webpack_require__(15).Events;
	
	SpringSimulator = __webpack_require__(29).SpringSimulator;
	
	FrictionSimulator = __webpack_require__(31).FrictionSimulator;
	
	MomentumBounceSimulator = __webpack_require__(32).MomentumBounceSimulator;
	
	Events.SimulationStart = 'simulationStart';
	
	Events.SimulationStep = 'simulationStep';
	
	Events.SimulationStop = 'simulationStop';
	
	SimulatorClasses = {
	  "spring": SpringSimulator,
	  "friction": FrictionSimulator,
	  "inertial-scroll": MomentumBounceSimulator
	};
	
	exports.Simulation = (function(superClass) {
	  extend(Simulation, superClass);
	
	  function Simulation(options) {
	    var SimulatorClass;
	    if (options == null) {
	      options = {};
	    }
	    this._update = bind(this._update, this);
	    this._start = bind(this._start, this);
	    this.start = bind(this.start, this);
	    Simulation.__super__.constructor.call(this, options);
	    this.options = _.defaults(options, {
	      layer: null,
	      properties: {},
	      model: "spring",
	      modelOptions: {},
	      delay: 0,
	      debug: false
	    });
	    this._running = false;
	    SimulatorClass = SimulatorClasses[this.options.model] || SpringSimulator;
	    this._simulator = new SimulatorClass(this.options.modelOptions);
	  }
	
	  Simulation.prototype.animatingProperties = function() {
	    return _.keys(this.options.properties);
	  };
	
	  Simulation.prototype.start = function() {
	    var animatingProperties, animation, property, ref;
	    if (this.options.layer === null) {
	      console.error("Simulation: missing layer");
	    }
	    if (this.options.debug) {
	      console.log("Simulation.start " + this._simulator.constructor.name, this.options.modelOptions);
	    }
	    animatingProperties = this.animatingProperties();
	    ref = this.options.layer.animatingProperties();
	    for (property in ref) {
	      animation = ref[property];
	      if (indexOf.call(animatingProperties, property) >= 0) {
	        animation.stop();
	      }
	    }
	    if (this.options.delay) {
	      Utils.delay(this.options.delay, this._start);
	    } else {
	      this._start();
	    }
	    return true;
	  };
	
	  Simulation.prototype.stop = function(emit) {
	    if (emit == null) {
	      emit = true;
	    }
	    if (!this._running) {
	      return;
	    }
	    this._running = false;
	    this.options.layer.context.removeAnimation(this);
	    if (emit) {
	      this.emit(Events.SimulationStop);
	    }
	    return Framer.Loop.off("update", this._update);
	  };
	
	  Simulation.prototype.emit = function(event) {
	    Simulation.__super__.emit.apply(this, arguments);
	    return this.options.layer.emit(event, this);
	  };
	
	  Simulation.prototype._start = function() {
	    if (this._running) {
	      return;
	    }
	    this._running = true;
	    this.options.layer.context.addAnimation(this);
	    this.emit(Events.SimulationStart);
	    return Framer.Loop.on("update", this._update);
	  };
	
	  Simulation.prototype._update = function(delta) {
	    var emit, result;
	    if (this._simulator.finished()) {
	      this.stop(emit = false);
	      this.emit("end");
	      return this.emit(Events.SimulationStop);
	    } else {
	      result = this._simulator.next(delta);
	      return this.emit(Events.SimulationStep, result, delta);
	    }
	  };
	
	  Simulation.define("simulator", {
	    get: function() {
	      return this._simulator;
	    }
	  });
	
	  Simulation.prototype.finished = function() {
	    return this._simulator.finished();
	  };
	
	  return Simulation;
	
	})(BaseClass);


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	var Defaults, Integrator, Simulator, Utils,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	Utils = __webpack_require__(4);
	
	Defaults = __webpack_require__(17).Defaults;
	
	Simulator = __webpack_require__(30).Simulator;
	
	Integrator = __webpack_require__(23).Integrator;
	
	exports.SpringSimulator = (function(superClass) {
	  extend(SpringSimulator, superClass);
	
	  function SpringSimulator() {
	    this.finished = bind(this.finished, this);
	    return SpringSimulator.__super__.constructor.apply(this, arguments);
	  }
	
	  SpringSimulator.prototype.setup = function(options) {
	    this.options = Defaults.getDefaults("SpringSimulator", options);
	    this.options = _.defaults(options, {
	      velocity: 0,
	      position: 0,
	      offset: 0
	    });
	    this._state = {
	      x: this.options.position,
	      v: this.options.velocity
	    };
	    return this._integrator = new Integrator((function(_this) {
	      return function(state) {
	        return -_this.options.tension * state.x - _this.options.friction * state.v;
	      };
	    })(this));
	  };
	
	  SpringSimulator.prototype.next = function(delta) {
	    this._state = this._integrator.integrateState(this._state, delta);
	    return this.getState();
	  };
	
	  SpringSimulator.prototype.finished = function() {
	    var positionNearZero, velocityNearZero;
	    positionNearZero = Math.abs(this._state.x) < this.options.tolerance;
	    velocityNearZero = Math.abs(this._state.v) < this.options.tolerance;
	    return positionNearZero && velocityNearZero;
	  };
	
	  SpringSimulator.prototype.setState = function(state) {
	    return this._state = {
	      x: state.x - this.options.offset,
	      v: state.v
	    };
	  };
	
	  SpringSimulator.prototype.getState = function() {
	    var state;
	    return state = {
	      x: this._state.x + this.options.offset,
	      v: this._state.v
	    };
	  };
	
	  return SpringSimulator;
	
	})(Simulator);


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	var BaseClass, Config, Utils, _,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	Utils = __webpack_require__(4);
	
	_ = __webpack_require__(1)._;
	
	Config = __webpack_require__(14).Config;
	
	BaseClass = __webpack_require__(6).BaseClass;
	
	exports.Simulator = (function(superClass) {
	  "The simulator class runs a physics simulation based on a set of input values\nat setup({input values}), and emits an output state {x, v}";
	  extend(Simulator, superClass);
	
	  Simulator.define("state", {
	    get: function() {
	      return _.clone(this._state);
	    },
	    set: function(state) {
	      return this._state = _.clone(state);
	    }
	  });
	
	  function Simulator(options) {
	    if (options == null) {
	      options = {};
	    }
	    this._state = {
	      x: 0,
	      v: 0
	    };
	    this.options = null;
	    this.setup(options);
	  }
	
	  Simulator.prototype.setup = function(options) {
	    throw Error("Not implemented");
	  };
	
	  Simulator.prototype.next = function(delta) {
	    throw Error("Not implemented");
	  };
	
	  Simulator.prototype.finished = function() {
	    throw Error("Not implemented");
	  };
	
	  return Simulator;
	
	})(BaseClass);


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	var Defaults, Integrator, Simulator, Utils,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	Utils = __webpack_require__(4);
	
	Defaults = __webpack_require__(17).Defaults;
	
	Simulator = __webpack_require__(30).Simulator;
	
	Integrator = __webpack_require__(23).Integrator;
	
	exports.FrictionSimulator = (function(superClass) {
	  extend(FrictionSimulator, superClass);
	
	  function FrictionSimulator() {
	    this.finished = bind(this.finished, this);
	    return FrictionSimulator.__super__.constructor.apply(this, arguments);
	  }
	
	  FrictionSimulator.prototype.setup = function(options) {
	    this.options = Defaults.getDefaults("FrictionSimulator", options);
	    this.options = _.defaults(options, {
	      velocity: 0,
	      position: 0
	    });
	    this._state = {
	      x: this.options.position,
	      v: this.options.velocity
	    };
	    return this._integrator = new Integrator((function(_this) {
	      return function(state) {
	        return -(_this.options.friction * state.v);
	      };
	    })(this));
	  };
	
	  FrictionSimulator.prototype.next = function(delta) {
	    this._state = this._integrator.integrateState(this._state, delta);
	    return this._state;
	  };
	
	  FrictionSimulator.prototype.finished = function() {
	    return Math.abs(this._state.v) < this.options.tolerance;
	  };
	
	  return FrictionSimulator;
	
	})(Simulator);


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	var Defaults, FrictionSimulator, Simulator, SpringSimulator, Utils,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	Utils = __webpack_require__(4);
	
	Defaults = __webpack_require__(17).Defaults;
	
	Simulator = __webpack_require__(30).Simulator;
	
	SpringSimulator = __webpack_require__(29).SpringSimulator;
	
	FrictionSimulator = __webpack_require__(31).FrictionSimulator;
	
	exports.MomentumBounceSimulator = (function(superClass) {
	  extend(MomentumBounceSimulator, superClass);
	
	  function MomentumBounceSimulator() {
	    this.finished = bind(this.finished, this);
	    return MomentumBounceSimulator.__super__.constructor.apply(this, arguments);
	  }
	
	  MomentumBounceSimulator.prototype.setup = function(options) {
	    this.options = Defaults.getDefaults("MomentumBounceSimulator", options);
	    this.options = _.defaults(options, {
	      velocity: 0,
	      position: 0,
	      min: 0,
	      max: 0
	    });
	    this._frictionSimulator = new FrictionSimulator({
	      friction: this.options.momentum.friction,
	      tolerance: this.options.momentum.tolerance,
	      velocity: this.options.velocity,
	      position: this.options.position
	    });
	    this._springSimulator = new SpringSimulator({
	      tension: this.options.bounce.tension,
	      friction: this.options.bounce.friction,
	      tolerance: this.options.bounce.tolerance,
	      velocity: this.options.velocity,
	      position: this.options.position
	    });
	    this._state = {
	      x: this.options.position,
	      v: this.options.velocity
	    };
	    return this._useSpring = false;
	  };
	
	  MomentumBounceSimulator.prototype.next = function(delta) {
	    if (this._useSpring) {
	      this._state = this._springSimulator.next(delta);
	    } else {
	      this._state = this._frictionSimulator.next(delta);
	      this._tryTransitionToSpring(this._state);
	    }
	    return this._state;
	  };
	
	  MomentumBounceSimulator.prototype.finished = function() {
	    if (this._useSpring) {
	      return this._springSimulator.finished();
	    }
	    return this._frictionSimulator.finished();
	  };
	
	  MomentumBounceSimulator.prototype.setState = function(state) {
	    var bound;
	    this._state = {
	      x: state.x,
	      v: state.v
	    };
	    this._frictionSimulator.setState(this._state);
	    if (this._isValidState()) {
	      return this._tryTransitionToSpring();
	    } else {
	      if (this._state.x <= this.options.min) {
	        bound = this.options.min;
	      }
	      if (this._state.x >= this.options.max) {
	        bound = this.options.max;
	      }
	      return this._transitionToSpring(bound);
	    }
	  };
	
	  MomentumBounceSimulator.prototype._tryTransitionToSpring = function(force) {
	    var aboveMaxWithVelocity, belowMinWithVelocity, bound;
	    belowMinWithVelocity = this._state.x < this.options.min && this._state.v <= 0;
	    aboveMaxWithVelocity = this._state.x > this.options.max && this._state.v >= 0;
	    if (belowMinWithVelocity || aboveMaxWithVelocity) {
	      if (belowMinWithVelocity) {
	        bound = this.options.min;
	      }
	      if (aboveMaxWithVelocity) {
	        bound = this.options.max;
	      }
	      return this._transitionToSpring(bound);
	    } else {
	      return this._useSpring = false;
	    }
	  };
	
	  MomentumBounceSimulator.prototype._transitionToSpring = function(bound) {
	    this._useSpring = true;
	    this._springSimulator.options.offset = bound;
	    return this._springSimulator.setState(this._state);
	  };
	
	  MomentumBounceSimulator.prototype._isValidState = function() {
	    var aboveMaxTravelingBack, belowMinTravelingBack, bound, check, friction, solution;
	    belowMinTravelingBack = this._state.x < this.options.min && this._state.v > 0;
	    aboveMaxTravelingBack = this._state.x > this.options.max && this._state.v < 0;
	    check = false;
	    if (belowMinTravelingBack) {
	      bound = this.options.min;
	      check = true;
	    } else if (aboveMaxTravelingBack) {
	      bound = this.options.max;
	      check = true;
	    }
	    if (check) {
	      friction = this._frictionSimulator.options.friction;
	      solution = 1 - (friction * (bound - this._state.x)) / this._state.v;
	      return solution > 0;
	    }
	    return true;
	  };
	
	  return MomentumBounceSimulator;
	
	})(Simulator);


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	var BaseClass, Events, Utils, _,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	_ = __webpack_require__(1)._;
	
	Utils = __webpack_require__(4);
	
	BaseClass = __webpack_require__(6).BaseClass;
	
	Events = __webpack_require__(15).Events;
	
	Events.EventBufferReset = "eventbufferreset";
	
	Events.EventBufferUpdated = "eventbufferupdated";
	
	exports.EventBuffer = (function(superClass) {
	  extend(EventBuffer, superClass);
	
	  function EventBuffer(options) {
	    if (options == null) {
	      options = {};
	    }
	    this.options = _.defaults(options, {
	      velocityTimeout: 100
	    });
	    this._events = [];
	  }
	
	  EventBuffer.prototype.push = function(event) {
	    this._events.push(event);
	    return this.emit(Events.EventBufferUpdated, event);
	  };
	
	  EventBuffer.prototype.reset = function() {
	    this._events.length = 0;
	    return this.emit(Events.EventBufferReset);
	  };
	
	  EventBuffer.define("length", {
	    get: function() {
	      return this._events.length;
	    }
	  });
	
	  EventBuffer.define("first", {
	    get: function() {
	      return this._events[0];
	    }
	  });
	
	  EventBuffer.define("offset", {
	    get: function() {
	      var current, first, offset;
	      if (events.length < 2) {
	        return {
	          x: 0,
	          y: 0
	        };
	      }
	      current = events[events.length - 1];
	      first = events[0];
	      return offset = {
	        x: current.x - first.x,
	        y: current.y - first.y
	      };
	    }
	  });
	
	  EventBuffer.define("events", {
	    get: function() {
	      var timeout;
	      timeout = Date.now() - this.options.velocityTimeout;
	      return _.filter(this._events, (function(_this) {
	        return function(event) {
	          return event.t > timeout;
	        };
	      })(this));
	    }
	  });
	
	  EventBuffer.define("angle", {
	    get: function() {
	      var events, p1, p2;
	      events = this.events;
	      if (events.length < 2) {
	        return 0;
	      }
	      p1 = events[0];
	      p2 = events[1];
	      return Math.atan2(p2.y - p1.y, p2.x - p1.x) * 180 / Math.PI;
	    }
	  });
	
	  EventBuffer.define("velocity", {
	    get: function() {
	      var current, events, first, time, velocity;
	      events = this.events;
	      if (events.length < 2) {
	        return {
	          x: 0,
	          y: 0
	        };
	      }
	      current = events[events.length - 1];
	      first = events[0];
	      time = current.t - first.t;
	      velocity = {
	        x: (current.x - first.x) / time,
	        y: (current.y - first.y) / time
	      };
	      if (velocity.x === Infinity) {
	        velocity.x = 0;
	      }
	      if (velocity.y === Infinity) {
	        velocity.y = 0;
	      }
	      return velocity;
	    }
	  });
	
	  return EventBuffer;
	
	})(BaseClass);


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	var BaseClass, Events, Gestures, Utils,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	Utils = __webpack_require__(4);
	
	BaseClass = __webpack_require__(6).BaseClass;
	
	Events = __webpack_require__(15).Events;
	
	Gestures = __webpack_require__(16).Gestures;
	
	Events.PinchStart = "pinchstart";
	
	Events.Pinch = "pinch";
	
	Events.PinchEnd = "pinchend";
	
	Events.RotateStart = "rotatestart";
	
	Events.Rotate = "rotate";
	
	Events.RotateEnd = "rotateend";
	
	Events.ScaleStart = "scalestart";
	
	Events.Scale = "scale";
	
	Events.ScaleEnd = "scaleend";
	
	exports.LayerPinchable = (function(superClass) {
	  extend(LayerPinchable, superClass);
	
	  LayerPinchable.define("enabled", LayerPinchable.simpleProperty("enabled", true));
	
	  LayerPinchable.define("threshold", LayerPinchable.simpleProperty("threshold", 0));
	
	  LayerPinchable.define("centerOrigin", LayerPinchable.simpleProperty("centerOrigin", true));
	
	  LayerPinchable.define("scale", LayerPinchable.simpleProperty("scale", true));
	
	  LayerPinchable.define("scaleIncrements", LayerPinchable.simpleProperty("scaleIncrements", 0));
	
	  LayerPinchable.define("minScale", LayerPinchable.simpleProperty("minScale", 0));
	
	  LayerPinchable.define("maxScale", LayerPinchable.simpleProperty("maxScale", Number.MAX_VALUE));
	
	  LayerPinchable.define("scaleFactor", LayerPinchable.simpleProperty("scaleFactor", 1));
	
	  LayerPinchable.define("rotate", LayerPinchable.simpleProperty("rotate", true));
	
	  LayerPinchable.define("rotateIncrements", LayerPinchable.simpleProperty("rotateIncrements", 0));
	
	  LayerPinchable.define("rotateMin", LayerPinchable.simpleProperty("rotateMin", 0));
	
	  LayerPinchable.define("rotateMax", LayerPinchable.simpleProperty("rotateMax", 0));
	
	  LayerPinchable.define("rotateFactor", LayerPinchable.simpleProperty("rotateFactor", 1));
	
	  function LayerPinchable(layer) {
	    this.layer = layer;
	    this._pinchEnd = bind(this._pinchEnd, this);
	    this._pinch = bind(this._pinch, this);
	    this._pinchStart = bind(this._pinchStart, this);
	    this._centerOrigin = bind(this._centerOrigin, this);
	    LayerPinchable.__super__.constructor.apply(this, arguments);
	    this._attach();
	  }
	
	  LayerPinchable.prototype._attach = function() {
	    this.layer.on(Gestures.PinchStart, this._pinchStart);
	    this.layer.on(Gestures.Pinch, this._pinch);
	    this.layer.on(Gestures.PinchEnd, this._pinchEnd);
	    return this.layer.on(Gestures.TapStart, this._tapStart);
	  };
	
	  LayerPinchable.prototype._reset = function() {
	    this._scaleStart = null;
	    this._rotationStart = null;
	    return this._rotationOffset = null;
	  };
	
	  LayerPinchable.prototype._tapStart = function(event) {};
	
	  LayerPinchable.prototype._centerOrigin = function(event) {
	    var originDelta, pinchLocation, topInSuperAfter, topInSuperBefore;
	    topInSuperBefore = Utils.convertPoint({}, this.layer, this.layer.superLayer);
	    pinchLocation = Utils.convertPointFromContext(event.touchCenter, this.layer, true, true);
	    this.layer.originX = pinchLocation.x / this.layer.width;
	    this.layer.originY = pinchLocation.y / this.layer.height;
	    topInSuperAfter = Utils.convertPoint({}, this.layer, this.layer.superLayer);
	    originDelta = {
	      x: topInSuperAfter.x - topInSuperBefore.x,
	      y: topInSuperAfter.y - topInSuperBefore.y
	    };
	    this.layer.x -= originDelta.x;
	    return this.layer.y -= originDelta.y;
	  };
	
	  LayerPinchable.prototype._pinchStart = function(event) {
	    this._reset();
	    if (this.centerOrigin) {
	      this._centerOrigin(event);
	    }
	    return this.normalizeRotation = Utils.rotationNormalizer();
	  };
	
	  LayerPinchable.prototype._pinch = function(event) {
	    var pointA, pointB, rotation, scale;
	    if (event.fingers !== 2) {
	      return;
	    }
	    if (!this.enabled) {
	      return;
	    }
	    pointA = {
	      x: event.touches[0].pageX,
	      y: event.touches[0].pageY
	    };
	    pointB = {
	      x: event.touches[1].pageX,
	      y: event.touches[1].pageY
	    };
	    if (!(Utils.pointTotal(Utils.pointAbs(Utils.pointSubtract(pointA, pointB))) > this.threshold)) {
	      return;
	    }
	    if (this.scale) {
	      if (this._scaleStart == null) {
	        this._scaleStart = this.layer.scale;
	      }
	      scale = (((event.scale - 1) * this.scaleFactor) + 1) * this._scaleStart;
	      if (this.minScale && this.maxScale) {
	        scale = Utils.clamp(scale, this.minScale, this.maxScale);
	      } else if (this.minScale) {
	        scale = Utils.clamp(scale, this.minScale, 1000000);
	      } else if (this.maxScale) {
	        scale = Utils.clamp(scale, 0.00001, this.maxScale);
	      }
	      if (this.scaleIncrements) {
	        scale = Utils.nearestIncrement(scale, this.scaleIncrements);
	      }
	      this.layer.scale = scale;
	      this.emit(Events.Scale, event);
	    }
	    if (this.rotate) {
	      if (this._rotationStart == null) {
	        this._rotationStart = this.layer.rotation;
	      }
	      if (this._rotationOffset == null) {
	        this._rotationOffset = event.rotation;
	      }
	      rotation = event.rotation - this._rotationOffset + this._rotationStart;
	      rotation = rotation * this.rotateFactor;
	      rotation = this.normalizeRotation(rotation);
	      if (this.rotateMin && this.rotateMax) {
	        rotation = Utils.clamp(rotation, this.rotateMin, this.rotateMax);
	      }
	      if (this.rotateIncrements) {
	        rotation = Utils.nearestIncrement(rotation, this.rotateIncrements);
	      }
	      return this.layer.rotation = rotation;
	    }
	  };
	
	  LayerPinchable.prototype._pinchEnd = function(event) {
	    return this._reset();
	  };
	
	  return LayerPinchable;
	
	})(BaseClass);


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	var Layer,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	Layer = __webpack_require__(13).Layer;
	
	"Todo: make it work in a parent layer";
	
	exports.BackgroundLayer = (function(superClass) {
	  extend(BackgroundLayer, superClass);
	
	  function BackgroundLayer(options) {
	    if (options == null) {
	      options = {};
	    }
	    this.layout = bind(this.layout, this);
	    if (options.backgroundColor == null) {
	      options.backgroundColor = "#fff";
	    }
	    BackgroundLayer.__super__.constructor.call(this, options);
	    this.sendToBack();
	    this.layout();
	    this._context.domEventManager.wrap(window).addEventListener("resize", this.layout);
	  }
	
	  BackgroundLayer.prototype.layout = function() {
	    if (this.parent) {
	      return this.frame = this.parent.frame;
	    } else {
	      return this.frame = this._context.frame;
	    }
	  };
	
	  return BackgroundLayer;
	
	})(Layer);


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	var Layer,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	Layer = __webpack_require__(13).Layer;
	
	exports.VideoLayer = (function(superClass) {
	  extend(VideoLayer, superClass);
	
	  function VideoLayer(options) {
	    if (options == null) {
	      options = {};
	    }
	    this.player = document.createElement("video");
	    this.player.setAttribute("webkit-playsinline", "true");
	    this.player.style.width = "100%";
	    this.player.style.height = "100%";
	    VideoLayer.__super__.constructor.call(this, options);
	    this.player.on = this._context.domEventManager.wrap(this.player).addEventListener;
	    this.player.off = this._context.domEventManager.wrap(this.player).removeEventListener;
	    this.video = options.video;
	    this._element.appendChild(this.player);
	  }
	
	  VideoLayer.define("video", {
	    get: function() {
	      return this.player.src;
	    },
	    set: function(video) {
	      return this.player.src = video;
	    }
	  });
	
	  return VideoLayer;
	
	})(Layer);


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	var AnimationGroup, EventEmitter, _,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	_ = __webpack_require__(1)._;
	
	EventEmitter = __webpack_require__(7).EventEmitter;
	
	AnimationGroup = (function(superClass) {
	  extend(AnimationGroup, superClass);
	
	  function AnimationGroup(animations) {
	    if (animations == null) {
	      animations = [];
	    }
	    this.setAnimations(animations);
	    this._currentAnimation = null;
	  }
	
	  AnimationGroup.prototype.setAnimations = function(animations) {
	    return this._animations = _.map(animations, function(animation) {
	      return animation.copy();
	    });
	  };
	
	  AnimationGroup.prototype.start = function() {
	    this.emit("start");
	    _.map(this._animations, (function(_this) {
	      return function(animation, index) {
	        var nextAnimation;
	        nextAnimation = _this._animations[index + 1];
	        if (nextAnimation) {
	          return animation.on(Events.AnimationEnd, function() {
	            nextAnimation.start();
	            return _this._currentAnimation = animation;
	          });
	        } else {
	          return animation.on(Events.AnimationEnd, function() {
	            _this.emit("end");
	            return _this._currentAnimation = null;
	          });
	        }
	      };
	    })(this));
	    return this._animations[0].start();
	  };
	
	  AnimationGroup.prototype.stop = function() {
	    var ref;
	    return (ref = this._currentAnimation) != null ? ref.stop() : void 0;
	  };
	
	  return AnimationGroup;
	
	})(EventEmitter);


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	var BaseClass, CanvasClass, Events,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	BaseClass = __webpack_require__(6).BaseClass;
	
	Events = __webpack_require__(15).Events;
	
	CanvasClass = (function(superClass) {
	  extend(CanvasClass, superClass);
	
	  function CanvasClass() {
	    this.addListener = bind(this.addListener, this);
	    return CanvasClass.__super__.constructor.apply(this, arguments);
	  }
	
	  CanvasClass.define("width", {
	    get: function() {
	      return window.innerWidth;
	    }
	  });
	
	  CanvasClass.define("height", {
	    get: function() {
	      return window.innerHeight;
	    }
	  });
	
	  CanvasClass.define("size", {
	    get: function() {
	      return {
	        width: this.width,
	        height: this.height
	      };
	    }
	  });
	
	  CanvasClass.define("frame", {
	    get: function() {
	      return {
	        x: 0,
	        y: 0,
	        width: this.width,
	        height: this.height
	      };
	    }
	  });
	
	  CanvasClass.define("backgroundColor", {
	    importable: false,
	    exportable: false,
	    get: function() {
	      return Framer.Device.background.backgroundColor;
	    },
	    set: function(value) {
	      return Framer.Device.background.backgroundColor = value;
	    }
	  });
	
	  CanvasClass.define("image", {
	    importable: false,
	    exportable: false,
	    get: function() {
	      return Framer.Device.background.image;
	    },
	    set: function(value) {
	      return Framer.Device.background.image = value;
	    }
	  });
	
	  CanvasClass.prototype.addListener = function(eventName, listener) {
	    if (eventName === "resize") {
	      Events.wrap(window).addEventListener("resize", (function(_this) {
	        return function() {
	          return _this.emit("resize");
	        };
	      })(this));
	    }
	    return CanvasClass.__super__.addListener.call(this, eventName, listener);
	  };
	
	  CanvasClass.prototype.on = CanvasClass.prototype.addListener;
	
	  CanvasClass.prototype.onResize = function(cb) {
	    return this.on("resize", cb);
	  };
	
	  return CanvasClass;
	
	})(BaseClass);
	
	exports.Canvas = new CanvasClass;


/***/ },
/* 39 */
/***/ function(module, exports) {

	var bottom, center, left, right, top, wrapper;
	
	center = function(layer, property, offset) {
	  var borderWidth, parent;
	  if (offset == null) {
	    offset = 0;
	  }
	  parent = Screen;
	  if (layer.parent) {
	    parent = layer.parent;
	  }
	  borderWidth = parent.borderWidth;
	  if (borderWidth == null) {
	    borderWidth = 0;
	  }
	  if (property === "x") {
	    return (parent.width / 2) - (layer.width / 2) - borderWidth + offset;
	  }
	  if (property === "y") {
	    return (parent.height / 2) - (layer.height / 2) - borderWidth + offset;
	  }
	  return 0;
	};
	
	left = function(layer, property, offset) {
	  var parent;
	  if (offset == null) {
	    offset = 0;
	  }
	  if (property !== "x") {
	    throw Error("Align.left only works for x");
	  }
	  parent = Screen;
	  if (layer.parent) {
	    parent = layer.parent;
	  }
	  return 0 + offset;
	};
	
	right = function(layer, property, offset) {
	  var borderWidth, parent;
	  if (offset == null) {
	    offset = 0;
	  }
	  if (property !== "x") {
	    throw Error("Align.right only works for x");
	  }
	  parent = Screen;
	  if (layer.parent) {
	    parent = layer.parent;
	  }
	  borderWidth = parent.borderWidth;
	  if (borderWidth == null) {
	    borderWidth = 0;
	  }
	  return parent.width - (2 * borderWidth) - layer.width + offset;
	};
	
	top = function(layer, property, offset) {
	  var parent;
	  if (offset == null) {
	    offset = 0;
	  }
	  if (property !== "y") {
	    throw Error("Align.top only works for y");
	  }
	  parent = Screen;
	  if (layer.parent) {
	    parent = layer.parent;
	  }
	  return 0 + offset;
	};
	
	bottom = function(layer, property, offset) {
	  var borderWidth, parent;
	  if (offset == null) {
	    offset = 0;
	  }
	  if (property !== "y") {
	    throw Error("Align.bottom only works for y");
	  }
	  parent = Screen;
	  if (layer.parent) {
	    parent = layer.parent;
	  }
	  borderWidth = parent.borderWidth;
	  if (borderWidth == null) {
	    borderWidth = 0;
	  }
	  return parent.height - (2 * borderWidth) - layer.height + offset;
	};
	
	wrapper = function(f) {
	  return function(a, b) {
	    if ((a == null) || _.isNumber(a)) {
	      return (function(l, p) {
	        return f(l, p, a);
	      });
	    }
	    return f(a, b, 0);
	  };
	};
	
	exports.Align = {
	  center: wrapper(center),
	  left: wrapper(left),
	  right: wrapper(right),
	  top: wrapper(top),
	  bottom: wrapper(bottom)
	};


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	var Context, Utils, printContext, printLayer,
	  slice = [].slice;
	
	Utils = __webpack_require__(4);
	
	Context = __webpack_require__(41).Context;
	
	"\nTodo:\n- Better looks\n- Resizable\n- Live in own space on top of all Framer stuff\n";
	
	printContext = null;
	
	printLayer = null;
	
	exports.print = function() {
	  var args;
	  args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
	  if (!printContext) {
	    printContext = new Context({
	      name: "Print"
	    });
	  }
	  printContext.run(function() {
	    var printNode, printPrefix, update;
	    if (!printLayer) {
	      printLayer = new Layer;
	      printLayer.scrollVertical = true;
	      printLayer.ignoreEvents = false;
	      printLayer.html = "";
	      printLayer.style = {
	        "font": "12px/1.35em Menlo",
	        "color": "rgba(0,0,0,.7)",
	        "padding": "8px",
	        "padding-bottom": "30px",
	        "border-top": "1px solid #d9d9d9"
	      };
	      printLayer.opacity = 0.9;
	      printLayer.style.zIndex = 999;
	      printLayer.visible = true;
	      printLayer.backgroundColor = "white";
	      update = function() {
	        printLayer.width = window.innerWidth;
	        printLayer.height = 160;
	        return printLayer.maxY = window.innerHeight;
	      };
	      update();
	      printContext.domEventManager.wrap(window).addEventListener("resize", update);
	    }
	    printPrefix = "» ";
	    printNode = document.createElement("div");
	    printNode.innerHTML = _.escape(printPrefix + args.map(function(obj) {
	      return Utils.inspect(obj);
	    }).join(", ")) + "<br>";
	    printNode.style["-webkit-user-select"] = "text";
	    printNode.style["cursor"] = "auto";
	    return printLayer._element.appendChild(printNode);
	  });
	  return Utils.delay(0, function() {
	    return printLayer._element.scrollTop = printLayer._element.scrollHeight;
	  });
	};


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	var BaseClass, Config, DOMEventManager, Defaults, Utils, _,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };
	
	_ = __webpack_require__(1)._;
	
	Utils = __webpack_require__(4);
	
	Config = __webpack_require__(14).Config;
	
	Defaults = __webpack_require__(17).Defaults;
	
	BaseClass = __webpack_require__(6).BaseClass;
	
	DOMEventManager = __webpack_require__(42).DOMEventManager;
	
	
	/*
	
	An easy way to think of the context is a bucket of things related to a set of layers. There
	is always at least one context on the screen, but often many more. For example, the device has
	a special context and replaces the default one (so it renders in the screen), and the print
	function uses on to draw the console.
	
	The default context lives under Framer.DefaultContext and the current one in
	Framer.CurrentContext. You can create layers in any context by using the run function.
	
	A context keeps track of everyting around those layers, so it can clean it up again. We use
	this a lot in Framer Studio's autocomplete function. Async things like running animations and
	timers get stopped too.
	
	Contexts can live inside another context (with a layer as a parent) so you can only reload
	a part of a prototype. This is mainly how device works.
	
	Another feature is to temporarily freeze/resume a context. If you freeze it, all user event
	will temporarily get blocked so in theory nothing will change in the context. You can restore
	these at any time.
	 */
	
	exports.Context = (function(superClass) {
	  extend(Context, superClass);
	
	  Context.define("parent", {
	    get: function() {
	      return this._parent;
	    }
	  });
	
	  Context.define("element", {
	    get: function() {
	      return this._element;
	    }
	  });
	
	  function Context(options) {
	    if (options == null) {
	      options = {};
	    }
	    options = Defaults.getDefaults("Context", options);
	    Context.__super__.constructor.apply(this, arguments);
	    if (!options.name) {
	      throw Error("Contexts need a name");
	    }
	    this._parent = options.parent;
	    this._name = options.name;
	    this.perspective = options.perspective;
	    this.perspectiveOriginX = options.perspectiveOriginX;
	    this.perspectiveOriginY = options.perspectiveOriginY;
	    this.reset();
	  }
	
	  Context.prototype.reset = function() {
	    this._createDOMEventManager();
	    this._createRootElement();
	    this.resetLayers();
	    this.resetAnimations();
	    this.resetTimers();
	    this.resetIntervals();
	    return this.emit("reset", this);
	  };
	
	  Context.define("layers", {
	    get: function() {
	      return _.clone(this._layers);
	    }
	  });
	
	  Context.define("layerCounter", {
	    get: function() {
	      return this._layerCounter;
	    }
	  });
	
	  Context.prototype.addLayer = function(layer) {
	    if (indexOf.call(this._layers, layer) >= 0) {
	      return;
	    }
	    this._layerCounter++;
	    return this._layers.push(layer);
	  };
	
	  Context.prototype.removeLayer = function(layer) {
	    return this._layers = _.without(this._layers, layer);
	  };
	
	  Context.prototype.resetLayers = function() {
	    this.resetGestures();
	    this._layers = [];
	    return this._layerCounter = 0;
	  };
	
	  Context.define("animations", {
	    get: function() {
	      return _.clone(this._animations);
	    }
	  });
	
	  Context.prototype.addAnimation = function(animation) {
	    if (indexOf.call(this._animations, animation) >= 0) {
	      return;
	    }
	    return this._animations.push(animation);
	  };
	
	  Context.prototype.removeAnimation = function(animation) {
	    return this._animations = _.without(this._animations, animation);
	  };
	
	  Context.prototype.resetAnimations = function() {
	    this.stopAnimations();
	    return this._animations = [];
	  };
	
	  Context.prototype.stopAnimations = function() {
	    if (!this._animations) {
	      return;
	    }
	    return this._animations.map(function(animation) {
	      return animation.stop(true);
	    });
	  };
	
	  Context.define("timers", {
	    get: function() {
	      return _.clone(this._timers);
	    }
	  });
	
	  Context.prototype.addTimer = function(timer) {
	    if (indexOf.call(this._timers, timer) >= 0) {
	      return;
	    }
	    return this._timers.push(timer);
	  };
	
	  Context.prototype.removeTimer = function(timer) {
	    return this._timers = _.without(this._timers, timer);
	  };
	
	  Context.prototype.resetTimers = function() {
	    if (this._timers) {
	      this._timers.map(window.clearTimeout);
	    }
	    return this._timers = [];
	  };
	
	  Context.define("intervals", {
	    get: function() {
	      return _.clone(this._intervals);
	    }
	  });
	
	  Context.prototype.addInterval = function(interval) {
	    if (indexOf.call(this._intervals, interval) >= 0) {
	      return;
	    }
	    return this._intervals.push(interval);
	  };
	
	  Context.prototype.removeInterval = function(interval) {
	    return this._intervals = _.without(this._intervals, interval);
	  };
	
	  Context.prototype.resetIntervals = function() {
	    if (this._intervals) {
	      this._intervals.map(window.clearInterval);
	    }
	    return this._intervals = [];
	  };
	
	  Context.prototype.resetGestures = function() {
	    var i, layer, len, ref;
	    if (!this._layers) {
	      return;
	    }
	    ref = this._layers;
	    for (i = 0, len = ref.length; i < len; i++) {
	      layer = ref[i];
	      if (layer._gestures) {
	        layer._gestures.destroy();
	      }
	    }
	  };
	
	  Context.prototype.run = function(fn) {
	    var previousContext;
	    previousContext = Framer.CurrentContext;
	    Framer.CurrentContext = this;
	    fn();
	    return Framer.CurrentContext = previousContext;
	  };
	
	  Context.prototype.freeze = function() {
	    var eventName, i, j, layer, layerId, layerListeners, len, len1, ref, ref1;
	    if (this._frozenEvents != null) {
	      throw new Error("Context is already frozen");
	    }
	    this._frozenEvents = {};
	    ref = this._layers;
	    for (i = 0, len = ref.length; i < len; i++) {
	      layer = ref[i];
	      layerListeners = {};
	      ref1 = layer.listenerEvents();
	      for (j = 0, len1 = ref1.length; j < len1; j++) {
	        eventName = ref1[j];
	        layerListeners[eventName] = layer.listeners(eventName);
	      }
	      layer.removeAllListeners();
	      layerId = this._layers.indexOf(layer);
	      this._frozenEvents[layerId] = layerListeners;
	    }
	    this.stopAnimations();
	    this.resetTimers();
	    return this.resetIntervals();
	  };
	
	  Context.prototype.resume = function() {
	    var eventName, events, i, layer, layerId, len, listener, listeners, ref;
	    if (this._frozenEvents == null) {
	      throw new Error("Context is not frozen, cannot resume");
	    }
	    ref = this._frozenEvents;
	    for (layerId in ref) {
	      events = ref[layerId];
	      layer = this._layers[layerId];
	      for (eventName in events) {
	        listeners = events[eventName];
	        for (i = 0, len = listeners.length; i < len; i++) {
	          listener = listeners[i];
	          layer.on(eventName, listener);
	        }
	      }
	    }
	    return delete this._frozenEvents;
	  };
	
	  Context.prototype._createDOMEventManager = function() {
	    var ref;
	    if ((ref = this.domEventManager) != null) {
	      ref.reset();
	    }
	    return this.domEventManager = new DOMEventManager;
	  };
	
	  Context.prototype._createRootElement = function() {
	    this._destroyRootElement();
	    this._element = document.createElement("div");
	    this._element.id = "FramerContextRoot-" + this._name;
	    this._element.classList.add("framerContext");
	    this._element.style["webkitPerspective"] = this.perspective;
	    this._element.style["backgroundColor"] = this.backgroundColor;
	    this.__pendingElementAppend = (function(_this) {
	      return function() {
	        var parentElement, ref;
	        parentElement = (ref = _this._parent) != null ? ref._element : void 0;
	        if (parentElement == null) {
	          parentElement = document.body;
	        }
	        return parentElement.appendChild(_this._element);
	      };
	    })(this);
	    return Utils.domComplete(this.__pendingElementAppend);
	  };
	
	  Context.prototype._destroyRootElement = function() {
	    var ref;
	    if ((ref = this._element) != null ? ref.parentNode : void 0) {
	      this._element.parentNode.removeChild(this._element);
	    }
	    if (this.__pendingElementAppend) {
	      Utils.domCompleteCancel(this.__pendingElementAppend);
	      this.__pendingElementAppend = null;
	    }
	    return this._element = null;
	  };
	
	  Context.define("width", {
	    get: function() {
	      if (this.parent != null) {
	        return this.parent.width;
	      }
	      return window.innerWidth;
	    }
	  });
	
	  Context.define("height", {
	    get: function() {
	      if (this.parent != null) {
	        return this.parent.height;
	      }
	      return window.innerHeight;
	    }
	  });
	
	  Context.define("frame", {
	    get: function() {
	      return {
	        x: 0,
	        y: 0,
	        width: this.width,
	        height: this.height
	      };
	    }
	  });
	
	  Context.define("size", {
	    get: function() {
	      return _.pick(this.frame, ["width", "height"]);
	    }
	  });
	
	  Context.define("point", {
	    get: function() {
	      return _.pick(this.frame, ["x", "y"]);
	    }
	  });
	
	  Context.define("canvasFrame", {
	    get: function() {
	      if (this.parent == null) {
	        return this.frame;
	      }
	      return this.parent.canvasFrame;
	    }
	  });
	
	  Context.define("backgroundColor", {
	    get: function() {
	      if (Color.isColor(this._backgroundColor)) {
	        return this._backgroundColor;
	      }
	      return "transparent";
	    },
	    set: function(value) {
	      var ref;
	      if (Color.isColor(value)) {
	        this._backgroundColor = value;
	        return (ref = this._element) != null ? ref.style["backgroundColor"] = new Color(value.toString()) : void 0;
	      }
	    }
	  });
	
	  Context.define("perspective", {
	    get: function() {
	      return this._perspective;
	    },
	    set: function(value) {
	      var ref;
	      if (_.isNumber(value)) {
	        this._perspective = value;
	        return (ref = this._element) != null ? ref.style["webkitPerspective"] = this._perspective : void 0;
	      }
	    }
	  });
	
	  Context.prototype._updatePerspective = function() {
	    var ref;
	    return (ref = this._element) != null ? ref.style["webkitPerspectiveOrigin"] = (this.perspectiveOriginX * 100) + "% " + (this.perspectiveOriginY * 100) + "%" : void 0;
	  };
	
	  Context.define("perspectiveOriginX", {
	    get: function() {
	      if (_.isNumber(this._perspectiveOriginX)) {
	        return this._perspectiveOriginX;
	      }
	      return 0.5;
	    },
	    set: function(value) {
	      if (_.isNumber(value)) {
	        this._perspectiveOriginX = value;
	        return this._updatePerspective();
	      }
	    }
	  });
	
	  Context.define("perspectiveOriginY", {
	    get: function() {
	      if (_.isNumber(this._perspectiveOriginY)) {
	        return this._perspectiveOriginY;
	      }
	      return .5;
	    },
	    set: function(value) {
	      if (_.isNumber(value)) {
	        this._perspectiveOriginY = value;
	        return this._updatePerspective();
	      }
	    }
	  });
	
	  Context.prototype.toInspect = function() {
	    var round;
	    round = function(value) {
	      if (parseInt(value) === value) {
	        return parseInt(value);
	      }
	      return Utils.round(value, 1);
	    };
	    return "<" + this.constructor.name + " id:" + this.id + " name:" + this._name + " " + (round(this.width)) + "x" + (round(this.height)) + ">";
	  };
	
	  return Context;
	
	})(BaseClass);


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	var DOMEventManagerElement, EventEmitter, EventManagerIdCounter, Utils, _,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
	
	_ = __webpack_require__(1)._;
	
	EventEmitter = __webpack_require__(7).EventEmitter;
	
	Utils = __webpack_require__(4);
	
	EventManagerIdCounter = 0;
	
	DOMEventManagerElement = (function(superClass) {
	  extend(DOMEventManagerElement, superClass);
	
	  function DOMEventManagerElement(element1) {
	    this.element = element1;
	  }
	
	  DOMEventManagerElement.prototype.addListener = function(eventName, listener, capture) {
	    if (capture == null) {
	      capture = false;
	    }
	    DOMEventManagerElement.__super__.addListener.call(this, eventName, listener);
	    return this.element.addEventListener(eventName, listener, false);
	  };
	
	  DOMEventManagerElement.prototype.removeListener = function(eventName, listener) {
	    DOMEventManagerElement.__super__.removeListener.call(this, eventName, listener);
	    return this.element.removeEventListener(eventName, listener, false);
	  };
	
	  DOMEventManagerElement.prototype.addEventListener = DOMEventManagerElement.prototype.addListener;
	
	  DOMEventManagerElement.prototype.removeEventListener = DOMEventManagerElement.prototype.removeListener;
	
	  return DOMEventManagerElement;
	
	})(EventEmitter);
	
	exports.DOMEventManager = (function() {
	  function DOMEventManager(element) {
	    this.wrap = bind(this.wrap, this);
	    this._elements = {};
	  }
	
	  DOMEventManager.prototype.wrap = function(element) {
	    if (!element._eventManagerId) {
	      element._eventManagerId = EventManagerIdCounter++;
	    }
	    if (!this._elements[element._eventManagerId]) {
	      this._elements[element._eventManagerId] = new DOMEventManagerElement(element);
	    }
	    return this._elements[element._eventManagerId];
	  };
	
	  DOMEventManager.prototype.reset = function() {
	    var element, elementEventManager, ref, results;
	    ref = this._elements;
	    results = [];
	    for (element in ref) {
	      elementEventManager = ref[element];
	      results.push(elementEventManager.removeAllListeners());
	    }
	    return results;
	  };
	
	  return DOMEventManager;

	})();


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	var EventMappers, Events, Layer, Utils, _, wrapComponent,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty,
	  slice = [].slice,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };
	
	_ = __webpack_require__(1)._;
	
	Utils = __webpack_require__(4);
	
	Layer = __webpack_require__(13).Layer;
	
	Events = __webpack_require__(15).Events;
	
	"ScrollComponent\n\ncontent <Layer>\ncontentSize <{width:n, height:n}>\ncontentInset <{top:n, right:n, bottom:n, left:n}> TODO\ncontentOffset <{x:n, y:n}> TODO\nscrollFrame <{x:n, y:n, width:n, height:n}>\nscrollPoint <{x:n, y:n}>\nscrollHorizontal <bool>\nscrollVertical <bool>\nspeedX <number>\nspeedY <number>\ndelaysContentTouches <bool> TODO\nloadPreset(<\"ios\"|\"android\">) TODO\nscrollToPoint(<{x:n, y:n}>, animate=true, animationOptions={})\nscrollToLayer(contentLayer, originX=0, originY=0)\nscrollFrameForContentLayer(<x:n, y:n>) <{x:n, y:n, width:n, height:n}> TODO\nclosestContentLayer(<x:n, y:n>) <Layer> TODO\n\nScrollComponent Events\n\n(all of the draggable events)\nScrollStart -> DragStart\nScrollWillMove -> DragWillMove\nScrollDidMove -> DragDidMove\nscroll -> DragMove (html compat)\nScrollEnd -> DragEnd";
	
	Events.ScrollStart = "scrollstart";
	
	Events.Scroll = "scroll";
	
	Events.ScrollMove = Events.Scroll;
	
	Events.ScrollEnd = "scrollend";
	
	Events.ScrollAnimationDidStart = "scrollanimationdidstart";
	
	Events.ScrollAnimationDidEnd = "scrollanimationdidend";
	
	EventMappers = {};
	
	EventMappers[Events.Move] = Events.Move;
	
	EventMappers[Events.ScrollStart] = Events.DragStart;
	
	EventMappers[Events.ScrollMove] = Events.DragMove;
	
	EventMappers[Events.ScrollEnd] = Events.DragEnd;
	
	EventMappers[Events.ScrollAnimationDidStart] = Events.DragAnimationStart;
	
	EventMappers[Events.ScrollAnimationDidEnd] = Events.DragAnimationEnd;
	
	EventMappers[Events.DirectionLockStart] = Events.DirectionLockStart;
	
	exports.ScrollComponent = (function(superClass) {
	  extend(ScrollComponent, superClass);
	
	  ScrollComponent.define("velocity", ScrollComponent.proxyProperty("content.draggable.velocity", {
	    importable: false
	  }));
	
	  ScrollComponent.define("scrollHorizontal", ScrollComponent.proxyProperty("content.draggable.horizontal"));
	
	  ScrollComponent.define("scrollVertical", ScrollComponent.proxyProperty("content.draggable.vertical"));
	
	  ScrollComponent.define("speedX", ScrollComponent.proxyProperty("content.draggable.speedX"));
	
	  ScrollComponent.define("speedY", ScrollComponent.proxyProperty("content.draggable.speedY"));
	
	  ScrollComponent.define("isDragging", ScrollComponent.proxyProperty("content.draggable.isDragging", {
	    importable: false
	  }));
	
	  ScrollComponent.define("isMoving", ScrollComponent.proxyProperty("content.draggable.isMoving", {
	    importable: false
	  }));
	
	  ScrollComponent.define("propagateEvents", ScrollComponent.proxyProperty("content.draggable.propagateEvents"));
	
	  ScrollComponent.define("directionLock", ScrollComponent.proxyProperty("content.draggable.directionLock"));
	
	  ScrollComponent.define("directionLockThreshold", ScrollComponent.proxyProperty("content.draggable.directionLockThreshold"));
	
	  ScrollComponent.define("content", {
	    importable: false,
	    exportable: false,
	    get: function() {
	      return this._content;
	    }
	  });
	
	  ScrollComponent.define("mouseWheelSpeedMultiplier", ScrollComponent.simpleProperty("mouseWheelSpeedMultiplier", 1));
	
	  function ScrollComponent(options) {
	    if (options == null) {
	      options = {};
	    }
	    this._onMouseWheel = bind(this._onMouseWheel, this);
	    this.updateContent = bind(this.updateContent, this);
	    if (options.clip == null) {
	      options.clip = true;
	    }
	    if (options.mouseWheelEnabled == null) {
	      options.mouseWheelEnabled = false;
	    }
	    if (options.backgroundColor == null) {
	      options.backgroundColor = null;
	    }
	    ScrollComponent.__super__.constructor.call(this, options);
	    this._contentInset = options.contentInset || Utils.rectZero();
	    this.setContentLayer(new Layer);
	    this._applyOptionsAndDefaults(options);
	    this._enableMouseWheelHandling(options.mouseWheelEnabled);
	    if (options.hasOwnProperty("wrap")) {
	      wrapComponent(this, options.wrap);
	    }
	  }
	
	  ScrollComponent.prototype.calculateContentFrame = function() {
	    var contentFrame, size;
	    if (!this.content) {
	      return Utils.rectZero();
	    }
	    contentFrame = this.content.contentFrame();
	    return size = {
	      x: 0,
	      y: 0,
	      width: Math.max(this.width, contentFrame.x + contentFrame.width),
	      height: Math.max(this.height, contentFrame.y + contentFrame.height)
	    };
	  };
	
	  ScrollComponent.prototype.setContentLayer = function(layer) {
	    if (this.content) {
	      this._content.destroy();
	    }
	    this._content = layer;
	    this._content.parent = this;
	    this._content.name = "content";
	    this._content.clip = true;
	    this._content.draggable.enabled = true;
	    this._content.draggable.momentum = true;
	    this._content.on("change:children", this.updateContent);
	    this.on("change:width", this.updateContent);
	    this.on("change:height", this.updateContent);
	    this.updateContent();
	    this.scrollPoint = {
	      x: 0,
	      y: 0
	    };
	    return this._content;
	  };
	
	  ScrollComponent.prototype.updateContent = function() {
	    var constraintsFrame, contentFrame, ref;
	    if (!this.content) {
	      return;
	    }
	    contentFrame = this.calculateContentFrame();
	    this.content.width = contentFrame.width;
	    this.content.height = contentFrame.height;
	    constraintsFrame = this.calculateContentFrame();
	    constraintsFrame = {
	      x: -constraintsFrame.width + this.width - this._contentInset.right,
	      y: -constraintsFrame.height + this.height - this._contentInset.bottom,
	      width: constraintsFrame.width + constraintsFrame.width - this.width + this._contentInset.left + this._contentInset.right,
	      height: constraintsFrame.height + constraintsFrame.height - this.height + this._contentInset.top + this._contentInset.bottom
	    };
	    this.content.draggable.constraints = constraintsFrame;
	    this.scrollPoint = this.scrollPoint;
	    if (this.content.children.length) {
	      if ((ref = this.content.backgroundColor) != null ? ref.isEqual(Framer.Defaults.Layer.backgroundColor) : void 0) {
	        return this.content.backgroundColor = null;
	      }
	    }
	  };
	
	  ScrollComponent.define("scroll", {
	    exportable: false,
	    get: function() {
	      return this.scrollHorizontal === true || this.scrollVertical === true;
	    },
	    set: function(value) {
	      if (!this.content) {
	        return;
	      }
	      if (value === false) {
	        this.content.animateStop();
	      }
	      return this.scrollHorizontal = this.scrollVertical = value;
	    }
	  });
	
	  ScrollComponent.prototype._calculateContentPoint = function(scrollPoint) {
	    var point;
	    scrollPoint = _.defaults(scrollPoint, {
	      x: 0,
	      y: 0
	    });
	    scrollPoint.x -= this.contentInset.left;
	    scrollPoint.y -= this.contentInset.top;
	    point = this._pointInConstraints(scrollPoint);
	    return Utils.pointInvert(point);
	  };
	
	  ScrollComponent.define("scrollX", {
	    get: function() {
	      if (!this.content) {
	        return 0;
	      }
	      return 0 - this.content.x + this.contentInset.left;
	    },
	    set: function(value) {
	      if (!this.content) {
	        return;
	      }
	      this.content.draggable.animateStop();
	      return this.content.x = this._calculateContentPoint({
	        x: value,
	        y: 0
	      }).x;
	    }
	  });
	
	  ScrollComponent.define("scrollY", {
	    get: function() {
	      if (!this.content) {
	        return 0;
	      }
	      return 0 - this.content.y + this.contentInset.top;
	    },
	    set: function(value) {
	      if (!this.content) {
	        return;
	      }
	      this.content.draggable.animateStop();
	      return this.content.y = this._calculateContentPoint({
	        x: 0,
	        y: value
	      }).y;
	    }
	  });
	
	  ScrollComponent.define("scrollPoint", {
	    importable: true,
	    exportable: false,
	    get: function() {
	      var point;
	      return point = {
	        x: this.scrollX,
	        y: this.scrollY
	      };
	    },
	    set: function(point) {
	      if (!this.content) {
	        return;
	      }
	      this.scrollX = point.x;
	      return this.scrollY = point.y;
	    }
	  });
	
	  ScrollComponent.define("scrollFrame", {
	    importable: true,
	    exportable: false,
	    get: function() {
	      var rect;
	      rect = this.scrollPoint;
	      rect.width = this.width;
	      rect.height = this.height;
	      return rect;
	    },
	    set: function(value) {
	      return this.scrollPoint = value;
	    }
	  });
	
	  ScrollComponent.define("contentInset", {
	    get: function() {
	      return _.clone(this._contentInset);
	    },
	    set: function(contentInset) {
	      var contentFrame;
	      this._contentInset = Utils.rectZero(Utils.parseRect(contentInset));
	      if (!this.content) {
	        return;
	      }
	      contentFrame = this.calculateContentFrame();
	      contentFrame.x = contentFrame.x + this._contentInset.left;
	      contentFrame.y = contentFrame.y + this._contentInset.top;
	      this.content.frame = contentFrame;
	      return this.updateContent();
	    }
	  });
	
	  ScrollComponent.define("direction", {
	    importable: false,
	    exportable: false,
	    get: function() {
	      var direction;
	      direction = this.content.draggable.direction;
	      if (direction === "down") {
	        return "up";
	      }
	      if (direction === "up") {
	        return "down";
	      }
	      if (direction === "right") {
	        return "left";
	      }
	      if (direction === "left") {
	        return "right";
	      }
	      return direction;
	    }
	  });
	
	  ScrollComponent.define("angle", {
	    importable: false,
	    exportable: false,
	    get: function() {
	      if (!this.content) {
	        return 0;
	      }
	      return -this.content.draggable.angle;
	    }
	  });
	
	  ScrollComponent.prototype.scrollToPoint = function(point, animate, animationOptions) {
	    var contentPoint;
	    if (animate == null) {
	      animate = true;
	    }
	    if (animationOptions == null) {
	      animationOptions = {
	        curve: "spring(500,50,0)"
	      };
	    }
	    contentPoint = this._calculateContentPoint(point);
	    this.content.draggable.animateStop();
	    if (animate) {
	      point = {};
	      if (contentPoint.hasOwnProperty("x")) {
	        point.x = contentPoint.x;
	      }
	      if (contentPoint.hasOwnProperty("y")) {
	        point.y = contentPoint.y;
	      }
	      animationOptions.properties = point;
	      this.content.animateStop();
	      return this.content.animate(animationOptions);
	    } else {
	      return this.content.point = contentPoint;
	    }
	  };
	
	  ScrollComponent.prototype.scrollToTop = function(animate, animationOptions) {
	    if (animate == null) {
	      animate = true;
	    }
	    if (animationOptions == null) {
	      animationOptions = {
	        curve: "spring(500,50,0)"
	      };
	    }
	    return this.scrollToPoint({
	      x: 0,
	      y: 0
	    }, animate, animationOptions);
	  };
	
	  ScrollComponent.prototype.scrollToLayer = function(contentLayer, originX, originY, animate, animationOptions) {
	    var scrollPoint;
	    if (originX == null) {
	      originX = 0;
	    }
	    if (originY == null) {
	      originY = 0;
	    }
	    if (animate == null) {
	      animate = true;
	    }
	    if (animationOptions == null) {
	      animationOptions = {
	        curve: "spring(500,50,0)"
	      };
	    }
	    if (contentLayer && contentLayer.parent !== this.content) {
	      throw Error("Can't scroll to this layer because it's not in the ScrollComponent. Add it to the content like layer.parent = scroll.content.");
	    }
	    if (!contentLayer || this.content.children.length === 0) {
	      scrollPoint = {
	        x: 0,
	        y: 0
	      };
	    } else {
	      scrollPoint = this._scrollPointForLayer(contentLayer, originX, originY);
	      scrollPoint.x -= this.width * originX;
	      scrollPoint.y -= this.height * originY;
	    }
	    this.scrollToPoint(scrollPoint, animate, animationOptions);
	    return contentLayer;
	  };
	
	  ScrollComponent.prototype.scrollToClosestLayer = function(originX, originY, animate, animationOptions) {
	    var closestLayer;
	    if (originX == null) {
	      originX = 0;
	    }
	    if (originY == null) {
	      originY = 0;
	    }
	    if (animate == null) {
	      animate = true;
	    }
	    if (animationOptions == null) {
	      animationOptions = {
	        curve: "spring(500,50,0)"
	      };
	    }
	    closestLayer = this.closestContentLayer(originX, originY, animate, animationOptions);
	    if (closestLayer) {
	      this.scrollToLayer(closestLayer, originX, originY);
	      return closestLayer;
	    } else {
	      if (!closestLayer) {
	        this.scrollToPoint({
	          x: 0,
	          y: 0
	        });
	      }
	      return null;
	    }
	  };
	
	  ScrollComponent.prototype.closestContentLayer = function(originX, originY) {
	    var scrollPoint;
	    if (originX == null) {
	      originX = 0;
	    }
	    if (originY == null) {
	      originY = 0;
	    }
	    scrollPoint = Utils.framePointForOrigin(this.scrollFrame, originX, originY);
	    return this.closestContentLayerForScrollPoint(scrollPoint, originX, originY);
	  };
	
	  ScrollComponent.prototype.closestContentLayerForScrollPoint = function(scrollPoint, originX, originY) {
	    if (originX == null) {
	      originX = 0;
	    }
	    if (originY == null) {
	      originY = 0;
	    }
	    return _.first(this._contentLayersSortedByDistanceForScrollPoint(scrollPoint, originX, originY));
	  };
	
	  ScrollComponent.prototype._scrollPointForLayer = function(layer, originX, originY, clamp) {
	    if (originX == null) {
	      originX = 0;
	    }
	    if (originY == null) {
	      originY = 0;
	    }
	    if (clamp == null) {
	      clamp = true;
	    }
	    return Utils.framePointForOrigin(layer, originX, originY);
	  };
	
	  ScrollComponent.prototype._contentLayersSortedByDistanceForScrollPoint = function(scrollPoint, originX, originY) {
	    if (originX == null) {
	      originX = 0;
	    }
	    if (originY == null) {
	      originY = 0;
	    }
	    return Utils.frameSortByAbsoluteDistance(scrollPoint, this.content.children, originX, originY);
	  };
	
	  ScrollComponent.prototype._pointInConstraints = function(point) {
	    var maxX, maxY, minX, minY, ref;
	    ref = this.content.draggable._calculateConstraints(this.content.draggable.constraints), minX = ref.minX, maxX = ref.maxX, minY = ref.minY, maxY = ref.maxY;
	    point = {
	      x: -Utils.clamp(-point.x, minX, maxX),
	      y: -Utils.clamp(-point.y, minY, maxY)
	    };
	    return point;
	  };
	
	  ScrollComponent.prototype.addListener = function() {
	    var eventName, eventNames, i, j, len, listener, results;
	    eventNames = 2 <= arguments.length ? slice.call(arguments, 0, i = arguments.length - 1) : (i = 0, []), listener = arguments[i++];
	    ScrollComponent.__super__.addListener.apply(this, arguments);
	    results = [];
	    for (j = 0, len = eventNames.length; j < len; j++) {
	      eventName = eventNames[j];
	      if (indexOf.call(_.keys(EventMappers), eventName) >= 0) {
	        results.push(this.content.on(EventMappers[eventName], listener));
	      } else {
	        results.push(void 0);
	      }
	    }
	    return results;
	  };
	
	  ScrollComponent.prototype.removeListener = function() {
	    var eventName, eventNames, i, j, len, listener, results;
	    eventNames = 2 <= arguments.length ? slice.call(arguments, 0, i = arguments.length - 1) : (i = 0, []), listener = arguments[i++];
	    ScrollComponent.__super__.removeListener.apply(this, arguments);
	    results = [];
	    for (j = 0, len = eventNames.length; j < len; j++) {
	      eventName = eventNames[j];
	      if (indexOf.call(_.keys(EventMappers), eventName) >= 0) {
	        results.push(this.content.off(EventMappers[eventName], listener));
	      } else {
	        results.push(void 0);
	      }
	    }
	    return results;
	  };
	
	  ScrollComponent.prototype.on = ScrollComponent.prototype.addListener;
	
	  ScrollComponent.prototype.off = ScrollComponent.prototype.removeListener;
	
	  ScrollComponent.define("mouseWheelEnabled", {
	    get: function() {
	      return this._mouseWheelEnabled;
	    },
	    set: function(value) {
	      this._mouseWheelEnabled = value;
	      return this._enableMouseWheelHandling(value);
	    }
	  });
	
	  ScrollComponent.prototype._enableMouseWheelHandling = function(enable) {
	    if (enable) {
	      return this.on(Events.MouseWheel, this._onMouseWheel);
	    } else {
	      return this.off(Events.MouseWheel, this._onMouseWheel);
	    }
	  };
	
	  ScrollComponent.prototype._onMouseWheel = function(event) {
	    var maxX, maxY, minX, minY, point, ref;
	    if (!this._mouseWheelScrolling) {
	      this._mouseWheelScrolling = true;
	      this.emit(Events.ScrollStart, event);
	    }
	    this.content.animateStop();
	    ref = this.content.draggable._calculateConstraints(this.content.draggable.constraints), minX = ref.minX, maxX = ref.maxX, minY = ref.minY, maxY = ref.maxY;
	    point = {
	      x: Utils.clamp(this.content.x + (event.wheelDeltaX * this.mouseWheelSpeedMultiplier), minX, maxX),
	      y: Utils.clamp(this.content.y + (event.wheelDeltaY * this.mouseWheelSpeedMultiplier), minY, maxY)
	    };
	    this.content.point = point;
	    this.emit(Events.Scroll, event);
	    return this._onMouseWheelEnd(event);
	  };
	
	  ScrollComponent.prototype._onMouseWheelEnd = Utils.debounce(0.3, function(event) {
	    this.emit(Events.ScrollEnd, event);
	    return this._mouseWheelScrolling = false;
	  });
	
	  ScrollComponent.prototype.copy = function() {
	    var contentLayer, copy;
	    copy = ScrollComponent.__super__.copy.apply(this, arguments);
	    contentLayer = _.first(_.without(copy.children, copy.content));
	    copy.setContentLayer(contentLayer);
	    copy.props = this.props;
	    return copy;
	  };
	
	  ScrollComponent.wrap = function(layer, options) {
	    return wrapComponent(new this(options), layer, options);
	  };
	
	  return ScrollComponent;
	
	})(Layer);
	
	wrapComponent = function(instance, layer, options) {
	  var i, l, len, ref, ref1, screenFrame, scroll, wrapper;
	  if (options == null) {
	    options = {
	      correct: true
	    };
	  }
	  if (!(layer instanceof Layer)) {
	    throw new Error("ScrollComponent.wrap expects a layer, not " + layer + ". Are you sure the layer exists?");
	  }
	  scroll = instance;
	  if (options.correct === true) {
	    if (layer.children.length === 0) {
	      wrapper = new Layer;
	      wrapper.name = "ScrollComponent";
	      wrapper.frame = layer.frame;
	      layer.parent = wrapper;
	      layer.x = layer.y = 0;
	      layer = wrapper;
	    }
	  }
	  scroll.frame = layer.frame;
	  scroll.parent = layer.parent;
	  scroll.index = layer.index;
	  if (layer.name && layer.name !== "") {
	    scroll.name = layer.name;
	  } else if ((ref = layer.__framerInstanceInfo) != null ? ref.name : void 0) {
	    scroll.name = layer.__framerInstanceInfo.name;
	  }
	  if (layer.image) {
	    scroll.image = layer.image;
	    layer.image = null;
	  }
	  if (instance.constructor.name === "PageComponent") {
	    ref1 = layer.children;
	    for (i = 0, len = ref1.length; i < len; i++) {
	      l = ref1[i];
	      scroll.addPage(l);
	    }
	  } else {
	    scroll.setContentLayer(layer);
	  }
	  if (options.correct === true) {
	    screenFrame = scroll.screenFrame;
	    if (screenFrame.x < Screen.width) {
	      if (screenFrame.x + screenFrame.width > Screen.width) {
	        scroll.width = Screen.width - screenFrame.x;
	      }
	    }
	    if (screenFrame.y < Screen.height) {
	      if (screenFrame.y + screenFrame.height > Screen.height) {
	        scroll.height = Screen.height - screenFrame.y;
	      }
	    }
	  }
	  return scroll;
	};


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	var Events, ScrollComponent,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };
	
	Events = __webpack_require__(15).Events;
	
	ScrollComponent = __webpack_require__(43).ScrollComponent;
	
	"PageComponent\n\noriginX <number>\noriginY <number>\n\nvelocityThreshold <number>\nanimationOptions <animationOptions={}>\ncurrentPage <Layer>\nclosestPage(<originX:n, originY:n>) <Layer>\n\nnextPage(direction=\"\", currentPage)\nsnapToNextPage(direction=\"\", animate, animationOptions={})\n";
	
	exports.PageComponent = (function(superClass) {
	  extend(PageComponent, superClass);
	
	  PageComponent.define("originX", PageComponent.simpleProperty("originX", .5));
	
	  PageComponent.define("originY", PageComponent.simpleProperty("originY", .5));
	
	  PageComponent.define("velocityThreshold", PageComponent.simpleProperty("velocityThreshold", 0.1));
	
	  PageComponent.define("animationOptions", PageComponent.simpleProperty("animationOptions", {
	    curve: "spring(500,50,0)"
	  }));
	
	  function PageComponent() {
	    this._resetHistory = bind(this._resetHistory, this);
	    this._scrollEnd = bind(this._scrollEnd, this);
	    this._onAnimationStop = bind(this._onAnimationStop, this);
	    this._onAnimationStep = bind(this._onAnimationStep, this);
	    this._onAnimationStart = bind(this._onAnimationStart, this);
	    this._scrollMove = bind(this._scrollMove, this);
	    this._scrollStart = bind(this._scrollStart, this);
	    PageComponent.__super__.constructor.apply(this, arguments);
	    this.content.draggable.momentum = false;
	    this.content.draggable.bounce = false;
	    this.content.on(Events.DragSessionStart, this._scrollStart);
	    this.content.on(Events.DragSessionEnd, this._scrollEnd);
	    this.content.on("change:frame", _.debounce(this._scrollMove, 16));
	    this.content.on("change:children", this._resetHistory);
	    this._resetHistory();
	  }
	
	  PageComponent.define("closestPage", {
	    get: function() {
	      return this.closestContentLayerForScrollPoint(this._originScrollPoint(), this.originX, this.originY);
	    }
	  });
	
	  PageComponent.define("currentPage", {
	    get: function() {
	      return _.last(this._previousPages);
	    }
	  });
	
	  PageComponent.define("previousPage", {
	    get: function() {
	      return this._previousPages[this._previousPages.length - 2];
	    }
	  });
	
	  PageComponent.prototype.nextPage = function(direction, currentPage, withoutCurrentPage) {
	    var layers, point;
	    if (direction == null) {
	      direction = "right";
	    }
	    if (currentPage == null) {
	      currentPage = null;
	    }
	    if (withoutCurrentPage == null) {
	      withoutCurrentPage = true;
	    }
	    if (currentPage == null) {
	      currentPage = this.currentPage;
	    }
	    point = {
	      x: 0,
	      y: 0
	    };
	    if (currentPage) {
	      point = Utils.framePointForOrigin(currentPage, this.originX, this.originY);
	    }
	    if (!withoutCurrentPage) {
	      point = {
	        x: this.scrollX + (this.originX * this.width),
	        y: this.scrollY + (this.originY * this.height)
	      };
	    }
	    if (direction === "up" || direction === "top" || direction === "north") {
	      layers = this.content.childrenAbove(point, this.originX, this.originY);
	    }
	    if (direction === "down" || direction === "bottom" || direction === "south") {
	      layers = this.content.childrenBelow(point, this.originX, this.originY);
	    }
	    if (direction === "left" || direction === "west") {
	      layers = this.content.childrenLeft(point, this.originX, this.originY);
	    }
	    if (direction === "right" || direction === "east") {
	      layers = this.content.childrenRight(point, this.originX, this.originY);
	    }
	    if (withoutCurrentPage) {
	      layers = _.without(layers, currentPage);
	    }
	    layers = Utils.frameSortByAbsoluteDistance(point, layers, this.originX, this.originY);
	    return _.first(layers);
	  };
	
	  PageComponent.prototype.snapToPage = function(page, animate, animationOptions) {
	    if (animate == null) {
	      animate = true;
	    }
	    if (animationOptions == null) {
	      animationOptions = null;
	    }
	    this.scrollToLayer(page, this.originX, this.originY, animate, animationOptions);
	    if (this.currentPage !== page) {
	      this._previousPages.push(page);
	      this.emit("change:previousPage", this.previousPage);
	      return this.emit("change:currentPage", this.currentPage);
	    }
	  };
	
	  PageComponent.prototype.snapToNextPage = function(direction, animate, animationOptions) {
	    var nextPage;
	    if (direction == null) {
	      direction = "right";
	    }
	    if (animate == null) {
	      animate = true;
	    }
	    if (animationOptions == null) {
	      animationOptions = null;
	    }
	    if (animationOptions == null) {
	      animationOptions = this.animationOptions;
	    }
	    nextPage = this.nextPage(direction);
	    if (nextPage == null) {
	      nextPage = this.closestPage;
	    }
	    return this.snapToPage(nextPage, animate, animationOptions);
	  };
	
	  PageComponent.prototype.snapToPreviousPage = function() {
	    if (!this.previousPage) {
	      return;
	    }
	    this.snapToPage(this.previousPage);
	    return this._previousPages = this._previousPages.slice(0, +(this._previousPages.length - 3) + 1 || 9e9);
	  };
	
	  PageComponent.prototype.addPage = function(page, direction) {
	    var directions, point, ref;
	    if (direction == null) {
	      direction = "right";
	    }
	    directions = ["down", "bottom", "south"] + ["right", "east"];
	    if (ref = !direction, indexOf.call(directions, ref) >= 0) {
	      direction = "right";
	      throw new Error(direction + " should be in " + directions);
	    }
	    point = page.point;
	    if (this.content.children.length) {
	      if (direction === "right" || direction === "east") {
	        point.x = Utils.frameGetMaxX(this.content.contentFrame());
	      }
	      if (direction === "down" || direction === "bottom" || direction === "south") {
	        point.y = Utils.frameGetMaxY(this.content.contentFrame());
	      }
	    }
	    page.point = point;
	    if (page.parent !== this.content) {
	      return page.parent = this.content;
	    } else {
	      return this.updateContent();
	    }
	  };
	
	  PageComponent.prototype.setContentLayer = function(contentLayer) {
	    if (this.content) {
	      this._onAnimationStop();
	      this.content.off(Events.AnimationStart, this._onAnimationStart);
	      this.content.off(Events.AnimationStop, this._onAnimationStop);
	    }
	    PageComponent.__super__.setContentLayer.call(this, contentLayer);
	    this.content.on(Events.AnimationStart, this._onAnimationStart);
	    return this.content.on(Events.AnimationStop, this._onAnimationStop);
	  };
	
	  PageComponent.prototype.horizontalPageIndex = function(page) {
	    return (_.sortBy(this.content.children, function(l) {
	      return l.x;
	    })).indexOf(page);
	  };
	
	  PageComponent.prototype.verticalPageIndex = function(page) {
	    return (_.sortBy(this.content.children, function(l) {
	      return l.y;
	    })).indexOf(page);
	  };
	
	  PageComponent.prototype._scrollStart = function() {
	    return this._currentPage = this.currentPage;
	  };
	
	  PageComponent.prototype._scrollMove = function() {
	    var currentPage;
	    currentPage = this.currentPage;
	    if (currentPage !== _.last(this._previousPages) && currentPage !== (void 0)) {
	      this._previousPages.push(currentPage);
	      return this.emit("change:currentPage", {
	        old: this.previousPage,
	        "new": currentPage
	      });
	    }
	  };
	
	  PageComponent.prototype._onAnimationStart = function() {
	    this._isMoving = true;
	    this._isAnimating = true;
	    return this.content.on("change:frame", this._onAnimationStep);
	  };
	
	  PageComponent.prototype._onAnimationStep = function() {
	    return this.emit(Events.Move, this.content.point);
	  };
	
	  PageComponent.prototype._onAnimationStop = function() {
	    this._isMoving = false;
	    this._isAnimating = false;
	    return this.content.off("change:frame", this._onAnimationStep);
	  };
	
	  PageComponent.prototype._scrollEnd = function() {
	    var maximumVelocity, nextPage, velocity, xDisabled, xLock, yDisabled, yLock;
	    if (this.content.isAnimating) {
	      return;
	    }
	    velocity = this.content.draggable.velocity;
	    xDisabled = !this.scrollHorizontal && (this.direction === "right" || this.direction === "left");
	    yDisabled = !this.scrollVertical && (this.direction === "down" || this.direction === "up");
	    xLock = this.content.draggable._directionLockEnabledX && (this.direction === "right" || this.direction === "left");
	    yLock = this.content.draggable._directionLockEnabledY && (this.direction === "down" || this.direction === "up");
	    maximumVelocity = Math.max(Math.abs(velocity.x), Math.abs(velocity.y));
	    if (maximumVelocity < this.velocityThreshold || xLock || yLock || xDisabled || yDisabled) {
	      return this.snapToPage(this.closestPage, true, this.animationOptions);
	    }
	    nextPage = this.nextPage(this.direction, this._currentPage, false);
	    if (nextPage == null) {
	      nextPage = this.closestPage;
	    }
	    return this.snapToPage(nextPage, true, this.animationOptions);
	  };
	
	  PageComponent.prototype._originScrollPoint = function() {
	    var scrollPoint;
	    scrollPoint = this.scrollPoint;
	    scrollPoint.x += this.width * this.originX;
	    scrollPoint.y += this.height * this.originY;
	    return scrollPoint;
	  };
	
	  PageComponent.prototype._resetHistory = function() {
	    this._currentPage = this.closestPage;
	    return this._previousPages = [this._currentPage];
	  };
	
	  return PageComponent;
	
	})(ScrollComponent);


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	var Events, Knob, Layer, Utils,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
	
	Utils = __webpack_require__(4);
	
	Layer = __webpack_require__(13).Layer;
	
	Events = __webpack_require__(15).Events;
	
	"SliderComponent\n\nknob <layer>\nknobSize <width, height>\nfill <layer>\nmin <number>\nmax <number>\n\npointForValue(<n>)\nvalueForPoint(<n>)\n\nanimateToValue(value, animationOptions={})";
	
	Events.SliderValueChange = "sliderValueChange";
	
	Knob = (function(superClass) {
	  extend(Knob, superClass);
	
	  function Knob(options) {
	    Knob.__super__.constructor.call(this, options);
	  }
	
	  Knob.define("constrained", Knob.simpleProperty("constrained", false));
	
	  return Knob;
	
	})(Layer);
	
	exports.SliderComponent = (function(superClass) {
	  extend(SliderComponent, superClass);
	
	  function SliderComponent(options) {
	    if (options == null) {
	      options = {};
	    }
	    this._updateValue = bind(this._updateValue, this);
	    this._setRadius = bind(this._setRadius, this);
	    this._updateFrame = bind(this._updateFrame, this);
	    this._updateKnob = bind(this._updateKnob, this);
	    this._updateFill = bind(this._updateFill, this);
	    this._touchEnd = bind(this._touchEnd, this);
	    this._touchStart = bind(this._touchStart, this);
	    _.defaults(options, {
	      backgroundColor: "#ccc",
	      borderRadius: 50,
	      clip: false,
	      width: 300,
	      height: 10,
	      value: 0,
	      knobSize: 30
	    });
	    if (options.hitArea == null) {
	      options.hitArea = options.knobSize;
	    }
	    this.knob = new Knob({
	      backgroundColor: "#fff",
	      shadowY: 1,
	      shadowBlur: 3,
	      shadowColor: "rgba(0,0,0,0.35)",
	      name: "knob"
	    });
	    this.fill = new Layer({
	      backgroundColor: "#333",
	      width: 0,
	      force2d: true,
	      name: "fill"
	    });
	    this.sliderOverlay = new Layer({
	      backgroundColor: null,
	      name: "sliderOverlay"
	    });
	    SliderComponent.__super__.constructor.call(this, options);
	    this.knobSize = options.knobSize;
	    this.knob.parent = this.fill.parent = this.sliderOverlay.parent = this;
	    if (this.width > this.height) {
	      this.fill.height = this.height;
	    } else {
	      this.fill.width = this.width;
	    }
	    this.fill.borderRadius = this.sliderOverlay.borderRadius = this.borderRadius;
	    this.knob.draggable.enabled = true;
	    this.knob.draggable.overdrag = false;
	    this.knob.draggable.momentum = true;
	    this.knob.draggable.momentumOptions = {
	      friction: 5,
	      tolerance: 0.25
	    };
	    this.knob.draggable.bounce = false;
	    this.knob.borderRadius = this.knobSize / 2;
	    this._updateFrame();
	    this._updateKnob();
	    this._updateFill();
	    this.on("change:frame", this._updateFrame);
	    this.on("change:borderRadius", this._setRadius);
	    this.knob.on("change:size", this._updateKnob);
	    this.knob.on("change:frame", this._updateFill);
	    this.knob.on("change:frame", this._updateValue);
	    this.sliderOverlay.on(Events.TapStart, this._touchStart);
	    this.sliderOverlay.on(Events.TapEnd, this._touchEnd);
	  }
	
	  SliderComponent.prototype._touchStart = function(event) {
	    var offsetX, offsetY;
	    event.preventDefault();
	    offsetX = (this.min / this.canvasScaleX()) - this.min;
	    offsetY = (this.min / this.canvasScaleY()) - this.min;
	    if (this.width > this.height) {
	      this.value = this.valueForPoint(Events.touchEvent(event).clientX - this.screenScaledFrame().x) / this.canvasScaleX() - offsetX;
	    } else {
	      this.value = this.valueForPoint(Events.touchEvent(event).clientY - this.screenScaledFrame().y) / this.canvasScaleY() - offsetY;
	    }
	    this.knob.draggable._touchStart(event);
	    return this._updateValue();
	  };
	
	  SliderComponent.prototype._touchEnd = function(event) {
	    return this._updateValue();
	  };
	
	  SliderComponent.prototype._updateFill = function() {
	    if (this.width > this.height) {
	      return this.fill.width = this.knob.midX;
	    } else {
	      return this.fill.height = this.knob.midY;
	    }
	  };
	
	  SliderComponent.prototype._updateKnob = function() {
	    if (this.width > this.height) {
	      this.knob.midX = this.fill.width;
	      return this.knob.centerY();
	    } else {
	      this.knob.midY = this.fill.height;
	      return this.knob.centerX();
	    }
	  };
	
	  SliderComponent.prototype._updateFrame = function() {
	    this.knob.draggable.constraints = {
	      x: -this.knob.width / 2,
	      y: -this.knob.height / 2,
	      width: this.width + this.knob.width,
	      height: this.height + this.knob.height
	    };
	    if (this.knob.constrained) {
	      this.knob.draggable.constraints = {
	        x: 0,
	        y: 0,
	        width: this.width,
	        height: this.height
	      };
	    }
	    if (this.width > this.height) {
	      this.fill.height = this.height;
	      this.knob.centerY();
	    } else {
	      this.fill.width = this.width;
	      this.knob.centerX();
	    }
	    if (this.width > this.height) {
	      this.knob.draggable.speedY = 0;
	    } else {
	      this.knob.draggable.speedX = 0;
	    }
	    return this.sliderOverlay.center();
	  };
	
	  SliderComponent.prototype._setRadius = function() {
	    var radius;
	    radius = this.borderRadius;
	    return this.fill.style.borderRadius = radius + "px 0 0 " + radius + "px";
	  };
	
	  SliderComponent.define("knobSize", {
	    get: function() {
	      return this._knobSize;
	    },
	    set: function(value) {
	      this._knobSize = value;
	      this.knob.width = this._knobSize;
	      this.knob.height = this._knobSize;
	      return this._updateFrame();
	    }
	  });
	
	  SliderComponent.define("hitArea", {
	    get: function() {
	      return this._hitArea;
	    },
	    set: function(value) {
	      this._hitArea = value;
	      if (this.width > this.height) {
	        this.sliderOverlay.width = this.width + this.hitArea;
	        return this.sliderOverlay.height = this.hitArea;
	      } else {
	        this.sliderOverlay.width = this.hitArea;
	        return this.sliderOverlay.height = this.height + this.hitArea;
	      }
	    }
	  });
	
	  SliderComponent.define("min", {
	    get: function() {
	      return this._min || 0;
	    },
	    set: function(value) {
	      return this._min = value;
	    }
	  });
	
	  SliderComponent.define("max", {
	    get: function() {
	      return this._max || 1;
	    },
	    set: function(value) {
	      return this._max = value;
	    }
	  });
	
	  SliderComponent.define("value", {
	    get: function() {
	      if (this.width > this.height) {
	        return this.valueForPoint(this.knob.midX);
	      } else {
	        return this.valueForPoint(this.knob.midY);
	      }
	    },
	    set: function(value) {
	      if (this.width > this.height) {
	        this.knob.midX = this.pointForValue(value);
	      } else {
	        this.knob.midY = this.pointForValue(value);
	      }
	      this._updateFill();
	      return this._updateValue();
	    }
	  });
	
	  SliderComponent.prototype._updateValue = function() {
	    if (this._lastUpdatedValue === this.value) {
	      return;
	    }
	    this._lastUpdatedValue = this.value;
	    this.emit("change:value", this.value);
	    return this.emit(Events.SliderValueChange, this.value);
	  };
	
	  SliderComponent.prototype.pointForValue = function(value) {
	    if (this.width > this.height) {
	      if (this.knob.constrained) {
	        return Utils.modulate(value, [this.min, this.max], [0 + (this.knob.width / 2), this.width - (this.knob.width / 2)], true);
	      } else {
	        return Utils.modulate(value, [this.min, this.max], [0, this.width], true);
	      }
	    } else {
	      if (this.knob.constrained) {
	        return Utils.modulate(value, [this.min, this.max], [0 + (this.knob.height / 2), this.height - (this.knob.height / 2)], true);
	      } else {
	        return Utils.modulate(value, [this.min, this.max], [0, this.height], true);
	      }
	    }
	  };
	
	  SliderComponent.prototype.valueForPoint = function(value) {
	    if (this.width > this.height) {
	      if (this.knob.constrained) {
	        return Utils.modulate(value, [0 + (this.knob.width / 2), this.width - (this.knob.width / 2)], [this.min, this.max], true);
	      } else {
	        return Utils.modulate(value, [0, this.width], [this.min, this.max], true);
	      }
	    } else {
	      if (this.knob.constrained) {
	        return Utils.modulate(value, [0 + (this.knob.height / 2), this.height - (this.knob.height / 2)], [this.min, this.max], true);
	      } else {
	        return Utils.modulate(value, [0, this.height], [this.min, this.max], true);
	      }
	    }
	  };
	
	  SliderComponent.prototype.animateToValue = function(value, animationOptions) {
	    if (animationOptions == null) {
	      animationOptions = {
	        curve: "spring(300,25,0)"
	      };
	    }
	    if (this.width > this.height) {
	      animationOptions.properties = {
	        x: this.pointForValue(value) - (this.knob.width / 2)
	      };
	    } else {
	      animationOptions.properties = {
	        y: this.pointForValue(value) - (this.knob.height / 2)
	      };
	    }
	    return this.knob.animate(animationOptions);
	  };
	
	  SliderComponent.prototype.onValueChange = function(cb) {
	    return this.on(Events.SliderValueChange, cb);
	  };
	
	  return SliderComponent;
	
	})(Layer);


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	var AppleWatch38BlackLeatherDevice, AppleWatch38Device, AppleWatch42Device, BaseClass, BuiltInDevices, Defaults, Devices, Events, HTCa9BaseDevice, HTCm8BaseDevice, Layer, MSFTLumia950BaseDevice, Nexus4BaseDevice, Nexus5BaseDevice, Nexus6BaseDevice, Nexus9BaseDevice, SamsungGalaxyNote5BaseDevice, Utils, _, iPadAir2BaseDevice, iPadMini4BaseDevice, iPadProBaseDevice, iPhone5BaseDevice, iPhone5CBaseDevice, iPhone6BaseDevice, iPhone6PlusBaseDevice, newDeviceMinVersion, oldDeviceMaxVersion, old_AppleWatch38Device, old_AppleWatch42Device, old_Nexus5BaseDevice, old_Nexus5BaseDeviceHand, old_Nexus9BaseDevice, old_iPadAirBaseDevice, old_iPadAirBaseDeviceHand, old_iPadMiniBaseDevice, old_iPadMiniBaseDeviceHand, old_iPhone5BaseDevice, old_iPhone5BaseDeviceHand, old_iPhone5CBaseDevice, old_iPhone5CBaseDeviceHand, old_iPhone6BaseDevice, old_iPhone6BaseDeviceHand, old_iPhone6PlusBaseDevice, old_iPhone6PlusBaseDeviceHand,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };
	
	Utils = __webpack_require__(4);
	
	_ = __webpack_require__(1)._;
	
	BaseClass = __webpack_require__(6).BaseClass;
	
	Layer = __webpack_require__(13).Layer;
	
	Defaults = __webpack_require__(17).Defaults;
	
	Events = __webpack_require__(15).Events;
	
	
	/*
	
	Device._setup()
	Device._update()
	Device._setupContext()
	
	Device.fullScreen bool
	Device.deviceType str
	Device.padding int
	
	Device.orientation(orientation:float)
	Device.orientationName landscape|portrait|unknown
	Device.rotateLeft()
	Device.rotateRight()
	
	Device.setDeviceScale(zoom:float, animate:bool)
	Device.setContentScale(zoom:float, animate:bool)
	
	Device.nextHand()
	
	 * Events
	Events.DeviceTypeDidChange
	Events.DeviceFullScreenDidChange
	 */
	
	exports.DeviceComponent = (function(superClass) {
	  extend(DeviceComponent, superClass);
	
	  DeviceComponent.define("context", {
	    get: function() {
	      return this._context;
	    }
	  });
	
	  function DeviceComponent(options) {
	    var defaults;
	    if (options == null) {
	      options = {};
	    }
	    this._orientationChange = bind(this._orientationChange, this);
	    this._updateDeviceImage = bind(this._updateDeviceImage, this);
	    this._update = bind(this._update, this);
	    defaults = Defaults.getDefaults("DeviceComponent", options);
	    if (Framer.Defaults.hasOwnProperty("DeviceView")) {
	      defaults = _.extend(defaults, Framer.Defaults.DeviceView);
	    }
	    this._setup();
	    this.animationOptions = defaults.animationOptions;
	    this.deviceType = defaults.deviceType;
	    _.extend(this, _.defaults(options, defaults));
	    window.addEventListener("orientationchange", this._orientationChange, true);
	  }
	
	  DeviceComponent.prototype._setup = function() {
	    var i, layer, len, ref;
	    if (this._setupDone) {
	      return;
	    }
	    this._setupDone = true;
	    this.background = new Layer;
	    this.background.clip = true;
	    this.background.backgroundColor = "transparent";
	    this.background.classList.add("DeviceBackground");
	    this.hands = new Layer;
	    this.handsImageLayer = new Layer({
	      parent: this.hands
	    });
	    this.phone = new Layer({
	      parent: this.hands
	    });
	    this.screen = new Layer({
	      parent: this.phone
	    });
	    this.viewport = new Layer({
	      parent: this.screen
	    });
	    this.content = new Layer({
	      parent: this.viewport
	    });
	    this.hands.backgroundColor = "transparent";
	    this.hands._alwaysUseImageCache = true;
	    this.handsImageLayer.backgroundColor = "transparent";
	    this.phone.backgroundColor = "transparent";
	    this.phone.classList.add("DevicePhone");
	    this.screen.classList.add("DeviceScreen");
	    this.screen.clip = true;
	    this.viewport.backgroundColor = "transparent";
	    this.viewport.classList.add("DeviceComponentPort");
	    this.content.backgroundColor = "transparent";
	    this.content.classList.add("DeviceContent");
	    this.content.originX = 0;
	    this.content.originY = 0;
	    if (!Utils.isMobile()) {
	      Framer.CurrentContext.domEventManager.wrap(window).addEventListener("resize", this._update);
	    }
	    ref = [this.background, this.phone, this.viewport, this.content, this.screen];
	    for (i = 0, len = ref.length; i < len; i++) {
	      layer = ref[i];
	      layer.on("touchmove", function(event) {
	        return event.preventDefault();
	      });
	    }
	    this._context = new Framer.Context({
	      parent: this.content,
	      name: "Device"
	    });
	    return this._context.perspective = 1200;
	  };
	
	  DeviceComponent.prototype._update = function() {
	    var backgroundOverlap, contentScaleFactor, height, i, layer, len, ref, ref1, width;
	    contentScaleFactor = this.contentScale;
	    if (contentScaleFactor > 1) {
	      contentScaleFactor = 1;
	    }
	    if (this._shouldRenderFullScreen()) {
	      ref = [this.background, this.hands, this.phone, this.viewport, this.content, this.screen];
	      for (i = 0, len = ref.length; i < len; i++) {
	        layer = ref[i];
	        layer.x = layer.y = 0;
	        layer.width = window.innerWidth / contentScaleFactor;
	        layer.height = window.innerHeight / contentScaleFactor;
	        layer.scale = 1;
	      }
	      return this.content.scale = contentScaleFactor;
	    } else {
	      backgroundOverlap = 100;
	      this.background.x = 0 - backgroundOverlap;
	      this.background.y = 0 - backgroundOverlap;
	      this.background.width = window.innerWidth + (2 * backgroundOverlap);
	      this.background.height = window.innerHeight + (2 * backgroundOverlap);
	      this.hands.scale = this._calculatePhoneScale();
	      this.hands.center();
	      this.phone.center();
	      ref1 = this._getOrientationDimensions(this._device.screenWidth / contentScaleFactor, this._device.screenHeight / contentScaleFactor), width = ref1[0], height = ref1[1];
	      this.screen.width = this.viewport.width = this._device.screenWidth;
	      this.screen.height = this.viewport.height = this._device.screenHeight;
	      this.content.width = width;
	      this.content.height = height;
	      this.screen.center();
	      if (this.selectedHand && this._orientation === 0) {
	        return this.setHand(this.selectedHand);
	      }
	    }
	  };
	
	  DeviceComponent.prototype._shouldRenderFullScreen = function() {
	    if (!this._device) {
	      return true;
	    }
	    if (this.fullScreen === true) {
	      return true;
	    }
	    if (this.deviceType === "fullscreen") {
	      return true;
	    }
	    if (Utils.deviceType() === "phone" && Utils.deviceType() === this._device.deviceType) {
	      return true;
	    }
	    if (Utils.deviceType() === "tablet" && Utils.deviceType() === this._device.deviceType) {
	      return true;
	    }
	    if (Utils.deviceType() === "phone" && this._device.deviceType === "tablet") {
	      return true;
	    }
	    return false;
	  };
	
	  DeviceComponent.prototype.setupContext = function() {
	    return Framer.CurrentContext = this._context;
	  };
	
	  DeviceComponent.define("fullScreen", {
	    get: function() {
	      return this._fullScreen;
	    },
	    set: function(fullScreen) {
	      return this._setFullScreen(fullScreen);
	    }
	  });
	
	  DeviceComponent.prototype._setFullScreen = function(fullScreen) {
	    if (this._deviceType === "fullscreen") {
	      return;
	    }
	    if (!_.isBoolean(fullScreen)) {
	      return;
	    }
	    if (fullScreen === this._fullScreen) {
	      return;
	    }
	    this._fullScreen = fullScreen;
	    if (fullScreen === true) {
	      this.phone.image = "";
	      this.hands.image = "";
	    } else {
	      this._updateDeviceImage();
	    }
	    this._update();
	    return this.emit("change:fullScreen");
	  };
	
	  DeviceComponent.define("deviceType", {
	    get: function() {
	      return this._deviceType;
	    },
	    set: function(deviceType) {
	      var device, i, key, lDevicetype, lKey, len, ref, shouldZoomToFit;
	      if (deviceType === this._deviceType) {
	        return;
	      }
	      device = null;
	      if (_.isString(deviceType)) {
	        lDevicetype = deviceType.toLowerCase();
	        ref = _.keys(Devices);
	        for (i = 0, len = ref.length; i < len; i++) {
	          key = ref[i];
	          lKey = key.toLowerCase();
	          if (lDevicetype === lKey) {
	            device = Devices[key];
	          }
	        }
	      }
	      if (!device) {
	        throw Error("No device named " + deviceType + ". Options are: " + (_.keys(Devices)));
	      }
	      if (this._device === device) {
	        return;
	      }
	      shouldZoomToFit = this._deviceType === "fullscreen";
	      this.screen.backgroundColor = "black";
	      if (device.backgroundColor != null) {
	        this.screen.backgroundColor = device.backgroundColor;
	      }
	      this._device = _.clone(device);
	      this._deviceType = deviceType;
	      this.fullscreen = false;
	      this._updateDeviceImage();
	      this._update();
	      this.emit("change:deviceType");
	      if (shouldZoomToFit) {
	        return this.deviceScale = "fit";
	      }
	    }
	  });
	
	  DeviceComponent.prototype._updateDeviceImage = function() {
	    if (/PhantomJS/.test(navigator.userAgent)) {
	      return;
	    }
	    if (this._shouldRenderFullScreen()) {
	      this.phone.image = "";
	      return this.hands.image = "";
	    } else if (!this._deviceImageUrl(this._deviceImageName())) {
	      return this.phone.image = "";
	    } else {
	      this.phone._alwaysUseImageCache = true;
	      this.phone.image = this._deviceImageUrl(this._deviceImageName());
	      this.phone.width = this._device.deviceImageWidth;
	      this.phone.height = this._device.deviceImageHeight;
	      this.hands.width = this.phone.width;
	      return this.hands.height = this.phone.height;
	    }
	  };
	
	  DeviceComponent.prototype._deviceImageName = function() {
	    if (this._device.hasOwnProperty("deviceImage")) {
	      return this._device.deviceImage;
	    }
	    return this._deviceType + ".png";
	  };
	
	  DeviceComponent.prototype._deviceImageUrl = function(name) {
	    var ref, resourceUrl;
	    if (!name) {
	      return null;
	    }
	    if (_.startsWith(name, "http://") || _.startsWith(name, "https://")) {
	      return name;
	    }
	    if (ref = this._deviceType, indexOf.call(BuiltInDevices, ref) < 0) {
	      return name;
	    }
	    resourceUrl = "//resources.framerjs.com/static/DeviceResources";
	    if (Utils.isFramerStudio() && window.FramerStudioInfo) {
	      if (this._device.minStudioVersion && Utils.framerStudioVersion() >= this._device.minStudioVersion || !this._device.minStudioVersion) {
	        if (this._device.maxStudioVersion && Utils.framerStudioVersion() <= this._device.maxStudioVersion || !this._device.maxStudioVersion) {
	          resourceUrl = window.FramerStudioInfo.deviceImagesUrl;
	        }
	      }
	    }
	    if (Utils.isJP2Supported() && this._device.deviceImageJP2 === true) {
	      return resourceUrl + "/" + (name.replace(".png", ".jp2"));
	    }
	    return resourceUrl + "/" + name;
	  };
	
	  DeviceComponent.define("deviceScale", {
	    get: function() {
	      if (this._shouldRenderFullScreen()) {
	        return 1;
	      }
	      return this._deviceScale || 1;
	    },
	    set: function(deviceScale) {
	      return this.setDeviceScale(deviceScale, false);
	    }
	  });
	
	  DeviceComponent.prototype.setDeviceScale = function(deviceScale, animate) {
	    var phoneScale;
	    if (animate == null) {
	      animate = false;
	    }
	    if (deviceScale === "fit" || deviceScale < 0) {
	      deviceScale = "fit";
	    } else {
	      deviceScale = parseFloat(deviceScale);
	    }
	    if (deviceScale === this._deviceScale) {
	      return;
	    }
	    this._deviceScale = deviceScale;
	    if (this._shouldRenderFullScreen()) {
	      return;
	    }
	    if (deviceScale === "fit") {
	      phoneScale = this._calculatePhoneScale();
	    } else {
	      phoneScale = deviceScale;
	    }
	    this.hands.animateStop();
	    if (animate) {
	      this.hands.animate(_.extend(this.animationOptions, {
	        properties: {
	          scale: phoneScale
	        }
	      }));
	    } else {
	      this.hands.scale = phoneScale;
	      this.hands.center();
	    }
	    return this.emit("change:deviceScale");
	  };
	
	  DeviceComponent.prototype._calculatePhoneScale = function() {
	    var height, paddingOffset, phoneScale, ref, ref1, width;
	    ref = this._getOrientationDimensions(this.phone.width, this.phone.height), width = ref[0], height = ref[1];
	    paddingOffset = ((ref1 = this._device) != null ? ref1.paddingOffset : void 0) || 0;
	    phoneScale = _.min([(window.innerWidth - ((this.padding + paddingOffset) * 2)) / width, (window.innerHeight - ((this.padding + paddingOffset) * 2)) / height]);
	    if (phoneScale > 1) {
	      phoneScale = 1;
	    }
	    this.emit("change:phoneScale", phoneScale);
	    if (this._deviceScale && this._deviceScale !== "fit") {
	      return this._deviceScale;
	    }
	    return phoneScale;
	  };
	
	  DeviceComponent.define("contentScale", {
	    get: function() {
	      return this._contentScale || 1;
	    },
	    set: function(contentScale) {
	      return this.setContentScale(contentScale, false);
	    }
	  });
	
	  DeviceComponent.prototype.setContentScale = function(contentScale, animate) {
	    if (animate == null) {
	      animate = false;
	    }
	    contentScale = parseFloat(contentScale);
	    if (contentScale <= 0) {
	      return;
	    }
	    if (contentScale === this._contentScale) {
	      return;
	    }
	    this._contentScale = contentScale;
	    if (animate) {
	      this.content.animate(_.extend(this.animationOptions, {
	        properties: {
	          scale: this._contentScale
	        }
	      }));
	    } else {
	      this.content.scale = this._contentScale;
	    }
	    this._update();
	    return this.emit("change:contentScale");
	  };
	
	  DeviceComponent.define("orientation", {
	    get: function() {
	      if (Utils.isMobile()) {
	        return window.orientation;
	      }
	      return this._orientation || 0;
	    },
	    set: function(orientation) {
	      return this.setOrientation(orientation, false);
	    }
	  });
	
	  DeviceComponent.prototype.setOrientation = function(orientation, animate) {
	    var animation, contentProperties, height, offset, phoneProperties, ref, ref1, width, x, y;
	    if (animate == null) {
	      animate = false;
	    }
	    if (Utils.framerStudioVersion() === oldDeviceMaxVersion) {
	      orientation *= -1;
	    }
	    if (orientation === "portrait") {
	      orientation = 0;
	    }
	    if (orientation === "landscape") {
	      orientation = 90;
	    }
	    if (this._shouldRenderFullScreen()) {
	      return;
	    }
	    orientation = parseInt(orientation);
	    if (orientation !== 0 && orientation !== 90 && orientation !== (-90)) {
	      return;
	    }
	    if (orientation === this._orientation) {
	      return;
	    }
	    this._orientation = orientation;
	    phoneProperties = {
	      rotationZ: -this._orientation,
	      scale: this._calculatePhoneScale()
	    };
	    ref = this._getOrientationDimensions(this._device.screenWidth, this._device.screenHeight), width = ref[0], height = ref[1];
	    this.content.width = width;
	    this.content.height = height;
	    offset = (this.screen.width - width) / 2;
	    if (this._orientation === -90) {
	      offset *= -1;
	    }
	    ref1 = [0, 0], x = ref1[0], y = ref1[1];
	    if (this.isLandscape()) {
	      x = offset;
	      y = offset;
	    }
	    contentProperties = {
	      rotationZ: this._orientation,
	      x: x,
	      y: y
	    };
	    this.hands.animateStop();
	    this.viewport.animateStop();
	    if (animate) {
	      animation = this.hands.animate(_.extend(this.animationOptions, {
	        properties: phoneProperties
	      }));
	      this.viewport.animate(_.extend(this.animationOptions, {
	        properties: contentProperties
	      }));
	      animation.on(Events.AnimationEnd, (function(_this) {
	        return function() {
	          return _this._update();
	        };
	      })(this));
	    } else {
	      this.hands.props = phoneProperties;
	      this.viewport.props = contentProperties;
	      this._update();
	    }
	    if (this._orientation !== 0) {
	      this.handsImageLayer.image = "";
	    }
	    return this.emit("change:orientation", this._orientation);
	  };
	
	  DeviceComponent.prototype._orientationChange = function() {
	    this._orientation = window.orientation;
	    this._update();
	    return this.emit("change:orientation", window.orientation);
	  };
	
	  DeviceComponent.prototype.isPortrait = function() {
	    return Math.abs(this.orientation) === 0;
	  };
	
	  DeviceComponent.prototype.isLandscape = function() {
	    return !this.isPortrait();
	  };
	
	  DeviceComponent.define("orientationName", {
	    get: function() {
	      if (this.isPortrait()) {
	        return "portrait";
	      }
	      if (this.isLandscape()) {
	        return "landscape";
	      }
	    },
	    set: function(orientationName) {
	      return this.setOrientation(orientationName, false);
	    }
	  });
	
	  DeviceComponent.prototype.rotateLeft = function(animate) {
	    if (animate == null) {
	      animate = true;
	    }
	    if (this.orientation === 90) {
	      return;
	    }
	    return this.setOrientation(this.orientation + 90, animate);
	  };
	
	  DeviceComponent.prototype.rotateRight = function(animate) {
	    if (animate == null) {
	      animate = true;
	    }
	    if (this.orientation === -90) {
	      return;
	    }
	    return this.setOrientation(this.orientation - 90, animate);
	  };
	
	  DeviceComponent.prototype._getOrientationDimensions = function(width, height) {
	    if (this.isLandscape()) {
	      return [height, width];
	    } else {
	      return [width, height];
	    }
	  };
	
	  DeviceComponent.prototype.handSwitchingSupported = function() {
	    return this._device.hands !== void 0;
	  };
	
	  DeviceComponent.prototype.nextHand = function() {
	    var hand, hands, nextHand, nextHandIndex;
	    if (this.hands.rotationZ !== 0) {
	      return;
	    }
	    if (this.handSwitchingSupported()) {
	      hands = _.keys(this._device.hands);
	      if (hands.length > 0) {
	        nextHandIndex = hands.indexOf(this.selectedHand) + 1;
	        nextHand = "";
	        if (nextHandIndex < hands.length) {
	          nextHand = hands[nextHandIndex];
	        }
	        hand = this.setHand(nextHand);
	        this._update();
	        return hand;
	      }
	    }
	    return false;
	  };
	
	  DeviceComponent.prototype.setHand = function(hand) {
	    var handData;
	    this.selectedHand = hand;
	    if (!hand || !this.handSwitchingSupported()) {
	      return this.handsImageLayer.image = "";
	    }
	    handData = this._device.hands[hand];
	    if (handData) {
	      this.hands.width = handData.width;
	      this.hands.height = handData.height;
	      this.hands.center();
	      this.phone.center();
	      this.handsImageLayer.size = this.hands.size;
	      this.handsImageLayer.y = 0;
	      if (handData.offset) {
	        this.handsImageLayer.y = handData.offset;
	      }
	      this.handsImageLayer.image = this.handImageUrl(hand);
	      return hand;
	    }
	  };
	
	  DeviceComponent.prototype.handImageUrl = function(hand) {
	    var resourceUrl;
	    resourceUrl = "//resources.framerjs.com/static/DeviceResources";
	    if (Utils.isFramerStudio() && window.FramerStudioInfo && Utils.framerStudioVersion() >= newDeviceMinVersion) {
	      resourceUrl = window.FramerStudioInfo.deviceImagesUrl;
	    }
	    return resourceUrl + "/" + hand + ".png";
	  };
	
	  return DeviceComponent;
	
	})(BaseClass);
	
	newDeviceMinVersion = 53;
	
	oldDeviceMaxVersion = 52;
	
	iPadAir2BaseDevice = {
	  deviceImageWidth: 1856,
	  deviceImageHeight: 2608,
	  deviceImageJP2: true,
	  screenWidth: 1536,
	  screenHeight: 2048,
	  deviceType: "phone",
	  minStudioVersion: newDeviceMinVersion
	};
	
	iPadMini4BaseDevice = {
	  deviceImageWidth: 1936,
	  deviceImageHeight: 2688,
	  deviceImageJP2: true,
	  screenWidth: 1536,
	  screenHeight: 2048,
	  deviceType: "phone",
	  minStudioVersion: newDeviceMinVersion
	};
	
	iPadProBaseDevice = {
	  deviceImageWidth: 2448,
	  deviceImageHeight: 3432,
	  deviceImageJP2: true,
	  screenWidth: 2048,
	  screenHeight: 2732,
	  deviceType: "phone",
	  minStudioVersion: newDeviceMinVersion
	};
	
	iPhone6BaseDevice = {
	  deviceImageWidth: 874,
	  deviceImageHeight: 1792,
	  deviceImageJP2: true,
	  screenWidth: 750,
	  screenHeight: 1334,
	  deviceType: "phone",
	  minStudioVersion: newDeviceMinVersion,
	  hands: {
	    "iphone-hands-2": {
	      width: 2400,
	      height: 3740
	    },
	    "iphone-hands-1": {
	      width: 2400,
	      height: 3740
	    }
	  }
	};
	
	iPhone6PlusBaseDevice = {
	  deviceImageWidth: 1452,
	  deviceImageHeight: 2968,
	  deviceImageJP2: true,
	  screenWidth: 1242,
	  screenHeight: 2208,
	  deviceType: "phone",
	  minStudioVersion: newDeviceMinVersion,
	  hands: {
	    "iphone-hands-2": {
	      width: 3987,
	      height: 6212
	    },
	    "iphone-hands-1": {
	      width: 3987,
	      height: 6212
	    }
	  }
	};
	
	iPhone5BaseDevice = {
	  deviceImageWidth: 768,
	  deviceImageHeight: 1612,
	  deviceImageJP2: true,
	  screenWidth: 640,
	  screenHeight: 1136,
	  deviceType: "phone",
	  minStudioVersion: newDeviceMinVersion,
	  hands: {
	    "iphone-hands-2": {
	      width: 2098,
	      height: 3269,
	      offset: 19
	    },
	    "iphone-hands-1": {
	      width: 2098,
	      height: 3269,
	      offset: 19
	    }
	  }
	};
	
	iPhone5CBaseDevice = {
	  deviceImageWidth: 776,
	  deviceImageHeight: 1620,
	  deviceImageJP2: true,
	  screenWidth: 640,
	  screenHeight: 1136,
	  deviceType: "phone",
	  minStudioVersion: newDeviceMinVersion,
	  hands: {
	    "iphone-hands-2": {
	      width: 2098,
	      height: 3269,
	      offset: 28
	    },
	    "iphone-hands-1": {
	      width: 2098,
	      height: 3269,
	      offset: 28
	    }
	  }
	};
	
	Nexus4BaseDevice = {
	  deviceImageWidth: 860,
	  deviceImageHeight: 1668,
	  deviceImageJP2: true,
	  screenWidth: 768,
	  screenHeight: 1280,
	  deviceType: "phone",
	  minStudioVersion: newDeviceMinVersion,
	  hands: {
	    "iphone-hands-2": {
	      width: 2362,
	      height: 3681,
	      offset: -52
	    },
	    "iphone-hands-1": {
	      width: 2362,
	      height: 3681,
	      offset: -52
	    }
	  }
	};
	
	Nexus5BaseDevice = {
	  deviceImageWidth: 1204,
	  deviceImageHeight: 2432,
	  deviceImageJP2: true,
	  screenWidth: 1080,
	  screenHeight: 1920,
	  deviceType: "phone",
	  minStudioVersion: newDeviceMinVersion,
	  hands: {
	    "iphone-hands-2": {
	      width: 3292,
	      height: 5130,
	      offset: 8
	    },
	    "iphone-hands-1": {
	      width: 3292,
	      height: 5130,
	      offset: 8
	    }
	  }
	};
	
	Nexus6BaseDevice = {
	  deviceImageWidth: 1576,
	  deviceImageHeight: 3220,
	  deviceImageJP2: true,
	  screenWidth: 1440,
	  screenHeight: 2560,
	  deviceType: "phone",
	  minStudioVersion: newDeviceMinVersion,
	  hands: {
	    "iphone-hands-2": {
	      width: 4304,
	      height: 6707,
	      offset: 8
	    },
	    "iphone-hands-1": {
	      width: 4304,
	      height: 6707,
	      offset: 8
	    }
	  }
	};
	
	Nexus9BaseDevice = {
	  deviceImageWidth: 1896,
	  deviceImageHeight: 2648,
	  deviceImageJP2: true,
	  screenWidth: 1536,
	  screenHeight: 2048,
	  deviceType: "phone",
	  minStudioVersion: newDeviceMinVersion
	};
	
	HTCa9BaseDevice = {
	  deviceImageWidth: 1252,
	  deviceImageHeight: 2592,
	  deviceImageJP2: true,
	  screenWidth: 1080,
	  screenHeight: 1920,
	  deviceType: "phone",
	  minStudioVersion: newDeviceMinVersion,
	  hands: {
	    "iphone-hands-2": {
	      width: 3436,
	      height: 5354,
	      offset: 36
	    },
	    "iphone-hands-1": {
	      width: 3436,
	      height: 5354,
	      offset: 36
	    }
	  }
	};
	
	HTCm8BaseDevice = {
	  deviceImageWidth: 1232,
	  deviceImageHeight: 2572,
	  deviceImageJP2: true,
	  screenWidth: 1080,
	  screenHeight: 1920,
	  deviceType: "phone",
	  minStudioVersion: newDeviceMinVersion,
	  hands: {
	    "iphone-hands-2": {
	      width: 3436,
	      height: 5354,
	      offset: 12
	    },
	    "iphone-hands-1": {
	      width: 3436,
	      height: 5354,
	      offset: 12
	    }
	  }
	};
	
	MSFTLumia950BaseDevice = {
	  deviceImageWidth: 1660,
	  deviceImageHeight: 3292,
	  deviceImageJP2: true,
	  screenWidth: 1440,
	  screenHeight: 2560,
	  deviceType: "phone",
	  minStudioVersion: newDeviceMinVersion,
	  hands: {
	    "iphone-hands-2": {
	      width: 4494,
	      height: 7003,
	      offset: -84
	    },
	    "iphone-hands-1": {
	      width: 4494,
	      height: 7003,
	      offset: -84
	    }
	  }
	};
	
	SamsungGalaxyNote5BaseDevice = {
	  deviceImageWidth: 1572,
	  deviceImageHeight: 3140,
	  deviceImageJP2: true,
	  screenWidth: 1440,
	  screenHeight: 2560,
	  deviceType: "phone",
	  minStudioVersion: newDeviceMinVersion,
	  hands: {
	    "iphone-hands-2": {
	      width: 4279,
	      height: 6668,
	      offset: -24
	    },
	    "iphone-hands-1": {
	      width: 4279,
	      height: 6668,
	      offset: -84
	    }
	  }
	};
	
	AppleWatch42Device = {
	  deviceImageWidth: 512,
	  deviceImageHeight: 990,
	  deviceImageJP2: true,
	  screenWidth: 312,
	  screenHeight: 390,
	  minStudioVersion: newDeviceMinVersion
	};
	
	AppleWatch38Device = {
	  deviceImageWidth: 472,
	  deviceImageHeight: 772,
	  deviceImageJP2: true,
	  screenWidth: 272,
	  screenHeight: 340,
	  minStudioVersion: newDeviceMinVersion
	};
	
	AppleWatch38BlackLeatherDevice = {
	  deviceImageWidth: 472,
	  deviceImageHeight: 796,
	  deviceImageJP2: true,
	  screenWidth: 272,
	  screenHeight: 340,
	  minStudioVersion: newDeviceMinVersion
	};
	
	old_iPhone6BaseDevice = {
	  deviceImageWidth: 870,
	  deviceImageHeight: 1738,
	  deviceImageJP2: true,
	  screenWidth: 750,
	  screenHeight: 1334,
	  deviceType: "phone",
	  maxStudioVersion: oldDeviceMaxVersion
	};
	
	old_iPhone6BaseDeviceHand = _.extend({}, old_iPhone6BaseDevice, {
	  deviceImageWidth: 1988,
	  deviceImageHeight: 2368,
	  deviceImageJP2: true,
	  paddingOffset: -150,
	  maxStudioVersion: oldDeviceMaxVersion
	});
	
	old_iPhone6PlusBaseDevice = {
	  deviceImageWidth: 1460,
	  deviceImageHeight: 2900,
	  deviceImageJP2: true,
	  screenWidth: 1242,
	  screenHeight: 2208,
	  deviceType: "phone",
	  maxStudioVersion: oldDeviceMaxVersion
	};
	
	old_iPhone6PlusBaseDeviceHand = _.extend({}, old_iPhone6PlusBaseDevice, {
	  deviceImageWidth: 3128,
	  deviceImageHeight: 3487,
	  deviceImageJP2: true,
	  paddingOffset: -150,
	  maxStudioVersion: oldDeviceMaxVersion
	});
	
	old_iPhone5BaseDevice = {
	  deviceImageWidth: 780,
	  deviceImageHeight: 1608,
	  deviceImageJP2: true,
	  screenWidth: 640,
	  screenHeight: 1136,
	  deviceType: "phone",
	  maxStudioVersion: oldDeviceMaxVersion
	};
	
	old_iPhone5BaseDeviceHand = _.extend({}, old_iPhone5BaseDevice, {
	  deviceImageWidth: 1884,
	  deviceImageHeight: 2234,
	  deviceImageJP2: true,
	  paddingOffset: -200,
	  maxStudioVersion: oldDeviceMaxVersion
	});
	
	old_iPhone5CBaseDevice = {
	  deviceImageWidth: 776,
	  deviceImageHeight: 1612,
	  deviceImageJP2: true,
	  screenWidth: 640,
	  screenHeight: 1136,
	  deviceType: "phone",
	  maxStudioVersion: oldDeviceMaxVersion
	};
	
	old_iPhone5CBaseDeviceHand = _.extend({}, old_iPhone5CBaseDevice, {
	  deviceImageWidth: 1894,
	  deviceImageHeight: 2244,
	  deviceImageJP2: true,
	  paddingOffset: -200,
	  maxStudioVersion: oldDeviceMaxVersion
	});
	
	old_iPadMiniBaseDevice = {
	  deviceImageWidth: 872,
	  deviceImageHeight: 1292,
	  deviceImageJP2: true,
	  screenWidth: 768,
	  screenHeight: 1024,
	  deviceType: "tablet",
	  maxStudioVersion: oldDeviceMaxVersion
	};
	
	old_iPadMiniBaseDeviceHand = _.extend({}, old_iPadMiniBaseDevice, {
	  deviceImageWidth: 1380,
	  deviceImageHeight: 2072,
	  deviceImageJP2: true,
	  paddingOffset: -120,
	  maxStudioVersion: oldDeviceMaxVersion
	});
	
	old_iPadAirBaseDevice = {
	  deviceImageWidth: 1769,
	  deviceImageHeight: 2509,
	  deviceImageJP2: true,
	  screenWidth: 1536,
	  screenHeight: 2048,
	  deviceType: "tablet",
	  maxStudioVersion: oldDeviceMaxVersion
	};
	
	old_iPadAirBaseDeviceHand = _.extend({}, old_iPadAirBaseDevice, {
	  deviceImageWidth: 4744,
	  deviceImageHeight: 4101,
	  deviceImageJP2: true,
	  paddingOffset: -120,
	  maxStudioVersion: oldDeviceMaxVersion
	});
	
	old_Nexus5BaseDevice = {
	  deviceImageWidth: 1208,
	  deviceImageHeight: 2440,
	  deviceImageJP2: true,
	  screenWidth: 1080,
	  screenHeight: 1920,
	  deviceType: "phone",
	  maxStudioVersion: oldDeviceMaxVersion
	};
	
	old_Nexus5BaseDeviceHand = _.extend({}, old_Nexus5BaseDevice, {
	  deviceImageWidth: 2692,
	  deviceImageHeight: 2996,
	  deviceImageJP2: true,
	  paddingOffset: -120,
	  maxStudioVersion: oldDeviceMaxVersion
	});
	
	old_Nexus9BaseDevice = {
	  deviceImageWidth: 1733,
	  deviceImageHeight: 2575,
	  deviceImageJP2: true,
	  screenWidth: 1536,
	  screenHeight: 2048,
	  deviceType: "tablet",
	  maxStudioVersion: oldDeviceMaxVersion
	};
	
	old_AppleWatch42Device = {
	  deviceImageWidth: 552,
	  deviceImageHeight: 938,
	  deviceImageJP2: true,
	  screenWidth: 312,
	  screenHeight: 390,
	  maxStudioVersion: oldDeviceMaxVersion
	};
	
	old_AppleWatch38Device = {
	  deviceImageWidth: 508,
	  deviceImageHeight: 900,
	  deviceImageJP2: true,
	  screenWidth: 272,
	  screenHeight: 340,
	  maxStudioVersion: oldDeviceMaxVersion
	};
	
	Devices = {
	  "fullscreen": {
	    name: "Fullscreen",
	    deviceType: "desktop",
	    backgroundColor: "white"
	  },
	  "apple-ipad-air-2-silver": _.clone(iPadAir2BaseDevice),
	  "apple-ipad-air-2-gold": _.clone(iPadAir2BaseDevice),
	  "apple-ipad-air-2-space-gray": _.clone(iPadAir2BaseDevice),
	  "apple-ipad-mini-4-silver": _.clone(iPadMini4BaseDevice),
	  "apple-ipad-mini-4-gold": _.clone(iPadMini4BaseDevice),
	  "apple-ipad-mini-4-space-gray": _.clone(iPadMini4BaseDevice),
	  "apple-ipad-pro-silver": _.clone(iPadProBaseDevice),
	  "apple-ipad-pro-gold": _.clone(iPadProBaseDevice),
	  "apple-ipad-pro-space-gray": _.clone(iPadProBaseDevice),
	  "apple-iphone-6s-gold": _.clone(iPhone6BaseDevice),
	  "apple-iphone-6s-rose-gold": _.clone(iPhone6BaseDevice),
	  "apple-iphone-6s-silver": _.clone(iPhone6BaseDevice),
	  "apple-iphone-6s-space-gray": _.clone(iPhone6BaseDevice),
	  "apple-iphone-6s-plus-gold": _.clone(iPhone6PlusBaseDevice),
	  "apple-iphone-6s-plus-rose-gold": _.clone(iPhone6PlusBaseDevice),
	  "apple-iphone-6s-plus-silver": _.clone(iPhone6PlusBaseDevice),
	  "apple-iphone-6s-plus-space-gray": _.clone(iPhone6PlusBaseDevice),
	  "apple-iphone-5s-gold": _.clone(iPhone5BaseDevice),
	  "apple-iphone-5s-silver": _.clone(iPhone5BaseDevice),
	  "apple-iphone-5s-space-gray": _.clone(iPhone5BaseDevice),
	  "apple-iphone-5c-blue": _.clone(iPhone5CBaseDevice),
	  "apple-iphone-5c-green": _.clone(iPhone5CBaseDevice),
	  "apple-iphone-5c-red": _.clone(iPhone5CBaseDevice),
	  "apple-iphone-5c-white": _.clone(iPhone5CBaseDevice),
	  "apple-iphone-5c-yellow": _.clone(iPhone5CBaseDevice),
	  "apple-watch-38mm-gold-black-leather-closed": _.clone(AppleWatch38BlackLeatherDevice),
	  "apple-watch-38mm-rose-gold-black-leather-closed": _.clone(AppleWatch38BlackLeatherDevice),
	  "apple-watch-38mm-stainless-steel-black-leather-closed": _.clone(AppleWatch38BlackLeatherDevice),
	  "apple-watch-38mm-black-steel-black-closed": _.clone(AppleWatch38Device),
	  "apple-watch-38mm-gold-midnight-blue-closed": _.clone(AppleWatch38Device),
	  "apple-watch-38mm-rose-gold-lavender-closed": _.clone(AppleWatch38Device),
	  "apple-watch-38mm-sport-aluminum-blue-closed": _.clone(AppleWatch38Device),
	  "apple-watch-38mm-sport-aluminum-fog-closed": _.clone(AppleWatch38Device),
	  "apple-watch-38mm-sport-aluminum-green-closed": _.clone(AppleWatch38Device),
	  "apple-watch-38mm-sport-aluminum-red-closed": _.clone(AppleWatch38Device),
	  "apple-watch-38mm-sport-aluminum-walnut-closed": _.clone(AppleWatch38Device),
	  "apple-watch-38mm-sport-aluminum-white-closed": _.clone(AppleWatch38Device),
	  "apple-watch-38mm-sport-aluminum-gold-antique-white-closed": _.clone(AppleWatch38Device),
	  "apple-watch-38mm-sport-aluminum-rose-gold-stone-closed": _.clone(AppleWatch38Device),
	  "apple-watch-38mm-sport-space-gray-black-closed": _.clone(AppleWatch38Device),
	  "apple-watch-42mm-black-steel-black-closed": _.clone(AppleWatch42Device),
	  "apple-watch-42mm-gold-black-leather-closed": _.clone(AppleWatch42Device),
	  "apple-watch-42mm-gold-midnight-blue-closed": _.clone(AppleWatch42Device),
	  "apple-watch-42mm-rose-gold-black-leather-closed": _.clone(AppleWatch42Device),
	  "apple-watch-42mm-rose-gold-lavender-closed": _.clone(AppleWatch42Device),
	  "apple-watch-42mm-sport-aluminum-blue-closed": _.clone(AppleWatch42Device),
	  "apple-watch-42mm-sport-aluminum-fog-closed": _.clone(AppleWatch42Device),
	  "apple-watch-42mm-sport-aluminum-green-closed": _.clone(AppleWatch42Device),
	  "apple-watch-42mm-sport-aluminum-red-closed": _.clone(AppleWatch42Device),
	  "apple-watch-42mm-sport-aluminum-walnut-closed": _.clone(AppleWatch42Device),
	  "apple-watch-42mm-sport-aluminum-white-closed": _.clone(AppleWatch42Device),
	  "apple-watch-42mm-sport-aluminum-gold-antique-white-closed": _.clone(AppleWatch42Device),
	  "apple-watch-42mm-sport-aluminum-rose-gold-stone-closed": _.clone(AppleWatch42Device),
	  "apple-watch-42mm-sport-space-gray-black-closed": _.clone(AppleWatch42Device),
	  "apple-watch-42mm-stainless-steel-black-leather-closed": _.clone(AppleWatch42Device),
	  "google-nexus-4": _.clone(Nexus4BaseDevice),
	  "google-nexus-5x": _.clone(Nexus5BaseDevice),
	  "google-nexus-6p": _.clone(Nexus6BaseDevice),
	  "google-nexus-9": _.clone(Nexus9BaseDevice),
	  "htc-one-a9-black": _.clone(HTCa9BaseDevice),
	  "htc-one-a9-white": _.clone(HTCa9BaseDevice),
	  "htc-one-m8-black": _.clone(HTCm8BaseDevice),
	  "htc-one-m8-gold": _.clone(HTCm8BaseDevice),
	  "htc-one-m8-silver": _.clone(HTCm8BaseDevice),
	  "microsoft-lumia-950-black": _.clone(MSFTLumia950BaseDevice),
	  "microsoft-lumia-950-white": _.clone(MSFTLumia950BaseDevice),
	  "samsung-galaxy-note-5-black": _.clone(SamsungGalaxyNote5BaseDevice),
	  "samsung-galaxy-note-5-gold": _.clone(SamsungGalaxyNote5BaseDevice),
	  "samsung-galaxy-note-5-pink": _.clone(SamsungGalaxyNote5BaseDevice),
	  "samsung-galaxy-note-5-silver-titanium": _.clone(SamsungGalaxyNote5BaseDevice),
	  "samsung-galaxy-note-5-white": _.clone(SamsungGalaxyNote5BaseDevice),
	  "desktop-safari-1024-600": {
	    deviceType: "browser",
	    name: "Desktop Safari 1024 x 600",
	    screenWidth: 1024,
	    screenHeight: 600,
	    deviceImageWidth: 1136,
	    deviceImageHeight: 760,
	    deviceImageJP2: true,
	    backgroundColor: "white"
	  },
	  "desktop-safari-1280-800": {
	    deviceType: "browser",
	    name: "Desktop Safari 1280 x 800",
	    screenWidth: 1280,
	    screenHeight: 800,
	    deviceImageWidth: 1392,
	    deviceImageHeight: 960,
	    deviceImageJP2: true,
	    backgroundColor: "white"
	  },
	  "desktop-safari-1440-900": {
	    deviceType: "browser",
	    name: "Desktop Safari 1440 x 900",
	    screenWidth: 1440,
	    screenHeight: 900,
	    deviceImageWidth: 1552,
	    deviceImageHeight: 1060,
	    deviceImageJP2: true,
	    backgroundColor: "white"
	  },
	  "iphone-6-spacegray": _.clone(old_iPhone6BaseDevice),
	  "iphone-6-spacegray-hand": _.clone(old_iPhone6BaseDeviceHand),
	  "iphone-6-silver": _.clone(old_iPhone6BaseDevice),
	  "iphone-6-silver-hand": _.clone(old_iPhone6BaseDeviceHand),
	  "iphone-6-gold": _.clone(old_iPhone6BaseDevice),
	  "iphone-6-gold-hand": _.clone(old_iPhone6BaseDeviceHand),
	  "iphone-6plus-spacegray": _.clone(old_iPhone6PlusBaseDevice),
	  "iphone-6plus-spacegray-hand": _.clone(old_iPhone6PlusBaseDeviceHand),
	  "iphone-6plus-silver": _.clone(old_iPhone6PlusBaseDevice),
	  "iphone-6plus-silver-hand": _.clone(old_iPhone6PlusBaseDeviceHand),
	  "iphone-6plus-gold": _.clone(old_iPhone6PlusBaseDevice),
	  "iphone-6plus-gold-hand": _.clone(old_iPhone6PlusBaseDeviceHand),
	  "iphone-5s-spacegray": _.clone(old_iPhone5BaseDevice),
	  "iphone-5s-spacegray-hand": _.clone(old_iPhone5BaseDeviceHand),
	  "iphone-5s-silver": _.clone(old_iPhone5BaseDevice),
	  "iphone-5s-silver-hand": _.clone(old_iPhone5BaseDeviceHand),
	  "iphone-5s-gold": _.clone(old_iPhone5BaseDevice),
	  "iphone-5s-gold-hand": _.clone(old_iPhone5BaseDeviceHand),
	  "iphone-5c-green": _.clone(old_iPhone5CBaseDevice),
	  "iphone-5c-green-hand": _.clone(old_iPhone5CBaseDeviceHand),
	  "iphone-5c-blue": _.clone(old_iPhone5CBaseDevice),
	  "iphone-5c-blue-hand": _.clone(old_iPhone5CBaseDeviceHand),
	  "iphone-5c-pink": _.clone(old_iPhone5CBaseDevice),
	  "iphone-5c-pink-hand": _.clone(old_iPhone5CBaseDeviceHand),
	  "iphone-5c-white": _.clone(old_iPhone5CBaseDevice),
	  "iphone-5c-white-hand": _.clone(old_iPhone5CBaseDeviceHand),
	  "iphone-5c-yellow": _.clone(old_iPhone5CBaseDevice),
	  "iphone-5c-yellow-hand": _.clone(old_iPhone5CBaseDeviceHand),
	  "ipad-mini-spacegray": _.clone(old_iPadMiniBaseDevice),
	  "ipad-mini-spacegray-hand": _.clone(old_iPadMiniBaseDeviceHand),
	  "ipad-mini-silver": _.clone(old_iPadMiniBaseDevice),
	  "ipad-mini-silver-hand": _.clone(old_iPadMiniBaseDeviceHand),
	  "ipad-air-spacegray": _.clone(old_iPadAirBaseDevice),
	  "ipad-air-spacegray-hand": _.clone(old_iPadAirBaseDeviceHand),
	  "ipad-air-silver": _.clone(old_iPadAirBaseDevice),
	  "ipad-air-silver-hand": _.clone(old_iPadAirBaseDeviceHand),
	  "nexus-5-black": _.clone(old_Nexus5BaseDevice),
	  "nexus-5-black-hand": _.clone(old_Nexus5BaseDeviceHand),
	  "nexus-9": _.clone(old_Nexus9BaseDevice),
	  "applewatchsport-38-aluminum-sportband-black": _.clone(old_AppleWatch38Device),
	  "applewatchsport-38-aluminum-sportband-blue": _.clone(old_AppleWatch38Device),
	  "applewatchsport-38-aluminum-sportband-green": _.clone(old_AppleWatch38Device),
	  "applewatchsport-38-aluminum-sportband-pink": _.clone(old_AppleWatch38Device),
	  "applewatchsport-38-aluminum-sportband-white": _.clone(old_AppleWatch38Device),
	  "applewatch-38-black-bracelet": _.clone(old_AppleWatch38Device),
	  "applewatch-38-steel-bracelet": _.clone(old_AppleWatch38Device),
	  "applewatchedition-38-gold-buckle-blue": _.clone(old_AppleWatch38Device),
	  "applewatchedition-38-gold-buckle-gray": _.clone(old_AppleWatch38Device),
	  "applewatchedition-38-gold-buckle-red": _.clone(old_AppleWatch38Device),
	  "applewatchedition-38-gold-sportband-black": _.clone(old_AppleWatch38Device),
	  "applewatchedition-38-gold-sportband-white": _.clone(old_AppleWatch38Device),
	  "applewatchsport-42-aluminum-sportband-black": _.clone(old_AppleWatch42Device),
	  "applewatchsport-42-aluminum-sportband-blue": _.clone(old_AppleWatch42Device),
	  "applewatchsport-42-aluminum-sportband-green": _.clone(old_AppleWatch42Device),
	  "applewatchsport-42-aluminum-sportband-pink": _.clone(old_AppleWatch42Device),
	  "applewatchsport-42-aluminum-sportband-white": _.clone(old_AppleWatch42Device),
	  "applewatch-42-black-bracelet": _.clone(old_AppleWatch42Device),
	  "applewatch-42-steel-bracelet": _.clone(old_AppleWatch42Device),
	  "applewatchedition-42-gold-buckle-blue": _.clone(old_AppleWatch42Device),
	  "applewatchedition-42-gold-buckle-gray": _.clone(old_AppleWatch42Device),
	  "applewatchedition-42-gold-buckle-red": _.clone(old_AppleWatch42Device),
	  "applewatchedition-42-gold-sportband-black": _.clone(old_AppleWatch42Device),
	  "applewatchedition-42-gold-sportband-white": _.clone(old_AppleWatch42Device)
	};
	
	exports.DeviceComponent.Devices = Devices;
	
	BuiltInDevices = _.keys(Devices);


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	var Config, EventEmitter, Utils, _, getTime,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	_ = __webpack_require__(1)._;
	
	Utils = __webpack_require__(4);
	
	Config = __webpack_require__(14).Config;
	
	EventEmitter = __webpack_require__(7).EventEmitter;
	
	getTime = function() {
	  return Utils.getTime() * 1000;
	};
	
	exports.AnimationLoop = (function(superClass) {
	  extend(AnimationLoop, superClass);
	
	  function AnimationLoop() {
	    this.start = bind(this.start, this);
	    this.delta = 1 / 60;
	    this.raf = true;
	    if (Utils.webkitVersion() > 600 && Utils.webkitVersion() < 601) {
	      if (Utils.isFramerStudio() || Utils.isDesktop()) {
	        this.raf = false;
	      }
	    }
	    this.maximumListeners = Infinity;
	  }
	
	  AnimationLoop.prototype.start = function() {
	    var _timestamp, animationLoop, tick, update;
	    animationLoop = this;
	    _timestamp = getTime();
	    update = function() {
	      var delta, timestamp;
	      if (animationLoop.delta) {
	        delta = animationLoop.delta;
	      } else {
	        timestamp = getTime();
	        delta = (timestamp - _timestamp) / 1000;
	        _timestamp = timestamp;
	      }
	      animationLoop.emit("update", delta);
	      return animationLoop.emit("render", delta);
	    };
	    tick = function(timestamp) {
	      if (animationLoop.raf) {
	        update();
	        return window.requestAnimationFrame(tick);
	      } else {
	        return window.setTimeout(function() {
	          update();
	          return window.requestAnimationFrame(tick);
	        }, 0);
	      }
	    };
	    return tick();
	  };
	
	  return AnimationLoop;
	
	})(EventEmitter);


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	var ChromeAlert, Utils, _, getScaleFromName, resizeFrame, sanitizeLayerName, startsWithNumber;
	
	_ = __webpack_require__(1)._;
	
	Utils = __webpack_require__(4);
	
	ChromeAlert = "Importing layers is currently only supported on Safari. If you really want it to work with Chrome quit it, open a terminal and run:\nopen -a Google\ Chrome -–allow-file-access-from-files";
	
	resizeFrame = function(scale, frame) {
	  var i, key, len, ref, result;
	  if (scale === 1) {
	    return frame;
	  }
	  result = {};
	  ref = ["x", "y", "width", "height"];
	  for (i = 0, len = ref.length; i < len; i++) {
	    key = ref[i];
	    if (frame.hasOwnProperty(key)) {
	      result[key] = frame[key] * scale;
	    }
	  }
	  return result;
	};
	
	getScaleFromName = function(str) {
	  var m, re;
	  re = /@([\d]+|[\d]+.[\d]+)x/;
	  m = void 0;
	  if ((m = re.exec(str)) !== null) {
	    if (m[1]) {
	      return parseFloat(m[1]);
	    }
	  }
	  return null;
	};
	
	startsWithNumber = function(str) {
	  return (new RegExp("^[0-9]")).test(str);
	};
	
	sanitizeLayerName = function(name) {
	  var i, len, ref, suffix;
	  ref = ["*", "-", ".png", ".jpg", ".pdf"];
	  for (i = 0, len = ref.length; i < len; i++) {
	    suffix = ref[i];
	    if (_.endsWith(name.toLowerCase(), suffix)) {
	      name = name.slice(0, +(name.length - suffix.length - 1) + 1 || 9e9);
	    }
	  }
	  return name;
	};
	
	exports.Importer = (function() {
	  function Importer(path1, scale1, extraLayerProperties) {
	    this.path = path1;
	    this.scale = scale1 != null ? scale1 : 1;
	    this.extraLayerProperties = extraLayerProperties != null ? extraLayerProperties : {};
	    this.paths = {
	      layerInfo: Utils.pathJoin(this.path, "layers.json"),
	      images: Utils.pathJoin(this.path, "images"),
	      documentName: this.path.split("/").pop()
	    };
	    this._createdLayers = [];
	    this._createdLayersByName = {};
	  }
	
	  Importer.prototype.load = function() {
	    var i, j, layer, layerInfo, layersByName, len, len1, ref, ref1;
	    layersByName = {};
	    layerInfo = this._loadlayerInfo();
	    if (layerInfo.length === 0) {
	      throw new Error("Importer: no layers. Do you have at least one layer group?");
	    }
	    layerInfo.map((function(_this) {
	      return function(layerItemInfo) {
	        return _this._createLayer(layerItemInfo);
	      };
	    })(this));
	    ref = this._createdLayers;
	    for (i = 0, len = ref.length; i < len; i++) {
	      layer = ref[i];
	      this._correctLayer(layer);
	    }
	    this._correctArtboards(this._createdLayers);
	    ref1 = this._createdLayers;
	    for (j = 0, len1 = ref1.length; j < len1; j++) {
	      layer = ref1[j];
	      if (!layer.parent) {
	        layer.parent = null;
	      }
	    }
	    return this._createdLayersByName;
	  };
	
	  Importer.prototype._loadlayerInfo = function() {
	    var importedKey, ref;
	    importedKey = this.paths.documentName + "/layers.json.js";
	    if ((ref = window.__imported__) != null ? ref.hasOwnProperty(importedKey) : void 0) {
	      return _.cloneDeep(window.__imported__[importedKey]);
	    }
	    return Framer.Utils.domLoadJSONSync(this.paths.layerInfo);
	  };
	
	  Importer.prototype._createLayer = function(info, parent) {
	    var LayerClass, layer, layerInfo, ref, ref1;
	    if (info.layerFrame) {
	      info.layerFrame = resizeFrame(this.scale, info.layerFrame);
	    }
	    if (info.maskFrame) {
	      info.maskFrame = resizeFrame(this.scale, info.maskFrame);
	    }
	    if (((ref = info.image) != null ? ref.frame : void 0) != null) {
	      info.image.frame = resizeFrame(this.scale, info.image.frame);
	    }
	    if (!info.children) {
	      info.children = [];
	    }
	    LayerClass = Layer;
	    layerInfo = {
	      shadow: true,
	      name: sanitizeLayerName(info.name),
	      frame: info.layerFrame,
	      clip: false,
	      backgroundColor: null,
	      visible: (ref1 = info.visible) != null ? ref1 : true
	    };
	    _.extend(layerInfo, this.extraLayerProperties);
	    if (info.image) {
	      layerInfo.frame = info.image.frame;
	      layerInfo.image = Utils.pathJoin(this.path, info.image.path);
	    }
	    if (info.maskFrame) {
	      layerInfo.clip = true;
	    }
	    if (info.kind === "artboard") {
	      layerInfo.backgroundColor = info.backgroundColor;
	    }
	    if (parent != null ? parent.contentLayer : void 0) {
	      layerInfo.parent = parent.contentLayer;
	    } else if (parent) {
	      layerInfo.parent = parent;
	    }
	    if (startsWithNumber(layerInfo.name)) {
	      throw new Error("(" + layerInfo.name + ") Layer or Artboard names can not start with a number");
	    }
	    layer = new LayerClass(layerInfo);
	    layer.name = layerInfo.name;
	    layer.__framerImportedFromPath = this.path;
	    if (layerInfo.name.toLowerCase().indexOf("scroll") !== -1) {
	      layer.scroll = true;
	    }
	    if (layerInfo.name.toLowerCase().indexOf("draggable") !== -1) {
	      layer.draggable.enabled = true;
	    }
	    if (!layer.image && !info.children.length && !info.maskFrame) {
	      layer.frame = Utils.frameZero();
	    }
	    _.clone(info.children).reverse().map((function(_this) {
	      return function(info) {
	        return _this._createLayer(info, layer);
	      };
	    })(this));
	    if (info.kind === "artboard") {
	      layer.point = {
	        x: 0,
	        y: 0
	      };
	    } else if (!layer.image && !info.maskFrame) {
	      layer.frame = layer.contentFrame();
	    }
	    layer._info = info;
	    this._createdLayers.push(layer);
	    return this._createdLayersByName[layer.name] = layer;
	  };
	
	  Importer.prototype._correctArtboards = function(layers) {
	    var i, j, layer, leftMostLayer, len, len1, pointOffset, results;
	    leftMostLayer = null;
	    for (i = 0, len = layers.length; i < len; i++) {
	      layer = layers[i];
	      if (layer._info.kind === "artboard") {
	        layer.point = layer._info.layerFrame;
	        layer.visible = true;
	        if (leftMostLayer === null || layer.x < leftMostLayer.x) {
	          leftMostLayer = layer;
	        }
	      }
	    }
	    if (!leftMostLayer) {
	      return;
	    }
	    pointOffset = leftMostLayer.point;
	    results = [];
	    for (j = 0, len1 = layers.length; j < len1; j++) {
	      layer = layers[j];
	      if (layer._info.kind === "artboard") {
	        layer.x -= pointOffset.x;
	        results.push(layer.y -= pointOffset.y);
	      } else {
	        results.push(void 0);
	      }
	    }
	    return results;
	  };
	
	  Importer.prototype._correctLayer = function(layer) {
	    var traverse;
	    traverse = function(layer) {
	      var child, i, len, ref, results;
	      if (layer.parent) {
	        layer.frame = Utils.convertPoint(layer.frame, null, layer.parent);
	      }
	      ref = layer.children;
	      results = [];
	      for (i = 0, len = ref.length; i < len; i++) {
	        child = ref[i];
	        results.push(traverse(child));
	      }
	      return results;
	    };
	    if (!layer.parent) {
	      return traverse(layer);
	    }
	  };
	
	  return Importer;
	
	})();
	
	exports.Importer.load = function(path, scale) {
	  var importer;
	  if (scale == null) {
	    scale = getScaleFromName(path);
	  }
	  if (scale == null) {
	    scale = 1;
	  }
	  importer = new exports.Importer(path, scale);
	  return importer.load();
	};


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	exports.TouchEmulator = __webpack_require__(50);
	
	exports.MobileScrollFix = __webpack_require__(51);
	
	exports.OmitNew = __webpack_require__(52);


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	var BaseClass, TouchEmulator, Utils, cancelEvent, createTouch, dispatchTouchEvent, touchEmulator,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	Utils = __webpack_require__(4);
	
	BaseClass = __webpack_require__(6).BaseClass;
	
	createTouch = function(event, identifier, offset) {
	  var touch;
	  if (offset == null) {
	    offset = {
	      x: 0,
	      y: 0
	    };
	  }
	  return touch = {
	    identifier: identifier,
	    target: event.target,
	    pageX: event.pageX - offset.x,
	    pageY: event.pageY - offset.y,
	    clientX: event.clientX - offset.x,
	    clientY: event.clientY - offset.y,
	    screenX: event.screenX - offset.x,
	    screenY: event.screenY - offset.y
	  };
	};
	
	dispatchTouchEvent = function(type, target, event, offset) {
	  var touchEvent, touches;
	  if (target == null) {
	    target = event.target;
	  }
	  touchEvent = document.createEvent("MouseEvent");
	  touchEvent.initMouseEvent(type, true, true, window, event.detail, event.screenX, event.screenY, event.clientX, event.clientY, event.ctrlKey, event.shiftKey, event.altKey, event.metaKey, event.button, event.relatedTarget);
	  touches = [];
	  touches.push(createTouch(event, 1));
	  if (offset) {
	    touches.push(createTouch(event, 2, offset));
	  }
	  touchEvent.touches = touchEvent.changedTouches = touchEvent.targetTouches = touches;
	  return target.dispatchEvent(touchEvent);
	};
	
	cancelEvent = function(event) {
	  event.preventDefault();
	  return event.stopPropagation();
	};
	
	TouchEmulator = (function(superClass) {
	  extend(TouchEmulator, superClass);
	
	  function TouchEmulator() {
	    this.mousemovePosition = bind(this.mousemovePosition, this);
	    this.mouseout = bind(this.mouseout, this);
	    this.mouseup = bind(this.mouseup, this);
	    this.mousemove = bind(this.mousemove, this);
	    this.mousedown = bind(this.mousedown, this);
	    this.keyup = bind(this.keyup, this);
	    this.keydown = bind(this.keydown, this);
	    var touchPointerInitialOffset;
	    this.touchPointerImage = "url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAAAXNSR0IArs4c6QAAIHpJREFUeAHtnXmsZWWRwN/Sb+luUBYjezMNGBxlZAmgMDFhJkAUGSRpl2EZxTAx0cRoZPQ/TZw/NFHUhBj/MEEnBGQM00YYgwZwQjTYkbigw6YgBGZAIbIjSy/vTf3Oe79L9dfn3HO31+8N3kq+V/VV1VdVX1Wd75x737v3TUyMYZyBcQbGGRhnYJyBcQbGGRhnYJyBcQbGGRhnYJyBcQbGGRhnYJyBcQbGGRhn4FWegclX+f7Y3rB7XHw152jY5Kyl3NTtpY43SMx1TVDHG8T2qq4ZVYJWaxNl/HmeaeIr520xlwXO80xjp5y32V4z8n6TshYCzzHX0fLExJzpurn7KguZ59IlZq28ktbumsVlYtZqoDlO6V6wOuyric57biokfGW9Yuyqm32sKTonZU0FthxMjk8a3I1ukmFS2bL5RmThMi7pco4xeJmvA3nO1wzuNSF7O+AcF7Rz6bp5lkFPLQdd0u5FufMFicAWDF5JM68bLM/8PIcGtLU0WwM/TeQaCKUKIccD7Vy6DlNI+Lvhc889d/6yyy7bfMwxx2x67Wtfe9j8/PyhU1NTB8aYn5ycnA39uRjzMYCXYry8uLi4fWFh4aUYT7z00kuPPvPMM4/cf//9D3/5y19+8Pvf/z46FNCmKHEufqZjSacxoIE10wgmeCms1f1pLBlD52GR4UE7nz7uuOPWXX311SccddRRx2/YsOGvp6enj1iW56KVhQmV3SD70gd4YdeuXf/zwgsv3PPAAw/8+uKLL77jzjvv3Bn8XTG0b0M4z76kcQYNiJdmq/STza02GEPG0HlYaPF0yKcOOuigdbfeeuupmzdvPmNubu5vggefQjBycUh2LpDJF9f51pe48hl2mO98+eWX73zwwQdvPeOMM25/7LHHaIZefOJPnyUO0d4HN773PS951L/FhmvC4UmDHdPf/va3D3v3u9/9D3Glnxz8fWJQ7HLYCOIy+RYgllaQY5Du+AwNeOtiwKMZpJ+Pk+Hn119//X9eeOGFjwSfOPQJxo9YOlgV3xjE8PcqsKnVgOzXZItJMLTYK2/d1q1bN7/rXe/aElf7iSEnaVx5HsW5AUg487qE52RLl/HE0so/cpvAwhNPHjQCY/LFF1/81Q9+8IOtW7ZseTDm/ZwKoV6B8ThfcZw3vuLOlh3oM2OLDa9M+LprrrnmyPe+970XzszMHBdyCktydyxjm8Cig/MVR1JNrBg/0kFWkHnEgDzHlWODpug2Ag+V0DPgHTt2/Pd111137UUXXfRQzG1Q48qxSYdaJ54yLmQrBmxkb4L+wOUoCz992mmnrb/xxhv/cb/99vv70CcxFj4X3yvfZKKXR0w7yYXuB9ritQE8BWgARnUiPP300/91zjnn/Pu2bdteDF6O02bIcUoTH/ReATe4N5zpq1vhaYLqSvrNb35z+pvf/Ob3x8u21wSPgm+PkRuAJDK38GDAROLHREobA3x5rClBmfpZLs/TwZiJm8LTAJwIFY6XlM/GK4Zrjz/++G3BYx80gg0gNmZxqHRih14xcDMr5mDZsH7AjpxA6OpIPfbYY+d//vOfX7rPPvucFjyKzsgNQNEZJItk5qTFtAJ8wNevNHgQaLKHLWTEbyPYBDQA7zVUjfD8889vO/nkk6/87W9/y/sJxG3z5gZ2L8YpDvWVAYJeabAIYEdOmPfOmW9961ub7rrrrn+N4p8Sui/E+HMaHKOMl2PYFCTRJjCRJE3aK6zEWQe6bTTZs5DEYbNSYOIk/udjsIcX2BN7Y48xpykY3kLMh/nJOQu1lQMdrZQH7eeNuVlxdcVEck5/05ve9E8RCHySSSK58h0UwWIH2dcVjn+KbDysz6AMDJT6pXxJ65Wf6hM7NKM60QJ7EnBb4J3HhbvvvvuquL39NGj2lk8CGxV/jiArGjxyINCVAm2bELBFB3eu/IceeujsTZs2bQkeCeEKL6/ynJgQr3nIe/WWQANwS6huCw8//PDWI4888qaY2+A0t/sE2wBgQLw0G9FPizQicx0z2gU7aov/hz/84T0HH3zwWaHHFc+g+HVJCXYHSAZ2m5KiDFwH5fpSv01eZzPzXI9d9k0TMGwCToL5P/7xjzcfcsgh/xF03X73ShM0JShiGhi0CXbUFv+pp566OF7i/W3oed/0yvfebhLagsGPSUdXGjwI9Guvmz4yTjtywO2AJmCsjzEfLxVv23///a8OelWagK5cCWDTjtrix5W/JYp/eujxsOTVz73f4lO8XguonjiW9rwW3RK0I0ae6X70WccgHzQ0R73PMgvkIHLxYpwEW4NfB6wRusWgTl941A3AJgUbAEwTdO75v//978+MY//vgkfxeWKmAbgCaAA2nDcd01bAh0lGWdqEDStvDaBQKP2xH3jgTvGX54vkInLyzNFHH31L8DK4D3jlXrLewDSFGRWwQQDs2OPq/8UvfnFq/Mr2vNDxpZInAMd/efWzaTcuDtZuPPgkVpxpePLFg8i1Iw6znRgyrTz7yDTFZ4/slaZn79VFQE7ITcx9eZhzZz5zjkN1eOCqHBXkIAmeeb73zVxxxRWHnX/++f8cfJJQV/hgV4klkYAJlRZ3k6PTBqNe3689m8L9gafiNnDcgQceeGf8Qon3DoBs1+IvSUb0c1RGc/Gh7V4agNvMTHT4hnvvvfdf4hc6+8W86vrAPvGzUZIiMMeOCZAG10GpX+qU60v9Ul6uL/VLebm+F33WkCeu+OpVQeCN8Yukp974xjdeHn94Qo64LXoqkp+6xgn24EAQw4I23JCY4jPY4NwTTzxx0QEHHHB80GyMYfG9J5K0vyQgT4xOjoLewHjyySd/HSfBNUHnHJEnG0AcrM5FAt030IGjADdj8fMJMHPbbbedFMU/IRxx3/ehjwc+OtyNuSkaoW2oC85027pe5dmmPjLGjjqZzjqZzjrSyNm7D7++FH4xcnUiOQtZL88DoTY4DNsAFFwom6Dq7BNOOGH92972tnNCyQ36xM/RRjJMCHZMmrwsl4cOIM6064fF2SY0voFe4+lVX3vkgkbo5Iickbvg5SbIOQ5RBbkG8nrGQy0OLzmgfNV3jrV4jXt+vMw5NXT5xUg++imSiQqyL2Advl0vPex+moJYaX/ETf6q22VgbgX7PPLII7cffvjh3wu67lZg/ojNPATZH1CoQcFkE7gbwB5zHvxmL7/88sPOPvvs84Muj36P/Rx83oS08hKHyT027Zosc13mZVp5ibNOpvWRcbl2kDk+KGiGyde85jVH7rvvvvfedNNNvCrwVENH/9LWgnlfMPDC8MJaR776q6f+kM0/99xzl8SvQTcFXf1KNDCdnI/+mI5hOQPmkvzxCyNOgY3xdwQPRxP8W9DkLr9TakPkhguV/oDCDQI2jkGDbYLqBPjKV75yWBR/c/C5rzHyMVYXfN4IcuZZT558sXyxfLE2MlYGzrQ6madOxvpq0i/l6onr7CvjAiFXjJfIIbkM2tPVPOfch7i6GMF9AUYGgezcgAiwOvoD80uOC+ITOX8VNPd+bgFsyKM/yK6AfZJkfNJgoE2+pPXKz7Wm/0pke1LVBRRsfmFUPQvEL80ejFcG18acC2mkp8CgzwAklJGLjy3GzGc+85mD3/nOd54VdL76KT7DIoqDtRtPfhOu08+6mUYXyDzocp51Ml3qIquDYe01ra9yvH79+oPibwvv+fGPf+yzQNYnHud1sXXl4aBfsPh1DUDXzseT/3nx5P+moJ+LwZO/XWugrIUexH8s66zVHrwMbfb17fpSv02efUGX+qW8nJf+6uSeppwC+8bfDtwVbxXfELSngBeUtw5icJT2Guc4GRTYRB7VLSA+hLnu9a9//TEh48i38F75BAiUeInb309tsKpMKEmBB26CvF5azJo6OvNKu91kTbpNa4idZwEweZwhp+Q2PrRKzcine0SH0WQrRM3AET4I4FCA7twKvvvd7x4bf8rNSUDxGb7bl5uAYEc5SAb2wJkepY9sK/vItDqZl2nlbZg15Ms3iLaTU3IbPC40813WIUT9Qb8nAA51Kg0moOoEeOtb3/rmoCl8fuhjQ4CYNSRBW9LgQWBYe4Osz7FKi7HHXt2fdD/7Zy0NQG7J5exybu8NmlzTIOg48K0/4whWd8D4IKBTMDbA0/Gu1Ww8rW4KmoDtXo8rNk9gDGlwppX3i7ONTPdqx9MJnOle15d6OYZMq5d5mVYOhs8gj4zt5JYcB00D5Nxbj2D3B4M2gF50TEDTX/ziFzcFJnh/wWHx88bq6JwEN56xCXFtv/quE5fr2Q88AT2gSR++NjINT75YG92wuq4Xkz8vJE7ViS996UtHBqryHdj8IxoI+rkF4AzQqZgmYkyfeuqpRwT23k/gbIDRC5CgbpDl0uJynXwxsUK7B/li1pe0a5ABpbyJl/l5DfxuUKcLjzg6TXDKKaccHvP7Yph35Hm4ps5eqO4O/TQAK3EkZKdVA8RLv0NCyNVPwHZxT4FotAFrI2P8O5fO8WVTxIIMDEirrx0xOplmvlpAzJ4E25dzzAlAzonfEWQFzHuOHSP9gg7FVSfGZ/pmN27ceEAYowFsAgJnAwQkzjS8upF1Mq1u5kEPO4xN+6PGZbxt/rI+ulxQ1SlAjsl1zKu8B7YO4mD1DoM0QLau0+kPf/jDB4bAYHPhy83kzTcVLutkuld91uSRY8i0OpnX5GMYft5DpptsZh1jtAkWlnPtgyA1GBgGuQVYdLBdOBVf0kQDGCQNYBMQHBtFHwxIgweBUdtri2FYf8OsN2fks8pv5JqT9n9jmH/ymIdrgt0d+mmAsljOqyDic25+jp8gLT7dK+SgpMXYgtamtHJtZFzK8ryX9dlWSdfFg44+Slyur5u7ps5OnT952rIBdsRLwdcG0+IjN2/qlmvl74F7bYA6BxiDX434zR9BEWQuft50iBqBRsGODSMNrgPsItO+dNZXVre+jedaMfqZblvfr7xt/8gZVX7j/QAuNvbqCLKiwYI5cV6Le20AF5cO6UJ4U/Fwwt+vWXwwCbOgQe4GBgcWcoLrEoJcfXXF2ChpfWg/Y2XZnrysJ62sSb9Nrh1xqQ8/x1/unzx3chu55hdEndwHbVxgbQfZDv02gBZ1yBx6at26deCqQwOzATaUNxXTDsgXdwSJyDJpMWp1dB0PXZNi3GWCS3v96pfrjUOMPIN8cZZJZ5nxVs8Ay7m2AdR3b857woM2AMZx6JiIr1/FFm8CESQBgw2KzUC7Kele5bG0K/RiHwP671c/r60LxAKBAfYlj3kv/swJ+tJlfrC5ELnmj0cB5I6K0e+PYRpAXwTgCVAFGHMwmzbhQe5Gl3P1xHVy/GQ5OhlKWTmv0806JZ39SYMBdOVVjGVeSZc2lYPrZHU8db0N7IoTwPcBjCfb7YsepAFwquMOvXws5cLnzZRBKcsYW86l9cN6ZaWturm64m46yNQTZ16mlYONEbl0jhd+E2Q76PRiz9wuLOeadfjTZ6aR9QSDNEA2rHN4Xv1sxodAN5rXQLPOTSvLutJidZqwttQv7Q8rL/3qR4y8pI2hXMtcGVgo18PPvE4DFPxsQ1s942EbQEeTOwOiMwnS4kN3g7w5aJPSbU2TjLX4MxnSOYbSH7bk9bIe/QyuhSctzry8JtOlbi/7r14JRKp5q929Zpt906NqgIn4OvUd0QBsikHipQnKzRm0mxejk2nm/YBrM9YndqT1X9ouGwY9eaVuL3Pi0Cf60vrPcWpPnvMSI68GuS6Fg85H1QCLy0F1goyA8tVHfN02iMwkoTssYCsXULqMST+D6BszNqTzHjOtjv5KXLe+1NFGznWdTl+8YRugs8n4/vyd8fXtPKnKExt4xnVBZv06eT88bYnbfJdy14lL3/LF5fpe9Jt0Sn6eV/7IdWLmGBK7N3KQBsChTjt0fBDkxfi2q43Lbjv83sKovYLyUk8HMIB9ecylm+ToZCj1yxMCuby8bqXocj+lH+Op+OR6WSHnOdPl+sY5V+ywgOOF+K8ZfGjBICoe/OXhXDl8eZlWHuJKDgbQAXq1p261KH5gF9B+G84x6XMYjD9tZlqbmQcNiKHRs2kX41PDfNpKe8gHhmEagAAdE/ElyARFkLlb3WCJWecGtJGxsnKd87b1vhIBZ1ofw9rXThMe1n653v3GdiYm4hvFuNiA7H+J0+fPQRsAx0IVXHzDN0FRfMBuXZotFRvaApbYDbqhMgGubbJXrkcPnoA9QL+lvn6bcBlP23p8oSOU/o1DXNor/WEHHfI6dfvtt9edANkf+j2BBWtTRs9B0/hXqbwnzRccrY9Pruwbt4HTgqYR+DgYL1UGCirWrTawVxNOLNKrtR/iIdf8FnBj/LOsbY8//jgfu/Prdsi1p53NQ6yt8fZ6ApSGnOtkMQLaFZ8JpPA2SpBVAB2dLnODbroiShv96pfr2+b5tpHptnWDytv2Qy6rvJJjcl3kEjm+M5TzLOvQvTYAC0qDzi3awu9+97unQ49AAeQdWUErA2tHHKxqnbjORrleO+IyoaWNcn2pX8q1Ky71S/tt89I+e4UnsB7QjrLJ5RzLV0/50qrdbcmrxf00AAZwlEcOZGd8weEzIfePFdEHsr4066Dz+kwrU78Nl/ba1ver7xUHznRbXE3y0n/ee5axXuDCml7Osb9yd13pxzWt2Ku1VTEUqiMoME3D8DmAX01WX2kSX3y8z5/+9KcT4792citgEKjBsd4NSesfvrwgW0HdpvVt8tJBm34pL9eX8Zf6/cqzfWxx/18f77ZufN3rXvereB+Ah0Dyy0fw+BsMG7NsiBB1h35PAKyxmTx0uhCB7bznnnueDTlBm4Syo/PaJjqWd5ol0+pnm5lukmMDPQE9oEkfvnbVyVgZONPqZF6mlbdhYwOby2lyS46XfWbf2R5reoZ+GwBHQnZKMFUXfuc733kyaN5hxLZNkHWh8zEK7Xo31YaxgU5pt2le+ssxZFv6zbxMKy9x1oFuG2U82DMPpe0QVXmcXs4teupmP+gB8HoGCtQP2I0Ul8FtgGJzG+Dl4Ib4LmC+2erY2dlZjqZ8G4hpB2wM/RO0PJSklXcWNhBt60ctL8Mo4y399auvPXJMftfHfyWdiz+8vje+S9iX2X5TCCeCDUHz4JvRE+BgGNCZXbkzAtz5k5/8hCBpDuy7GXXBBmq3Z16mlbfhvCbTrsu8TA8qx0Ye2NFuprNOprNOptWRF2aXrv6f/vSnz5PbmFtwcq4+egMBReoHKCYDkAZTaEZV9Piv2rs+9KEP7R9zAyZQNrW3AH9ATpC8JcnuP5X1qr/76j1no7BnXjldZy+55JJH4h9NcaL66WsvOptFn3tG04VjMbuo7CEyMLG3gc67grFi489+9rNN8XFxmoJ3q+zaJn8Ej2ygTcS6ErSlv1HbL/21zct4Sv26+Mhd9fQfb/0uxLeDPBxzTtb87p95tQnEpf3Geb8nAIZMKjgPAnasi1Ng4QMf+MB+wTNINunwNMgBywu1oQE/gP6kK+YAP4a1V653r037J682wPwHP/jBxyOfFJ6Xfbzta05dn/cZ4t7BYva+or7oNBKj8zAY9Mb4FyiHn3TSSdj2YZBjC8AvQetf2kShk6FNv02ebUG36Zfycn0Z77D6pT2Lvz5yOBH/cvaRCKB8+Mu3gIEbAUf9AsE2DYKiO+nSHZ/85CefCGxzBFkBaw0YnGntoggtoAM06WcbWXdp1Su2tF/q55gyrb8SZ51Ml3rOs06m6+TETF3I28xll13Gy+oqn4G98rHRNELUO+BkEKDjGUDG0ARfjfiPoJPHHHPM7Fve8hbuZWyCDRN4CfLcFPImXuaXdpzjB9CfdsXItJPpJjk6GVzbpN8mz7agsz455KXf3NVXX/3yV7/6Vd5e9yVf0/EfKoOBxet3tesotEX3Sq+CDz4fFt0Qr1033H///QfFW5jcv9gIXeyGg+wJ8MEa/Uo32WnTb5O3BdW2vk3eZJ91Vf7iLfX5uHgee+aZZ7h9MnwG8BTgtLXBbfimfIRqPQx6AmCNYAVpsKM6xuIPGKeeffbZqXPPPZc3igyedQYN3QZuDJzppnVZJ9Pq69sEwpenTjesbtP67BO6nGNbnn7IGzmrXk3F7fP5+Lcx3Pe5cHp5+CvtxbJ2GEUDlMXHq5upcDzILJ544olz8d+w8EfSfBg0OSXGRrcNKXNdv/rExVpjZ32GNvtZ7jp5zrthfYMdxMLVP3v99dcvfOpTn/Lop/i89vf4Rz83HvOBoSkBvRpkvaO678fcWwGdzG8Jq1tBvEU8H383uP/mzZvZDJvyCAuyssFGjEd6qM1h+P8JkDPyNx8v92bjS6CejHf9uF3mo58GIGfmzSYgRwPnCafDggGICcyrnCOfwF+ODW3fsmXL83FLoDHo9FxsN+NabMnT7mpiY1mJ+GKrFayL3KyLHD1HroJTd+wbR87F8vLB0DC3AD16AjDPdCmfiq88r8Z5553H+wU+DFps9PPGutHqggF0gW5rhpFpu3Ky/EOfWaaPzMt0KSdfXITUYf4jH/nI9htvvNF3+mgAj3+vetfX+Q71/mFUDaBnr2rmJV01xy9/+cuJF154Yeass87Cd7kx7bRhE2BC0JfXtnYUcn01+e9FXuUjgiEPc5/+9KcXv/a1r/HQx9HPsPhcKJ485QkQouFgFA1ABG7GaCx+5ktPxm+2JuJ/4cydfvrp8MomMKndMH5Msj67YXW1Wa7vV64dcWmvWyzKvPLn4vt/pz73uc9xv68rfl1+tGHczvvGo2qA0nFuAIJ0jl5F33zzzRNHHHHETLxVzLyts9HJdqTBvYxQ26NhWCdI1+GS55oSqwdfGlwO5J3iX3nlldMf+9jHcuGheQbgys9Xf2lHH6E2OIyyAXKRiaicyzPwyRtuuGFibm5u5u1vf3tbE9AggI0iXTFrfujDpKEiL9NN8tKka5v02+TaY58Uv3qz5wtf+MK6j3/84xz1NgCYh2YbgP26Z7G+QjQ8jLIBiCYXvYk2ajYy+aMf/Wgy/s5t5h3veAf68HrZaLV2Wd+EiIPdKXYdD3kJ6oHrhrHlPZU28ry0p4zi8ypo9hOf+MS6z3/+8xSaovsuH3Nf71v8nI9sN1SHh1E3ABGRpJyoTJcbYD4Zfzsweffdd8/Eu4UT8X4BPDcthpdHTDtFzrQ6mZdp5SXOOtAloA+U65rm6laL4geFZ8zGn3bNXnTRReu++c1vlsXnJKD4jBW974f9DuTidJhDEtoEO0wAmKbjKvCNIt4s4m3i+aOPPnr2uuuuW4h3DX0CJhEmOchGQAdfYEAaXAfD6pc2m/zBZ7DvuXgFNPu+971vOj7cafG5+tlrXfE9Ady/exPHsuFhJU4AompKvBG7CTcHfzH+QeIED0Xx+YKZ+AsYZU2ngHJwWYDMy3rSlT9+LAN8QHmJu9l3nVhbzCl89fZuvMRb/573vGfiiSeeoNgWHuyxn6/8vVL88F1djeCVgF6bAN+dIsc/SJz84Q9/yCdgZ0877bTJ+NKJnFALU8arTpbLK3V7mbu2zl6WaavkeeLNPPDAA3Nx5M9fccUVu2Jv+cqn+B75q1J8gl+pE8DEtDVBp/CxwGRXvPgV8uTXv/71mcXFxbkzzjiDWwG21Mc+tJALoJ1umHWuybRryiteP2LXZn1k3uLI6+xnP/vZje9///un4/N8FJiC+7DnLc6rn73kod3sJ1RGDyvdAETc1gR5k3nji3HFTNx6661T8YcR83FbmD7++OOzLrbVlwb3CtpCX7oO6yPjvIb9MSz+7FVXXbUx3tNf/73vfS+2UF31+di3+OXrfBugyQ8+Rw5txRmVQ/2YLBMm9l5JQ1YvkxKu/iyaeTwkTsXvybd/9KMf5UoigT4tkzyLF2RFY1ueNBiAL4+5tHJ43YD1xIx+J/Y4sTbEf/qejYc84uGq5wp3OPe4L9/kcQ/YNm5xsFYGet3wKLzrC5wHCczDJqgenkJGA+SmmNm0adNU/NuU7RdccMGLRx11lAn1FQOJxL44yD0KDi8D+iQbDEhbAPlgYgWIbyru8TPXXnvt+m984xuz8Xf7Fj4X2wag4MaKXh74ySOm1Ry8ouDGVtRJMq4/cDnKJsiN4MtGm4Hkz8QXU07Hg+JiHLfbL7300j/H7xdoAk+FnFALKU4h1ZJNcRLjdHz0bTperWzcunXr7LZt2/iWVHxSXIvsvT3zcmwWv4zR+MS1wY2S6UZHabPNlj4zJrHMGWUjUOy6ZoBfNQLyaIapE044YTEaYseZZ575UvzKmSLYDEF2HhpzcjONb+bGwBpj4W3ruVtuuWU+Cj5zxx13UHR0LThYuiw6fOMoC8/cGEocopUHNrsakP1C52EziCk+tI1g4cWcDsrQrUY0xEQ8Myxu3rx5IW4TO9/whjfsiLEz/jh1IT64OhHfs7Pr0EMPpQATjz766FR8v9H09u3bJ+KPMafuu+++dTF4CccHXKbink7BUfUqFlt0cB7ImWMfmuJabDE8R5AV2ATOVxznQqy4sxoH+rcBULHw8KTBDgpsweswevDVF+tDHCp7gAURU6w8LCrYItfhvAZbuejQgD6kK+be/kEyVhuMIWOLJKaI0GJPhc4VHzJpC56bwLXIAO0uzZZ+5oJYQIvH3OJDU/RyyHdNxtoW4xEaEC/N9vJPErFWwFgytlBiG4C5hYa2IeTledZlrzYBNDIgF4FCAmAGMmmKLg1mnuXQzqUzDnHHF/xVBxOw6oEsB5DjgXYuXYdtijosr25d3Z5zsTJt0eFB1+Gsn2n8OIcGmK8JMMFrIpgURI7L4iGWVp7nJe2VDj/TupHnnMIKFshiw5e2mCVGJ/PyHBrQ7tJsDfw0kWsglNoQcnzS4G50kwwHymqdJaaFyrikyznL4WW+JuU5XzO414SsdsA5TulesDrE30TnveVClbTzXjF21c0+1hSdk7KmAusSTI65jpYnxlSm6+a6KwuW59IlZq28ktbumsVlYtZsoA2BlfHneaZZXs4bTO7Gbips5rOgnO9mZC1PBknKWt1P3V7qeIPEX1fgOt4gtld1zagStKqbaHE+7B5fFYVuydFYPM7AOAPjDIwzMM7AOAPjDIwzMM7AOAPjDIwz8JeRgf8DaDwRu+DgmJMAAAAASUVORK5CYII=')";
	    this.touchPointerImageActive = "url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAAAXNSR0IArs4c6QAAHipJREFUeAHtnXus3VWVx9v76L19UQptoS8sFCqgDsMrpURBOwjKSHhpBBNGZmAkJhAyf/ivMUZj1MjIEB9MIiRQRV5OjBODjjOAg84MSCmFoVAp0BbaAiOUtvRBe9v5fvY53+O6u79z73nd3tN7z0rWWWuvvdfea6+19t6/3+/87rkTJnSg44GOBzoe6Hig44GOBzoe6Hig44GOBzoe6Hig44GOBzoe6Hig44GOBzoe6Hig44GOBzoe6HhgzHpg4pid2eCJtWKeBwZ3OTZKPWNjGoNmURTsItkgpQYLh31SjJRjGvRnQ2r5HGI58nSel2sZMAa5Gk8/sa6WftuiTSMOaQfDo91FfJEMu6O8qIwsD2Qsm89prud65G0NuUPa2lgZF+01X0SLZMzNcs8zLyOPwct5lyON/FD6HrOtaJED2spAGRNtNB9pzudl5hNlsQxfDYoCG2XwRvqoxrsO2nZgx7SdYTIo2mYemvOW5ZQ5IesKOvBA3kdJenAQke8XOvDmHeyhKLquhwfcT6nUBp92RBuYMsgE2xUpfC1IkI0Tb7/99lnLli07/thjj503efLkuX19fbO7urpmTJw4cZJor9pOKiPB2b1///69Bw4c2CO6fc+ePa9v27bttU2bNq2/7bbb1t51113vqg3tSASjg2x5LMMDlpVKbZQIdrANG21qeyKtFnSvbOq7hSnoDzzwwEIF/PSjjz56SW9v7/EEW3UxWPCAA4a+A+VxY9/mJwwMDGzcvn37mtWrV6/81Kc+9Zx49zsQ+nO/DnqkHjdS+FEDT3jUDCgPHO2Ar4YORgq22qXAP/jgg8ctX778Y0ccccQZCvhMyQmIg7Nb/LYyviO6vcy/J7q3jPtEAe8IfeKnCunryDKFZ7w0JjvE1q1bn7jnnnseuvHGG7dI7iTw2EMlAnWAaak0Cp/R8aMwfBrSNkTqBIgBR0Y5BUEB71+xYsVfH3PMMeco6MdIjuPBncI3hZvL+H+iBJogkxQxUA4A1GOapkBLDuWB2WThgjLOF50uTLboqFj37LPP/utZZ531lGS2A+okpH+QsnmxlQRANirAZEcTPL6dHmkMfiXwN91005Ff/vKXL9MWf67OcVYsjt4l3ChcJ3xVuEfooEMdCNo6AA4IY1JvW8RWLhzzJCARGJMdgmRYInyfkOuInr17925YuXLlA+ecc84zKseEc+BNow3wgGmpdIg+46QP0ZCVYRxsBOahBDsGP62yz33uc9O///3vXz1jxoyl5XoCy+r+X+FLQrZ6As/WTqCpd8BNCQDgAJRKpXL0hfloj5OBBIAn6CQC1xgnCz8g5NggEdbdfffdd1533XUkI2M7GRgXG4oSQeJDnwSeKIMfKvCYkcaA2+msthT8l19++YLjjjvuUm31/ZIR2E1CVtl6IQEn+MgddJyeO1qiioPjamO8WKadgbocvRvF3YBE4Eg4TXiKcIrwwObNmx9asmTJv+zYsQN7YiI4AUxjQlazRV20HpjcoQSPlzuVslc+FOf23HfffSdcccUV13Z3d89XmeC+IXxcyMqKK54V5lVW5FRVtwSi3UWJwHUCF43sUicIJ+nOYcuPf/zj2z//+c9vVNkJ6uS0raYOvqlURhYckJEdpdS7x4pOhI+BZ8Wnlb9+/fqLtOovLxu2Q3SVkO2eizy2epCgV1vtqioEnGtbChsMI7S+5xETwccCO8Bi4TLhEcIB3Trefdppp/23eCdBbreTQE0OOqKQjQg044h6DPI4dpppDH4K/CWXXDLtpz/96Q1Tpkw5VQMQ5FeE/yV8W+hVT+BxpJ0G9RgOkFdRkRxZrLeOxEme1+fyvJ5yOq5EmQdHFchu8GHhImHvm2+++fCcOXPuE4/tTl4nAjZ4PrbNVFUjAxg+0uAxoBEdfDuuVxd582644YZ/0FnPqmGl/0H4rJCrfILPeY/jcBSOMziAdpjHpN51bmsa5eab0Wc+AJSdgItFjgTwLOFfCvt0PbBGTyX/6d13322LJIiOkn0tB/efB54yjvKW3/uzn/3sxMsvv/xGyXAcV/f/KeRiz8H31kmQvOJjwBxEVVeCbpnbUcfYuTzKaBPrXYcccNk0lyEH2QlAJ8FJ4tkNpum5wR/f//7336pjjh2ORPZu4B3A1HabqmlrAUNHEuyMSOPKx0G9jz766OnnnXfe34mn3WvCh4Vs+QSfwLPycYIdIza1hSJHz9QyKFCtDjlgPVPLUqU+GtX3PNkNQG4RFwqXC6crCTYsXbr0lqefftp3MCQCyBw9T2wCAdNSqUWfdkKLuhvUDX27f5wBb6dUVn45+Nerjkm/JPytkMe1HAHeJu0QiRLQV+6QKDNvWlarkCJ5lJk3rSiWmSJ5lJn3vEl0rgnYDUiCvxJO37Vr18uzZ8/+Rx0HPtp8vDFfz9lJkM9XTZoHDBwJwAEGePCg4OsZ/hKt/L9VHRN/QfiIkOf1BN9OwRGA+4ECLtvJUWbe1G1No3wk9R08VjbbPfPaKPyNcLu+nTx+48aNfyOeHYIkYWHYT7bLNkNbDgzSarChNtwT8cSYZO93vvOdeZdddtkN4gnwK8LfCVn53hK9AtxPNSqVSjJUazOUfKT16Z+5kAQkNccax9xv4WfOnHnWiy++eJH43jLaT9FmVSVA1lJgsJGAaDy8J5XO/AsvvHDazTfffJOu9injjEeFMfg+C/N+qpWlflASFMlGUz9PgldkIA+1di9evPjiRx555C/E4w/Q/oJGm1VsLbAaWwkYC0BtvLc1T27SqlWrru/v75+rNlzt/4eQr2tZ+T4D2TqtbwdIlPo1jfKitkWyaN9o6GO7z3Ioxx3XBkfpodep8svjL7zwAtc9PjrcVqKRAZzUarBjoQ4ClAToXbt27cemTZu2RDxv1zwm3CrkfCT4rHwmnduV96Umg1aGx0QOtLM+9jFPAk3S86zjDe2GffoC6RrxXiheOJ4b1BB5yxqiuaMa6qSsFA01T/8gk+q+8847jz/ppJMuFk/AnxRuKfM4gy3SelD0TMUmoAxEu827LTTyrkevXfRJchIeP3BNwJPOnXqhZYkeGX9YvJMA242el+egquahVUeAjYJiMNQZ7Iubvvvvv//v9cUOt0IvCZ8S+j7fK1+iSpDgHTz3G+tjHXKDbaEc20Q+r7Mu9FDpx3FYAIDuCmef+Nhjj/2PvgGtdhT4WIj6Je0GPu2UBlQPUsEgI/3CQ0mEHj3w+Ije0TtGPBd7rP48+NaxHhSwHD6vc5soj3w76xNIdj0CzU6wRshR0PuTn/zkEvEsHHYC5m8fMDej2OaBjpsFDDLYOCh9E/zuj370o9M++MEPflw8Z94zQpLA277YNClT9+e+ojyv8zi5POpEPm832vrYBnAc4JunoXrN7cxvfOMbc8Wno1O0KAkkrvgNviGwQxpSLivRh9GGpsBLzgOOPr1WfdXcuXP5MmST8DdCLgDJerZ+n/1iE7AybFfky9UHkbxNLEf+IMWyIG8Ty5EfSX0Cja+mCD8iPEFfGq2fPn36P4snMVgsJIn9hc+wzSi2MWjFDuCRnQSmaev/7Gc/O0PB5x6XgKcMF2UyGA9gg3WgsWyedm4T+bx9Xj5c9PEFweVBEd9+7tad0gnf/e53F4iPx4DnwzwNkbesZtqUskZB34hxYFz9/Rs2bLhs4cKFZ0u+QfiokNXvjBab9HGAbTHvBCmSI4v11qE/87E+l7ejPn7j3GcXWCZc/Pbbb6896qijVohn8fjReEt3AQLWCsChEdPqP+OMMybPnz+frR/j15apty/aM37UU3FQ2fa5LfVRJ/K0AWJ/h5M+tnsXeFH8Xj0mPvnqq68+Ujz+zOfq+aqqcbCDGunBBkQKT59pF9A7fR8uP+7lid9mIVu/EyCO7T6QWZ5TVVWCC+96yy2zPKduF8dCBkRZruey28W2SblF+t6x8A/+ekO4/9vf/vZ5okNdDGKPbRJbH8TJ1adZau2BbQT9GXv0eJOzn9W/ThiDH9vDo2OZ2MqELIttXB9lY0WfubEL4Ct8tldvD/G6OQngJLBPJGoecFyzYINM0/avzJ2r+/6Z6pyr2NeETgDGi+OiB0TqvqLMbZCNVX12AZAkYMfcqQdnU/VcYJF45gxG39g/EjcGZFUjkBsRyxjZ85nPfIYLPy72mAi7AFsbYKNNS9L6P8eyPr6y76bpOcrpKr8kZBGxwKiPPlcxgY8Rl4eljSZA3rGNSWe/Krt18XeSKAaz+sloG+fAUTYvNkGRzHU5LWpbJMv1XC5qWyRz+5wWtS2S5XouF7VFBkAJMs9NFs2aNetEUXyb7wASNQd02Aw48Kb01/XNb37z2J6enmniedz7ppDJAG6XU9fFCVqWty0qu+1Y0Wc+LB4uBnfpKJ38ve99b4H4oiTAHw1DMwlQFAj667nooovIWLawPwmZCAmQZ7yDpapKZsN7Qq53OdbBuz7n3d71Lh9O+t4J8B0+3Hv++eefIOodljnlKFH9gJPqBQ9sPZfpK2XookWLyFa2fSdAbBsDY91IaZvbFXUiH/XMjwV95kISVHw4b968hWW/MH/8HOer4kFlZMNC7uhhFUKDaAC8A9Otx5jzVMZ4Xu1mIl79tAPiuDnvft2fdSwfL/rMF7/hw316V4BvUvMjQKLGAo8iEJ1fktT/6cDQV/cXvvCFI3XrwmtOPL7kVS8mAXgsBzQG2H3QzvXWcd1407ff8OFe3qPQL5EcJR4/RN/hp4bBTq23AwfJwUEfvuviiy8+VpQznz/ohLqt2Eq2WhYpvNETRCfyro96tIly+KgT+djOeqaxLupEPraxnmmsizqRj22sZxrr0AF87cTX5/t0bTVHlDrXW0eiQX6mXBM0cxvI4AZPskvn/9ESsv3zpY8nENtaZzgadSI/nJ7ro07kXT8cjTqRH07P9VEn8q4fjqID4kN8OaAv1fCtgw/FzwDtvGMkQa0f9SaAjXL/LkNTEuinW/jyAsP4IwgbRX01oE2sj+XIj1d95o0vB/SXxTxZrfi6zEffmbff1WRoqDcBhuotGaYLwBlqRNZidIRonHnqzTvYLhfVIXM7eMDtLXe5qA6Z28EDbm+5y0V1yNwOHnB7y10uqkPmdvCA21vusuuQp8U0depU/mrau63roQ2Dt5N6O8DIiPSTDNP7/nyfzQ7AdwCelMeJOqpO4Akn/UxGkfrxrI8PuKAekG95odb+GMon6NQELd8B9Mtd7pOHGBgJBeBJCFMnA3UAZScMPGAZvPVMx4s+c7cP8S3zz+dOm4bAwWpIuaxkYxLVY0sMZAfwBaADRnO3hY+AHHB9TJTxro9P8OeA3q3IHwDZb/iuIWhFAsSBMQgjk8HlChsJJbBAkcxy7wIuF7Utkrn9WNNnXmkxhQRA1hJoJgEIQgxE4stGYhxJEOuRxXKeDNQDblMqlT4ti3Q86ePLCcG3+CH6wnzJW3V8NpMAcZhoAIEB2bqBWFeSlD6ryWObofjxpO9j0EmPX5qdf/JtqxLAgZrIz60rUzGUowCIhiJ3OfKpoT5y2VDlvI4+ctlQ5byunfXx5QH5lhdr7D/sbRpanQAT9gkmTeJvHNIOQOZyfhly4112MFymPTLvIuNZH5+kxSTXpqPAzmgFzR3caJ8EC3CWwvOOO/3HoEY+jh15t7Guy/QZ+agTebcZK/rMIyVAeQeo+BqHNAvRcfX2hSHRmMTr1694AEQQSABDDIZ56szT3rzlUIPritohK5JbF3q46/Pt6sSyb5lPoe+pqBdwTKsgGaV/orC13CFPBO14RATJUIvcbaxnSh+ug68mdxvXmx5u+syjD6PLvvWiQ9Q00HmzMCgbX331VRIAZ6esLfOU84DEMvUOUBE/3vXTYtIPS74jP9nfphI1Ds0mQMxGLvb2P/XUU7wGxpnlHcCBxkoHNw92lFfjx6M+vgP5DqBrzZo1+Db5WdQQY2BZzbTRBIjZB5+eVEH1e7+8BYwMo7nLqBbQjrw23+BDfHlAbwb7Devoc1VVdgX4uqDeBGDgIkCeUFm6R3/Vynts9M2r4dCiYEt80LZPO8DtI2+ZqetMcznlvM5tYl3eJpYjH3UPlT7jpK+A33nnna3PPPOMv2G1v7Evh2oxytulcr0JgFIcIBrirWlg3bp1/PgTffNugMewAyVKAXZimFrudtCiOrdznanlY0mfo3S6cKLOf3xqH0OB6H+XU0WtHzivEfDApjYsfQn0y1/+cqM6pW+/wJDuY1WOwfG4yIBYZ5nltjO2SUplPberVn846nsu+LDnV7/6FT7la2F8bH/b/6aqqg+io2vVtGE4FSS4II//uF2ZoieBU/VPFa8sPxH8o2RcvQIYij4U8PhFcrcptfyz3njRZ97soCfpCeBEvQ30wHvvvce7gbwd5B+MSAtO5TwhJKoNvDJqaz24FQGKaCMGZOg+/R+9V1RPYvhVZrFDrnLX2yaok82JEsuWWc90rOjjO94B7NKvh26UT6sF2zFg/nWDnVWPYj6gy5UEUGcDX/3qV18QZRK8JMru4ICKHRTYGFTb4+BCred240GfOXP1j+96fvjDH7KLxu3fPocaIm/ZsNSOHrZh1sDBwFCQQIOVY0D81Ndff/3jepOVM2yT8A0hSTIcMJFG7aLvsaCPT2cLF+gofVd/FfSQeLZ//tiWOwG+Fay2I6iqdmCgZgBnR/QuQLbuu/fee58XJZN5n73WZwLY5ARwotVDx4K+fdb9i1/84kX5w6vfF4DR5/ANgx1dbwcxIDgcjLsAj4F5Ejh18+bNF+hnTqaKf72MGIx+EZW4Enz4odoMVYcuMFSboepK2qOjjy9ZMPP1n0T4uThWPxd+IKs/vSEs6mRg0TEXo9jagcEaAQ8WqQ3BsLQDiO7V0yt+984ZzV0CiZInkEQpibDHdZaZIqc+trHMbWKdZaZuG9tY5jaxzjJTt41tLHObWGeZqdvGNpa5DXX4apawW/9Ia60ovuRP7R3w6POcV7P6AAMaBXSNGA4SXL4G5lqAXYBHmFO2bNlyvn7+lAuat4T8ZAzJgi4TAIbiqXc7eMNQOm5PG8DlUqn02Y762MRfAc/S2b9HZ/+/ifetn89+kgH/FSWExPUBQWsG7FioEcNADE34xS9+cZVeZmBy3Nf68bDYQasZWxywyMd2yGOdefTMx/bwgOug5qO8HfRZPCwabv0mfetb33palIs9fBivAfCzd1uxhcmNvCZg0GbAAaMP81Bjcvjzzz+//9xzz+068cQTubLlGNgudPJYT6IUHCiALuB6U8tcNkVunci73rRd9bF9vrBf/tqkn9hl++e890MfkoDAG73gJKr4Er4uiE6pS7Hc2PoYDw8lqUDOMoKdjgF+50Y/Gv0x/eARZZ4MclHIZGoF+nfSoJOXh+snb5+XR1MfW1j5c/TAZ4L+x/C/KwnwUbzwy2/9nACmw9lfWB9XTGGDYYQOiI2AOkOhvoDZs1ego+APOgrokmcDXBM4cXDAcKgmCdyOsczXQsvqFZ120ccH3DGlW2X9V5XVCj6Bz7d/HBf9HHlVNQbNHgGMivOBnFrm4HQ999xzAzNmzNi9bNmyearkvGOSJAkQ9a1juctFbYaqOxz02SnnCvueeOKJ9Zdeeula8Vzw+aIPH/mCz0kgUWvADm22txgEMtpIgnFHALL1J9S/SDtVv3p1vMpc4PA7gpxztoXMBih7lVI2X0SpPxz18Q9X/VPfeuutdxcsWPA7/TdRVj9P/ECf/76wJgGcBPgBbAoIVKvABkWKsb4jIJOZ0B798uXz+meJvN1C9s8TkhgAQQSxy1RsAsscaNsONX846RN87ven8eXZpz/96ZUKvh/04Ctf/edBV1XzgacTwI4rlRr/jJkIH41miweZVCUJTj311Cf1kgPvuPHcgFXABaMDKLYC1QJMg9jePDRCO+oTfM786fqqd/9111335MMPP8xFn1e8E8Bbf1xU9rVpnGvdfKsSwAPnhjoR4i6QzjddE+4+5ZRTVioJeH2MJJgr5LqAAGKXAyo2gW01dTsqi/h21a8En2cjX/rSl1auWLGChZB2R9E8+PZh9C1zbgnYma3ozBkZDbXx0JgEabJseR/60Iee1D9Q9k4wR+14BQqISUAwAQfVNMpyvh31CT7PQngYNvFrX/va0/q3MHxLOtxFn32qpgnsa5cbpnZswx0UKDo4pgTCiAP8qJgtPz0u1jOCPv0b+Q/o7oAHIRwXPChiS2zZRNXXaINXfr+2/QNa+asUfK6DuNhzArAw4tnPosEHLCAnQUt9glGthqGSynVMAj5Nhq3wRz/60Vsnn3zygP69HBdGJAkJgjOYPGBdqLFIbpnbRL28zmXT2LaV+syFefVr1xu45pprnrzjjjvY9Rx4KFs/ye9z30E3bWngNU6CkUgAOrYjS6MUlz2hCn3wwQd37Ny5c7seG8/W+4TcOvKAhHocEwMyFK+mlfGHaletrpX67HwcaTzl69ULMjs+8YlPrPz1r3+9VeU8+F75eQIw/4qPxLcUcMJIgfu2o30mQ0k8kNtAAs0KgXIk9OkHESc/9NBDp+hOgfOSFcDWyE+mskoA+sQpOR2ujnog13N5uLqkXKM+uxhffjG3nscff3yDbn//WL7VI/jMySt/uODHJJBa62CkdgBbiGMj5GXqPDlo2u63bdvGXxj9ST86ufvMM8+cqR+cwIk8K8Cp7Aa0BejPfTrBchntYh1l6+RtXXY9ekA9+viUi7wUfF7m1L/PWXPVVVe9rLM/rnoSwFf8zIm5x+0++sXzVZPWgifa2l4H9+Yx7Fw7EwriMALLbgCt7ATw+qeTffrvY4t0LCws//IITvKFU74jqGoQeOwiB1JneeRjB/Xqk6QEP+1uq1at2nLFFVes1T+C9lM9gu7A+8yP5z725EkgUcVO+JaCJ9jSTgs68zhQME8Cyk4AHwvxaJh0wQUXTNOusFj/fp6LKRzFWYkTca4Tod6AYgs6tq8Rfamn3YnrFQLfrce6u77yla+8cNttt/ECjANuiq0OPnPwmc/YhzT4Gq8ycfiRBjsZavQuYJpWjupjEpAI3hkmffKTn5z29a9/fcHpp5/OMwP6wXE4EQdzlkIbBfdXiz42pWsWUezv1t/v77zrrrteufnmm7m3J8i2x0G3DHvjtp8H3oloquYjA0z4UILHgxpxHryTAIpzfTQ4+JH2LF68uP/WW2+drwurOfqrGQKBEwGc6xVGACjXAjjb9kXeutRhg+3AvmTz5s2bt99///0by4FnTDAPuuXYg60RGS+iiqkMHVHwhEd0kKxzjwmNmCdC3A18PMQAIEt47bXXHnH99dfP1r+qnTV58mSSAWc68PA+Z5G5zglDGT7aYp7xYkIiT3bqgm7P73//+zdvueWWLT//+c93SE6AGcer3NRy2zBU4LEFMC2VRvCTCY0GeFw7OqdpZckwKIngZCAgToZInQzdV1555RR9pz7z7LPPnq7byRnaHbiDABxo80mYfdCGMaHY5HKyT/fx21avXv223tV/+wc/+ME7SgISisA6yF7lLrsuX/W2BQoCOS1JR/iTiY0WeOxIk6NlUFplgXq7JdBOBgc9Utc5cbqWLl3av3z58sn64mmKLiD7Z8+e3ae3bfv5TeO+vr5uoW4uuuhjAl/LDgwM7NOPMQ3ordz3XnvttV1r167dpav5nffcc882vd1MII0EN2IMOnK3i8HPA1+UAFI9dGDnH7oRDx7JNjj4OS1KhhjomBRRDl9JhDJP38gAj1Mq/fnTQTGNW3YMqoOPzAE3dTsHnD7cX04ZGdmoAE5oB7AdkTpApk4EyjGwMdDwsUw7t7WeKfN23/CAgwPvwCMzT4DhHeBIo9w6kbpvKJDTkvQQf+KAdgLbE6mDFGlMBgJOnQPtoEfq+qiHzGDeQUHuoCMzT8DNO+CxDE9765iHAi6bT8LR/PDER9OGfOxok3lorRgTgoADDrxp7LfU4s+fMUh5QF02JSHc3tR1lAHLXbYsVY72hx0x2nYUjR9tMw81omO+GqWNg57zlK0HDzhY5qEEFKAuBtdtq1HrFFFkbQE4oN0h2mg+0pzPy8wPmeUuQ4cCAgtEmvMOvtvFessihW8riE5pK8MKjIm2FvHILB+Ounu3cxnqIBbxros08kU6yNoWihzQtsYGw6LdRXyRDPUoLyojc0DhgVg2n9Nq7VIH7fyRO6Sdba1mWz6HWI48+nm5Wp9R7mAjq8bndVG/rflGHNLWE5JxRXMqktU7jxh86xbJXHdYUG6ZOlCbBw77YNc2zU6rjgc6Huh4oOOBjgc6Huh4oOOBjgc6Huh4oOOBjgc6Huh4oOOBMemB/weNeh3RI/q/7QAAAABJRU5ErkJggg==')";
	    this.touchPointerImageSize = 64;
	    this.touchPointerInitialOffset = {
	      x: 0,
	      y: 0
	    };
	    this.keyPinchCode = 18;
	    this.keyPanCode = 91;
	    this.context = new Framer.Context({
	      name: "TouchEmulator"
	    });
	    this.context._element.style.zIndex = 10000;
	    this.wrap = this.context.domEventManager.wrap;
	    this.wrap(document).addEventListener("mousedown", this.mousedown, true);
	    this.wrap(document).addEventListener("mousemove", this.mousemove, true);
	    this.wrap(document).addEventListener("mouseup", this.mouseup, true);
	    this.wrap(document).addEventListener("keydown", this.keydown, true);
	    this.wrap(document).addEventListener("keyup", this.keyup, true);
	    this.wrap(document).addEventListener("mouseout", this.mouseout, true);
	    this.isMouseDown = false;
	    this.isPinchKeyDown = false;
	    this.isPanKeyDown = false;
	    touchPointerInitialOffset = this.touchPointerInitialOffset;
	    this.context.run((function(_this) {
	      return function() {
	        _this.touchPointLayer = new Layer({
	          width: _this.touchPointerImageSize,
	          height: _this.touchPointerImageSize,
	          backgroundColor: null,
	          opacity: 0
	        });
	        return _this.touchPointLayer.style.backgroundImage = _this.touchPointerImage;
	      };
	    })(this));
	  }
	
	  TouchEmulator.prototype.destroy = function() {
	    this.context.reset();
	    return this.context = null;
	  };
	
	  TouchEmulator.prototype.keydown = function(event) {
	    if (event.keyCode === this.keyPinchCode) {
	      this.isPinchKeyDown = true;
	      this.startPoint = this.centerPoint = null;
	      this.showTouchCursor();
	      this.touchPointLayer.midX = this.point.x;
	      this.touchPointLayer.midY = this.point.y;
	    }
	    if (event.keyCode === this.keyPanCode) {
	      this.isPanKeyDown = true;
	      return cancelEvent(event);
	    }
	  };
	
	  TouchEmulator.prototype.keyup = function(event) {
	    if (event.keyCode === this.keyPinchCode) {
	      cancelEvent(event);
	      this.isPinchKeyDown = false;
	      this.hideTouchCursor();
	    }
	    if (event.keyCode === this.keyPanCode) {
	      cancelEvent(event);
	      if (this.touchPoint && this.point) {
	        this.centerPoint = Utils.pointCenter(this.touchPoint, this.point);
	        return this.isPanKeyDown = false;
	      }
	    }
	  };
	
	  TouchEmulator.prototype.mousedown = function(event) {
	    this.isMouseDown = true;
	    this.target = event.target;
	    if (this.isPinchKeyDown) {
	      dispatchTouchEvent("touchstart", this.target, event, this.touchPointDelta);
	    } else {
	      dispatchTouchEvent("touchstart", this.target, event);
	    }
	    return this.touchPointLayer.style.backgroundImage = this.touchPointerImageActive;
	  };
	
	  TouchEmulator.prototype.mousemove = function(event) {
	    this.point = {
	      x: event.pageX,
	      y: event.pageY
	    };
	    if (this.startPoint == null) {
	      this.startPoint = this.point;
	    }
	    if (this.centerPoint == null) {
	      this.centerPoint = this.point;
	    }
	    if (this.isPinchKeyDown && !this.isPanKeyDown) {
	      if (this.touchPointerInitialOffset && this.centerPoint) {
	        this.touchPoint = Utils.pointAdd(this.touchPointerInitialOffset, this.pinchPoint(this.point, this.centerPoint));
	        this.touchPointDelta = Utils.pointSubtract(this.point, this.touchPoint);
	      }
	    }
	    if (this.isPinchKeyDown && this.isPanKeyDown) {
	      if (this.touchPoint && this.touchPointDelta) {
	        this.touchPoint = this.panPoint(this.point, this.touchPointDelta);
	      }
	    }
	    if (this.isPinchKeyDown || this.isPanKeyDown) {
	      if (this.touchPoint) {
	        this.touchPointLayer.visible = true;
	        this.touchPointLayer.midX = this.touchPoint.x;
	        this.touchPointLayer.midY = this.touchPoint.y;
	      }
	    }
	    if (this.isMouseDown) {
	      if ((this.isPinchKeyDown || this.isPanKeyDown) && this.touchPointDelta) {
	        return dispatchTouchEvent("touchmove", this.target, event, this.touchPointDelta);
	      } else {
	        return dispatchTouchEvent("touchmove", this.target, event);
	      }
	    }
	  };
	
	  TouchEmulator.prototype.mouseup = function(event) {
	    if (this.isPinchKeyDown || this.isPanKeyDown) {
	      dispatchTouchEvent("touchend", this.target, event, this.touchPointDelta);
	    } else {
	      dispatchTouchEvent("touchend", this.target, event);
	    }
	    return this.endMultiTouch();
	  };
	
	  TouchEmulator.prototype.mouseout = function(event) {
	    var fromElement;
	    if (this.isMouseDown) {
	      return;
	    }
	    fromElement = event.relatedTarget || event.toElement;
	    if (!fromElement || fromElement.nodeName === "HTML") {
	      return this.endMultiTouch();
	    }
	  };
	
	  TouchEmulator.prototype.showTouchCursor = function() {
	    this.touchPointLayer.animateStop();
	    this.touchPointLayer.midX = this.point.x;
	    this.touchPointLayer.midY = this.point.y;
	    this.touchPointLayer.scale = 1.8;
	    return this.touchPointLayer.animate({
	      properties: {
	        opacity: 1,
	        scale: 1
	      },
	      time: 0.1,
	      curve: "ease-out"
	    });
	  };
	
	  TouchEmulator.prototype.hideTouchCursor = function() {
	    this.touchPointLayer.animateStop();
	    return this.touchPointLayer.animate({
	      properties: {
	        opacity: 0,
	        scale: 1.2
	      },
	      time: 0.08
	    });
	  };
	
	  TouchEmulator.prototype.mousemovePosition = function(event) {
	    return this.point = {
	      x: event.pageX,
	      y: event.pageY
	    };
	  };
	
	  TouchEmulator.prototype.endMultiTouch = function() {
	    this.isMouseDown = false;
	    this.touchPointLayer.style.backgroundImage = this.touchPointerImage;
	    return this.hideTouchCursor();
	  };
	
	  TouchEmulator.prototype.pinchPoint = function(point, centerPoint) {
	    return Utils.pointSubtract(centerPoint, Utils.pointSubtract(point, centerPoint));
	  };
	
	  TouchEmulator.prototype.panPoint = function(point, offsetPoint) {
	    return Utils.pointSubtract(point, offsetPoint);
	  };
	
	  return TouchEmulator;
	
	})(BaseClass);
	
	touchEmulator = null;
	
	exports.enable = function() {
	  if (Utils.isTouch()) {
	    return;
	  }
	  return touchEmulator != null ? touchEmulator : touchEmulator = new TouchEmulator();
	};
	
	exports.disable = function() {
	  if (!touchEmulator) {
	    return;
	  }
	  touchEmulator.destroy();
	  return touchEmulator = null;
	};


/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	var Utils,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	Utils = __webpack_require__(4);
	
	exports.enable = function() {
	  var MobileScrollFixLayer, handleScrollingLayerTouchMove, handleScrollingLayerTouchStart;
	  document.ontouchmove = function(event) {
	    if (event.target === document.body) {
	      return event.preventDefault();
	    }
	  };
	  handleScrollingLayerTouchMove = function(event) {
	    return event.stopPropagation();
	  };
	  handleScrollingLayerTouchStart = function(event) {
	    var element, startTopScroll;
	    element = this._element;
	    startTopScroll = element.scrollTop;
	    if (startTopScroll <= 0) {
	      element.scrollTop = 1;
	    }
	    if (startTopScroll + element.offsetHeight >= element.scrollHeight) {
	      return element.scrollTop = element.scrollHeight - element.offsetHeight - 1;
	    }
	  };
	  MobileScrollFixLayer = (function(superClass) {
	    extend(MobileScrollFixLayer, superClass);
	
	    function MobileScrollFixLayer(options) {
	      this._updateScrollListeners = bind(this._updateScrollListeners, this);
	      MobileScrollFixLayer.__super__.constructor.call(this, options);
	      if (this.constructor.name === "Layer") {
	        this.on("change:scrollVertical", this._updateScrollListeners);
	        this._updateScrollListeners();
	      }
	    }
	
	    MobileScrollFixLayer.prototype._updateScrollListeners = function() {
	      if (this.scrollVertical === true) {
	        this.on("touchmove", handleScrollingLayerTouchMove);
	        return this.on("touchstart", handleScrollingLayerTouchStart);
	      } else {
	        this.off("touchmove", handleScrollingLayerTouchMove);
	        return this.off("touchstart", handleScrollingLayerTouchStart);
	      }
	    };
	
	    return MobileScrollFixLayer;
	
	  })(Framer.Layer);
	  return window.Layer = window.Framer.Layer = MobileScrollFixLayer;
	};


/***/ },
/* 52 */
/***/ function(module, exports) {

	var slice = [].slice;
	
	exports.enable = function(module) {
	  var ClassWrapper;
	  if (module == null) {
	    module = window;
	  }
	  ClassWrapper = function(Klass) {
	    return function() {
	      var args;
	      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
	      return this.prototype = (function(func, args, ctor) {
	        ctor.prototype = func.prototype;
	        var child = new ctor, result = func.apply(child, args);
	        return Object(result) === result ? result : child;
	      })(Klass, args, function(){});
	    };
	  };
	  module.Frame = ClassWrapper(Framer.Frame);
	  module.Layer = ClassWrapper(Framer.Layer);
	  module.BackgroundLayer = ClassWrapper(Framer.BackgroundLayer);
	  module.VideoLayer = ClassWrapper(Framer.VideoLayer);
	  return module.Animation = ClassWrapper(Framer.Animation);
	};


/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	var DOMEventManager, GestureInputDoubleTapTime, GestureInputEdgeSwipeDistance, GestureInputForceTapDesktop, GestureInputForceTapMobile, GestureInputForceTapMobilePollTime, GestureInputLongPressTime, GestureInputMinimumFingerDistance, GestureInputSwipeThreshold, GestureInputVelocityTime, Utils,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
	
	Utils = __webpack_require__(4);
	
	GestureInputLongPressTime = 0.5;
	
	GestureInputDoubleTapTime = 0.25;
	
	GestureInputSwipeThreshold = 30;
	
	GestureInputEdgeSwipeDistance = 30;
	
	GestureInputVelocityTime = 0.1;
	
	GestureInputForceTapDesktop = MouseEvent.WEBKIT_FORCE_AT_FORCE_MOUSE_DOWN;
	
	GestureInputForceTapMobile = 0.7;
	
	GestureInputForceTapMobilePollTime = 1 / 30;
	
	GestureInputMinimumFingerDistance = 30;
	
	DOMEventManager = __webpack_require__(42).DOMEventManager;
	
	exports.GestureInputRecognizer = (function() {
	  function GestureInputRecognizer() {
	    this._process = bind(this._process, this);
	    this.edgeswipedirectionend = bind(this.edgeswipedirectionend, this);
	    this.edgeswipedirectionstart = bind(this.edgeswipedirectionstart, this);
	    this.edgeswipedirection = bind(this.edgeswipedirection, this);
	    this.swipedirectionend = bind(this.swipedirectionend, this);
	    this.swipedirection = bind(this.swipedirection, this);
	    this.swipedirectionstart = bind(this.swipedirectionstart, this);
	    this.swipeend = bind(this.swipeend, this);
	    this.swipe = bind(this.swipe, this);
	    this.swipestart = bind(this.swipestart, this);
	    this.rotateend = bind(this.rotateend, this);
	    this.rotate = bind(this.rotate, this);
	    this.rotatestart = bind(this.rotatestart, this);
	    this.scaleend = bind(this.scaleend, this);
	    this.scale = bind(this.scale, this);
	    this.scalestart = bind(this.scalestart, this);
	    this.pinchend = bind(this.pinchend, this);
	    this.pinch = bind(this.pinch, this);
	    this.pinchstart = bind(this.pinchstart, this);
	    this.panright = bind(this.panright, this);
	    this.panleft = bind(this.panleft, this);
	    this.pandown = bind(this.pandown, this);
	    this.panup = bind(this.panup, this);
	    this.panend = bind(this.panend, this);
	    this.pan = bind(this.pan, this);
	    this.panstart = bind(this.panstart, this);
	    this.forcetapend = bind(this.forcetapend, this);
	    this.forcetapstart = bind(this.forcetapstart, this);
	    this.forcetapchange = bind(this.forcetapchange, this);
	    this._updateMacForce = bind(this._updateMacForce, this);
	    this._updateTouchForce = bind(this._updateTouchForce, this);
	    this.longpressend = bind(this.longpressend, this);
	    this.longpressstart = bind(this.longpressstart, this);
	    this.doubletap = bind(this.doubletap, this);
	    this.tapend = bind(this.tapend, this);
	    this.tapstart = bind(this.tapstart, this);
	    this.tap = bind(this.tap, this);
	    this.touchend = bind(this.touchend, this);
	    this.touchmove = bind(this.touchmove, this);
	    this.touchstart = bind(this.touchstart, this);
	    this.startTouch = bind(this.startTouch, this);
	    this.startMouse = bind(this.startMouse, this);
	    this.em = new DOMEventManager();
	    this.em.wrap(window).addEventListener("mousedown", this.startMouse);
	    this.em.wrap(window).addEventListener("touchstart", this.startTouch);
	  }
	
	  GestureInputRecognizer.prototype.destroy = function() {
	    return this.em.removeAllListeners();
	  };
	
	  GestureInputRecognizer.prototype.cancel = function() {
	    window.clearTimeout(this.session.pressTimer);
	    return this.session = null;
	  };
	
	  GestureInputRecognizer.prototype.startMouse = function(event) {
	    if (this.session) {
	      return;
	    }
	    this.em.wrap(window).addEventListener("mousemove", this.touchmove);
	    this.em.wrap(window).addEventListener("mouseup", this.touchend);
	    return this.touchstart(event);
	  };
	
	  GestureInputRecognizer.prototype.startTouch = function(event) {
	    if (this.session) {
	      return;
	    }
	    this.em.wrap(window).addEventListener("touchmove", this.touchmove);
	    this.em.wrap(window).addEventListener("touchend", this.touchend);
	    return this.touchstart(event);
	  };
	
	  GestureInputRecognizer.prototype.touchstart = function(event) {
	    if (this.session) {
	      return;
	    }
	    this.em.wrap(window).addEventListener("webkitmouseforcechanged", this._updateMacForce);
	    this.session = {
	      startEvent: this._getGestureEvent(event),
	      lastEvent: null,
	      startMultiEvent: null,
	      startTime: Date.now(),
	      pressTimer: window.setTimeout(this.longpressstart, GestureInputLongPressTime * 1000),
	      started: {},
	      events: [],
	      eventCount: 0
	    };
	    event = this._getGestureEvent(event);
	    this.tapstart(event);
	    if (Date.now() - this.doubleTapTime < (GestureInputDoubleTapTime * 1000)) {
	      this.doubletap(event);
	    } else {
	      this.doubleTapTime = Date.now();
	    }
	    this._process(event);
	    if (Utils.isTouch()) {
	      return this._updateTouchForce();
	    }
	  };
	
	  GestureInputRecognizer.prototype.touchmove = function(event) {
	    return this._process(this._getGestureEvent(event));
	  };
	
	  GestureInputRecognizer.prototype.touchend = function(event) {
	    var eventName, ref, ref1, value;
	    if (event.touches != null) {
	      if (Utils.isTouch()) {
	        if (!(event.touches.length === 0)) {
	          return;
	        }
	      } else {
	        if (!(event.touches.length === event.changedTouches.length)) {
	          return;
	        }
	      }
	    }
	    this.em.wrap(window).removeEventListener("mousemove", this.touchmove);
	    this.em.wrap(window).removeEventListener("mouseup", this.touchend);
	    this.em.wrap(window).removeEventListener("touchmove", this.touchmove);
	    this.em.wrap(window).removeEventListener("touchend", this.touchend);
	    this.em.wrap(window).addEventListener("webkitmouseforcechanged", this._updateMacForce);
	    event = this._getGestureEvent(event);
	    ref = this.session.started;
	    for (eventName in ref) {
	      value = ref[eventName];
	      if (value) {
	        this[eventName + "end"](event);
	      }
	    }
	    if (!((ref1 = this.session) != null ? ref1.startEvent : void 0)) {
	      this.tap(event);
	    } else if (this.session.startEvent.target === event.target) {
	      this.tap(event);
	    }
	    this.tapend(event);
	    return this.cancel();
	  };
	
	  GestureInputRecognizer.prototype.tap = function(event) {
	    return this._dispatchEvent("tap", event);
	  };
	
	  GestureInputRecognizer.prototype.tapstart = function(event) {
	    return this._dispatchEvent("tapstart", event);
	  };
	
	  GestureInputRecognizer.prototype.tapend = function(event) {
	    return this._dispatchEvent("tapend", event);
	  };
	
	  GestureInputRecognizer.prototype.doubletap = function(event) {
	    return this._dispatchEvent("doubletap", event);
	  };
	
	  GestureInputRecognizer.prototype.longpressstart = function() {
	    var event;
	    if (!this.session) {
	      return;
	    }
	    if (this.session.started.longpress) {
	      return;
	    }
	    event = this._getGestureEvent(this.session.startEvent);
	    this.session.started.longpress = event;
	    this._dispatchEvent("longpressstart", event);
	    return this._dispatchEvent("longpress", event);
	  };
	
	  GestureInputRecognizer.prototype.longpressend = function(event) {
	    return this._dispatchEvent("longpressend", event);
	  };
	
	  GestureInputRecognizer.prototype._updateTouchForce = function() {
	    var event, ref, ref1;
	    if (!((ref = this.session) != null ? (ref1 = ref.lastEvent) != null ? ref1.touches.length : void 0 : void 0)) {
	      return;
	    }
	    this.session.force = this.session.lastEvent.touches[0].force || 0;
	    event = this._getGestureEvent(this.session.lastEvent);
	    this.forcetapchange(event);
	    if (this.session.force >= GestureInputForceTapMobile) {
	      this.forcetapstart(event);
	    } else {
	      this.forcetapend(event);
	    }
	    return setTimeout(this._updateTouchForce, GestureInputForceTapMobilePollTime);
	  };
	
	  GestureInputRecognizer.prototype._updateMacForce = function(event) {
	    if (!this.session) {
	      return;
	    }
	    this.session.force = Utils.modulate(event.webkitForce, [0, 3], [0, 1]);
	    this.forcetapchange(this._getGestureEvent(event));
	    if (event.webkitForce >= GestureInputForceTapDesktop) {
	      return this.forcetapstart(event);
	    } else {
	      return this.forcetapend(event);
	    }
	  };
	
	  GestureInputRecognizer.prototype.forcetapchange = function(event) {
	    return this._dispatchEvent("forcetapchange", event);
	  };
	
	  GestureInputRecognizer.prototype.forcetapstart = function(event) {
	    if (!this.session) {
	      return;
	    }
	    if (this.session.started.forcetap) {
	      return;
	    }
	    this.session.started.forcetap = event;
	    this._dispatchEvent("forcetapstart", event);
	    return this._dispatchEvent("forcetap", event);
	  };
	
	  GestureInputRecognizer.prototype.forcetapend = function(event) {
	    if (!this.session) {
	      return;
	    }
	    if (!this.session.started.forcetap) {
	      return;
	    }
	    this.session.started.forcetap = null;
	    return this._dispatchEvent("forcetapend", event);
	  };
	
	  GestureInputRecognizer.prototype.panstart = function(event) {
	    this.session.started.pan = event;
	    return this._dispatchEvent("panstart", event, this.session.started.pan.target);
	  };
	
	  GestureInputRecognizer.prototype.pan = function(event) {
	    var direction;
	    this._dispatchEvent("pan", event, this.session.started.pan.target);
	    direction = this._getDirection(event.delta);
	    if (direction) {
	      return this["pan" + direction](event);
	    }
	  };
	
	  GestureInputRecognizer.prototype.panend = function(event) {
	    this._dispatchEvent("panend", event, this.session.started.pan.target);
	    return this.session.started.pan = null;
	  };
	
	  GestureInputRecognizer.prototype.panup = function(event) {
	    return this._dispatchEvent("panup", event, this.session.started.pan.target);
	  };
	
	  GestureInputRecognizer.prototype.pandown = function(event) {
	    return this._dispatchEvent("pandown", event, this.session.started.pan.target);
	  };
	
	  GestureInputRecognizer.prototype.panleft = function(event) {
	    return this._dispatchEvent("panleft", event, this.session.started.pan.target);
	  };
	
	  GestureInputRecognizer.prototype.panright = function(event) {
	    return this._dispatchEvent("panright", event, this.session.started.pan.target);
	  };
	
	  GestureInputRecognizer.prototype.pinchstart = function(event) {
	    this.session.started.pinch = event;
	    this.scalestart(event, this.session.started.pinch.target);
	    this.rotatestart(event, this.session.started.pinch.target);
	    return this._dispatchEvent("pinchstart", event);
	  };
	
	  GestureInputRecognizer.prototype.pinch = function(event) {
	    this._dispatchEvent("pinch", event);
	    this.scale(event, this.session.started.pinch.target);
	    return this.rotate(event, this.session.started.pinch.target);
	  };
	
	  GestureInputRecognizer.prototype.pinchend = function(event) {
	    this._dispatchEvent("pinchend", event);
	    this.scaleend(event, this.session.started.pinch.target);
	    this.rotateend(event, this.session.started.pinch.target);
	    return this.session.started.pinch = null;
	  };
	
	  GestureInputRecognizer.prototype.scalestart = function(event) {
	    return this._dispatchEvent("scalestart", event);
	  };
	
	  GestureInputRecognizer.prototype.scale = function(event) {
	    return this._dispatchEvent("scale", event);
	  };
	
	  GestureInputRecognizer.prototype.scaleend = function(event) {
	    return this._dispatchEvent("scaleend", event);
	  };
	
	  GestureInputRecognizer.prototype.rotatestart = function(event) {
	    return this._dispatchEvent("rotatestart", event);
	  };
	
	  GestureInputRecognizer.prototype.rotate = function(event) {
	    return this._dispatchEvent("rotate", event);
	  };
	
	  GestureInputRecognizer.prototype.rotateend = function(event) {
	    return this._dispatchEvent("rotateend", event);
	  };
	
	  GestureInputRecognizer.prototype.swipestart = function(event) {
	    this._dispatchEvent("swipestart", event);
	    this.session.started.swipe = event;
	    return this.swipedirectionstart(event);
	  };
	
	  GestureInputRecognizer.prototype.swipe = function(event) {
	    this._dispatchEvent("swipe", event);
	    return this.swipedirection(event);
	  };
	
	  GestureInputRecognizer.prototype.swipeend = function(event) {
	    return this._dispatchEvent("swipeend", event);
	  };
	
	  GestureInputRecognizer.prototype.swipedirectionstart = function(event) {
	    var direction, maxX, maxY, ref, ref1, ref2, ref3, swipeEdge;
	    if (!event.offsetDirection) {
	      return;
	    }
	    if (this.session.started.swipedirection) {
	      return;
	    }
	    this.session.started.swipedirection = event;
	    direction = this.session.started.swipedirection.offsetDirection;
	    this._dispatchEvent("swipe" + direction + "start", event);
	    swipeEdge = this._edgeForSwipeDirection(direction);
	    maxX = Utils.frameGetMaxX(Screen.canvasFrame);
	    maxY = Utils.frameGetMaxY(Screen.canvasFrame);
	    if (swipeEdge === "top" && (0 < (ref = event.start.y - Screen.canvasFrame.y) && ref < GestureInputEdgeSwipeDistance)) {
	      this.edgeswipedirectionstart(event);
	    }
	    if (swipeEdge === "right" && (maxX - GestureInputEdgeSwipeDistance < (ref1 = event.start.x) && ref1 < maxX)) {
	      this.edgeswipedirectionstart(event);
	    }
	    if (swipeEdge === "bottom" && (maxY - GestureInputEdgeSwipeDistance < (ref2 = event.start.y) && ref2 < maxY)) {
	      this.edgeswipedirectionstart(event);
	    }
	    if (swipeEdge === "left" && (0 < (ref3 = event.start.x - Screen.canvasFrame.x) && ref3 < GestureInputEdgeSwipeDistance)) {
	      return this.edgeswipedirectionstart(event);
	    }
	  };
	
	  GestureInputRecognizer.prototype.swipedirection = function(event) {
	    var direction;
	    if (!this.session.started.swipedirection) {
	      return;
	    }
	    direction = this.session.started.swipedirection.offsetDirection;
	    this._dispatchEvent("swipe" + direction, event);
	    if (this.session.started.edgeswipedirection) {
	      return this.edgeswipedirection(event);
	    }
	  };
	
	  GestureInputRecognizer.prototype.swipedirectionend = function(event) {
	    var direction;
	    if (!this.session.started.swipedirection) {
	      return;
	    }
	    direction = this.session.started.swipedirection.offsetDirection;
	    return this._dispatchEvent("swipe" + direction + "end", event);
	  };
	
	  GestureInputRecognizer.prototype.edgeswipedirection = function(event) {
	    var swipeEdge;
	    swipeEdge = this._edgeForSwipeDirection(this.session.started.edgeswipedirection.offsetDirection);
	    Screen.emit("edgeswipe", this._createEvent("edgeswipe", event));
	    return Screen.emit("edgeswipe" + swipeEdge, this._createEvent("edgeswipe" + swipeEdge, event));
	  };
	
	  GestureInputRecognizer.prototype.edgeswipedirectionstart = function(event) {
	    var swipeEdge;
	    if (this.session.started.edgeswipedirection) {
	      return;
	    }
	    this.session.started.edgeswipedirection = event;
	    swipeEdge = this._edgeForSwipeDirection(this.session.started.edgeswipedirection.offsetDirection);
	    Screen.emit("edgeswipestart", this._createEvent("edgeswipestart", event));
	    return Screen.emit("edgeswipe" + swipeEdge + "start", this._createEvent("edgeswipe" + swipeEdge + "start", event));
	  };
	
	  GestureInputRecognizer.prototype.edgeswipedirectionend = function(event) {
	    var swipeEdge;
	    swipeEdge = this._edgeForSwipeDirection(this.session.started.edgeswipedirection.offsetDirection);
	    Screen.emit("edgeswipeend", this._createEvent("edgeswipeend", event));
	    return Screen.emit("edgeswipe" + swipeEdge + "end", this._createEvent("edgeswipe" + swipeEdge + "end", event));
	  };
	
	  GestureInputRecognizer.prototype._process = function(event) {
	    if (!this.session) {
	      return;
	    }
	    this.session.events.push(event);
	    event.eventCount = this.session.eventCount++;
	    if (Math.abs(event.delta.x) > 0 || Math.abs(event.delta.y) > 0) {
	      if (!this.session.started.pan) {
	        this.panstart(event);
	      } else {
	        this.pan(event);
	      }
	    }
	    if (this.session.started.pinch && event.fingers === 1) {
	      this.pinchend(event);
	    } else if (!this.session.started.pinch && event.fingers === 2) {
	      this.pinchstart(event);
	    } else if (this.session.started.pinch) {
	      this.pinch(event);
	    }
	    if (!this.session.started.swipe && (Math.abs(event.offset.x) > GestureInputSwipeThreshold || Math.abs(event.offset.y) > GestureInputSwipeThreshold)) {
	      this.swipestart(event);
	    } else if (this.session.started.swipe) {
	      this.swipe(event);
	    }
	    return this.session.lastEvent = event;
	  };
	
	  GestureInputRecognizer.prototype._getEventPoint = function(event) {
	    var ref;
	    if ((ref = event.touches) != null ? ref.length : void 0) {
	      return this._getTouchPoint(event, 0);
	    }
	    return {
	      x: event.pageX,
	      y: event.pageY
	    };
	  };
	
	  GestureInputRecognizer.prototype._getGestureEvent = function(event) {
	    var events, i, len, pointKey, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, touchPointA, touchPointB;
	    _.extend(event, {
	      time: Date.now(),
	      point: this._getEventPoint(event),
	      start: this._getEventPoint(event),
	      previous: this._getEventPoint(event),
	      offset: {
	        x: 0,
	        y: 0
	      },
	      offsetTime: 0,
	      offsetAngle: 0,
	      offsetDirection: null,
	      delta: {
	        x: 0,
	        y: 0
	      },
	      deltaTime: 0,
	      deltaAngle: 0,
	      deltaDirection: null,
	      force: 0,
	      velocity: {
	        x: 0,
	        y: 0
	      },
	      fingers: ((ref = event.touches) != null ? ref.length : void 0) || 0,
	      touchCenter: this._getEventPoint(event),
	      touchOffset: {
	        x: 0,
	        y: 0
	      },
	      touchDistance: 0,
	      scale: 1,
	      scaleDirection: null,
	      rotation: 0
	    });
	    if ((ref1 = this.session) != null ? ref1.startEvent : void 0) {
	      event.start = this.session.startEvent.point;
	      event.offset = Utils.pointSubtract(event.point, event.start);
	      event.offsetTime = event.time - this.session.startEvent.time;
	      event.offsetAngle = Utils.pointAngle(this.session.startEvent.point, event.point);
	      event.offsetDirection = this._getDirection(event.offset);
	      event.touchCenterStart = this.session.startEvent.touchCenter;
	    }
	    if ((ref2 = this.session) != null ? ref2.lastEvent : void 0) {
	      event.previous = this.session.lastEvent.point;
	      event.deltaTime = event.time - this.session.lastEvent.time;
	      event.delta = Utils.pointSubtract(event.point, this.session.lastEvent.point);
	      event.deltaAngle = Utils.pointAngle(event.point, this.session.lastEvent.point);
	      event.deltaDirection = this._getDirection(event.delta);
	    }
	    if (event.fingers > 1) {
	      touchPointA = this._getTouchPoint(event, 0);
	      touchPointB = this._getTouchPoint(event, 1);
	      event.touchCenter = Utils.pointCenter(touchPointB, touchPointA);
	      event.touchOffset = Utils.pointSubtract(touchPointB, touchPointA);
	      event.touchDistance = _.max([GestureInputMinimumFingerDistance, Utils.pointDistance(touchPointA, touchPointB)]);
	      event.rotation = Utils.pointAngle(touchPointA, touchPointB);
	    }
	    if ((ref3 = this.session) != null ? ref3.events : void 0) {
	      events = _.filter(this.session.events, function(e) {
	        if (e.eventCount === 0) {
	          return false;
	        }
	        return e.time > (event.time - (GestureInputVelocityTime * 1000));
	      });
	      event.velocity = this._getVelocity(events);
	    }
	    if ((ref4 = this.session) != null ? ref4.started.pinch : void 0) {
	      event.scale = event.touchDistance / this.session.started.pinch.touchDistance;
	      event.scaleDirection = this._getScaleDirection(event.scale - this.session.lastEvent.scale);
	      if (!event.scaleDirection && ((ref5 = this.session) != null ? ref5.lastEvent : void 0)) {
	        event.scaleDirection = this.session.lastEvent.scaleDirection;
	      }
	    }
	    if ((ref6 = this.session) != null ? ref6.lastEvent : void 0) {
	      if ((event.fingers !== (ref7 = this.session.lastEvent.fingers) && ref7 === 2)) {
	        event.delta = {
	          x: 0,
	          y: 0
	        };
	      }
	      if (event.fingers === 2 && this.session.lastEvent.fingers === 2) {
	        event.delta = Utils.pointSubtract(event.touchCenter, this.session.lastEvent.touchCenter);
	      }
	    }
	    if ((ref8 = this.session) != null ? ref8.lastEvent : void 0) {
	      if (this.session.force) {
	        event.force = this.session.force;
	      }
	    }
	    ref9 = ["point", "start", "previous", "offset", "delta", "velocity", "touchCenter", "touchOffset"];
	    for (i = 0, len = ref9.length; i < len; i++) {
	      pointKey = ref9[i];
	      event[pointKey + "X"] = event[pointKey].x;
	      event[pointKey + "Y"] = event[pointKey].y;
	    }
	    return event;
	  };
	
	  GestureInputRecognizer.prototype._getTouchPoint = function(event, index) {
	    var point;
	    return point = {
	      x: event.touches[index].pageX,
	      y: event.touches[index].pageY
	    };
	  };
	
	  GestureInputRecognizer.prototype._getDirection = function(offset) {
	    if (Math.abs(offset.x) > Math.abs(offset.y)) {
	      if (offset.x > 0) {
	        return "right";
	      }
	      if (offset.x < 0) {
	        return "left";
	      }
	    }
	    if (Math.abs(offset.x) < Math.abs(offset.y)) {
	      if (offset.y < 0) {
	        return "up";
	      }
	      if (offset.y > 0) {
	        return "down";
	      }
	    }
	    return null;
	  };
	
	  GestureInputRecognizer.prototype._edgeForSwipeDirection = function(direction) {
	    if (direction === "down") {
	      return "top";
	    }
	    if (direction === "left") {
	      return "right";
	    }
	    if (direction === "up") {
	      return "bottom";
	    }
	    if (direction === "right") {
	      return "left";
	    }
	    return null;
	  };
	
	  GestureInputRecognizer.prototype._getScaleDirection = function(offset) {
	    if (offset > 0) {
	      return "up";
	    }
	    if (offset < 0) {
	      return "down";
	    }
	    return null;
	  };
	
	  GestureInputRecognizer.prototype._createEvent = function(type, event) {
	    var k, touchEvent, v;
	    touchEvent = document.createEvent("MouseEvent");
	    touchEvent.initMouseEvent(type, true, true, window, event.detail, event.screenX, event.screenY, event.clientX, event.clientY, event.ctrlKey, event.shiftKey, event.altKey, event.metaKey, event.button, event.relatedTarget);
	    touchEvent.touches = event.touches;
	    touchEvent.changedTouches = event.touches;
	    touchEvent.targetTouches = event.touches;
	    for (k in event) {
	      v = event[k];
	      touchEvent[k] = v;
	    }
	    return touchEvent;
	  };
	
	  GestureInputRecognizer.prototype._dispatchEvent = function(type, event, target) {
	    var ref, ref1, touchEvent;
	    touchEvent = this._createEvent(type, event);
	    if (target == null) {
	      target = (ref = this.session) != null ? (ref1 = ref.startEvent) != null ? ref1.target : void 0 : void 0;
	    }
	    if (target == null) {
	      target = event.target;
	    }
	    return target.dispatchEvent(touchEvent);
	  };
	
	  GestureInputRecognizer.prototype._getVelocity = function(events) {
	    var current, first, time, velocity;
	    if (events.length < 2) {
	      return {
	        x: 0,
	        y: 0
	      };
	    }
	    current = events[events.length - 1];
	    first = events[0];
	    time = current.time - first.time;
	    velocity = {
	      x: (current.point.x - first.point.x) / time,
	      y: (current.point.y - first.point.y) / time
	    };
	    if (velocity.x === Infinity) {
	      velocity.x = 0;
	    }
	    if (velocity.y === Infinity) {
	      velocity.y = 0;
	    }
	    return velocity;
	  };
	
	  return GestureInputRecognizer;

	})();


/***/ },
/* 54 */
/***/ function(module, exports) {

	exports.date = 1461931338;
	
	exports.branch = "ben-components";
	
	exports.hash = "17cf486";
	
	exports.build = 1677;
	
	exports.version = exports.branch + "/" + exports.hash;


/***/ }
/******/ ]);

},{}]},{},[])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIuLi8uLi8uLi8uLi8uLi9Vc2Vycy9iZW4vRG9jdW1lbnRzL0Rlc2lnbi9GcmFtZXIvRnJhbWVyL2V4dHJhcy9EZXZTZXJ2ZXIuZnJhbWVyL21vZHVsZXMvZnJhbWVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcbi8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2Vcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBEZWZhdWx0cywgRnJhbWVyLCBfO1xuXHRcblx0XyA9IF9fd2VicGFja19yZXF1aXJlX18oMSkuXztcblx0XG5cdGlmICh3aW5kb3cub250b3VjaHN0YXJ0ID09PSB2b2lkIDApIHtcblx0ICB3aW5kb3cub250b3VjaHN0YXJ0ID0gbnVsbDtcblx0fVxuXHRcblx0RnJhbWVyID0ge307XG5cdFxuXHRGcmFtZXIuXyA9IF87XG5cdFxuXHRGcmFtZXIuVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHRcblx0RnJhbWVyLkNvbG9yID0gKF9fd2VicGFja19yZXF1aXJlX18oMTApKS5Db2xvcjtcblx0XG5cdEZyYW1lci5MYXllciA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKSkuTGF5ZXI7XG5cdFxuXHRGcmFtZXIuQmFja2dyb3VuZExheWVyID0gKF9fd2VicGFja19yZXF1aXJlX18oMzUpKS5CYWNrZ3JvdW5kTGF5ZXI7XG5cdFxuXHRGcmFtZXIuVmlkZW9MYXllciA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KSkuVmlkZW9MYXllcjtcblx0XG5cdEZyYW1lci5FdmVudHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygxNSkpLkV2ZW50cztcblx0XG5cdEZyYW1lci5HZXN0dXJlcyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KSkuR2VzdHVyZXM7XG5cdFxuXHRGcmFtZXIuQW5pbWF0aW9uID0gKF9fd2VicGFja19yZXF1aXJlX18oMTgpKS5BbmltYXRpb247XG5cdFxuXHRGcmFtZXIuQW5pbWF0aW9uR3JvdXAgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygzNykpLkFuaW1hdGlvbkdyb3VwO1xuXHRcblx0RnJhbWVyLlNjcmVlbiA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDUpKS5TY3JlZW47XG5cdFxuXHRGcmFtZXIuQ2FudmFzID0gKF9fd2VicGFja19yZXF1aXJlX18oMzgpKS5DYW52YXM7XG5cdFxuXHRGcmFtZXIuQWxpZ24gPSAoX193ZWJwYWNrX3JlcXVpcmVfXygzOSkpLkFsaWduO1xuXHRcblx0RnJhbWVyLnByaW50ID0gKF9fd2VicGFja19yZXF1aXJlX18oNDApKS5wcmludDtcblx0XG5cdEZyYW1lci5TY3JvbGxDb21wb25lbnQgPSAoX193ZWJwYWNrX3JlcXVpcmVfXyg0MykpLlNjcm9sbENvbXBvbmVudDtcblx0XG5cdEZyYW1lci5QYWdlQ29tcG9uZW50ID0gKF9fd2VicGFja19yZXF1aXJlX18oNDQpKS5QYWdlQ29tcG9uZW50O1xuXHRcblx0RnJhbWVyLlNsaWRlckNvbXBvbmVudCA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1KSkuU2xpZGVyQ29tcG9uZW50O1xuXHRcblx0RnJhbWVyLkRldmljZUNvbXBvbmVudCA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2KSkuRGV2aWNlQ29tcG9uZW50O1xuXHRcblx0RnJhbWVyLkRldmljZVZpZXcgPSBGcmFtZXIuRGV2aWNlQ29tcG9uZW50O1xuXHRcblx0aWYgKHdpbmRvdykge1xuXHQgIF8uZXh0ZW5kKHdpbmRvdywgRnJhbWVyKTtcblx0fVxuXHRcblx0RnJhbWVyLkNvbnRleHQgPSAoX193ZWJwYWNrX3JlcXVpcmVfXyg0MSkpLkNvbnRleHQ7XG5cdFxuXHRGcmFtZXIuQ29uZmlnID0gKF9fd2VicGFja19yZXF1aXJlX18oMTQpKS5Db25maWc7XG5cdFxuXHRGcmFtZXIuRXZlbnRFbWl0dGVyID0gKF9fd2VicGFja19yZXF1aXJlX18oNykpLkV2ZW50RW1pdHRlcjtcblx0XG5cdEZyYW1lci5CYXNlQ2xhc3MgPSAoX193ZWJwYWNrX3JlcXVpcmVfXyg2KSkuQmFzZUNsYXNzO1xuXHRcblx0RnJhbWVyLkxheWVyU3R5bGUgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygyNSkpLkxheWVyU3R5bGU7XG5cdFxuXHRGcmFtZXIuQW5pbWF0aW9uTG9vcCA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KSkuQW5pbWF0aW9uTG9vcDtcblx0XG5cdEZyYW1lci5MaW5lYXJBbmltYXRvciA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KSkuTGluZWFyQW5pbWF0b3I7XG5cdFxuXHRGcmFtZXIuQmV6aWVyQ3VydmVBbmltYXRvciA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKSkuQmV6aWVyQ3VydmVBbmltYXRvcjtcblx0XG5cdEZyYW1lci5TcHJpbmdESE9BbmltYXRvciA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KSkuU3ByaW5nREhPQW5pbWF0b3I7XG5cdFxuXHRGcmFtZXIuU3ByaW5nUks0QW5pbWF0b3IgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygyMikpLlNwcmluZ1JLNEFuaW1hdG9yO1xuXHRcblx0RnJhbWVyLkxheWVyRHJhZ2dhYmxlID0gKF9fd2VicGFja19yZXF1aXJlX18oMjcpKS5MYXllckRyYWdnYWJsZTtcblx0XG5cdEZyYW1lci5JbXBvcnRlciA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDQ4KSkuSW1wb3J0ZXI7XG5cdFxuXHRGcmFtZXIuRXh0cmFzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OSk7XG5cdFxuXHRGcmFtZXIuR2VzdHVyZUlucHV0UmVjb2duaXplciA9IG5ldyAoX193ZWJwYWNrX3JlcXVpcmVfXyg1MykpLkdlc3R1cmVJbnB1dFJlY29nbml6ZXI7XG5cdFxuXHRGcmFtZXIuVmVyc2lvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNTQpO1xuXHRcblx0RnJhbWVyLkxvb3AgPSBuZXcgRnJhbWVyLkFuaW1hdGlvbkxvb3AoKTtcblx0XG5cdFV0aWxzLmRvbUNvbXBsZXRlKEZyYW1lci5Mb29wLnN0YXJ0KTtcblx0XG5cdGlmICh3aW5kb3cpIHtcblx0ICB3aW5kb3cuRnJhbWVyID0gRnJhbWVyO1xuXHR9XG5cdFxuXHREZWZhdWx0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KSkuRGVmYXVsdHM7XG5cdFxuXHREZWZhdWx0cy5zZXR1cCgpO1xuXHRcblx0RnJhbWVyLnJlc2V0RGVmYXVsdHMgPSBEZWZhdWx0cy5yZXNldDtcblx0XG5cdEZyYW1lci5EZWZhdWx0Q29udGV4dCA9IG5ldyBGcmFtZXIuQ29udGV4dCh7XG5cdCAgbmFtZTogXCJEZWZhdWx0XCJcblx0fSk7XG5cdFxuXHRGcmFtZXIuRGVmYXVsdENvbnRleHQuYmFja2dyb3VuZENvbG9yID0gXCJ3aGl0ZVwiO1xuXHRcblx0RnJhbWVyLkN1cnJlbnRDb250ZXh0ID0gRnJhbWVyLkRlZmF1bHRDb250ZXh0O1xuXHRcblx0aWYgKFV0aWxzLmlzTW9iaWxlKCkpIHtcblx0ICBGcmFtZXIuRXh0cmFzLk1vYmlsZVNjcm9sbEZpeC5lbmFibGUoKTtcblx0fVxuXHRcblx0aWYgKCFVdGlscy5pc1RvdWNoKCkpIHtcblx0ICBGcmFtZXIuRXh0cmFzLlRvdWNoRW11bGF0b3IuZW5hYmxlKCk7XG5cdH1cblxuXG4vKioqLyB9LFxuLyogMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0ZXhwb3J0cy5fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxuXG4vKioqLyB9LFxuLyogMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihtb2R1bGUsIGdsb2JhbCkgey8qKlxuXHQgKiBAbGljZW5zZVxuXHQgKiBsb2Rhc2ggMy4xMC4xIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuXHQgKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gLWQgLW8gLi9pbmRleC5qc2Bcblx0ICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cblx0ICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cblx0ICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuXHQgKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuXHQgKi9cblx0OyhmdW5jdGlvbigpIHtcblx0XG5cdCAgLyoqIFVzZWQgYXMgYSBzYWZlIHJlZmVyZW5jZSBmb3IgYHVuZGVmaW5lZGAgaW4gcHJlLUVTNSBlbnZpcm9ubWVudHMuICovXG5cdCAgdmFyIHVuZGVmaW5lZDtcblx0XG5cdCAgLyoqIFVzZWQgYXMgdGhlIHNlbWFudGljIHZlcnNpb24gbnVtYmVyLiAqL1xuXHQgIHZhciBWRVJTSU9OID0gJzMuMTAuMSc7XG5cdFxuXHQgIC8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHdyYXBwZXIgbWV0YWRhdGEuICovXG5cdCAgdmFyIEJJTkRfRkxBRyA9IDEsXG5cdCAgICAgIEJJTkRfS0VZX0ZMQUcgPSAyLFxuXHQgICAgICBDVVJSWV9CT1VORF9GTEFHID0gNCxcblx0ICAgICAgQ1VSUllfRkxBRyA9IDgsXG5cdCAgICAgIENVUlJZX1JJR0hUX0ZMQUcgPSAxNixcblx0ICAgICAgUEFSVElBTF9GTEFHID0gMzIsXG5cdCAgICAgIFBBUlRJQUxfUklHSFRfRkxBRyA9IDY0LFxuXHQgICAgICBBUllfRkxBRyA9IDEyOCxcblx0ICAgICAgUkVBUkdfRkxBRyA9IDI1Njtcblx0XG5cdCAgLyoqIFVzZWQgYXMgZGVmYXVsdCBvcHRpb25zIGZvciBgXy50cnVuY2AuICovXG5cdCAgdmFyIERFRkFVTFRfVFJVTkNfTEVOR1RIID0gMzAsXG5cdCAgICAgIERFRkFVTFRfVFJVTkNfT01JU1NJT04gPSAnLi4uJztcblx0XG5cdCAgLyoqIFVzZWQgdG8gZGV0ZWN0IHdoZW4gYSBmdW5jdGlvbiBiZWNvbWVzIGhvdC4gKi9cblx0ICB2YXIgSE9UX0NPVU5UID0gMTUwLFxuXHQgICAgICBIT1RfU1BBTiA9IDE2O1xuXHRcblx0ICAvKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cblx0ICB2YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblx0XG5cdCAgLyoqIFVzZWQgdG8gaW5kaWNhdGUgdGhlIHR5cGUgb2YgbGF6eSBpdGVyYXRlZXMuICovXG5cdCAgdmFyIExBWllfRklMVEVSX0ZMQUcgPSAxLFxuXHQgICAgICBMQVpZX01BUF9GTEFHID0gMjtcblx0XG5cdCAgLyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFwiRnVuY3Rpb25zXCIgbWV0aG9kcy4gKi9cblx0ICB2YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXHRcblx0ICAvKiogVXNlZCBhcyB0aGUgaW50ZXJuYWwgYXJndW1lbnQgcGxhY2Vob2xkZXIuICovXG5cdCAgdmFyIFBMQUNFSE9MREVSID0gJ19fbG9kYXNoX3BsYWNlaG9sZGVyX18nO1xuXHRcblx0ICAvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG5cdCAgdmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcblx0ICAgICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuXHQgICAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuXHQgICAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuXHQgICAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG5cdCAgICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuXHQgICAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcblx0ICAgICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG5cdCAgICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuXHQgICAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcblx0ICAgICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG5cdCAgICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuXHQgICAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXHRcblx0ICB2YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuXHQgICAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG5cdCAgICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcblx0ICAgICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuXHQgICAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcblx0ICAgICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG5cdCAgICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuXHQgICAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuXHQgICAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuXHQgICAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXHRcblx0ICAvKiogVXNlZCB0byBtYXRjaCBlbXB0eSBzdHJpbmcgbGl0ZXJhbHMgaW4gY29tcGlsZWQgdGVtcGxhdGUgc291cmNlLiAqL1xuXHQgIHZhciByZUVtcHR5U3RyaW5nTGVhZGluZyA9IC9cXGJfX3AgXFwrPSAnJzsvZyxcblx0ICAgICAgcmVFbXB0eVN0cmluZ01pZGRsZSA9IC9cXGIoX19wIFxcKz0pICcnIFxcKy9nLFxuXHQgICAgICByZUVtcHR5U3RyaW5nVHJhaWxpbmcgPSAvKF9fZVxcKC4qP1xcKXxcXGJfX3RcXCkpIFxcK1xcbicnOy9nO1xuXHRcblx0ICAvKiogVXNlZCB0byBtYXRjaCBIVE1MIGVudGl0aWVzIGFuZCBIVE1MIGNoYXJhY3RlcnMuICovXG5cdCAgdmFyIHJlRXNjYXBlZEh0bWwgPSAvJig/OmFtcHxsdHxndHxxdW90fCMzOXwjOTYpOy9nLFxuXHQgICAgICByZVVuZXNjYXBlZEh0bWwgPSAvWyY8PlwiJ2BdL2csXG5cdCAgICAgIHJlSGFzRXNjYXBlZEh0bWwgPSBSZWdFeHAocmVFc2NhcGVkSHRtbC5zb3VyY2UpLFxuXHQgICAgICByZUhhc1VuZXNjYXBlZEh0bWwgPSBSZWdFeHAocmVVbmVzY2FwZWRIdG1sLnNvdXJjZSk7XG5cdFxuXHQgIC8qKiBVc2VkIHRvIG1hdGNoIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG5cdCAgdmFyIHJlRXNjYXBlID0gLzwlLShbXFxzXFxTXSs/KSU+L2csXG5cdCAgICAgIHJlRXZhbHVhdGUgPSAvPCUoW1xcc1xcU10rPyklPi9nLFxuXHQgICAgICByZUludGVycG9sYXRlID0gLzwlPShbXFxzXFxTXSs/KSU+L2c7XG5cdFxuXHQgIC8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cblx0ICB2YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxuXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcblx0ICAgICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvLFxuXHQgICAgICByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcblxcXFxdfFxcXFwuKSo/KVxcMilcXF0vZztcblx0XG5cdCAgLyoqXG5cdCAgICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYCBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXBhdHRlcm5zKVxuXHQgICAqIGFuZCB0aG9zZSBvdXRsaW5lZCBieSBbYEVzY2FwZVJlZ0V4cFBhdHRlcm5gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1lc2NhcGVyZWdleHBwYXR0ZXJuKS5cblx0ICAgKi9cblx0ICB2YXIgcmVSZWdFeHBDaGFycyA9IC9eWzohLF18W1xcXFxeJC4qKz8oKVtcXF17fXxcXC9dfCheWzAtOWEtZkEtRm5ydHV2eF0pfChbXFxuXFxyXFx1MjAyOFxcdTIwMjldKS9nLFxuXHQgICAgICByZUhhc1JlZ0V4cENoYXJzID0gUmVnRXhwKHJlUmVnRXhwQ2hhcnMuc291cmNlKTtcblx0XG5cdCAgLyoqIFVzZWQgdG8gbWF0Y2ggW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzKS4gKi9cblx0ICB2YXIgcmVDb21ib01hcmsgPSAvW1xcdTAzMDAtXFx1MDM2ZlxcdWZlMjAtXFx1ZmUyM10vZztcblx0XG5cdCAgLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG5cdCAgdmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXHRcblx0ICAvKiogVXNlZCB0byBtYXRjaCBbRVMgdGVtcGxhdGUgZGVsaW1pdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtdGVtcGxhdGUtbGl0ZXJhbC1sZXhpY2FsLWNvbXBvbmVudHMpLiAqL1xuXHQgIHZhciByZUVzVGVtcGxhdGUgPSAvXFwkXFx7KFteXFxcXH1dKig/OlxcXFwuW15cXFxcfV0qKSopXFx9L2c7XG5cdFxuXHQgIC8qKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzLiAqL1xuXHQgIHZhciByZUZsYWdzID0gL1xcdyokLztcblx0XG5cdCAgLyoqIFVzZWQgdG8gZGV0ZWN0IGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG5cdCAgdmFyIHJlSGFzSGV4UHJlZml4ID0gL14wW3hYXS87XG5cdFxuXHQgIC8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpID4gNSkuICovXG5cdCAgdmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cdFxuXHQgIC8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cblx0ICB2YXIgcmVJc1VpbnQgPSAvXlxcZCskLztcblx0XG5cdCAgLyoqIFVzZWQgdG8gbWF0Y2ggbGF0aW4tMSBzdXBwbGVtZW50YXJ5IGxldHRlcnMgKGV4Y2x1ZGluZyBtYXRoZW1hdGljYWwgb3BlcmF0b3JzKS4gKi9cblx0ICB2YXIgcmVMYXRpbjEgPSAvW1xceGMwLVxceGQ2XFx4ZDgtXFx4ZGVcXHhkZi1cXHhmNlxceGY4LVxceGZmXS9nO1xuXHRcblx0ICAvKiogVXNlZCB0byBlbnN1cmUgY2FwdHVyaW5nIG9yZGVyIG9mIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG5cdCAgdmFyIHJlTm9NYXRjaCA9IC8oJF4pLztcblx0XG5cdCAgLyoqIFVzZWQgdG8gbWF0Y2ggdW5lc2NhcGVkIGNoYXJhY3RlcnMgaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLiAqL1xuXHQgIHZhciByZVVuZXNjYXBlZFN0cmluZyA9IC9bJ1xcblxcclxcdTIwMjhcXHUyMDI5XFxcXF0vZztcblx0XG5cdCAgLyoqIFVzZWQgdG8gbWF0Y2ggd29yZHMgdG8gY3JlYXRlIGNvbXBvdW5kIHdvcmRzLiAqL1xuXHQgIHZhciByZVdvcmRzID0gKGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIHVwcGVyID0gJ1tBLVpcXFxceGMwLVxcXFx4ZDZcXFxceGQ4LVxcXFx4ZGVdJyxcblx0ICAgICAgICBsb3dlciA9ICdbYS16XFxcXHhkZi1cXFxceGY2XFxcXHhmOC1cXFxceGZmXSsnO1xuXHRcblx0ICAgIHJldHVybiBSZWdFeHAodXBwZXIgKyAnKyg/PScgKyB1cHBlciArIGxvd2VyICsgJyl8JyArIHVwcGVyICsgJz8nICsgbG93ZXIgKyAnfCcgKyB1cHBlciArICcrfFswLTldKycsICdnJyk7XG5cdCAgfSgpKTtcblx0XG5cdCAgLyoqIFVzZWQgdG8gYXNzaWduIGRlZmF1bHQgYGNvbnRleHRgIG9iamVjdCBwcm9wZXJ0aWVzLiAqL1xuXHQgIHZhciBjb250ZXh0UHJvcHMgPSBbXG5cdCAgICAnQXJyYXknLCAnQXJyYXlCdWZmZXInLCAnRGF0ZScsICdFcnJvcicsICdGbG9hdDMyQXJyYXknLCAnRmxvYXQ2NEFycmF5Jyxcblx0ICAgICdGdW5jdGlvbicsICdJbnQ4QXJyYXknLCAnSW50MTZBcnJheScsICdJbnQzMkFycmF5JywgJ01hdGgnLCAnTnVtYmVyJyxcblx0ICAgICdPYmplY3QnLCAnUmVnRXhwJywgJ1NldCcsICdTdHJpbmcnLCAnXycsICdjbGVhclRpbWVvdXQnLCAnaXNGaW5pdGUnLFxuXHQgICAgJ3BhcnNlRmxvYXQnLCAncGFyc2VJbnQnLCAnc2V0VGltZW91dCcsICdUeXBlRXJyb3InLCAnVWludDhBcnJheScsXG5cdCAgICAnVWludDhDbGFtcGVkQXJyYXknLCAnVWludDE2QXJyYXknLCAnVWludDMyQXJyYXknLCAnV2Vha01hcCdcblx0ICBdO1xuXHRcblx0ICAvKiogVXNlZCB0byBtYWtlIHRlbXBsYXRlIHNvdXJjZVVSTHMgZWFzaWVyIHRvIGlkZW50aWZ5LiAqL1xuXHQgIHZhciB0ZW1wbGF0ZUNvdW50ZXIgPSAtMTtcblx0XG5cdCAgLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xuXHQgIHZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xuXHQgIHR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxuXHQgIHR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cblx0ICB0eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxuXHQgIHR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cblx0ICB0eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcblx0ICB0eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG5cdCAgdHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxuXHQgIHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID0gdHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID1cblx0ICB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9IHR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPVxuXHQgIHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID1cblx0ICB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID0gdHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9XG5cdCAgdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cdFxuXHQgIC8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIHN1cHBvcnRlZCBieSBgXy5jbG9uZWAuICovXG5cdCAgdmFyIGNsb25lYWJsZVRhZ3MgPSB7fTtcblx0ICBjbG9uZWFibGVUYWdzW2FyZ3NUYWddID0gY2xvbmVhYmxlVGFnc1thcnJheVRhZ10gPVxuXHQgIGNsb25lYWJsZVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gY2xvbmVhYmxlVGFnc1tib29sVGFnXSA9XG5cdCAgY2xvbmVhYmxlVGFnc1tkYXRlVGFnXSA9IGNsb25lYWJsZVRhZ3NbZmxvYXQzMlRhZ10gPVxuXHQgIGNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDhUYWddID1cblx0ICBjbG9uZWFibGVUYWdzW2ludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50MzJUYWddID1cblx0ICBjbG9uZWFibGVUYWdzW251bWJlclRhZ10gPSBjbG9uZWFibGVUYWdzW29iamVjdFRhZ10gPVxuXHQgIGNsb25lYWJsZVRhZ3NbcmVnZXhwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3RyaW5nVGFnXSA9XG5cdCAgY2xvbmVhYmxlVGFnc1t1aW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPVxuXHQgIGNsb25lYWJsZVRhZ3NbdWludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG5cdCAgY2xvbmVhYmxlVGFnc1tlcnJvclRhZ10gPSBjbG9uZWFibGVUYWdzW2Z1bmNUYWddID1cblx0ICBjbG9uZWFibGVUYWdzW21hcFRhZ10gPSBjbG9uZWFibGVUYWdzW3NldFRhZ10gPVxuXHQgIGNsb25lYWJsZVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblx0XG5cdCAgLyoqIFVzZWQgdG8gbWFwIGxhdGluLTEgc3VwcGxlbWVudGFyeSBsZXR0ZXJzIHRvIGJhc2ljIGxhdGluIGxldHRlcnMuICovXG5cdCAgdmFyIGRlYnVycmVkTGV0dGVycyA9IHtcblx0ICAgICdcXHhjMCc6ICdBJywgICdcXHhjMSc6ICdBJywgJ1xceGMyJzogJ0EnLCAnXFx4YzMnOiAnQScsICdcXHhjNCc6ICdBJywgJ1xceGM1JzogJ0EnLFxuXHQgICAgJ1xceGUwJzogJ2EnLCAgJ1xceGUxJzogJ2EnLCAnXFx4ZTInOiAnYScsICdcXHhlMyc6ICdhJywgJ1xceGU0JzogJ2EnLCAnXFx4ZTUnOiAnYScsXG5cdCAgICAnXFx4YzcnOiAnQycsICAnXFx4ZTcnOiAnYycsXG5cdCAgICAnXFx4ZDAnOiAnRCcsICAnXFx4ZjAnOiAnZCcsXG5cdCAgICAnXFx4YzgnOiAnRScsICAnXFx4YzknOiAnRScsICdcXHhjYSc6ICdFJywgJ1xceGNiJzogJ0UnLFxuXHQgICAgJ1xceGU4JzogJ2UnLCAgJ1xceGU5JzogJ2UnLCAnXFx4ZWEnOiAnZScsICdcXHhlYic6ICdlJyxcblx0ICAgICdcXHhjQyc6ICdJJywgICdcXHhjZCc6ICdJJywgJ1xceGNlJzogJ0knLCAnXFx4Y2YnOiAnSScsXG5cdCAgICAnXFx4ZUMnOiAnaScsICAnXFx4ZWQnOiAnaScsICdcXHhlZSc6ICdpJywgJ1xceGVmJzogJ2knLFxuXHQgICAgJ1xceGQxJzogJ04nLCAgJ1xceGYxJzogJ24nLFxuXHQgICAgJ1xceGQyJzogJ08nLCAgJ1xceGQzJzogJ08nLCAnXFx4ZDQnOiAnTycsICdcXHhkNSc6ICdPJywgJ1xceGQ2JzogJ08nLCAnXFx4ZDgnOiAnTycsXG5cdCAgICAnXFx4ZjInOiAnbycsICAnXFx4ZjMnOiAnbycsICdcXHhmNCc6ICdvJywgJ1xceGY1JzogJ28nLCAnXFx4ZjYnOiAnbycsICdcXHhmOCc6ICdvJyxcblx0ICAgICdcXHhkOSc6ICdVJywgICdcXHhkYSc6ICdVJywgJ1xceGRiJzogJ1UnLCAnXFx4ZGMnOiAnVScsXG5cdCAgICAnXFx4ZjknOiAndScsICAnXFx4ZmEnOiAndScsICdcXHhmYic6ICd1JywgJ1xceGZjJzogJ3UnLFxuXHQgICAgJ1xceGRkJzogJ1knLCAgJ1xceGZkJzogJ3knLCAnXFx4ZmYnOiAneScsXG5cdCAgICAnXFx4YzYnOiAnQWUnLCAnXFx4ZTYnOiAnYWUnLFxuXHQgICAgJ1xceGRlJzogJ1RoJywgJ1xceGZlJzogJ3RoJyxcblx0ICAgICdcXHhkZic6ICdzcydcblx0ICB9O1xuXHRcblx0ICAvKiogVXNlZCB0byBtYXAgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLiAqL1xuXHQgIHZhciBodG1sRXNjYXBlcyA9IHtcblx0ICAgICcmJzogJyZhbXA7Jyxcblx0ICAgICc8JzogJyZsdDsnLFxuXHQgICAgJz4nOiAnJmd0OycsXG5cdCAgICAnXCInOiAnJnF1b3Q7Jyxcblx0ICAgIFwiJ1wiOiAnJiMzOTsnLFxuXHQgICAgJ2AnOiAnJiM5NjsnXG5cdCAgfTtcblx0XG5cdCAgLyoqIFVzZWQgdG8gbWFwIEhUTUwgZW50aXRpZXMgdG8gY2hhcmFjdGVycy4gKi9cblx0ICB2YXIgaHRtbFVuZXNjYXBlcyA9IHtcblx0ICAgICcmYW1wOyc6ICcmJyxcblx0ICAgICcmbHQ7JzogJzwnLFxuXHQgICAgJyZndDsnOiAnPicsXG5cdCAgICAnJnF1b3Q7JzogJ1wiJyxcblx0ICAgICcmIzM5Oyc6IFwiJ1wiLFxuXHQgICAgJyYjOTY7JzogJ2AnXG5cdCAgfTtcblx0XG5cdCAgLyoqIFVzZWQgdG8gZGV0ZXJtaW5lIGlmIHZhbHVlcyBhcmUgb2YgdGhlIGxhbmd1YWdlIHR5cGUgYE9iamVjdGAuICovXG5cdCAgdmFyIG9iamVjdFR5cGVzID0ge1xuXHQgICAgJ2Z1bmN0aW9uJzogdHJ1ZSxcblx0ICAgICdvYmplY3QnOiB0cnVlXG5cdCAgfTtcblx0XG5cdCAgLyoqIFVzZWQgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZCByZWdleGVzLiAqL1xuXHQgIHZhciByZWdleHBFc2NhcGVzID0ge1xuXHQgICAgJzAnOiAneDMwJywgJzEnOiAneDMxJywgJzInOiAneDMyJywgJzMnOiAneDMzJywgJzQnOiAneDM0Jyxcblx0ICAgICc1JzogJ3gzNScsICc2JzogJ3gzNicsICc3JzogJ3gzNycsICc4JzogJ3gzOCcsICc5JzogJ3gzOScsXG5cdCAgICAnQSc6ICd4NDEnLCAnQic6ICd4NDInLCAnQyc6ICd4NDMnLCAnRCc6ICd4NDQnLCAnRSc6ICd4NDUnLCAnRic6ICd4NDYnLFxuXHQgICAgJ2EnOiAneDYxJywgJ2InOiAneDYyJywgJ2MnOiAneDYzJywgJ2QnOiAneDY0JywgJ2UnOiAneDY1JywgJ2YnOiAneDY2Jyxcblx0ICAgICduJzogJ3g2ZScsICdyJzogJ3g3MicsICd0JzogJ3g3NCcsICd1JzogJ3g3NScsICd2JzogJ3g3NicsICd4JzogJ3g3OCdcblx0ICB9O1xuXHRcblx0ICAvKiogVXNlZCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy4gKi9cblx0ICB2YXIgc3RyaW5nRXNjYXBlcyA9IHtcblx0ICAgICdcXFxcJzogJ1xcXFwnLFxuXHQgICAgXCInXCI6IFwiJ1wiLFxuXHQgICAgJ1xcbic6ICduJyxcblx0ICAgICdcXHInOiAncicsXG5cdCAgICAnXFx1MjAyOCc6ICd1MjAyOCcsXG5cdCAgICAnXFx1MjAyOSc6ICd1MjAyOSdcblx0ICB9O1xuXHRcblx0ICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xuXHQgIHZhciBmcmVlRXhwb3J0cyA9IG9iamVjdFR5cGVzW3R5cGVvZiBleHBvcnRzXSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdFxuXHQgIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cblx0ICB2YXIgZnJlZU1vZHVsZSA9IG9iamVjdFR5cGVzW3R5cGVvZiBtb2R1bGVdICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0XG5cdCAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cblx0ICB2YXIgZnJlZUdsb2JhbCA9IGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUgJiYgdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCAmJiBnbG9iYWw7XG5cdFxuXHQgIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG5cdCAgdmFyIGZyZWVTZWxmID0gb2JqZWN0VHlwZXNbdHlwZW9mIHNlbGZdICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgJiYgc2VsZjtcblx0XG5cdCAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGB3aW5kb3dgLiAqL1xuXHQgIHZhciBmcmVlV2luZG93ID0gb2JqZWN0VHlwZXNbdHlwZW9mIHdpbmRvd10gJiYgd2luZG93ICYmIHdpbmRvdy5PYmplY3QgJiYgd2luZG93O1xuXHRcblx0ICAvKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xuXHQgIHZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzICYmIGZyZWVFeHBvcnRzO1xuXHRcblx0ICAvKipcblx0ICAgKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LlxuXHQgICAqXG5cdCAgICogVGhlIGB0aGlzYCB2YWx1ZSBpcyB1c2VkIGlmIGl0J3MgdGhlIGdsb2JhbCBvYmplY3QgdG8gYXZvaWQgR3JlYXNlbW9ua2V5J3Ncblx0ICAgKiByZXN0cmljdGVkIGB3aW5kb3dgIG9iamVjdCwgb3RoZXJ3aXNlIHRoZSBgd2luZG93YCBvYmplY3QgaXMgdXNlZC5cblx0ICAgKi9cblx0ICB2YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgKChmcmVlV2luZG93ICE9PSAodGhpcyAmJiB0aGlzLndpbmRvdykpICYmIGZyZWVXaW5kb3cpIHx8IGZyZWVTZWxmIHx8IHRoaXM7XG5cdFxuXHQgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHRcblx0ICAvKipcblx0ICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgY29tcGFyZUFzY2VuZGluZ2Agd2hpY2ggY29tcGFyZXMgdmFsdWVzIGFuZFxuXHQgICAqIHNvcnRzIHRoZW0gaW4gYXNjZW5kaW5nIG9yZGVyIHdpdGhvdXQgZ3VhcmFudGVlaW5nIGEgc3RhYmxlIHNvcnQuXG5cdCAgICpcblx0ICAgKiBAcHJpdmF0ZVxuXHQgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG5cdCAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cblx0ICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYHZhbHVlYC5cblx0ICAgKi9cblx0ICBmdW5jdGlvbiBiYXNlQ29tcGFyZUFzY2VuZGluZyh2YWx1ZSwgb3RoZXIpIHtcblx0ICAgIGlmICh2YWx1ZSAhPT0gb3RoZXIpIHtcblx0ICAgICAgdmFyIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLFxuXHQgICAgICAgICAgdmFsSXNVbmRlZiA9IHZhbHVlID09PSB1bmRlZmluZWQsXG5cdCAgICAgICAgICB2YWxJc1JlZmxleGl2ZSA9IHZhbHVlID09PSB2YWx1ZTtcblx0XG5cdCAgICAgIHZhciBvdGhJc051bGwgPSBvdGhlciA9PT0gbnVsbCxcblx0ICAgICAgICAgIG90aElzVW5kZWYgPSBvdGhlciA9PT0gdW5kZWZpbmVkLFxuXHQgICAgICAgICAgb3RoSXNSZWZsZXhpdmUgPSBvdGhlciA9PT0gb3RoZXI7XG5cdFxuXHQgICAgICBpZiAoKHZhbHVlID4gb3RoZXIgJiYgIW90aElzTnVsbCkgfHwgIXZhbElzUmVmbGV4aXZlIHx8XG5cdCAgICAgICAgICAodmFsSXNOdWxsICYmICFvdGhJc1VuZGVmICYmIG90aElzUmVmbGV4aXZlKSB8fFxuXHQgICAgICAgICAgKHZhbElzVW5kZWYgJiYgb3RoSXNSZWZsZXhpdmUpKSB7XG5cdCAgICAgICAgcmV0dXJuIDE7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKCh2YWx1ZSA8IG90aGVyICYmICF2YWxJc051bGwpIHx8ICFvdGhJc1JlZmxleGl2ZSB8fFxuXHQgICAgICAgICAgKG90aElzTnVsbCAmJiAhdmFsSXNVbmRlZiAmJiB2YWxJc1JlZmxleGl2ZSkgfHxcblx0ICAgICAgICAgIChvdGhJc1VuZGVmICYmIHZhbElzUmVmbGV4aXZlKSkge1xuXHQgICAgICAgIHJldHVybiAtMTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIDA7XG5cdCAgfVxuXHRcblx0ICAvKipcblx0ICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maW5kSW5kZXhgIGFuZCBgXy5maW5kTGFzdEluZGV4YCB3aXRob3V0XG5cdCAgICogc3VwcG9ydCBmb3IgY2FsbGJhY2sgc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG5cdCAgICpcblx0ICAgKiBAcHJpdmF0ZVxuXHQgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG5cdCAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG5cdCAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG5cdCAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cblx0ICAgKi9cblx0ICBmdW5jdGlvbiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21SaWdodCkge1xuXHQgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcblx0ICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xO1xuXHRcblx0ICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG5cdCAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG5cdCAgICAgICAgcmV0dXJuIGluZGV4O1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gLTE7XG5cdCAgfVxuXHRcblx0ICAvKipcblx0ICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbmRleE9mYCB3aXRob3V0IHN1cHBvcnQgZm9yIGJpbmFyeSBzZWFyY2hlcy5cblx0ICAgKlxuXHQgICAqIEBwcml2YXRlXG5cdCAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cblx0ICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuXHQgICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuXHQgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcblx0ICAgIGlmICh2YWx1ZSAhPT0gdmFsdWUpIHtcblx0ICAgICAgcmV0dXJuIGluZGV4T2ZOYU4oYXJyYXksIGZyb21JbmRleCk7XG5cdCAgICB9XG5cdCAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggLSAxLFxuXHQgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XG5cdCAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHQgICAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiBpbmRleDtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIC0xO1xuXHQgIH1cblx0XG5cdCAgLyoqXG5cdCAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNGdW5jdGlvbmAgd2l0aG91dCBzdXBwb3J0IGZvciBlbnZpcm9ubWVudHNcblx0ICAgKiB3aXRoIGluY29ycmVjdCBgdHlwZW9mYCByZXN1bHRzLlxuXHQgICAqXG5cdCAgICogQHByaXZhdGVcblx0ICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cblx0ICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIGJhc2VJc0Z1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAvLyBBdm9pZCBhIENoYWtyYSBKSVQgYnVnIGluIGNvbXBhdGliaWxpdHkgbW9kZXMgb2YgSUUgMTEuXG5cdCAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL2lzc3Vlcy8xNjIxIGZvciBtb3JlIGRldGFpbHMuXG5cdCAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicgfHwgZmFsc2U7XG5cdCAgfVxuXHRcblx0ICAvKipcblx0ICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGlmIGl0J3Mgbm90IG9uZS4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkXG5cdCAgICogZm9yIGBudWxsYCBvciBgdW5kZWZpbmVkYCB2YWx1ZXMuXG5cdCAgICpcblx0ICAgKiBAcHJpdmF0ZVxuXHQgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG5cdCAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuXHQgICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6ICh2YWx1ZSArICcnKTtcblx0ICB9XG5cdFxuXHQgIC8qKlxuXHQgICAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1MZWZ0YCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBjaGFyYWN0ZXJcblx0ICAgKiBvZiBgc3RyaW5nYCB0aGF0IGlzIG5vdCBmb3VuZCBpbiBgY2hhcnNgLlxuXHQgICAqXG5cdCAgICogQHByaXZhdGVcblx0ICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cblx0ICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnMgVGhlIGNoYXJhY3RlcnMgdG8gZmluZC5cblx0ICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgY2hhcmFjdGVyIG5vdCBmb3VuZCBpbiBgY2hhcnNgLlxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIGNoYXJzTGVmdEluZGV4KHN0cmluZywgY2hhcnMpIHtcblx0ICAgIHZhciBpbmRleCA9IC0xLFxuXHQgICAgICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cdFxuXHQgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgY2hhcnMuaW5kZXhPZihzdHJpbmcuY2hhckF0KGluZGV4KSkgPiAtMSkge31cblx0ICAgIHJldHVybiBpbmRleDtcblx0ICB9XG5cdFxuXHQgIC8qKlxuXHQgICAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1SaWdodGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBjaGFyYWN0ZXJcblx0ICAgKiBvZiBgc3RyaW5nYCB0aGF0IGlzIG5vdCBmb3VuZCBpbiBgY2hhcnNgLlxuXHQgICAqXG5cdCAgICogQHByaXZhdGVcblx0ICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cblx0ICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnMgVGhlIGNoYXJhY3RlcnMgdG8gZmluZC5cblx0ICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBjaGFyYWN0ZXIgbm90IGZvdW5kIGluIGBjaGFyc2AuXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gY2hhcnNSaWdodEluZGV4KHN0cmluZywgY2hhcnMpIHtcblx0ICAgIHZhciBpbmRleCA9IHN0cmluZy5sZW5ndGg7XG5cdFxuXHQgICAgd2hpbGUgKGluZGV4LS0gJiYgY2hhcnMuaW5kZXhPZihzdHJpbmcuY2hhckF0KGluZGV4KSkgPiAtMSkge31cblx0ICAgIHJldHVybiBpbmRleDtcblx0ICB9XG5cdFxuXHQgIC8qKlxuXHQgICAqIFVzZWQgYnkgYF8uc29ydEJ5YCB0byBjb21wYXJlIHRyYW5zZm9ybWVkIGVsZW1lbnRzIG9mIGEgY29sbGVjdGlvbiBhbmQgc3RhYmxlXG5cdCAgICogc29ydCB0aGVtIGluIGFzY2VuZGluZyBvcmRlci5cblx0ICAgKlxuXHQgICAqIEBwcml2YXRlXG5cdCAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG5cdCAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cblx0ICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYG9iamVjdGAuXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gY29tcGFyZUFzY2VuZGluZyhvYmplY3QsIG90aGVyKSB7XG5cdCAgICByZXR1cm4gYmFzZUNvbXBhcmVBc2NlbmRpbmcob2JqZWN0LmNyaXRlcmlhLCBvdGhlci5jcml0ZXJpYSkgfHwgKG9iamVjdC5pbmRleCAtIG90aGVyLmluZGV4KTtcblx0ICB9XG5cdFxuXHQgIC8qKlxuXHQgICAqIFVzZWQgYnkgYF8uc29ydEJ5T3JkZXJgIHRvIGNvbXBhcmUgbXVsdGlwbGUgcHJvcGVydGllcyBvZiBhIHZhbHVlIHRvIGFub3RoZXJcblx0ICAgKiBhbmQgc3RhYmxlIHNvcnQgdGhlbS5cblx0ICAgKlxuXHQgICAqIElmIGBvcmRlcnNgIGlzIHVuc3BlY2lmaWVkLCBhbGwgdmFsdWVzcyBhcmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLFxuXHQgICAqIGEgdmFsdWUgaXMgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlciBpZiBpdHMgY29ycmVzcG9uZGluZyBvcmRlciBpcyBcImFzY1wiLCBhbmRcblx0ICAgKiBkZXNjZW5kaW5nIGlmIFwiZGVzY1wiLlxuXHQgICAqXG5cdCAgICogQHByaXZhdGVcblx0ICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cblx0ICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuXHQgICAqIEBwYXJhbSB7Ym9vbGVhbltdfSBvcmRlcnMgVGhlIG9yZGVyIHRvIHNvcnQgYnkgZm9yIGVhY2ggcHJvcGVydHkuXG5cdCAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGBvYmplY3RgLlxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpIHtcblx0ICAgIHZhciBpbmRleCA9IC0xLFxuXHQgICAgICAgIG9iakNyaXRlcmlhID0gb2JqZWN0LmNyaXRlcmlhLFxuXHQgICAgICAgIG90aENyaXRlcmlhID0gb3RoZXIuY3JpdGVyaWEsXG5cdCAgICAgICAgbGVuZ3RoID0gb2JqQ3JpdGVyaWEubGVuZ3RoLFxuXHQgICAgICAgIG9yZGVyc0xlbmd0aCA9IG9yZGVycy5sZW5ndGg7XG5cdFxuXHQgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0ICAgICAgdmFyIHJlc3VsdCA9IGJhc2VDb21wYXJlQXNjZW5kaW5nKG9iakNyaXRlcmlhW2luZGV4XSwgb3RoQ3JpdGVyaWFbaW5kZXhdKTtcblx0ICAgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgICAgIGlmIChpbmRleCA+PSBvcmRlcnNMZW5ndGgpIHtcblx0ICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBvcmRlciA9IG9yZGVyc1tpbmRleF07XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdCAqICgob3JkZXIgPT09ICdhc2MnIHx8IG9yZGVyID09PSB0cnVlKSA/IDEgOiAtMSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIC8vIEZpeGVzIGFuIGBBcnJheSNzb3J0YCBidWcgaW4gdGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBhcHBsaWNhdGlvbnNcblx0ICAgIC8vIHRoYXQgY2F1c2VzIGl0LCB1bmRlciBjZXJ0YWluIGNpcmN1bXN0YW5jZXMsIHRvIHByb3ZpZGUgdGhlIHNhbWUgdmFsdWUgZm9yXG5cdCAgICAvLyBgb2JqZWN0YCBhbmQgYG90aGVyYC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNoa2VuYXMvdW5kZXJzY29yZS9wdWxsLzEyNDdcblx0ICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG5cdCAgICAvL1xuXHQgICAgLy8gVGhpcyBhbHNvIGVuc3VyZXMgYSBzdGFibGUgc29ydCBpbiBWOCBhbmQgb3RoZXIgZW5naW5lcy5cblx0ICAgIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9OTAgZm9yIG1vcmUgZGV0YWlscy5cblx0ICAgIHJldHVybiBvYmplY3QuaW5kZXggLSBvdGhlci5pbmRleDtcblx0ICB9XG5cdFxuXHQgIC8qKlxuXHQgICAqIFVzZWQgYnkgYF8uZGVidXJyYCB0byBjb252ZXJ0IGxhdGluLTEgc3VwcGxlbWVudGFyeSBsZXR0ZXJzIHRvIGJhc2ljIGxhdGluIGxldHRlcnMuXG5cdCAgICpcblx0ICAgKiBAcHJpdmF0ZVxuXHQgICAqIEBwYXJhbSB7c3RyaW5nfSBsZXR0ZXIgVGhlIG1hdGNoZWQgbGV0dGVyIHRvIGRlYnVyci5cblx0ICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBsZXR0ZXIuXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gZGVidXJyTGV0dGVyKGxldHRlcikge1xuXHQgICAgcmV0dXJuIGRlYnVycmVkTGV0dGVyc1tsZXR0ZXJdO1xuXHQgIH1cblx0XG5cdCAgLyoqXG5cdCAgICogVXNlZCBieSBgXy5lc2NhcGVgIHRvIGNvbnZlcnQgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLlxuXHQgICAqXG5cdCAgICogQHByaXZhdGVcblx0ICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG5cdCAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gZXNjYXBlSHRtbENoYXIoY2hyKSB7XG5cdCAgICByZXR1cm4gaHRtbEVzY2FwZXNbY2hyXTtcblx0ICB9XG5cdFxuXHQgIC8qKlxuXHQgICAqIFVzZWQgYnkgYF8uZXNjYXBlUmVnRXhwYCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHJlZ2V4ZXMuXG5cdCAgICpcblx0ICAgKiBAcHJpdmF0ZVxuXHQgICAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cblx0ICAgKiBAcGFyYW0ge3N0cmluZ30gbGVhZGluZ0NoYXIgVGhlIGNhcHR1cmUgZ3JvdXAgZm9yIGEgbGVhZGluZyBjaGFyYWN0ZXIuXG5cdCAgICogQHBhcmFtIHtzdHJpbmd9IHdoaXRlc3BhY2VDaGFyIFRoZSBjYXB0dXJlIGdyb3VwIGZvciBhIHdoaXRlc3BhY2UgY2hhcmFjdGVyLlxuXHQgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIGVzY2FwZVJlZ0V4cENoYXIoY2hyLCBsZWFkaW5nQ2hhciwgd2hpdGVzcGFjZUNoYXIpIHtcblx0ICAgIGlmIChsZWFkaW5nQ2hhcikge1xuXHQgICAgICBjaHIgPSByZWdleHBFc2NhcGVzW2Nocl07XG5cdCAgICB9IGVsc2UgaWYgKHdoaXRlc3BhY2VDaGFyKSB7XG5cdCAgICAgIGNociA9IHN0cmluZ0VzY2FwZXNbY2hyXTtcblx0ICAgIH1cblx0ICAgIHJldHVybiAnXFxcXCcgKyBjaHI7XG5cdCAgfVxuXHRcblx0ICAvKipcblx0ICAgKiBVc2VkIGJ5IGBfLnRlbXBsYXRlYCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy5cblx0ICAgKlxuXHQgICAqIEBwcml2YXRlXG5cdCAgICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuXHQgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIGVzY2FwZVN0cmluZ0NoYXIoY2hyKSB7XG5cdCAgICByZXR1cm4gJ1xcXFwnICsgc3RyaW5nRXNjYXBlc1tjaHJdO1xuXHQgIH1cblx0XG5cdCAgLyoqXG5cdCAgICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYE5hTmAgaXMgZm91bmQgaW4gYGFycmF5YC5cblx0ICAgKlxuXHQgICAqIEBwcml2YXRlXG5cdCAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cblx0ICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cblx0ICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cblx0ICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCBgTmFOYCwgZWxzZSBgLTFgLlxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIGluZGV4T2ZOYU4oYXJyYXksIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG5cdCAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuXHQgICAgICAgIGluZGV4ID0gZnJvbUluZGV4ICsgKGZyb21SaWdodCA/IDAgOiAtMSk7XG5cdFxuXHQgICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcblx0ICAgICAgdmFyIG90aGVyID0gYXJyYXlbaW5kZXhdO1xuXHQgICAgICBpZiAob3RoZXIgIT09IG90aGVyKSB7XG5cdCAgICAgICAgcmV0dXJuIGluZGV4O1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gLTE7XG5cdCAgfVxuXHRcblx0ICAvKipcblx0ICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS5cblx0ICAgKlxuXHQgICAqIEBwcml2YXRlXG5cdCAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cblx0ICAgKi9cblx0ICBmdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcblx0ICAgIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcblx0ICB9XG5cdFxuXHQgIC8qKlxuXHQgICAqIFVzZWQgYnkgYHRyaW1tZWRMZWZ0SW5kZXhgIGFuZCBgdHJpbW1lZFJpZ2h0SW5kZXhgIHRvIGRldGVybWluZSBpZiBhXG5cdCAgICogY2hhcmFjdGVyIGNvZGUgaXMgd2hpdGVzcGFjZS5cblx0ICAgKlxuXHQgICAqIEBwcml2YXRlXG5cdCAgICogQHBhcmFtIHtudW1iZXJ9IGNoYXJDb2RlIFRoZSBjaGFyYWN0ZXIgY29kZSB0byBpbnNwZWN0LlxuXHQgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgY2hhckNvZGVgIGlzIHdoaXRlc3BhY2UsIGVsc2UgYGZhbHNlYC5cblx0ICAgKi9cblx0ICBmdW5jdGlvbiBpc1NwYWNlKGNoYXJDb2RlKSB7XG5cdCAgICByZXR1cm4gKChjaGFyQ29kZSA8PSAxNjAgJiYgKGNoYXJDb2RlID49IDkgJiYgY2hhckNvZGUgPD0gMTMpIHx8IGNoYXJDb2RlID09IDMyIHx8IGNoYXJDb2RlID09IDE2MCkgfHwgY2hhckNvZGUgPT0gNTc2MCB8fCBjaGFyQ29kZSA9PSA2MTU4IHx8XG5cdCAgICAgIChjaGFyQ29kZSA+PSA4MTkyICYmIChjaGFyQ29kZSA8PSA4MjAyIHx8IGNoYXJDb2RlID09IDgyMzIgfHwgY2hhckNvZGUgPT0gODIzMyB8fCBjaGFyQ29kZSA9PSA4MjM5IHx8IGNoYXJDb2RlID09IDgyODcgfHwgY2hhckNvZGUgPT0gMTIyODggfHwgY2hhckNvZGUgPT0gNjUyNzkpKSk7XG5cdCAgfVxuXHRcblx0ICAvKipcblx0ICAgKiBSZXBsYWNlcyBhbGwgYHBsYWNlaG9sZGVyYCBlbGVtZW50cyBpbiBgYXJyYXlgIHdpdGggYW4gaW50ZXJuYWwgcGxhY2Vob2xkZXJcblx0ICAgKiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGVpciBpbmRleGVzLlxuXHQgICAqXG5cdCAgICogQHByaXZhdGVcblx0ICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuXHQgICAqIEBwYXJhbSB7Kn0gcGxhY2Vob2xkZXIgVGhlIHBsYWNlaG9sZGVyIHRvIHJlcGxhY2UuXG5cdCAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcGxhY2Vob2xkZXIgaW5kZXhlcy5cblx0ICAgKi9cblx0ICBmdW5jdGlvbiByZXBsYWNlSG9sZGVycyhhcnJheSwgcGxhY2Vob2xkZXIpIHtcblx0ICAgIHZhciBpbmRleCA9IC0xLFxuXHQgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcblx0ICAgICAgICByZXNJbmRleCA9IC0xLFxuXHQgICAgICAgIHJlc3VsdCA9IFtdO1xuXHRcblx0ICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdCAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHBsYWNlaG9sZGVyKSB7XG5cdCAgICAgICAgYXJyYXlbaW5kZXhdID0gUExBQ0VIT0xERVI7XG5cdCAgICAgICAgcmVzdWx0WysrcmVzSW5kZXhdID0gaW5kZXg7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfVxuXHRcblx0ICAvKipcblx0ICAgKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmlxYCBvcHRpbWl6ZWQgZm9yIHNvcnRlZCBhcnJheXMgd2l0aG91dCBzdXBwb3J0XG5cdCAgICogZm9yIGNhbGxiYWNrIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuXHQgICAqXG5cdCAgICogQHByaXZhdGVcblx0ICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cblx0ICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG5cdCAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlLXZhbHVlLWZyZWUgYXJyYXkuXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gc29ydGVkVW5pcShhcnJheSwgaXRlcmF0ZWUpIHtcblx0ICAgIHZhciBzZWVuLFxuXHQgICAgICAgIGluZGV4ID0gLTEsXG5cdCAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuXHQgICAgICAgIHJlc0luZGV4ID0gLTEsXG5cdCAgICAgICAgcmVzdWx0ID0gW107XG5cdFxuXHQgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0ICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuXHQgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgYXJyYXkpIDogdmFsdWU7XG5cdFxuXHQgICAgICBpZiAoIWluZGV4IHx8IHNlZW4gIT09IGNvbXB1dGVkKSB7XG5cdCAgICAgICAgc2VlbiA9IGNvbXB1dGVkO1xuXHQgICAgICAgIHJlc3VsdFsrK3Jlc0luZGV4XSA9IHZhbHVlO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH1cblx0XG5cdCAgLyoqXG5cdCAgICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbUxlZnRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IG5vbi13aGl0ZXNwYWNlXG5cdCAgICogY2hhcmFjdGVyIG9mIGBzdHJpbmdgLlxuXHQgICAqXG5cdCAgICogQHByaXZhdGVcblx0ICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cblx0ICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyLlxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIHRyaW1tZWRMZWZ0SW5kZXgoc3RyaW5nKSB7XG5cdCAgICB2YXIgaW5kZXggPSAtMSxcblx0ICAgICAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXHRcblx0ICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoICYmIGlzU3BhY2Uoc3RyaW5nLmNoYXJDb2RlQXQoaW5kZXgpKSkge31cblx0ICAgIHJldHVybiBpbmRleDtcblx0ICB9XG5cdFxuXHQgIC8qKlxuXHQgICAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1SaWdodGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBub24td2hpdGVzcGFjZVxuXHQgICAqIGNoYXJhY3RlciBvZiBgc3RyaW5nYC5cblx0ICAgKlxuXHQgICAqIEBwcml2YXRlXG5cdCAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG5cdCAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyLlxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIHRyaW1tZWRSaWdodEluZGV4KHN0cmluZykge1xuXHQgICAgdmFyIGluZGV4ID0gc3RyaW5nLmxlbmd0aDtcblx0XG5cdCAgICB3aGlsZSAoaW5kZXgtLSAmJiBpc1NwYWNlKHN0cmluZy5jaGFyQ29kZUF0KGluZGV4KSkpIHt9XG5cdCAgICByZXR1cm4gaW5kZXg7XG5cdCAgfVxuXHRcblx0ICAvKipcblx0ICAgKiBVc2VkIGJ5IGBfLnVuZXNjYXBlYCB0byBjb252ZXJ0IEhUTUwgZW50aXRpZXMgdG8gY2hhcmFjdGVycy5cblx0ICAgKlxuXHQgICAqIEBwcml2YXRlXG5cdCAgICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gdW5lc2NhcGUuXG5cdCAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5lc2NhcGVkIGNoYXJhY3Rlci5cblx0ICAgKi9cblx0ICBmdW5jdGlvbiB1bmVzY2FwZUh0bWxDaGFyKGNocikge1xuXHQgICAgcmV0dXJuIGh0bWxVbmVzY2FwZXNbY2hyXTtcblx0ICB9XG5cdFxuXHQgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHRcblx0ICAvKipcblx0ICAgKiBDcmVhdGUgYSBuZXcgcHJpc3RpbmUgYGxvZGFzaGAgZnVuY3Rpb24gdXNpbmcgdGhlIGdpdmVuIGBjb250ZXh0YCBvYmplY3QuXG5cdCAgICpcblx0ICAgKiBAc3RhdGljXG5cdCAgICogQG1lbWJlck9mIF9cblx0ICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuXHQgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dD1yb290XSBUaGUgY29udGV4dCBvYmplY3QuXG5cdCAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGEgbmV3IGBsb2Rhc2hgIGZ1bmN0aW9uLlxuXHQgICAqIEBleGFtcGxlXG5cdCAgICpcblx0ICAgKiBfLm1peGluKHsgJ2Zvbyc6IF8uY29uc3RhbnQoJ2ZvbycpIH0pO1xuXHQgICAqXG5cdCAgICogdmFyIGxvZGFzaCA9IF8ucnVuSW5Db250ZXh0KCk7XG5cdCAgICogbG9kYXNoLm1peGluKHsgJ2Jhcic6IGxvZGFzaC5jb25zdGFudCgnYmFyJykgfSk7XG5cdCAgICpcblx0ICAgKiBfLmlzRnVuY3Rpb24oXy5mb28pO1xuXHQgICAqIC8vID0+IHRydWVcblx0ICAgKiBfLmlzRnVuY3Rpb24oXy5iYXIpO1xuXHQgICAqIC8vID0+IGZhbHNlXG5cdCAgICpcblx0ICAgKiBsb2Rhc2guaXNGdW5jdGlvbihsb2Rhc2guZm9vKTtcblx0ICAgKiAvLyA9PiBmYWxzZVxuXHQgICAqIGxvZGFzaC5pc0Z1bmN0aW9uKGxvZGFzaC5iYXIpO1xuXHQgICAqIC8vID0+IHRydWVcblx0ICAgKlxuXHQgICAqIC8vIHVzaW5nIGBjb250ZXh0YCB0byBtb2NrIGBEYXRlI2dldFRpbWVgIHVzZSBpbiBgXy5ub3dgXG5cdCAgICogdmFyIG1vY2sgPSBfLnJ1bkluQ29udGV4dCh7XG5cdCAgICogICAnRGF0ZSc6IGZ1bmN0aW9uKCkge1xuXHQgICAqICAgICByZXR1cm4geyAnZ2V0VGltZSc6IGdldFRpbWVNb2NrIH07XG5cdCAgICogICB9XG5cdCAgICogfSk7XG5cdCAgICpcblx0ICAgKiAvLyBvciBjcmVhdGluZyBhIHN1cGVkLXVwIGBkZWZlcmAgaW4gTm9kZS5qc1xuXHQgICAqIHZhciBkZWZlciA9IF8ucnVuSW5Db250ZXh0KHsgJ3NldFRpbWVvdXQnOiBzZXRJbW1lZGlhdGUgfSkuZGVmZXI7XG5cdCAgICovXG5cdCAgZnVuY3Rpb24gcnVuSW5Db250ZXh0KGNvbnRleHQpIHtcblx0ICAgIC8vIEF2b2lkIGlzc3VlcyB3aXRoIHNvbWUgRVMzIGVudmlyb25tZW50cyB0aGF0IGF0dGVtcHQgdG8gdXNlIHZhbHVlcywgbmFtZWRcblx0ICAgIC8vIGFmdGVyIGJ1aWx0LWluIGNvbnN0cnVjdG9ycyBsaWtlIGBPYmplY3RgLCBmb3IgdGhlIGNyZWF0aW9uIG9mIGxpdGVyYWxzLlxuXHQgICAgLy8gRVM1IGNsZWFycyB0aGlzIHVwIGJ5IHN0YXRpbmcgdGhhdCBsaXRlcmFscyBtdXN0IHVzZSBidWlsdC1pbiBjb25zdHJ1Y3RvcnMuXG5cdCAgICAvLyBTZWUgaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTEuMS41IGZvciBtb3JlIGRldGFpbHMuXG5cdCAgICBjb250ZXh0ID0gY29udGV4dCA/IF8uZGVmYXVsdHMocm9vdC5PYmplY3QoKSwgY29udGV4dCwgXy5waWNrKHJvb3QsIGNvbnRleHRQcm9wcykpIDogcm9vdDtcblx0XG5cdCAgICAvKiogTmF0aXZlIGNvbnN0cnVjdG9yIHJlZmVyZW5jZXMuICovXG5cdCAgICB2YXIgQXJyYXkgPSBjb250ZXh0LkFycmF5LFxuXHQgICAgICAgIERhdGUgPSBjb250ZXh0LkRhdGUsXG5cdCAgICAgICAgRXJyb3IgPSBjb250ZXh0LkVycm9yLFxuXHQgICAgICAgIEZ1bmN0aW9uID0gY29udGV4dC5GdW5jdGlvbixcblx0ICAgICAgICBNYXRoID0gY29udGV4dC5NYXRoLFxuXHQgICAgICAgIE51bWJlciA9IGNvbnRleHQuTnVtYmVyLFxuXHQgICAgICAgIE9iamVjdCA9IGNvbnRleHQuT2JqZWN0LFxuXHQgICAgICAgIFJlZ0V4cCA9IGNvbnRleHQuUmVnRXhwLFxuXHQgICAgICAgIFN0cmluZyA9IGNvbnRleHQuU3RyaW5nLFxuXHQgICAgICAgIFR5cGVFcnJvciA9IGNvbnRleHQuVHlwZUVycm9yO1xuXHRcblx0ICAgIC8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG5cdCAgICB2YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcblx0ICAgICAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGUsXG5cdCAgICAgICAgc3RyaW5nUHJvdG8gPSBTdHJpbmcucHJvdG90eXBlO1xuXHRcblx0ICAgIC8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cblx0ICAgIHZhciBmblRvU3RyaW5nID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xuXHRcblx0ICAgIC8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xuXHQgICAgdmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cdFxuXHQgICAgLyoqIFVzZWQgdG8gZ2VuZXJhdGUgdW5pcXVlIElEcy4gKi9cblx0ICAgIHZhciBpZENvdW50ZXIgPSAwO1xuXHRcblx0ICAgIC8qKlxuXHQgICAgICogVXNlZCB0byByZXNvbHZlIHRoZSBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcblx0ICAgICAqIG9mIHZhbHVlcy5cblx0ICAgICAqL1xuXHQgICAgdmFyIG9ialRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cdFxuXHQgICAgLyoqIFVzZWQgdG8gcmVzdG9yZSB0aGUgb3JpZ2luYWwgYF9gIHJlZmVyZW5jZSBpbiBgXy5ub0NvbmZsaWN0YC4gKi9cblx0ICAgIHZhciBvbGREYXNoID0gcm9vdC5fO1xuXHRcblx0ICAgIC8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG5cdCAgICB2YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuXHQgICAgICBmblRvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UoL1tcXFxcXiQuKis/KClbXFxde318XS9nLCAnXFxcXCQmJylcblx0ICAgICAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG5cdCAgICApO1xuXHRcblx0ICAgIC8qKiBOYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG5cdCAgICB2YXIgQXJyYXlCdWZmZXIgPSBjb250ZXh0LkFycmF5QnVmZmVyLFxuXHQgICAgICAgIGNsZWFyVGltZW91dCA9IGNvbnRleHQuY2xlYXJUaW1lb3V0LFxuXHQgICAgICAgIHBhcnNlRmxvYXQgPSBjb250ZXh0LnBhcnNlRmxvYXQsXG5cdCAgICAgICAgcG93ID0gTWF0aC5wb3csXG5cdCAgICAgICAgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZSxcblx0ICAgICAgICBTZXQgPSBnZXROYXRpdmUoY29udGV4dCwgJ1NldCcpLFxuXHQgICAgICAgIHNldFRpbWVvdXQgPSBjb250ZXh0LnNldFRpbWVvdXQsXG5cdCAgICAgICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2UsXG5cdCAgICAgICAgVWludDhBcnJheSA9IGNvbnRleHQuVWludDhBcnJheSxcblx0ICAgICAgICBXZWFrTWFwID0gZ2V0TmF0aXZlKGNvbnRleHQsICdXZWFrTWFwJyk7XG5cdFxuXHQgICAgLyogTmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cblx0ICAgIHZhciBuYXRpdmVDZWlsID0gTWF0aC5jZWlsLFxuXHQgICAgICAgIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKSxcblx0ICAgICAgICBuYXRpdmVGbG9vciA9IE1hdGguZmxvb3IsXG5cdCAgICAgICAgbmF0aXZlSXNBcnJheSA9IGdldE5hdGl2ZShBcnJheSwgJ2lzQXJyYXknKSxcblx0ICAgICAgICBuYXRpdmVJc0Zpbml0ZSA9IGNvbnRleHQuaXNGaW5pdGUsXG5cdCAgICAgICAgbmF0aXZlS2V5cyA9IGdldE5hdGl2ZShPYmplY3QsICdrZXlzJyksXG5cdCAgICAgICAgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG5cdCAgICAgICAgbmF0aXZlTWluID0gTWF0aC5taW4sXG5cdCAgICAgICAgbmF0aXZlTm93ID0gZ2V0TmF0aXZlKERhdGUsICdub3cnKSxcblx0ICAgICAgICBuYXRpdmVQYXJzZUludCA9IGNvbnRleHQucGFyc2VJbnQsXG5cdCAgICAgICAgbmF0aXZlUmFuZG9tID0gTWF0aC5yYW5kb207XG5cdFxuXHQgICAgLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgYC1JbmZpbml0eWAgYW5kIGBJbmZpbml0eWAuICovXG5cdCAgICB2YXIgTkVHQVRJVkVfSU5GSU5JVFkgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksXG5cdCAgICAgICAgUE9TSVRJVkVfSU5GSU5JVFkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cdFxuXHQgICAgLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdGhlIG1heGltdW0gbGVuZ3RoIGFuZCBpbmRleCBvZiBhbiBhcnJheS4gKi9cblx0ICAgIHZhciBNQVhfQVJSQVlfTEVOR1RIID0gNDI5NDk2NzI5NSxcblx0ICAgICAgICBNQVhfQVJSQVlfSU5ERVggPSBNQVhfQVJSQVlfTEVOR1RIIC0gMSxcblx0ICAgICAgICBIQUxGX01BWF9BUlJBWV9MRU5HVEggPSBNQVhfQVJSQVlfTEVOR1RIID4+PiAxO1xuXHRcblx0ICAgIC8qKlxuXHQgICAgICogVXNlZCBhcyB0aGUgW21heGltdW0gbGVuZ3RoXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIubWF4X3NhZmVfaW50ZWdlcilcblx0ICAgICAqIG9mIGFuIGFycmF5LWxpa2UgdmFsdWUuXG5cdCAgICAgKi9cblx0ICAgIHZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblx0XG5cdCAgICAvKiogVXNlZCB0byBzdG9yZSBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cblx0ICAgIHZhciBtZXRhTWFwID0gV2Vha01hcCAmJiBuZXcgV2Vha01hcDtcblx0XG5cdCAgICAvKiogVXNlZCB0byBsb29rdXAgdW5taW5pZmllZCBmdW5jdGlvbiBuYW1lcy4gKi9cblx0ICAgIHZhciByZWFsTmFtZXMgPSB7fTtcblx0XG5cdCAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgb2JqZWN0IHdoaWNoIHdyYXBzIGB2YWx1ZWAgdG8gZW5hYmxlIGltcGxpY2l0IGNoYWluaW5nLlxuXHQgICAgICogTWV0aG9kcyB0aGF0IG9wZXJhdGUgb24gYW5kIHJldHVybiBhcnJheXMsIGNvbGxlY3Rpb25zLCBhbmQgZnVuY3Rpb25zIGNhblxuXHQgICAgICogYmUgY2hhaW5lZCB0b2dldGhlci4gTWV0aG9kcyB0aGF0IHJldHJpZXZlIGEgc2luZ2xlIHZhbHVlIG9yIG1heSByZXR1cm4gYVxuXHQgICAgICogcHJpbWl0aXZlIHZhbHVlIHdpbGwgYXV0b21hdGljYWxseSBlbmQgdGhlIGNoYWluIHJldHVybmluZyB0aGUgdW53cmFwcGVkXG5cdCAgICAgKiB2YWx1ZS4gRXhwbGljaXQgY2hhaW5pbmcgbWF5IGJlIGVuYWJsZWQgdXNpbmcgYF8uY2hhaW5gLiBUaGUgZXhlY3V0aW9uIG9mXG5cdCAgICAgKiBjaGFpbmVkIG1ldGhvZHMgaXMgbGF6eSwgdGhhdCBpcywgZXhlY3V0aW9uIGlzIGRlZmVycmVkIHVudGlsIGBfI3ZhbHVlYFxuXHQgICAgICogaXMgaW1wbGljaXRseSBvciBleHBsaWNpdGx5IGNhbGxlZC5cblx0ICAgICAqXG5cdCAgICAgKiBMYXp5IGV2YWx1YXRpb24gYWxsb3dzIHNldmVyYWwgbWV0aG9kcyB0byBzdXBwb3J0IHNob3J0Y3V0IGZ1c2lvbi4gU2hvcnRjdXRcblx0ICAgICAqIGZ1c2lvbiBpcyBhbiBvcHRpbWl6YXRpb24gc3RyYXRlZ3kgd2hpY2ggbWVyZ2UgaXRlcmF0ZWUgY2FsbHM7IHRoaXMgY2FuIGhlbHBcblx0ICAgICAqIHRvIGF2b2lkIHRoZSBjcmVhdGlvbiBvZiBpbnRlcm1lZGlhdGUgZGF0YSBzdHJ1Y3R1cmVzIGFuZCBncmVhdGx5IHJlZHVjZSB0aGVcblx0ICAgICAqIG51bWJlciBvZiBpdGVyYXRlZSBleGVjdXRpb25zLlxuXHQgICAgICpcblx0ICAgICAqIENoYWluaW5nIGlzIHN1cHBvcnRlZCBpbiBjdXN0b20gYnVpbGRzIGFzIGxvbmcgYXMgdGhlIGBfI3ZhbHVlYCBtZXRob2QgaXNcblx0ICAgICAqIGRpcmVjdGx5IG9yIGluZGlyZWN0bHkgaW5jbHVkZWQgaW4gdGhlIGJ1aWxkLlxuXHQgICAgICpcblx0ICAgICAqIEluIGFkZGl0aW9uIHRvIGxvZGFzaCBtZXRob2RzLCB3cmFwcGVycyBoYXZlIGBBcnJheWAgYW5kIGBTdHJpbmdgIG1ldGhvZHMuXG5cdCAgICAgKlxuXHQgICAgICogVGhlIHdyYXBwZXIgYEFycmF5YCBtZXRob2RzIGFyZTpcblx0ICAgICAqIGBjb25jYXRgLCBgam9pbmAsIGBwb3BgLCBgcHVzaGAsIGByZXZlcnNlYCwgYHNoaWZ0YCwgYHNsaWNlYCwgYHNvcnRgLFxuXHQgICAgICogYHNwbGljZWAsIGFuZCBgdW5zaGlmdGBcblx0ICAgICAqXG5cdCAgICAgKiBUaGUgd3JhcHBlciBgU3RyaW5nYCBtZXRob2RzIGFyZTpcblx0ICAgICAqIGByZXBsYWNlYCBhbmQgYHNwbGl0YFxuXHQgICAgICpcblx0ICAgICAqIFRoZSB3cmFwcGVyIG1ldGhvZHMgdGhhdCBzdXBwb3J0IHNob3J0Y3V0IGZ1c2lvbiBhcmU6XG5cdCAgICAgKiBgY29tcGFjdGAsIGBkcm9wYCwgYGRyb3BSaWdodGAsIGBkcm9wUmlnaHRXaGlsZWAsIGBkcm9wV2hpbGVgLCBgZmlsdGVyYCxcblx0ICAgICAqIGBmaXJzdGAsIGBpbml0aWFsYCwgYGxhc3RgLCBgbWFwYCwgYHBsdWNrYCwgYHJlamVjdGAsIGByZXN0YCwgYHJldmVyc2VgLFxuXHQgICAgICogYHNsaWNlYCwgYHRha2VgLCBgdGFrZVJpZ2h0YCwgYHRha2VSaWdodFdoaWxlYCwgYHRha2VXaGlsZWAsIGB0b0FycmF5YCxcblx0ICAgICAqIGFuZCBgd2hlcmVgXG5cdCAgICAgKlxuXHQgICAgICogVGhlIGNoYWluYWJsZSB3cmFwcGVyIG1ldGhvZHMgYXJlOlxuXHQgICAgICogYGFmdGVyYCwgYGFyeWAsIGBhc3NpZ25gLCBgYXRgLCBgYmVmb3JlYCwgYGJpbmRgLCBgYmluZEFsbGAsIGBiaW5kS2V5YCxcblx0ICAgICAqIGBjYWxsYmFja2AsIGBjaGFpbmAsIGBjaHVua2AsIGBjb21taXRgLCBgY29tcGFjdGAsIGBjb25jYXRgLCBgY29uc3RhbnRgLFxuXHQgICAgICogYGNvdW50QnlgLCBgY3JlYXRlYCwgYGN1cnJ5YCwgYGRlYm91bmNlYCwgYGRlZmF1bHRzYCwgYGRlZmF1bHRzRGVlcGAsXG5cdCAgICAgKiBgZGVmZXJgLCBgZGVsYXlgLCBgZGlmZmVyZW5jZWAsIGBkcm9wYCwgYGRyb3BSaWdodGAsIGBkcm9wUmlnaHRXaGlsZWAsXG5cdCAgICAgKiBgZHJvcFdoaWxlYCwgYGZpbGxgLCBgZmlsdGVyYCwgYGZsYXR0ZW5gLCBgZmxhdHRlbkRlZXBgLCBgZmxvd2AsIGBmbG93UmlnaHRgLFxuXHQgICAgICogYGZvckVhY2hgLCBgZm9yRWFjaFJpZ2h0YCwgYGZvckluYCwgYGZvckluUmlnaHRgLCBgZm9yT3duYCwgYGZvck93blJpZ2h0YCxcblx0ICAgICAqIGBmdW5jdGlvbnNgLCBgZ3JvdXBCeWAsIGBpbmRleEJ5YCwgYGluaXRpYWxgLCBgaW50ZXJzZWN0aW9uYCwgYGludmVydGAsXG5cdCAgICAgKiBgaW52b2tlYCwgYGtleXNgLCBga2V5c0luYCwgYG1hcGAsIGBtYXBLZXlzYCwgYG1hcFZhbHVlc2AsIGBtYXRjaGVzYCxcblx0ICAgICAqIGBtYXRjaGVzUHJvcGVydHlgLCBgbWVtb2l6ZWAsIGBtZXJnZWAsIGBtZXRob2RgLCBgbWV0aG9kT2ZgLCBgbWl4aW5gLFxuXHQgICAgICogYG1vZEFyZ3NgLCBgbmVnYXRlYCwgYG9taXRgLCBgb25jZWAsIGBwYWlyc2AsIGBwYXJ0aWFsYCwgYHBhcnRpYWxSaWdodGAsXG5cdCAgICAgKiBgcGFydGl0aW9uYCwgYHBpY2tgLCBgcGxhbnRgLCBgcGx1Y2tgLCBgcHJvcGVydHlgLCBgcHJvcGVydHlPZmAsIGBwdWxsYCxcblx0ICAgICAqIGBwdWxsQXRgLCBgcHVzaGAsIGByYW5nZWAsIGByZWFyZ2AsIGByZWplY3RgLCBgcmVtb3ZlYCwgYHJlc3RgLCBgcmVzdFBhcmFtYCxcblx0ICAgICAqIGByZXZlcnNlYCwgYHNldGAsIGBzaHVmZmxlYCwgYHNsaWNlYCwgYHNvcnRgLCBgc29ydEJ5YCwgYHNvcnRCeUFsbGAsXG5cdCAgICAgKiBgc29ydEJ5T3JkZXJgLCBgc3BsaWNlYCwgYHNwcmVhZGAsIGB0YWtlYCwgYHRha2VSaWdodGAsIGB0YWtlUmlnaHRXaGlsZWAsXG5cdCAgICAgKiBgdGFrZVdoaWxlYCwgYHRhcGAsIGB0aHJvdHRsZWAsIGB0aHJ1YCwgYHRpbWVzYCwgYHRvQXJyYXlgLCBgdG9QbGFpbk9iamVjdGAsXG5cdCAgICAgKiBgdHJhbnNmb3JtYCwgYHVuaW9uYCwgYHVuaXFgLCBgdW5zaGlmdGAsIGB1bnppcGAsIGB1bnppcFdpdGhgLCBgdmFsdWVzYCxcblx0ICAgICAqIGB2YWx1ZXNJbmAsIGB3aGVyZWAsIGB3aXRob3V0YCwgYHdyYXBgLCBgeG9yYCwgYHppcGAsIGB6aXBPYmplY3RgLCBgemlwV2l0aGBcblx0ICAgICAqXG5cdCAgICAgKiBUaGUgd3JhcHBlciBtZXRob2RzIHRoYXQgYXJlICoqbm90KiogY2hhaW5hYmxlIGJ5IGRlZmF1bHQgYXJlOlxuXHQgICAgICogYGFkZGAsIGBhdHRlbXB0YCwgYGNhbWVsQ2FzZWAsIGBjYXBpdGFsaXplYCwgYGNlaWxgLCBgY2xvbmVgLCBgY2xvbmVEZWVwYCxcblx0ICAgICAqIGBkZWJ1cnJgLCBgZW5kc1dpdGhgLCBgZXNjYXBlYCwgYGVzY2FwZVJlZ0V4cGAsIGBldmVyeWAsIGBmaW5kYCwgYGZpbmRJbmRleGAsXG5cdCAgICAgKiBgZmluZEtleWAsIGBmaW5kTGFzdGAsIGBmaW5kTGFzdEluZGV4YCwgYGZpbmRMYXN0S2V5YCwgYGZpbmRXaGVyZWAsIGBmaXJzdGAsXG5cdCAgICAgKiBgZmxvb3JgLCBgZ2V0YCwgYGd0YCwgYGd0ZWAsIGBoYXNgLCBgaWRlbnRpdHlgLCBgaW5jbHVkZXNgLCBgaW5kZXhPZmAsXG5cdCAgICAgKiBgaW5SYW5nZWAsIGBpc0FyZ3VtZW50c2AsIGBpc0FycmF5YCwgYGlzQm9vbGVhbmAsIGBpc0RhdGVgLCBgaXNFbGVtZW50YCxcblx0ICAgICAqIGBpc0VtcHR5YCwgYGlzRXF1YWxgLCBgaXNFcnJvcmAsIGBpc0Zpbml0ZWAgYGlzRnVuY3Rpb25gLCBgaXNNYXRjaGAsXG5cdCAgICAgKiBgaXNOYXRpdmVgLCBgaXNOYU5gLCBgaXNOdWxsYCwgYGlzTnVtYmVyYCwgYGlzT2JqZWN0YCwgYGlzUGxhaW5PYmplY3RgLFxuXHQgICAgICogYGlzUmVnRXhwYCwgYGlzU3RyaW5nYCwgYGlzVW5kZWZpbmVkYCwgYGlzVHlwZWRBcnJheWAsIGBqb2luYCwgYGtlYmFiQ2FzZWAsXG5cdCAgICAgKiBgbGFzdGAsIGBsYXN0SW5kZXhPZmAsIGBsdGAsIGBsdGVgLCBgbWF4YCwgYG1pbmAsIGBub0NvbmZsaWN0YCwgYG5vb3BgLFxuXHQgICAgICogYG5vd2AsIGBwYWRgLCBgcGFkTGVmdGAsIGBwYWRSaWdodGAsIGBwYXJzZUludGAsIGBwb3BgLCBgcmFuZG9tYCwgYHJlZHVjZWAsXG5cdCAgICAgKiBgcmVkdWNlUmlnaHRgLCBgcmVwZWF0YCwgYHJlc3VsdGAsIGByb3VuZGAsIGBydW5JbkNvbnRleHRgLCBgc2hpZnRgLCBgc2l6ZWAsXG5cdCAgICAgKiBgc25ha2VDYXNlYCwgYHNvbWVgLCBgc29ydGVkSW5kZXhgLCBgc29ydGVkTGFzdEluZGV4YCwgYHN0YXJ0Q2FzZWAsXG5cdCAgICAgKiBgc3RhcnRzV2l0aGAsIGBzdW1gLCBgdGVtcGxhdGVgLCBgdHJpbWAsIGB0cmltTGVmdGAsIGB0cmltUmlnaHRgLCBgdHJ1bmNgLFxuXHQgICAgICogYHVuZXNjYXBlYCwgYHVuaXF1ZUlkYCwgYHZhbHVlYCwgYW5kIGB3b3Jkc2Bcblx0ICAgICAqXG5cdCAgICAgKiBUaGUgd3JhcHBlciBtZXRob2QgYHNhbXBsZWAgd2lsbCByZXR1cm4gYSB3cmFwcGVkIHZhbHVlIHdoZW4gYG5gIGlzIHByb3ZpZGVkLFxuXHQgICAgICogb3RoZXJ3aXNlIGFuIHVud3JhcHBlZCB2YWx1ZSBpcyByZXR1cm5lZC5cblx0ICAgICAqXG5cdCAgICAgKiBAbmFtZSBfXG5cdCAgICAgKiBAY29uc3RydWN0b3Jcblx0ICAgICAqIEBjYXRlZ29yeSBDaGFpblxuXHQgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcCBpbiBhIGBsb2Rhc2hgIGluc3RhbmNlLlxuXHQgICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMiwgM10pO1xuXHQgICAgICpcblx0ICAgICAqIC8vIHJldHVybnMgYW4gdW53cmFwcGVkIHZhbHVlXG5cdCAgICAgKiB3cmFwcGVkLnJlZHVjZShmdW5jdGlvbih0b3RhbCwgbikge1xuXHQgICAgICogICByZXR1cm4gdG90YWwgKyBuO1xuXHQgICAgICogfSk7XG5cdCAgICAgKiAvLyA9PiA2XG5cdCAgICAgKlxuXHQgICAgICogLy8gcmV0dXJucyBhIHdyYXBwZWQgdmFsdWVcblx0ICAgICAqIHZhciBzcXVhcmVzID0gd3JhcHBlZC5tYXAoZnVuY3Rpb24obikge1xuXHQgICAgICogICByZXR1cm4gbiAqIG47XG5cdCAgICAgKiB9KTtcblx0ICAgICAqXG5cdCAgICAgKiBfLmlzQXJyYXkoc3F1YXJlcyk7XG5cdCAgICAgKiAvLyA9PiBmYWxzZVxuXHQgICAgICpcblx0ICAgICAqIF8uaXNBcnJheShzcXVhcmVzLnZhbHVlKCkpO1xuXHQgICAgICogLy8gPT4gdHJ1ZVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBsb2Rhc2godmFsdWUpIHtcblx0ICAgICAgaWYgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzQXJyYXkodmFsdWUpICYmICEodmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikpIHtcblx0ICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBMb2Rhc2hXcmFwcGVyKSB7XG5cdCAgICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnX19jaGFpbl9fJykgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ19fd3JhcHBlZF9fJykpIHtcblx0ICAgICAgICAgIHJldHVybiB3cmFwcGVyQ2xvbmUodmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIodmFsdWUpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogVGhlIGZ1bmN0aW9uIHdob3NlIHByb3RvdHlwZSBhbGwgY2hhaW5pbmcgd3JhcHBlcnMgaW5oZXJpdCBmcm9tLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGJhc2VMb2Rhc2goKSB7XG5cdCAgICAgIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuXG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBUaGUgYmFzZSBjb25zdHJ1Y3RvciBmb3IgY3JlYXRpbmcgYGxvZGFzaGAgd3JhcHBlciBvYmplY3RzLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuXHQgICAgICogQHBhcmFtIHtib29sZWFufSBbY2hhaW5BbGxdIEVuYWJsZSBjaGFpbmluZyBmb3IgYWxsIHdyYXBwZXIgbWV0aG9kcy5cblx0ICAgICAqIEBwYXJhbSB7QXJyYXl9IFthY3Rpb25zPVtdXSBBY3Rpb25zIHRvIHBlZm9ybSB0byByZXNvbHZlIHRoZSB1bndyYXBwZWQgdmFsdWUuXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIExvZGFzaFdyYXBwZXIodmFsdWUsIGNoYWluQWxsLCBhY3Rpb25zKSB7XG5cdCAgICAgIHRoaXMuX193cmFwcGVkX18gPSB2YWx1ZTtcblx0ICAgICAgdGhpcy5fX2FjdGlvbnNfXyA9IGFjdGlvbnMgfHwgW107XG5cdCAgICAgIHRoaXMuX19jaGFpbl9fID0gISFjaGFpbkFsbDtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIEFuIG9iamVjdCBlbnZpcm9ubWVudCBmZWF0dXJlIGZsYWdzLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAdHlwZSBPYmplY3Rcblx0ICAgICAqL1xuXHQgICAgdmFyIHN1cHBvcnQgPSBsb2Rhc2guc3VwcG9ydCA9IHt9O1xuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQnkgZGVmYXVsdCwgdGhlIHRlbXBsYXRlIGRlbGltaXRlcnMgdXNlZCBieSBsb2Rhc2ggYXJlIGxpa2UgdGhvc2UgaW5cblx0ICAgICAqIGVtYmVkZGVkIFJ1YnkgKEVSQikuIENoYW5nZSB0aGUgZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZVxuXHQgICAgICogYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQHR5cGUgT2JqZWN0XG5cdCAgICAgKi9cblx0ICAgIGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzID0ge1xuXHRcblx0ICAgICAgLyoqXG5cdCAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gYmUgSFRNTC1lc2NhcGVkLlxuXHQgICAgICAgKlxuXHQgICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG5cdCAgICAgICAqIEB0eXBlIFJlZ0V4cFxuXHQgICAgICAgKi9cblx0ICAgICAgJ2VzY2FwZSc6IHJlRXNjYXBlLFxuXHRcblx0ICAgICAgLyoqXG5cdCAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGNvZGUgdG8gYmUgZXZhbHVhdGVkLlxuXHQgICAgICAgKlxuXHQgICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG5cdCAgICAgICAqIEB0eXBlIFJlZ0V4cFxuXHQgICAgICAgKi9cblx0ICAgICAgJ2V2YWx1YXRlJzogcmVFdmFsdWF0ZSxcblx0XG5cdCAgICAgIC8qKlxuXHQgICAgICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGluamVjdC5cblx0ICAgICAgICpcblx0ICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuXHQgICAgICAgKiBAdHlwZSBSZWdFeHBcblx0ICAgICAgICovXG5cdCAgICAgICdpbnRlcnBvbGF0ZSc6IHJlSW50ZXJwb2xhdGUsXG5cdFxuXHQgICAgICAvKipcblx0ICAgICAgICogVXNlZCB0byByZWZlcmVuY2UgdGhlIGRhdGEgb2JqZWN0IGluIHRoZSB0ZW1wbGF0ZSB0ZXh0LlxuXHQgICAgICAgKlxuXHQgICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG5cdCAgICAgICAqIEB0eXBlIHN0cmluZ1xuXHQgICAgICAgKi9cblx0ICAgICAgJ3ZhcmlhYmxlJzogJycsXG5cdFxuXHQgICAgICAvKipcblx0ICAgICAgICogVXNlZCB0byBpbXBvcnQgdmFyaWFibGVzIGludG8gdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuXHQgICAgICAgKlxuXHQgICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG5cdCAgICAgICAqIEB0eXBlIE9iamVjdFxuXHQgICAgICAgKi9cblx0ICAgICAgJ2ltcG9ydHMnOiB7XG5cdFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c1xuXHQgICAgICAgICAqIEB0eXBlIEZ1bmN0aW9uXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgJ18nOiBsb2Rhc2hcblx0ICAgICAgfVxuXHQgICAgfTtcblx0XG5cdCAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGEgbGF6eSB3cmFwcGVyIG9iamVjdCB3aGljaCB3cmFwcyBgdmFsdWVgIHRvIGVuYWJsZSBsYXp5IGV2YWx1YXRpb24uXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIExhenlXcmFwcGVyKHZhbHVlKSB7XG5cdCAgICAgIHRoaXMuX193cmFwcGVkX18gPSB2YWx1ZTtcblx0ICAgICAgdGhpcy5fX2FjdGlvbnNfXyA9IFtdO1xuXHQgICAgICB0aGlzLl9fZGlyX18gPSAxO1xuXHQgICAgICB0aGlzLl9fZmlsdGVyZWRfXyA9IGZhbHNlO1xuXHQgICAgICB0aGlzLl9faXRlcmF0ZWVzX18gPSBbXTtcblx0ICAgICAgdGhpcy5fX3Rha2VDb3VudF9fID0gUE9TSVRJVkVfSU5GSU5JVFk7XG5cdCAgICAgIHRoaXMuX192aWV3c19fID0gW107XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGxhenkgd3JhcHBlciBvYmplY3QuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBuYW1lIGNsb25lXG5cdCAgICAgKiBAbWVtYmVyT2YgTGF6eVdyYXBwZXJcblx0ICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBgTGF6eVdyYXBwZXJgIG9iamVjdC5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gbGF6eUNsb25lKCkge1xuXHQgICAgICB2YXIgcmVzdWx0ID0gbmV3IExhenlXcmFwcGVyKHRoaXMuX193cmFwcGVkX18pO1xuXHQgICAgICByZXN1bHQuX19hY3Rpb25zX18gPSBhcnJheUNvcHkodGhpcy5fX2FjdGlvbnNfXyk7XG5cdCAgICAgIHJlc3VsdC5fX2Rpcl9fID0gdGhpcy5fX2Rpcl9fO1xuXHQgICAgICByZXN1bHQuX19maWx0ZXJlZF9fID0gdGhpcy5fX2ZpbHRlcmVkX187XG5cdCAgICAgIHJlc3VsdC5fX2l0ZXJhdGVlc19fID0gYXJyYXlDb3B5KHRoaXMuX19pdGVyYXRlZXNfXyk7XG5cdCAgICAgIHJlc3VsdC5fX3Rha2VDb3VudF9fID0gdGhpcy5fX3Rha2VDb3VudF9fO1xuXHQgICAgICByZXN1bHQuX192aWV3c19fID0gYXJyYXlDb3B5KHRoaXMuX192aWV3c19fKTtcblx0ICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFJldmVyc2VzIHRoZSBkaXJlY3Rpb24gb2YgbGF6eSBpdGVyYXRpb24uXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBuYW1lIHJldmVyc2Vcblx0ICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuXHQgICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IHJldmVyc2VkIGBMYXp5V3JhcHBlcmAgb2JqZWN0LlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBsYXp5UmV2ZXJzZSgpIHtcblx0ICAgICAgaWYgKHRoaXMuX19maWx0ZXJlZF9fKSB7XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcblx0ICAgICAgICByZXN1bHQuX19kaXJfXyA9IC0xO1xuXHQgICAgICAgIHJlc3VsdC5fX2ZpbHRlcmVkX18gPSB0cnVlO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcblx0ICAgICAgICByZXN1bHQuX19kaXJfXyAqPSAtMTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogRXh0cmFjdHMgdGhlIHVud3JhcHBlZCB2YWx1ZSBmcm9tIGl0cyBsYXp5IHdyYXBwZXIuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBuYW1lIHZhbHVlXG5cdCAgICAgKiBAbWVtYmVyT2YgTGF6eVdyYXBwZXJcblx0ICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB1bndyYXBwZWQgdmFsdWUuXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGxhenlWYWx1ZSgpIHtcblx0ICAgICAgdmFyIGFycmF5ID0gdGhpcy5fX3dyYXBwZWRfXy52YWx1ZSgpLFxuXHQgICAgICAgICAgZGlyID0gdGhpcy5fX2Rpcl9fLFxuXHQgICAgICAgICAgaXNBcnIgPSBpc0FycmF5KGFycmF5KSxcblx0ICAgICAgICAgIGlzUmlnaHQgPSBkaXIgPCAwLFxuXHQgICAgICAgICAgYXJyTGVuZ3RoID0gaXNBcnIgPyBhcnJheS5sZW5ndGggOiAwLFxuXHQgICAgICAgICAgdmlldyA9IGdldFZpZXcoMCwgYXJyTGVuZ3RoLCB0aGlzLl9fdmlld3NfXyksXG5cdCAgICAgICAgICBzdGFydCA9IHZpZXcuc3RhcnQsXG5cdCAgICAgICAgICBlbmQgPSB2aWV3LmVuZCxcblx0ICAgICAgICAgIGxlbmd0aCA9IGVuZCAtIHN0YXJ0LFxuXHQgICAgICAgICAgaW5kZXggPSBpc1JpZ2h0ID8gZW5kIDogKHN0YXJ0IC0gMSksXG5cdCAgICAgICAgICBpdGVyYXRlZXMgPSB0aGlzLl9faXRlcmF0ZWVzX18sXG5cdCAgICAgICAgICBpdGVyTGVuZ3RoID0gaXRlcmF0ZWVzLmxlbmd0aCxcblx0ICAgICAgICAgIHJlc0luZGV4ID0gMCxcblx0ICAgICAgICAgIHRha2VDb3VudCA9IG5hdGl2ZU1pbihsZW5ndGgsIHRoaXMuX190YWtlQ291bnRfXyk7XG5cdFxuXHQgICAgICBpZiAoIWlzQXJyIHx8IGFyckxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgfHwgKGFyckxlbmd0aCA9PSBsZW5ndGggJiYgdGFrZUNvdW50ID09IGxlbmd0aCkpIHtcblx0ICAgICAgICByZXR1cm4gYmFzZVdyYXBwZXJWYWx1ZSgoaXNSaWdodCAmJiBpc0FycikgPyBhcnJheS5yZXZlcnNlKCkgOiBhcnJheSwgdGhpcy5fX2FjdGlvbnNfXyk7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXHRcblx0ICAgICAgb3V0ZXI6XG5cdCAgICAgIHdoaWxlIChsZW5ndGgtLSAmJiByZXNJbmRleCA8IHRha2VDb3VudCkge1xuXHQgICAgICAgIGluZGV4ICs9IGRpcjtcblx0XG5cdCAgICAgICAgdmFyIGl0ZXJJbmRleCA9IC0xLFxuXHQgICAgICAgICAgICB2YWx1ZSA9IGFycmF5W2luZGV4XTtcblx0XG5cdCAgICAgICAgd2hpbGUgKCsraXRlckluZGV4IDwgaXRlckxlbmd0aCkge1xuXHQgICAgICAgICAgdmFyIGRhdGEgPSBpdGVyYXRlZXNbaXRlckluZGV4XSxcblx0ICAgICAgICAgICAgICBpdGVyYXRlZSA9IGRhdGEuaXRlcmF0ZWUsXG5cdCAgICAgICAgICAgICAgdHlwZSA9IGRhdGEudHlwZSxcblx0ICAgICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKHZhbHVlKTtcblx0XG5cdCAgICAgICAgICBpZiAodHlwZSA9PSBMQVpZX01BUF9GTEFHKSB7XG5cdCAgICAgICAgICAgIHZhbHVlID0gY29tcHV0ZWQ7XG5cdCAgICAgICAgICB9IGVsc2UgaWYgKCFjb21wdXRlZCkge1xuXHQgICAgICAgICAgICBpZiAodHlwZSA9PSBMQVpZX0ZJTFRFUl9GTEFHKSB7XG5cdCAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH1cblx0XG5cdCAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGEgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS92YWx1ZSBwYWlycy5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG5hbWUgQ2FjaGVcblx0ICAgICAqIEBtZW1iZXJPZiBfLm1lbW9pemVcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gTWFwQ2FjaGUoKSB7XG5cdCAgICAgIHRoaXMuX19kYXRhX18gPSB7fTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBjYWNoZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQG5hbWUgZGVsZXRlXG5cdCAgICAgKiBAbWVtYmVyT2YgXy5tZW1vaXplLkNhY2hlXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cblx0ICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQgc3VjY2Vzc2Z1bGx5LCBlbHNlIGBmYWxzZWAuXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIG1hcERlbGV0ZShrZXkpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIEdldHMgdGhlIGNhY2hlZCB2YWx1ZSBmb3IgYGtleWAuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBuYW1lIGdldFxuXHQgICAgICogQG1lbWJlck9mIF8ubWVtb2l6ZS5DYWNoZVxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG5cdCAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2FjaGVkIHZhbHVlLlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBtYXBHZXQoa2V5KSB7XG5cdCAgICAgIHJldHVybiBrZXkgPT0gJ19fcHJvdG9fXycgPyB1bmRlZmluZWQgOiB0aGlzLl9fZGF0YV9fW2tleV07XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDaGVja3MgaWYgYSBjYWNoZWQgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQG5hbWUgaGFzXG5cdCAgICAgKiBAbWVtYmVyT2YgXy5tZW1vaXplLkNhY2hlXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuXHQgICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gbWFwSGFzKGtleSkge1xuXHQgICAgICByZXR1cm4ga2V5ICE9ICdfX3Byb3RvX18nICYmIGhhc093blByb3BlcnR5LmNhbGwodGhpcy5fX2RhdGFfXywga2V5KTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFNldHMgYHZhbHVlYCB0byBga2V5YCBvZiB0aGUgY2FjaGUuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBuYW1lIHNldFxuXHQgICAgICogQG1lbWJlck9mIF8ubWVtb2l6ZS5DYWNoZVxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBjYWNoZS5cblx0ICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuXHQgICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgb2JqZWN0LlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBtYXBTZXQoa2V5LCB2YWx1ZSkge1xuXHQgICAgICBpZiAoa2V5ICE9ICdfX3Byb3RvX18nKSB7XG5cdCAgICAgICAgdGhpcy5fX2RhdGFfX1trZXldID0gdmFsdWU7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9XG5cdFxuXHQgICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHRcblx0ICAgIC8qKlxuXHQgICAgICpcblx0ICAgICAqIENyZWF0ZXMgYSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG5cdCAgICAgIHZhciBsZW5ndGggPSB2YWx1ZXMgPyB2YWx1ZXMubGVuZ3RoIDogMDtcblx0XG5cdCAgICAgIHRoaXMuZGF0YSA9IHsgJ2hhc2gnOiBuYXRpdmVDcmVhdGUobnVsbCksICdzZXQnOiBuZXcgU2V0IH07XG5cdCAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuXHQgICAgICAgIHRoaXMucHVzaCh2YWx1ZXNbbGVuZ3RoXSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIGBjYWNoZWAgbWltaWNraW5nIHRoZSByZXR1cm4gc2lnbmF0dXJlIG9mXG5cdCAgICAgKiBgXy5pbmRleE9mYCBieSByZXR1cm5pbmcgYDBgIGlmIHRoZSB2YWx1ZSBpcyBmb3VuZCwgZWxzZSBgLTFgLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHNlYXJjaC5cblx0ICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG5cdCAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGAwYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGAtMWAuXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGNhY2hlSW5kZXhPZihjYWNoZSwgdmFsdWUpIHtcblx0ICAgICAgdmFyIGRhdGEgPSBjYWNoZS5kYXRhLFxuXHQgICAgICAgICAgcmVzdWx0ID0gKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc09iamVjdCh2YWx1ZSkpID8gZGF0YS5zZXQuaGFzKHZhbHVlKSA6IGRhdGEuaGFzaFt2YWx1ZV07XG5cdFxuXHQgICAgICByZXR1cm4gcmVzdWx0ID8gMCA6IC0xO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQWRkcyBgdmFsdWVgIHRvIHRoZSBjYWNoZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQG5hbWUgcHVzaFxuXHQgICAgICogQG1lbWJlck9mIFNldENhY2hlXG5cdCAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gY2FjaGVQdXNoKHZhbHVlKSB7XG5cdCAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuXHQgICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzT2JqZWN0KHZhbHVlKSkge1xuXHQgICAgICAgIGRhdGEuc2V0LmFkZCh2YWx1ZSk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgZGF0YS5oYXNoW3ZhbHVlXSA9IHRydWU7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGEgbmV3IGFycmF5IGpvaW5pbmcgYGFycmF5YCB3aXRoIGBvdGhlcmAuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBqb2luLlxuXHQgICAgICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGpvaW4uXG5cdCAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBjb25jYXRlbmF0ZWQgYXJyYXkuXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGFycmF5Q29uY2F0KGFycmF5LCBvdGhlcikge1xuXHQgICAgICB2YXIgaW5kZXggPSAtMSxcblx0ICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcblx0ICAgICAgICAgIG90aEluZGV4ID0gLTEsXG5cdCAgICAgICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGgsXG5cdCAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGggKyBvdGhMZW5ndGgpO1xuXHRcblx0ICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0ICAgICAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbaW5kZXhdO1xuXHQgICAgICB9XG5cdCAgICAgIHdoaWxlICgrK290aEluZGV4IDwgb3RoTGVuZ3RoKSB7XG5cdCAgICAgICAgcmVzdWx0W2luZGV4KytdID0gb3RoZXJbb3RoSW5kZXhdO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cblx0ICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBhcnJheUNvcHkoc291cmNlLCBhcnJheSkge1xuXHQgICAgICB2YXIgaW5kZXggPSAtMSxcblx0ICAgICAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cdFxuXHQgICAgICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcblx0ICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0ICAgICAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBhcnJheTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcblx0ICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cblx0ICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG5cdCAgICAgIHZhciBpbmRleCA9IC0xLFxuXHQgICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcblx0ICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0ICAgICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBhcnJheTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoUmlnaHRgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuXHQgICAgICogY2FsbGJhY2sgc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuXHQgICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGFycmF5RWFjaFJpZ2h0KGFycmF5LCBpdGVyYXRlZSkge1xuXHQgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcblx0ICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG5cdCAgICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W2xlbmd0aF0sIGxlbmd0aCwgYXJyYXkpID09PSBmYWxzZSkge1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBhcnJheTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5ldmVyeWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG5cdCAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuXHQgICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG5cdCAgICAgKiAgZWxzZSBgZmFsc2VgLlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBhcnJheUV2ZXJ5KGFycmF5LCBwcmVkaWNhdGUpIHtcblx0ICAgICAgdmFyIGluZGV4ID0gLTEsXG5cdCAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFxuXHQgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHQgICAgICAgIGlmICghcHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuXHQgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUV4dHJlbXVtYCBmb3IgYXJyYXlzIHdoaWNoIGludm9rZXMgYGl0ZXJhdGVlYFxuXHQgICAgICogd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgZnVuY3Rpb24gdXNlZCB0byBjb21wYXJlIHZhbHVlcy5cblx0ICAgICAqIEBwYXJhbSB7Kn0gZXhWYWx1ZSBUaGUgaW5pdGlhbCBleHRyZW11bSB2YWx1ZS5cblx0ICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBleHRyZW11bSB2YWx1ZS5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gYXJyYXlFeHRyZW11bShhcnJheSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IsIGV4VmFsdWUpIHtcblx0ICAgICAgdmFyIGluZGV4ID0gLTEsXG5cdCAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG5cdCAgICAgICAgICBjb21wdXRlZCA9IGV4VmFsdWUsXG5cdCAgICAgICAgICByZXN1bHQgPSBjb21wdXRlZDtcblx0XG5cdCAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdCAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuXHQgICAgICAgICAgICBjdXJyZW50ID0gK2l0ZXJhdGVlKHZhbHVlKTtcblx0XG5cdCAgICAgICAgaWYgKGNvbXBhcmF0b3IoY3VycmVudCwgY29tcHV0ZWQpKSB7XG5cdCAgICAgICAgICBjb21wdXRlZCA9IGN1cnJlbnQ7XG5cdCAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuXHQgICAgICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cblx0ICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG5cdCAgICAgIHZhciBpbmRleCA9IC0xLFxuXHQgICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuXHQgICAgICAgICAgcmVzSW5kZXggPSAtMSxcblx0ICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXHRcblx0ICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0ICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG5cdCAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuXHQgICAgICAgICAgcmVzdWx0WysrcmVzSW5kZXhdID0gdmFsdWU7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcblx0ICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cblx0ICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG5cdCAgICAgIHZhciBpbmRleCA9IC0xLFxuXHQgICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuXHQgICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblx0XG5cdCAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdCAgICAgICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cblx0ICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cblx0ICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuXHQgICAgICB2YXIgaW5kZXggPSAtMSxcblx0ICAgICAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG5cdCAgICAgICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cdFxuXHQgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHQgICAgICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGFycmF5O1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG5cdCAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG5cdCAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG5cdCAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0RnJvbUFycmF5XSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWBcblx0ICAgICAqICBhcyB0aGUgaW5pdGlhbCB2YWx1ZS5cblx0ICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gYXJyYXlSZWR1Y2UoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEZyb21BcnJheSkge1xuXHQgICAgICB2YXIgaW5kZXggPSAtMSxcblx0ICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XG5cdCAgICAgIGlmIChpbml0RnJvbUFycmF5ICYmIGxlbmd0aCkge1xuXHQgICAgICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbKytpbmRleF07XG5cdCAgICAgIH1cblx0ICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0ICAgICAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZVJpZ2h0YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3Jcblx0ICAgICAqIGNhbGxiYWNrIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cblx0ICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cblx0ICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRGcm9tQXJyYXldIFNwZWNpZnkgdXNpbmcgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgXG5cdCAgICAgKiAgYXMgdGhlIGluaXRpYWwgdmFsdWUuXG5cdCAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGFycmF5UmVkdWNlUmlnaHQoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEZyb21BcnJheSkge1xuXHQgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHQgICAgICBpZiAoaW5pdEZyb21BcnJheSAmJiBsZW5ndGgpIHtcblx0ICAgICAgICBhY2N1bXVsYXRvciA9IGFycmF5Wy0tbGVuZ3RoXTtcblx0ICAgICAgfVxuXHQgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcblx0ICAgICAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtsZW5ndGhdLCBsZW5ndGgsIGFycmF5KTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG5cdCAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuXHQgICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuXHQgICAgICogIGVsc2UgYGZhbHNlYC5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcblx0ICAgICAgdmFyIGluZGV4ID0gLTEsXG5cdCAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFxuXHQgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHQgICAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG5cdCAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnN1bWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG5cdCAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy4uXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuXHQgICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3VtLlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBhcnJheVN1bShhcnJheSwgaXRlcmF0ZWUpIHtcblx0ICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcblx0ICAgICAgICAgIHJlc3VsdCA9IDA7XG5cdFxuXHQgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcblx0ICAgICAgICByZXN1bHQgKz0gK2l0ZXJhdGVlKGFycmF5W2xlbmd0aF0pIHx8IDA7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFVzZWQgYnkgYF8uZGVmYXVsdHNgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uYXNzaWduYCB1c2UuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7Kn0gb2JqZWN0VmFsdWUgVGhlIGRlc3RpbmF0aW9uIG9iamVjdCBwcm9wZXJ0eSB2YWx1ZS5cblx0ICAgICAqIEBwYXJhbSB7Kn0gc291cmNlVmFsdWUgVGhlIHNvdXJjZSBvYmplY3QgcHJvcGVydHkgdmFsdWUuXG5cdCAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgdG8gYXNzaWduIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGFzc2lnbkRlZmF1bHRzKG9iamVjdFZhbHVlLCBzb3VyY2VWYWx1ZSkge1xuXHQgICAgICByZXR1cm4gb2JqZWN0VmFsdWUgPT09IHVuZGVmaW5lZCA/IHNvdXJjZVZhbHVlIDogb2JqZWN0VmFsdWU7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBVc2VkIGJ5IGBfLnRlbXBsYXRlYCB0byBjdXN0b21pemUgaXRzIGBfLmFzc2lnbmAgdXNlLlxuXHQgICAgICpcblx0ICAgICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFzc2lnbkRlZmF1bHRzYCBleGNlcHQgdGhhdCBpdCBpZ25vcmVzXG5cdCAgICAgKiBpbmhlcml0ZWQgcHJvcGVydHkgdmFsdWVzIHdoZW4gY2hlY2tpbmcgaWYgYSBwcm9wZXJ0eSBpcyBgdW5kZWZpbmVkYC5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHsqfSBvYmplY3RWYWx1ZSBUaGUgZGVzdGluYXRpb24gb2JqZWN0IHByb3BlcnR5IHZhbHVlLlxuXHQgICAgICogQHBhcmFtIHsqfSBzb3VyY2VWYWx1ZSBUaGUgc291cmNlIG9iamVjdCBwcm9wZXJ0eSB2YWx1ZS5cblx0ICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBhc3NvY2lhdGVkIHdpdGggdGhlIG9iamVjdCBhbmQgc291cmNlIHZhbHVlcy5cblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cblx0ICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSB0byBhc3NpZ24gdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gYXNzaWduT3duRGVmYXVsdHMob2JqZWN0VmFsdWUsIHNvdXJjZVZhbHVlLCBrZXksIG9iamVjdCkge1xuXHQgICAgICByZXR1cm4gKG9iamVjdFZhbHVlID09PSB1bmRlZmluZWQgfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKVxuXHQgICAgICAgID8gc291cmNlVmFsdWVcblx0ICAgICAgICA6IG9iamVjdFZhbHVlO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmFzc2lnbmAgZm9yIGN1c3RvbWl6aW5nIGFzc2lnbmVkIHZhbHVlcyB3aXRob3V0XG5cdCAgICAgKiBzdXBwb3J0IGZvciBhcmd1bWVudCBqdWdnbGluZywgbXVsdGlwbGUgc291cmNlcywgYW5kIGB0aGlzYCBiaW5kaW5nIGBjdXN0b21pemVyYFxuXHQgICAgICogZnVuY3Rpb25zLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cblx0ICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGFzc2lnbldpdGgob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpIHtcblx0ICAgICAgdmFyIGluZGV4ID0gLTEsXG5cdCAgICAgICAgICBwcm9wcyA9IGtleXMoc291cmNlKSxcblx0ICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblx0XG5cdCAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdCAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XSxcblx0ICAgICAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XSxcblx0ICAgICAgICAgICAgcmVzdWx0ID0gY3VzdG9taXplcih2YWx1ZSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpO1xuXHRcblx0ICAgICAgICBpZiAoKHJlc3VsdCA9PT0gcmVzdWx0ID8gKHJlc3VsdCAhPT0gdmFsdWUpIDogKHZhbHVlID09PSB2YWx1ZSkpIHx8XG5cdCAgICAgICAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG5cdCAgICAgICAgICBvYmplY3Rba2V5XSA9IHJlc3VsdDtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIG9iamVjdDtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbmAgd2l0aG91dCBzdXBwb3J0IGZvciBhcmd1bWVudCBqdWdnbGluZyxcblx0ICAgICAqIG11bHRpcGxlIHNvdXJjZXMsIGFuZCBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuXHQgICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSkge1xuXHQgICAgICByZXR1cm4gc291cmNlID09IG51bGxcblx0ICAgICAgICA/IG9iamVjdFxuXHQgICAgICAgIDogYmFzZUNvcHkoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hdGAgd2l0aG91dCBzdXBwb3J0IGZvciBzdHJpbmcgY29sbGVjdGlvbnNcblx0ICAgICAqIGFuZCBpbmRpdmlkdWFsIGtleSBhcmd1bWVudHMuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cblx0ICAgICAqIEBwYXJhbSB7bnVtYmVyW118c3RyaW5nW119IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyBvciBpbmRleGVzIG9mIGVsZW1lbnRzIHRvIHBpY2suXG5cdCAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBwaWNrZWQgZWxlbWVudHMuXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGJhc2VBdChjb2xsZWN0aW9uLCBwcm9wcykge1xuXHQgICAgICB2YXIgaW5kZXggPSAtMSxcblx0ICAgICAgICAgIGlzTmlsID0gY29sbGVjdGlvbiA9PSBudWxsLFxuXHQgICAgICAgICAgaXNBcnIgPSAhaXNOaWwgJiYgaXNBcnJheUxpa2UoY29sbGVjdGlvbiksXG5cdCAgICAgICAgICBsZW5ndGggPSBpc0FyciA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMCxcblx0ICAgICAgICAgIHByb3BzTGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuXHQgICAgICAgICAgcmVzdWx0ID0gQXJyYXkocHJvcHNMZW5ndGgpO1xuXHRcblx0ICAgICAgd2hpbGUoKytpbmRleCA8IHByb3BzTGVuZ3RoKSB7XG5cdCAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblx0ICAgICAgICBpZiAoaXNBcnIpIHtcblx0ICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBpc0luZGV4KGtleSwgbGVuZ3RoKSA/IGNvbGxlY3Rpb25ba2V5XSA6IHVuZGVmaW5lZDtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IGlzTmlsID8gdW5kZWZpbmVkIDogY29sbGVjdGlvbltrZXldO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cblx0ICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBjb3B5LlxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuXHQgICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gYmFzZUNvcHkoc291cmNlLCBwcm9wcywgb2JqZWN0KSB7XG5cdCAgICAgIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXHRcblx0ICAgICAgdmFyIGluZGV4ID0gLTEsXG5cdCAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cdFxuXHQgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHQgICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cdCAgICAgICAgb2JqZWN0W2tleV0gPSBzb3VyY2Vba2V5XTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gb2JqZWN0O1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2FsbGJhY2tgIHdoaWNoIHN1cHBvcnRzIHNwZWNpZnlpbmcgdGhlXG5cdCAgICAgKiBudW1iZXIgb2YgYXJndW1lbnRzIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0geyp9IFtmdW5jPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGEgY2FsbGJhY2suXG5cdCAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuXHQgICAgICogQHBhcmFtIHtudW1iZXJ9IFthcmdDb3VudF0gVGhlIG51bWJlciBvZiBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG5cdCAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNhbGxiYWNrLlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBiYXNlQ2FsbGJhY2soZnVuYywgdGhpc0FyZywgYXJnQ291bnQpIHtcblx0ICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgZnVuYztcblx0ICAgICAgaWYgKHR5cGUgPT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgIHJldHVybiB0aGlzQXJnID09PSB1bmRlZmluZWRcblx0ICAgICAgICAgID8gZnVuY1xuXHQgICAgICAgICAgOiBiaW5kQ2FsbGJhY2soZnVuYywgdGhpc0FyZywgYXJnQ291bnQpO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChmdW5jID09IG51bGwpIHtcblx0ICAgICAgICByZXR1cm4gaWRlbnRpdHk7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHR5cGUgPT0gJ29iamVjdCcpIHtcblx0ICAgICAgICByZXR1cm4gYmFzZU1hdGNoZXMoZnVuYyk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHRoaXNBcmcgPT09IHVuZGVmaW5lZFxuXHQgICAgICAgID8gcHJvcGVydHkoZnVuYylcblx0ICAgICAgICA6IGJhc2VNYXRjaGVzUHJvcGVydHkoZnVuYywgdGhpc0FyZyk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbG9uZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhcmd1bWVudCBqdWdnbGluZ1xuXHQgICAgICogYW5kIGB0aGlzYCBiaW5kaW5nIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuXHQgICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcgdmFsdWVzLlxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IFtrZXldIFRoZSBrZXkgb2YgYHZhbHVlYC5cblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IGB2YWx1ZWAgYmVsb25ncyB0by5cblx0ICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0E9W11dIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIG9iamVjdHMuXG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tCPVtdXSBBc3NvY2lhdGVzIGNsb25lcyB3aXRoIHNvdXJjZSBjb3VudGVycGFydHMuXG5cdCAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBiYXNlQ2xvbmUodmFsdWUsIGlzRGVlcCwgY3VzdG9taXplciwga2V5LCBvYmplY3QsIHN0YWNrQSwgc3RhY2tCKSB7XG5cdCAgICAgIHZhciByZXN1bHQ7XG5cdCAgICAgIGlmIChjdXN0b21pemVyKSB7XG5cdCAgICAgICAgcmVzdWx0ID0gb2JqZWN0ID8gY3VzdG9taXplcih2YWx1ZSwga2V5LCBvYmplY3QpIDogY3VzdG9taXplcih2YWx1ZSk7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuXHQgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgfVxuXHQgICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcblx0ICAgICAgaWYgKGlzQXJyKSB7XG5cdCAgICAgICAgcmVzdWx0ID0gaW5pdENsb25lQXJyYXkodmFsdWUpO1xuXHQgICAgICAgIGlmICghaXNEZWVwKSB7XG5cdCAgICAgICAgICByZXR1cm4gYXJyYXlDb3B5KHZhbHVlLCByZXN1bHQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB2YXIgdGFnID0gb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSksXG5cdCAgICAgICAgICAgIGlzRnVuYyA9IHRhZyA9PSBmdW5jVGFnO1xuXHRcblx0ICAgICAgICBpZiAodGFnID09IG9iamVjdFRhZyB8fCB0YWcgPT0gYXJnc1RhZyB8fCAoaXNGdW5jICYmICFvYmplY3QpKSB7XG5cdCAgICAgICAgICByZXN1bHQgPSBpbml0Q2xvbmVPYmplY3QoaXNGdW5jID8ge30gOiB2YWx1ZSk7XG5cdCAgICAgICAgICBpZiAoIWlzRGVlcCkge1xuXHQgICAgICAgICAgICByZXR1cm4gYmFzZUFzc2lnbihyZXN1bHQsIHZhbHVlKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgcmV0dXJuIGNsb25lYWJsZVRhZ3NbdGFnXVxuXHQgICAgICAgICAgICA/IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGlzRGVlcClcblx0ICAgICAgICAgICAgOiAob2JqZWN0ID8gdmFsdWUgOiB7fSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIC8vIENoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gaXRzIGNvcnJlc3BvbmRpbmcgY2xvbmUuXG5cdCAgICAgIHN0YWNrQSB8fCAoc3RhY2tBID0gW10pO1xuXHQgICAgICBzdGFja0IgfHwgKHN0YWNrQiA9IFtdKTtcblx0XG5cdCAgICAgIHZhciBsZW5ndGggPSBzdGFja0EubGVuZ3RoO1xuXHQgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcblx0ICAgICAgICBpZiAoc3RhY2tBW2xlbmd0aF0gPT0gdmFsdWUpIHtcblx0ICAgICAgICAgIHJldHVybiBzdGFja0JbbGVuZ3RoXTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgLy8gQWRkIHRoZSBzb3VyY2UgdmFsdWUgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzIGFuZCBhc3NvY2lhdGUgaXQgd2l0aCBpdHMgY2xvbmUuXG5cdCAgICAgIHN0YWNrQS5wdXNoKHZhbHVlKTtcblx0ICAgICAgc3RhY2tCLnB1c2gocmVzdWx0KTtcblx0XG5cdCAgICAgIC8vIFJlY3Vyc2l2ZWx5IHBvcHVsYXRlIGNsb25lIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG5cdCAgICAgIChpc0FyciA/IGFycmF5RWFjaCA6IGJhc2VGb3JPd24pKHZhbHVlLCBmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG5cdCAgICAgICAgcmVzdWx0W2tleV0gPSBiYXNlQ2xvbmUoc3ViVmFsdWUsIGlzRGVlcCwgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2tBLCBzdGFja0IpO1xuXHQgICAgICB9KTtcblx0ICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcblx0ICAgICAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuXHQgICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cblx0ICAgICAqL1xuXHQgICAgdmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG5cdCAgICAgIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG5cdCAgICAgIHJldHVybiBmdW5jdGlvbihwcm90b3R5cGUpIHtcblx0ICAgICAgICBpZiAoaXNPYmplY3QocHJvdG90eXBlKSkge1xuXHQgICAgICAgICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvdHlwZTtcblx0ICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xuXHQgICAgICAgICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCB7fTtcblx0ICAgICAgfTtcblx0ICAgIH0oKSk7XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5kZWxheWAgYW5kIGBfLmRlZmVyYCB3aGljaCBhY2NlcHRzIGFuIGluZGV4XG5cdCAgICAgKiBvZiB3aGVyZSB0byBzbGljZSB0aGUgYXJndW1lbnRzIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWxheS5cblx0ICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGludm9jYXRpb24uXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJncyBUaGUgYXJndW1lbnRzIHByb3ZpZGUgdG8gYGZ1bmNgLlxuXHQgICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXIgaWQuXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGJhc2VEZWxheShmdW5jLCB3YWl0LCBhcmdzKSB7XG5cdCAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7IH0sIHdhaXQpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZGlmZmVyZW5jZWAgd2hpY2ggYWNjZXB0cyBhIHNpbmdsZSBhcnJheVxuXHQgICAgICogb2YgdmFsdWVzIHRvIGV4Y2x1ZGUuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuXHQgICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cblx0ICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gYmFzZURpZmZlcmVuY2UoYXJyYXksIHZhbHVlcykge1xuXHQgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuXHQgICAgICAgICAgcmVzdWx0ID0gW107XG5cdFxuXHQgICAgICBpZiAoIWxlbmd0aCkge1xuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIGluZGV4ID0gLTEsXG5cdCAgICAgICAgICBpbmRleE9mID0gZ2V0SW5kZXhPZigpLFxuXHQgICAgICAgICAgaXNDb21tb24gPSBpbmRleE9mID09IGJhc2VJbmRleE9mLFxuXHQgICAgICAgICAgY2FjaGUgPSAoaXNDb21tb24gJiYgdmFsdWVzLmxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFKSA/IGNyZWF0ZUNhY2hlKHZhbHVlcykgOiBudWxsLFxuXHQgICAgICAgICAgdmFsdWVzTGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcblx0XG5cdCAgICAgIGlmIChjYWNoZSkge1xuXHQgICAgICAgIGluZGV4T2YgPSBjYWNoZUluZGV4T2Y7XG5cdCAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcblx0ICAgICAgICB2YWx1ZXMgPSBjYWNoZTtcblx0ICAgICAgfVxuXHQgICAgICBvdXRlcjpcblx0ICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0ICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG5cdFxuXHQgICAgICAgIGlmIChpc0NvbW1vbiAmJiB2YWx1ZSA9PT0gdmFsdWUpIHtcblx0ICAgICAgICAgIHZhciB2YWx1ZXNJbmRleCA9IHZhbHVlc0xlbmd0aDtcblx0ICAgICAgICAgIHdoaWxlICh2YWx1ZXNJbmRleC0tKSB7XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZXNbdmFsdWVzSW5kZXhdID09PSB2YWx1ZSkge1xuXHQgICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKGluZGV4T2YodmFsdWVzLCB2YWx1ZSwgMCkgPCAwKSB7XG5cdCAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG5cdCAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG5cdCAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fHN0cmluZ30gUmV0dXJucyBgY29sbGVjdGlvbmAuXG5cdCAgICAgKi9cblx0ICAgIHZhciBiYXNlRWFjaCA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd24pO1xuXHRcblx0ICAgIC8qKlxuXHQgICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaFJpZ2h0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG5cdCAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG5cdCAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fHN0cmluZ30gUmV0dXJucyBgY29sbGVjdGlvbmAuXG5cdCAgICAgKi9cblx0ICAgIHZhciBiYXNlRWFjaFJpZ2h0ID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93blJpZ2h0LCB0cnVlKTtcblx0XG5cdCAgICAvKipcblx0ICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmV2ZXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG5cdCAgICAgKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuXHQgICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG5cdCAgICAgKiAgZWxzZSBgZmFsc2VgXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGJhc2VFdmVyeShjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcblx0ICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG5cdCAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuXHQgICAgICAgIHJlc3VsdCA9ICEhcHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgfSk7XG5cdCAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBHZXRzIHRoZSBleHRyZW11bSB2YWx1ZSBvZiBgY29sbGVjdGlvbmAgaW52b2tpbmcgYGl0ZXJhdGVlYCBmb3IgZWFjaCB2YWx1ZVxuXHQgICAgICogaW4gYGNvbGxlY3Rpb25gIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2ggdGhlIHZhbHVlIGlzIHJhbmtlZC5cblx0ICAgICAqIFRoZSBgaXRlcmF0ZWVgIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGNvbXBhcmUgdmFsdWVzLlxuXHQgICAgICogQHBhcmFtIHsqfSBleFZhbHVlIFRoZSBpbml0aWFsIGV4dHJlbXVtIHZhbHVlLlxuXHQgICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGV4dHJlbXVtIHZhbHVlLlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBiYXNlRXh0cmVtdW0oY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IsIGV4VmFsdWUpIHtcblx0ICAgICAgdmFyIGNvbXB1dGVkID0gZXhWYWx1ZSxcblx0ICAgICAgICAgIHJlc3VsdCA9IGNvbXB1dGVkO1xuXHRcblx0ICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG5cdCAgICAgICAgdmFyIGN1cnJlbnQgPSAraXRlcmF0ZWUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcblx0ICAgICAgICBpZiAoY29tcGFyYXRvcihjdXJyZW50LCBjb21wdXRlZCkgfHwgKGN1cnJlbnQgPT09IGV4VmFsdWUgJiYgY3VycmVudCA9PT0gcmVzdWx0KSkge1xuXHQgICAgICAgICAgY29tcHV0ZWQgPSBjdXJyZW50O1xuXHQgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG5cdCAgICAgICAgfVxuXHQgICAgICB9KTtcblx0ICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbGxgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZpbGwuXG5cdCAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBmaWxsIGBhcnJheWAgd2l0aC5cblx0ICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuXHQgICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuXHQgICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGJhc2VGaWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQsIGVuZCkge1xuXHQgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcblx0ICAgICAgc3RhcnQgPSBzdGFydCA9PSBudWxsID8gMCA6ICgrc3RhcnQgfHwgMCk7XG5cdCAgICAgIGlmIChzdGFydCA8IDApIHtcblx0ICAgICAgICBzdGFydCA9IC1zdGFydCA+IGxlbmd0aCA/IDAgOiAobGVuZ3RoICsgc3RhcnQpO1xuXHQgICAgICB9XG5cdCAgICAgIGVuZCA9IChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiBsZW5ndGgpID8gbGVuZ3RoIDogKCtlbmQgfHwgMCk7XG5cdCAgICAgIGlmIChlbmQgPCAwKSB7XG5cdCAgICAgICAgZW5kICs9IGxlbmd0aDtcblx0ICAgICAgfVxuXHQgICAgICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoZW5kID4+PiAwKTtcblx0ICAgICAgc3RhcnQgPj4+PSAwO1xuXHRcblx0ICAgICAgd2hpbGUgKHN0YXJ0IDwgbGVuZ3RoKSB7XG5cdCAgICAgICAgYXJyYXlbc3RhcnQrK10gPSB2YWx1ZTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gYXJyYXk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maWx0ZXJgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcblx0ICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG5cdCAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gYmFzZUZpbHRlcihjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcblx0ICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcblx0ICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcblx0ICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0pO1xuXHQgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZGAsIGBfLmZpbmRMYXN0YCwgYF8uZmluZEtleWAsIGFuZCBgXy5maW5kTGFzdEtleWAsXG5cdCAgICAgKiB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLCB3aGljaCBpdGVyYXRlc1xuXHQgICAgICogb3ZlciBgY29sbGVjdGlvbmAgdXNpbmcgdGhlIHByb3ZpZGVkIGBlYWNoRnVuY2AuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzZWFyY2guXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYGNvbGxlY3Rpb25gLlxuXHQgICAgICogQHBhcmFtIHtib29sZWFufSBbcmV0S2V5XSBTcGVjaWZ5IHJldHVybmluZyB0aGUga2V5IG9mIHRoZSBmb3VuZCBlbGVtZW50XG5cdCAgICAgKiAgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG5cdCAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZm91bmQgZWxlbWVudCBvciBpdHMga2V5LCBlbHNlIGB1bmRlZmluZWRgLlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBiYXNlRmluZChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGVhY2hGdW5jLCByZXRLZXkpIHtcblx0ICAgICAgdmFyIHJlc3VsdDtcblx0ICAgICAgZWFjaEZ1bmMoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuXHQgICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGtleSwgY29sbGVjdGlvbikpIHtcblx0ICAgICAgICAgIHJlc3VsdCA9IHJldEtleSA/IGtleSA6IHZhbHVlO1xuXHQgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdCAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIGFkZGVkIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nXG5cdCAgICAgKiBmbGF0dGVuaW5nIGFuZCBzcGVjaWZ5aW5nIHRoZSBzdGFydCBpbmRleC5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG5cdCAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGZsYXR0ZW4uXG5cdCAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1N0cmljdF0gUmVzdHJpY3QgZmxhdHRlbmluZyB0byBhcnJheXMtbGlrZSBvYmplY3RzLlxuXHQgICAgICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdD1bXV0gVGhlIGluaXRpYWwgcmVzdWx0IHZhbHVlLlxuXHQgICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgaXNEZWVwLCBpc1N0cmljdCwgcmVzdWx0KSB7XG5cdCAgICAgIHJlc3VsdCB8fCAocmVzdWx0ID0gW10pO1xuXHRcblx0ICAgICAgdmFyIGluZGV4ID0gLTEsXG5cdCAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFxuXHQgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHQgICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcblx0ICAgICAgICBpZiAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSkgJiZcblx0ICAgICAgICAgICAgKGlzU3RyaWN0IHx8IGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkpIHtcblx0ICAgICAgICAgIGlmIChpc0RlZXApIHtcblx0ICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cblx0ICAgICAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGlzRGVlcCwgaXNTdHJpY3QsIHJlc3VsdCk7XG5cdCAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBhcnJheVB1c2gocmVzdWx0LCB2YWx1ZSk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcblx0ICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHZhbHVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JJbmAgYW5kIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlc1xuXHQgICAgICogb3ZlciBgb2JqZWN0YCBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgaW52b2tpbmcgYGl0ZXJhdGVlYCBmb3Jcblx0ICAgICAqIGVhY2ggcHJvcGVydHkuIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseVxuXHQgICAgICogcmV0dXJuaW5nIGBmYWxzZWAuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cblx0ICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG5cdCAgICAgKi9cblx0ICAgIHZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuXHRcblx0ICAgIC8qKlxuXHQgICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBiYXNlRm9yYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIHByb3BlcnRpZXNcblx0ICAgICAqIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuXHQgICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cblx0ICAgICAqL1xuXHQgICAgdmFyIGJhc2VGb3JSaWdodCA9IGNyZWF0ZUJhc2VGb3IodHJ1ZSk7XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuXHQgICAgICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuXHQgICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gYmFzZUZvckluKG9iamVjdCwgaXRlcmF0ZWUpIHtcblx0ICAgICAgcmV0dXJuIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5c0luKTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93bmAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuXHQgICAgICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuXHQgICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gYmFzZUZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG5cdCAgICAgIHJldHVybiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duUmlnaHRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcblx0ICAgICAqIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cblx0ICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGJhc2VGb3JPd25SaWdodChvYmplY3QsIGl0ZXJhdGVlKSB7XG5cdCAgICAgIHJldHVybiBiYXNlRm9yUmlnaHQob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mdW5jdGlvbnNgIHdoaWNoIGNyZWF0ZXMgYW4gYXJyYXkgb2Zcblx0ICAgICAqIGBvYmplY3RgIGZ1bmN0aW9uIHByb3BlcnR5IG5hbWVzIGZpbHRlcmVkIGZyb20gdGhvc2UgcHJvdmlkZWQuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuXHQgICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGZpbHRlci5cblx0ICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHByb3BlcnR5IG5hbWVzLlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBiYXNlRnVuY3Rpb25zKG9iamVjdCwgcHJvcHMpIHtcblx0ICAgICAgdmFyIGluZGV4ID0gLTEsXG5cdCAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG5cdCAgICAgICAgICByZXNJbmRleCA9IC0xLFxuXHQgICAgICAgICAgcmVzdWx0ID0gW107XG5cdFxuXHQgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHQgICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cdCAgICAgICAgaWYgKGlzRnVuY3Rpb24ob2JqZWN0W2tleV0pKSB7XG5cdCAgICAgICAgICByZXN1bHRbKytyZXNJbmRleF0gPSBrZXk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0cmluZyBwYXRoc1xuXHQgICAgICogYW5kIGRlZmF1bHQgdmFsdWVzLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhdGhLZXldIFRoZSBrZXkgcmVwcmVzZW50YXRpb24gb2YgcGF0aC5cblx0ICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgsIHBhdGhLZXkpIHtcblx0ICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChwYXRoS2V5ICE9PSB1bmRlZmluZWQgJiYgcGF0aEtleSBpbiB0b09iamVjdChvYmplY3QpKSB7XG5cdCAgICAgICAgcGF0aCA9IFtwYXRoS2V5XTtcblx0ICAgICAgfVxuXHQgICAgICB2YXIgaW5kZXggPSAwLFxuXHQgICAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cdFxuXHQgICAgICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcblx0ICAgICAgICBvYmplY3QgPSBvYmplY3RbcGF0aFtpbmRleCsrXV07XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2l0aG91dCBzdXBwb3J0IGZvciBgdGhpc2AgYmluZGluZ1xuXHQgICAgICogYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cblx0ICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpbmcgdmFsdWVzLlxuXHQgICAgICogQHBhcmFtIHtib29sZWFufSBbaXNMb29zZV0gU3BlY2lmeSBwZXJmb3JtaW5nIHBhcnRpYWwgY29tcGFyaXNvbnMuXG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgb2JqZWN0cy5cblx0ICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0JdIFRyYWNrcyB0cmF2ZXJzZWQgYG90aGVyYCBvYmplY3RzLlxuXHQgICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBjdXN0b21pemVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQikge1xuXHQgICAgICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG5cdCAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0KHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcblx0ICAgICAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYmFzZUlzRXF1YWwsIGN1c3RvbWl6ZXIsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcblx0ICAgICAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcblx0ICAgICAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyBvYmplY3RzLlxuXHQgICAgICogQHBhcmFtIHtib29sZWFufSBbaXNMb29zZV0gU3BlY2lmeSBwZXJmb3JtaW5nIHBhcnRpYWwgY29tcGFyaXNvbnMuXG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgb2JqZWN0cy5cblx0ICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIFRyYWNrcyB0cmF2ZXJzZWQgYG90aGVyYCBvYmplY3RzLlxuXHQgICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKSB7XG5cdCAgICAgIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcblx0ICAgICAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG5cdCAgICAgICAgICBvYmpUYWcgPSBhcnJheVRhZyxcblx0ICAgICAgICAgIG90aFRhZyA9IGFycmF5VGFnO1xuXHRcblx0ICAgICAgaWYgKCFvYmpJc0Fycikge1xuXHQgICAgICAgIG9ialRhZyA9IG9ialRvU3RyaW5nLmNhbGwob2JqZWN0KTtcblx0ICAgICAgICBpZiAob2JqVGFnID09IGFyZ3NUYWcpIHtcblx0ICAgICAgICAgIG9ialRhZyA9IG9iamVjdFRhZztcblx0ICAgICAgICB9IGVsc2UgaWYgKG9ialRhZyAhPSBvYmplY3RUYWcpIHtcblx0ICAgICAgICAgIG9iaklzQXJyID0gaXNUeXBlZEFycmF5KG9iamVjdCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIGlmICghb3RoSXNBcnIpIHtcblx0ICAgICAgICBvdGhUYWcgPSBvYmpUb1N0cmluZy5jYWxsKG90aGVyKTtcblx0ICAgICAgICBpZiAob3RoVGFnID09IGFyZ3NUYWcpIHtcblx0ICAgICAgICAgIG90aFRhZyA9IG9iamVjdFRhZztcblx0ICAgICAgICB9IGVsc2UgaWYgKG90aFRhZyAhPSBvYmplY3RUYWcpIHtcblx0ICAgICAgICAgIG90aElzQXJyID0gaXNUeXBlZEFycmF5KG90aGVyKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcblx0ICAgICAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcblx0ICAgICAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cdFxuXHQgICAgICBpZiAoaXNTYW1lVGFnICYmICEob2JqSXNBcnIgfHwgb2JqSXNPYmopKSB7XG5cdCAgICAgICAgcmV0dXJuIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnKTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoIWlzTG9vc2UpIHtcblx0ICAgICAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuXHQgICAgICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblx0XG5cdCAgICAgICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcblx0ICAgICAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsIG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlciwgY3VzdG9taXplciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICBpZiAoIWlzU2FtZVRhZykge1xuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgfVxuXHQgICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG5cdCAgICAgIC8vIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGRldGVjdGluZyBjaXJjdWxhciByZWZlcmVuY2VzIHNlZSBodHRwczovL2VzNS5naXRodWIuaW8vI0pPLlxuXHQgICAgICBzdGFja0EgfHwgKHN0YWNrQSA9IFtdKTtcblx0ICAgICAgc3RhY2tCIHx8IChzdGFja0IgPSBbXSk7XG5cdFxuXHQgICAgICB2YXIgbGVuZ3RoID0gc3RhY2tBLmxlbmd0aDtcblx0ICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG5cdCAgICAgICAgaWYgKHN0YWNrQVtsZW5ndGhdID09IG9iamVjdCkge1xuXHQgICAgICAgICAgcmV0dXJuIHN0YWNrQltsZW5ndGhdID09IG90aGVyO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICAvLyBBZGQgYG9iamVjdGAgYW5kIGBvdGhlcmAgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuXHQgICAgICBzdGFja0EucHVzaChvYmplY3QpO1xuXHQgICAgICBzdGFja0IucHVzaChvdGhlcik7XG5cdFxuXHQgICAgICB2YXIgcmVzdWx0ID0gKG9iaklzQXJyID8gZXF1YWxBcnJheXMgOiBlcXVhbE9iamVjdHMpKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpO1xuXHRcblx0ICAgICAgc3RhY2tBLnBvcCgpO1xuXHQgICAgICBzdGFja0IucG9wKCk7XG5cdFxuXHQgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXRjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuXHQgICAgICogc2hvcnRoYW5kcyBhbmQgYHRoaXNgIGJpbmRpbmcuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuXHQgICAgICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIHRvIG1hdGNoLlxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaW5nIG9iamVjdHMuXG5cdCAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBiYXNlSXNNYXRjaChvYmplY3QsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuXHQgICAgICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuXHQgICAgICAgICAgbGVuZ3RoID0gaW5kZXgsXG5cdCAgICAgICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblx0XG5cdCAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuXHQgICAgICAgIHJldHVybiAhbGVuZ3RoO1xuXHQgICAgICB9XG5cdCAgICAgIG9iamVjdCA9IHRvT2JqZWN0KG9iamVjdCk7XG5cdCAgICAgIHdoaWxlIChpbmRleC0tKSB7XG5cdCAgICAgICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuXHQgICAgICAgIGlmICgobm9DdXN0b21pemVyICYmIGRhdGFbMl0pXG5cdCAgICAgICAgICAgICAgPyBkYXRhWzFdICE9PSBvYmplY3RbZGF0YVswXV1cblx0ICAgICAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG5cdCAgICAgICAgICAgICkge1xuXHQgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHQgICAgICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuXHQgICAgICAgIHZhciBrZXkgPSBkYXRhWzBdLFxuXHQgICAgICAgICAgICBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuXHQgICAgICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cdFxuXHQgICAgICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuXHQgICAgICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyID8gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSkgOiB1bmRlZmluZWQ7XG5cdCAgICAgICAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZCA/IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgY3VzdG9taXplciwgdHJ1ZSkgOiByZXN1bHQpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXBgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2sgc2hvcnRoYW5kc1xuXHQgICAgICogYW5kIGB0aGlzYCBiaW5kaW5nLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cblx0ICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gYmFzZU1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuXHQgICAgICB2YXIgaW5kZXggPSAtMSxcblx0ICAgICAgICAgIHJlc3VsdCA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gQXJyYXkoY29sbGVjdGlvbi5sZW5ndGgpIDogW107XG5cdFxuXHQgICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG5cdCAgICAgICAgcmVzdWx0WysraW5kZXhdID0gaXRlcmF0ZWUodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG5cdCAgICAgIH0pO1xuXHQgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lcyBub3QgY2xvbmUgYHNvdXJjZWAuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG5cdCAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG5cdCAgICAgIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcblx0ICAgICAgaWYgKG1hdGNoRGF0YS5sZW5ndGggPT0gMSAmJiBtYXRjaERhdGFbMF1bMl0pIHtcblx0ICAgICAgICB2YXIga2V5ID0gbWF0Y2hEYXRhWzBdWzBdLFxuXHQgICAgICAgICAgICB2YWx1ZSA9IG1hdGNoRGF0YVswXVsxXTtcblx0XG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuXHQgICAgICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIHJldHVybiBvYmplY3Rba2V5XSA9PT0gdmFsdWUgJiYgKHZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiB0b09iamVjdChvYmplY3QpKSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG5cdCAgICAgICAgcmV0dXJuIGJhc2VJc01hdGNoKG9iamVjdCwgbWF0Y2hEYXRhKTtcblx0ICAgICAgfTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNQcm9wZXJ0eWAgd2hpY2ggZG9lcyBub3QgY2xvbmUgYHNyY1ZhbHVlYC5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cblx0ICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG5cdCAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuXHQgICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHBhdGgpLFxuXHQgICAgICAgICAgaXNDb21tb24gPSBpc0tleShwYXRoKSAmJiBpc1N0cmljdENvbXBhcmFibGUoc3JjVmFsdWUpLFxuXHQgICAgICAgICAgcGF0aEtleSA9IChwYXRoICsgJycpO1xuXHRcblx0ICAgICAgcGF0aCA9IHRvUGF0aChwYXRoKTtcblx0ICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuXHQgICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuXHQgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIga2V5ID0gcGF0aEtleTtcblx0ICAgICAgICBvYmplY3QgPSB0b09iamVjdChvYmplY3QpO1xuXHQgICAgICAgIGlmICgoaXNBcnIgfHwgIWlzQ29tbW9uKSAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG5cdCAgICAgICAgICBvYmplY3QgPSBwYXRoLmxlbmd0aCA9PSAxID8gb2JqZWN0IDogYmFzZUdldChvYmplY3QsIGJhc2VTbGljZShwYXRoLCAwLCAtMSkpO1xuXHQgICAgICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIGtleSA9IGxhc3QocGF0aCk7XG5cdCAgICAgICAgICBvYmplY3QgPSB0b09iamVjdChvYmplY3QpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlXG5cdCAgICAgICAgICA/IChzcmNWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IChrZXkgaW4gb2JqZWN0KSlcblx0ICAgICAgICAgIDogYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9iamVjdFtrZXldLCB1bmRlZmluZWQsIHRydWUpO1xuXHQgICAgICB9O1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVyZ2VgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXJndW1lbnQganVnZ2xpbmcsXG5cdCAgICAgKiBtdWx0aXBsZSBzb3VyY2VzLCBhbmQgYHRoaXNgIGJpbmRpbmcgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdlZCB2YWx1ZXMuXG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSBvYmplY3RzLlxuXHQgICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQj1bXV0gQXNzb2NpYXRlcyB2YWx1ZXMgd2l0aCBzb3VyY2UgY291bnRlcnBhcnRzLlxuXHQgICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyLCBzdGFja0EsIHN0YWNrQikge1xuXHQgICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcblx0ICAgICAgICByZXR1cm4gb2JqZWN0O1xuXHQgICAgICB9XG5cdCAgICAgIHZhciBpc1NyY0FyciA9IGlzQXJyYXlMaWtlKHNvdXJjZSkgJiYgKGlzQXJyYXkoc291cmNlKSB8fCBpc1R5cGVkQXJyYXkoc291cmNlKSksXG5cdCAgICAgICAgICBwcm9wcyA9IGlzU3JjQXJyID8gdW5kZWZpbmVkIDoga2V5cyhzb3VyY2UpO1xuXHRcblx0ICAgICAgYXJyYXlFYWNoKHByb3BzIHx8IHNvdXJjZSwgZnVuY3Rpb24oc3JjVmFsdWUsIGtleSkge1xuXHQgICAgICAgIGlmIChwcm9wcykge1xuXHQgICAgICAgICAga2V5ID0gc3JjVmFsdWU7XG5cdCAgICAgICAgICBzcmNWYWx1ZSA9IHNvdXJjZVtrZXldO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoaXNPYmplY3RMaWtlKHNyY1ZhbHVlKSkge1xuXHQgICAgICAgICAgc3RhY2tBIHx8IChzdGFja0EgPSBbXSk7XG5cdCAgICAgICAgICBzdGFja0IgfHwgKHN0YWNrQiA9IFtdKTtcblx0ICAgICAgICAgIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgYmFzZU1lcmdlLCBjdXN0b21pemVyLCBzdGFja0EsIHN0YWNrQik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV0sXG5cdCAgICAgICAgICAgICAgcmVzdWx0ID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIodmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKSA6IHVuZGVmaW5lZCxcblx0ICAgICAgICAgICAgICBpc0NvbW1vbiA9IHJlc3VsdCA9PT0gdW5kZWZpbmVkO1xuXHRcblx0ICAgICAgICAgIGlmIChpc0NvbW1vbikge1xuXHQgICAgICAgICAgICByZXN1bHQgPSBzcmNWYWx1ZTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIGlmICgocmVzdWx0ICE9PSB1bmRlZmluZWQgfHwgKGlzU3JjQXJyICYmICEoa2V5IGluIG9iamVjdCkpKSAmJlxuXHQgICAgICAgICAgICAgIChpc0NvbW1vbiB8fCAocmVzdWx0ID09PSByZXN1bHQgPyAocmVzdWx0ICE9PSB2YWx1ZSkgOiAodmFsdWUgPT09IHZhbHVlKSkpKSB7XG5cdCAgICAgICAgICAgIG9iamVjdFtrZXldID0gcmVzdWx0O1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdCAgICAgIHJldHVybiBvYmplY3Q7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VNZXJnZWAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuXHQgICAgICogZGVlcCBtZXJnZXMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcblx0ICAgICAqIHJlZmVyZW5jZXMgdG8gYmUgbWVyZ2VkLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBtZXJnZS5cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG1lcmdlRnVuYyBUaGUgZnVuY3Rpb24gdG8gbWVyZ2UgdmFsdWVzLlxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2VkIHZhbHVlcy5cblx0ICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0E9W11dIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIG9iamVjdHMuXG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tCPVtdXSBBc3NvY2lhdGVzIHZhbHVlcyB3aXRoIHNvdXJjZSBjb3VudGVycGFydHMuXG5cdCAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBtZXJnZUZ1bmMsIGN1c3RvbWl6ZXIsIHN0YWNrQSwgc3RhY2tCKSB7XG5cdCAgICAgIHZhciBsZW5ndGggPSBzdGFja0EubGVuZ3RoLFxuXHQgICAgICAgICAgc3JjVmFsdWUgPSBzb3VyY2Vba2V5XTtcblx0XG5cdCAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuXHQgICAgICAgIGlmIChzdGFja0FbbGVuZ3RoXSA9PSBzcmNWYWx1ZSkge1xuXHQgICAgICAgICAgb2JqZWN0W2tleV0gPSBzdGFja0JbbGVuZ3RoXTtcblx0ICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV0sXG5cdCAgICAgICAgICByZXN1bHQgPSBjdXN0b21pemVyID8gY3VzdG9taXplcih2YWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpIDogdW5kZWZpbmVkLFxuXHQgICAgICAgICAgaXNDb21tb24gPSByZXN1bHQgPT09IHVuZGVmaW5lZDtcblx0XG5cdCAgICAgIGlmIChpc0NvbW1vbikge1xuXHQgICAgICAgIHJlc3VsdCA9IHNyY1ZhbHVlO1xuXHQgICAgICAgIGlmIChpc0FycmF5TGlrZShzcmNWYWx1ZSkgJiYgKGlzQXJyYXkoc3JjVmFsdWUpIHx8IGlzVHlwZWRBcnJheShzcmNWYWx1ZSkpKSB7XG5cdCAgICAgICAgICByZXN1bHQgPSBpc0FycmF5KHZhbHVlKVxuXHQgICAgICAgICAgICA/IHZhbHVlXG5cdCAgICAgICAgICAgIDogKGlzQXJyYXlMaWtlKHZhbHVlKSA/IGFycmF5Q29weSh2YWx1ZSkgOiBbXSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qoc3JjVmFsdWUpIHx8IGlzQXJndW1lbnRzKHNyY1ZhbHVlKSkge1xuXHQgICAgICAgICAgcmVzdWx0ID0gaXNBcmd1bWVudHModmFsdWUpXG5cdCAgICAgICAgICAgID8gdG9QbGFpbk9iamVjdCh2YWx1ZSlcblx0ICAgICAgICAgICAgOiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkgPyB2YWx1ZSA6IHt9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICAvLyBBZGQgdGhlIHNvdXJjZSB2YWx1ZSB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMgYW5kIGFzc29jaWF0ZVxuXHQgICAgICAvLyBpdCB3aXRoIGl0cyBtZXJnZWQgdmFsdWUuXG5cdCAgICAgIHN0YWNrQS5wdXNoKHNyY1ZhbHVlKTtcblx0ICAgICAgc3RhY2tCLnB1c2gocmVzdWx0KTtcblx0XG5cdCAgICAgIGlmIChpc0NvbW1vbikge1xuXHQgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuXHQgICAgICAgIG9iamVjdFtrZXldID0gbWVyZ2VGdW5jKHJlc3VsdCwgc3JjVmFsdWUsIGN1c3RvbWl6ZXIsIHN0YWNrQSwgc3RhY2tCKTtcblx0ICAgICAgfSBlbHNlIGlmIChyZXN1bHQgPT09IHJlc3VsdCA/IChyZXN1bHQgIT09IHZhbHVlKSA6ICh2YWx1ZSA9PT0gdmFsdWUpKSB7XG5cdCAgICAgICAgb2JqZWN0W2tleV0gPSByZXN1bHQ7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuXHQgICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcblx0ICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuXHQgICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuXHQgICAgICB9O1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUHJvcGVydHlgIHdoaWNoIHN1cHBvcnRzIGRlZXAgcGF0aHMuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG5cdCAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG5cdCAgICAgIHZhciBwYXRoS2V5ID0gKHBhdGggKyAnJyk7XG5cdCAgICAgIHBhdGggPSB0b1BhdGgocGF0aCk7XG5cdCAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcblx0ICAgICAgICByZXR1cm4gYmFzZUdldChvYmplY3QsIHBhdGgsIHBhdGhLZXkpO1xuXHQgICAgICB9O1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHVsbEF0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcblx0ICAgICAqIGluZGV4IGFyZ3VtZW50cyBhbmQgY2FwdHVyaW5nIHRoZSByZW1vdmVkIGVsZW1lbnRzLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuXHQgICAgICogQHBhcmFtIHtudW1iZXJbXX0gaW5kZXhlcyBUaGUgaW5kZXhlcyBvZiBlbGVtZW50cyB0byByZW1vdmUuXG5cdCAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gYmFzZVB1bGxBdChhcnJheSwgaW5kZXhlcykge1xuXHQgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBpbmRleGVzLmxlbmd0aCA6IDA7XG5cdCAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuXHQgICAgICAgIHZhciBpbmRleCA9IGluZGV4ZXNbbGVuZ3RoXTtcblx0ICAgICAgICBpZiAoaW5kZXggIT0gcHJldmlvdXMgJiYgaXNJbmRleChpbmRleCkpIHtcblx0ICAgICAgICAgIHZhciBwcmV2aW91cyA9IGluZGV4O1xuXHQgICAgICAgICAgc3BsaWNlLmNhbGwoYXJyYXksIGluZGV4LCAxKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGFycmF5O1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZG9tYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFyZ3VtZW50IGp1Z2dsaW5nXG5cdCAgICAgKiBhbmQgcmV0dXJuaW5nIGZsb2F0aW5nLXBvaW50IG51bWJlcnMuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIG1pbmltdW0gcG9zc2libGUgdmFsdWUuXG5cdCAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IFRoZSBtYXhpbXVtIHBvc3NpYmxlIHZhbHVlLlxuXHQgICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcmFuZG9tIG51bWJlci5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gYmFzZVJhbmRvbShtaW4sIG1heCkge1xuXHQgICAgICByZXR1cm4gbWluICsgbmF0aXZlRmxvb3IobmF0aXZlUmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVkdWNlYCBhbmQgYF8ucmVkdWNlUmlnaHRgIHdpdGhvdXQgc3VwcG9ydFxuXHQgICAgICogZm9yIGNhbGxiYWNrIHNob3J0aGFuZHMgYW5kIGB0aGlzYCBiaW5kaW5nLCB3aGljaCBpdGVyYXRlcyBvdmVyIGBjb2xsZWN0aW9uYFxuXHQgICAgICogdXNpbmcgdGhlIHByb3ZpZGVkIGBlYWNoRnVuY2AuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuXHQgICAgICogQHBhcmFtIHsqfSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCB2YWx1ZS5cblx0ICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5pdEZyb21Db2xsZWN0aW9uIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IG9yIGxhc3QgZWxlbWVudFxuXHQgICAgICogIG9mIGBjb2xsZWN0aW9uYCBhcyB0aGUgaW5pdGlhbCB2YWx1ZS5cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYGNvbGxlY3Rpb25gLlxuXHQgICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBiYXNlUmVkdWNlKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEZyb21Db2xsZWN0aW9uLCBlYWNoRnVuYykge1xuXHQgICAgICBlYWNoRnVuYyhjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcblx0ICAgICAgICBhY2N1bXVsYXRvciA9IGluaXRGcm9tQ29sbGVjdGlvblxuXHQgICAgICAgICAgPyAoaW5pdEZyb21Db2xsZWN0aW9uID0gZmFsc2UsIHZhbHVlKVxuXHQgICAgICAgICAgOiBpdGVyYXRlZShhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcblx0ICAgICAgfSk7XG5cdCAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXREYXRhYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIGRldGVjdGlvbi5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXNzb2NpYXRlIG1ldGFkYXRhIHdpdGguXG5cdCAgICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1ldGFkYXRhLlxuXHQgICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cblx0ICAgICAqL1xuXHQgICAgdmFyIGJhc2VTZXREYXRhID0gIW1ldGFNYXAgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIGRhdGEpIHtcblx0ICAgICAgbWV0YU1hcC5zZXQoZnVuYywgZGF0YSk7XG5cdCAgICAgIHJldHVybiBmdW5jO1xuXHQgICAgfTtcblx0XG5cdCAgICAvKipcblx0ICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNsaWNlYCB3aXRob3V0IGFuIGl0ZXJhdGVlIGNhbGwgZ3VhcmQuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzbGljZS5cblx0ICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuXHQgICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuXHQgICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcblx0ICAgICAgdmFyIGluZGV4ID0gLTEsXG5cdCAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFxuXHQgICAgICBzdGFydCA9IHN0YXJ0ID09IG51bGwgPyAwIDogKCtzdGFydCB8fCAwKTtcblx0ICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuXHQgICAgICAgIHN0YXJ0ID0gLXN0YXJ0ID4gbGVuZ3RoID8gMCA6IChsZW5ndGggKyBzdGFydCk7XG5cdCAgICAgIH1cblx0ICAgICAgZW5kID0gKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IGxlbmd0aCkgPyBsZW5ndGggOiAoK2VuZCB8fCAwKTtcblx0ICAgICAgaWYgKGVuZCA8IDApIHtcblx0ICAgICAgICBlbmQgKz0gbGVuZ3RoO1xuXHQgICAgICB9XG5cdCAgICAgIGxlbmd0aCA9IHN0YXJ0ID4gZW5kID8gMCA6ICgoZW5kIC0gc3RhcnQpID4+PiAwKTtcblx0ICAgICAgc3RhcnQgPj4+PSAwO1xuXHRcblx0ICAgICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cdCAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdCAgICAgICAgcmVzdWx0W2luZGV4XSA9IGFycmF5W2luZGV4ICsgc3RhcnRdO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb21lYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrIHNob3J0aGFuZHNcblx0ICAgICAqIGFuZCBgdGhpc2AgYmluZGluZy5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuXHQgICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuXHQgICAgICogIGVsc2UgYGZhbHNlYC5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gYmFzZVNvbWUoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG5cdCAgICAgIHZhciByZXN1bHQ7XG5cdFxuXHQgICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcblx0ICAgICAgICByZXN1bHQgPSBwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcblx0ICAgICAgICByZXR1cm4gIXJlc3VsdDtcblx0ICAgICAgfSk7XG5cdCAgICAgIHJldHVybiAhIXJlc3VsdDtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRCeWAgd2hpY2ggdXNlcyBgY29tcGFyZXJgIHRvIGRlZmluZVxuXHQgICAgICogdGhlIHNvcnQgb3JkZXIgb2YgYGFycmF5YCBhbmQgcmVwbGFjZXMgY3JpdGVyaWEgb2JqZWN0cyB3aXRoIHRoZWlyXG5cdCAgICAgKiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNvcnQuXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJlciBUaGUgZnVuY3Rpb24gdG8gZGVmaW5lIHNvcnQgb3JkZXIuXG5cdCAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gYmFzZVNvcnRCeShhcnJheSwgY29tcGFyZXIpIHtcblx0ICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XG5cdCAgICAgIGFycmF5LnNvcnQoY29tcGFyZXIpO1xuXHQgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcblx0ICAgICAgICBhcnJheVtsZW5ndGhdID0gYXJyYXlbbGVuZ3RoXS52YWx1ZTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gYXJyYXk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0QnlPcmRlcmAgd2l0aG91dCBwYXJhbSBndWFyZHMuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uW118T2JqZWN0W118c3RyaW5nW119IGl0ZXJhdGVlcyBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG5cdCAgICAgKiBAcGFyYW0ge2Jvb2xlYW5bXX0gb3JkZXJzIFRoZSBzb3J0IG9yZGVycyBvZiBgaXRlcmF0ZWVzYC5cblx0ICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gYmFzZVNvcnRCeU9yZGVyKGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKSB7XG5cdCAgICAgIHZhciBjYWxsYmFjayA9IGdldENhbGxiYWNrKCksXG5cdCAgICAgICAgICBpbmRleCA9IC0xO1xuXHRcblx0ICAgICAgaXRlcmF0ZWVzID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBmdW5jdGlvbihpdGVyYXRlZSkgeyByZXR1cm4gY2FsbGJhY2soaXRlcmF0ZWUpOyB9KTtcblx0XG5cdCAgICAgIHZhciByZXN1bHQgPSBiYXNlTWFwKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgICAgdmFyIGNyaXRlcmlhID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBmdW5jdGlvbihpdGVyYXRlZSkgeyByZXR1cm4gaXRlcmF0ZWUodmFsdWUpOyB9KTtcblx0ICAgICAgICByZXR1cm4geyAnY3JpdGVyaWEnOiBjcml0ZXJpYSwgJ2luZGV4JzogKytpbmRleCwgJ3ZhbHVlJzogdmFsdWUgfTtcblx0ICAgICAgfSk7XG5cdFxuXHQgICAgICByZXR1cm4gYmFzZVNvcnRCeShyZXN1bHQsIGZ1bmN0aW9uKG9iamVjdCwgb3RoZXIpIHtcblx0ICAgICAgICByZXR1cm4gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycyk7XG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc3VtYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrIHNob3J0aGFuZHNcblx0ICAgICAqIGFuZCBgdGhpc2AgYmluZGluZy5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG5cdCAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGJhc2VTdW0oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcblx0ICAgICAgdmFyIHJlc3VsdCA9IDA7XG5cdCAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuXHQgICAgICAgIHJlc3VsdCArPSAraXRlcmF0ZWUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB8fCAwO1xuXHQgICAgICB9KTtcblx0ICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuaXFgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2sgc2hvcnRoYW5kc1xuXHQgICAgICogYW5kIGB0aGlzYCBiaW5kaW5nLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cblx0ICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZS12YWx1ZS1mcmVlIGFycmF5LlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBiYXNlVW5pcShhcnJheSwgaXRlcmF0ZWUpIHtcblx0ICAgICAgdmFyIGluZGV4ID0gLTEsXG5cdCAgICAgICAgICBpbmRleE9mID0gZ2V0SW5kZXhPZigpLFxuXHQgICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuXHQgICAgICAgICAgaXNDb21tb24gPSBpbmRleE9mID09IGJhc2VJbmRleE9mLFxuXHQgICAgICAgICAgaXNMYXJnZSA9IGlzQ29tbW9uICYmIGxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFLFxuXHQgICAgICAgICAgc2VlbiA9IGlzTGFyZ2UgPyBjcmVhdGVDYWNoZSgpIDogbnVsbCxcblx0ICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXHRcblx0ICAgICAgaWYgKHNlZW4pIHtcblx0ICAgICAgICBpbmRleE9mID0gY2FjaGVJbmRleE9mO1xuXHQgICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgaXNMYXJnZSA9IGZhbHNlO1xuXHQgICAgICAgIHNlZW4gPSBpdGVyYXRlZSA/IFtdIDogcmVzdWx0O1xuXHQgICAgICB9XG5cdCAgICAgIG91dGVyOlxuXHQgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHQgICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcblx0ICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgYXJyYXkpIDogdmFsdWU7XG5cdFxuXHQgICAgICAgIGlmIChpc0NvbW1vbiAmJiB2YWx1ZSA9PT0gdmFsdWUpIHtcblx0ICAgICAgICAgIHZhciBzZWVuSW5kZXggPSBzZWVuLmxlbmd0aDtcblx0ICAgICAgICAgIHdoaWxlIChzZWVuSW5kZXgtLSkge1xuXHQgICAgICAgICAgICBpZiAoc2VlbltzZWVuSW5kZXhdID09PSBjb21wdXRlZCkge1xuXHQgICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICBpZiAoaXRlcmF0ZWUpIHtcblx0ICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAoaW5kZXhPZihzZWVuLCBjb21wdXRlZCwgMCkgPCAwKSB7XG5cdCAgICAgICAgICBpZiAoaXRlcmF0ZWUgfHwgaXNMYXJnZSkge1xuXHQgICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udmFsdWVzYCBhbmQgYF8udmFsdWVzSW5gIHdoaWNoIGNyZWF0ZXMgYW5cblx0ICAgICAqIGFycmF5IG9mIGBvYmplY3RgIHByb3BlcnR5IHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lc1xuXHQgICAgICogb2YgYHByb3BzYC5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuXHQgICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuXHQgICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBiYXNlVmFsdWVzKG9iamVjdCwgcHJvcHMpIHtcblx0ICAgICAgdmFyIGluZGV4ID0gLTEsXG5cdCAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG5cdCAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXHRcblx0ICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0ICAgICAgICByZXN1bHRbaW5kZXhdID0gb2JqZWN0W3Byb3BzW2luZGV4XV07XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmRyb3BSaWdodFdoaWxlYCwgYF8uZHJvcFdoaWxlYCwgYF8udGFrZVJpZ2h0V2hpbGVgLFxuXHQgICAgICogYW5kIGBfLnRha2VXaGlsZWAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFjayBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG5cdCAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0Ryb3BdIFNwZWNpZnkgZHJvcHBpbmcgZWxlbWVudHMgaW5zdGVhZCBvZiB0YWtpbmcgdGhlbS5cblx0ICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuXHQgICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBiYXNlV2hpbGUoYXJyYXksIHByZWRpY2F0ZSwgaXNEcm9wLCBmcm9tUmlnaHQpIHtcblx0ICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcblx0ICAgICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTE7XG5cdFxuXHQgICAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSAmJiBwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7fVxuXHQgICAgICByZXR1cm4gaXNEcm9wXG5cdCAgICAgICAgPyBiYXNlU2xpY2UoYXJyYXksIChmcm9tUmlnaHQgPyAwIDogaW5kZXgpLCAoZnJvbVJpZ2h0ID8gaW5kZXggKyAxIDogbGVuZ3RoKSlcblx0ICAgICAgICA6IGJhc2VTbGljZShhcnJheSwgKGZyb21SaWdodCA/IGluZGV4ICsgMSA6IDApLCAoZnJvbVJpZ2h0ID8gbGVuZ3RoIDogaW5kZXgpKTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGB3cmFwcGVyVmFsdWVgIHdoaWNoIHJldHVybnMgdGhlIHJlc3VsdCBvZlxuXHQgICAgICogcGVyZm9ybWluZyBhIHNlcXVlbmNlIG9mIGFjdGlvbnMgb24gdGhlIHVud3JhcHBlZCBgdmFsdWVgLCB3aGVyZSBlYWNoXG5cdCAgICAgKiBzdWNjZXNzaXZlIGFjdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdW53cmFwcGVkIHZhbHVlLlxuXHQgICAgICogQHBhcmFtIHtBcnJheX0gYWN0aW9ucyBBY3Rpb25zIHRvIHBlZm9ybSB0byByZXNvbHZlIHRoZSB1bndyYXBwZWQgdmFsdWUuXG5cdCAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGJhc2VXcmFwcGVyVmFsdWUodmFsdWUsIGFjdGlvbnMpIHtcblx0ICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlO1xuXHQgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcblx0ICAgICAgICByZXN1bHQgPSByZXN1bHQudmFsdWUoKTtcblx0ICAgICAgfVxuXHQgICAgICB2YXIgaW5kZXggPSAtMSxcblx0ICAgICAgICAgIGxlbmd0aCA9IGFjdGlvbnMubGVuZ3RoO1xuXHRcblx0ICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0ICAgICAgICB2YXIgYWN0aW9uID0gYWN0aW9uc1tpbmRleF07XG5cdCAgICAgICAgcmVzdWx0ID0gYWN0aW9uLmZ1bmMuYXBwbHkoYWN0aW9uLnRoaXNBcmcsIGFycmF5UHVzaChbcmVzdWx0XSwgYWN0aW9uLmFyZ3MpKTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogUGVyZm9ybXMgYSBiaW5hcnkgc2VhcmNoIG9mIGBhcnJheWAgdG8gZGV0ZXJtaW5lIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgXG5cdCAgICAgKiBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvIG1haW50YWluIGl0cyBzb3J0IG9yZGVyLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG5cdCAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cblx0ICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldEhpZ2hlc3RdIFNwZWNpZnkgcmV0dXJuaW5nIHRoZSBoaWdoZXN0IHF1YWxpZmllZCBpbmRleC5cblx0ICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG5cdCAgICAgKiAgaW50byBgYXJyYXlgLlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBiaW5hcnlJbmRleChhcnJheSwgdmFsdWUsIHJldEhpZ2hlc3QpIHtcblx0ICAgICAgdmFyIGxvdyA9IDAsXG5cdCAgICAgICAgICBoaWdoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiBsb3c7XG5cdFxuXHQgICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID09PSB2YWx1ZSAmJiBoaWdoIDw9IEhBTEZfTUFYX0FSUkFZX0xFTkdUSCkge1xuXHQgICAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG5cdCAgICAgICAgICB2YXIgbWlkID0gKGxvdyArIGhpZ2gpID4+PiAxLFxuXHQgICAgICAgICAgICAgIGNvbXB1dGVkID0gYXJyYXlbbWlkXTtcblx0XG5cdCAgICAgICAgICBpZiAoKHJldEhpZ2hlc3QgPyAoY29tcHV0ZWQgPD0gdmFsdWUpIDogKGNvbXB1dGVkIDwgdmFsdWUpKSAmJiBjb21wdXRlZCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgaGlnaCA9IG1pZDtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGhpZ2g7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGJpbmFyeUluZGV4QnkoYXJyYXksIHZhbHVlLCBpZGVudGl0eSwgcmV0SGlnaGVzdCk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGJpbmFyeUluZGV4YCBleGNlcHQgdGhhdCBpdCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yXG5cdCAgICAgKiBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlIHRoZWlyIHNvcnQgcmFua2luZy4gVGhlXG5cdCAgICAgKiBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG5cdCAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG5cdCAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXRIaWdoZXN0XSBTcGVjaWZ5IHJldHVybmluZyB0aGUgaGlnaGVzdCBxdWFsaWZpZWQgaW5kZXguXG5cdCAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuXHQgICAgICogIGludG8gYGFycmF5YC5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gYmluYXJ5SW5kZXhCeShhcnJheSwgdmFsdWUsIGl0ZXJhdGVlLCByZXRIaWdoZXN0KSB7XG5cdCAgICAgIHZhbHVlID0gaXRlcmF0ZWUodmFsdWUpO1xuXHRcblx0ICAgICAgdmFyIGxvdyA9IDAsXG5cdCAgICAgICAgICBoaWdoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuXHQgICAgICAgICAgdmFsSXNOYU4gPSB2YWx1ZSAhPT0gdmFsdWUsXG5cdCAgICAgICAgICB2YWxJc051bGwgPSB2YWx1ZSA9PT0gbnVsbCxcblx0ICAgICAgICAgIHZhbElzVW5kZWYgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xuXHRcblx0ICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcblx0ICAgICAgICB2YXIgbWlkID0gbmF0aXZlRmxvb3IoKGxvdyArIGhpZ2gpIC8gMiksXG5cdCAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUoYXJyYXlbbWlkXSksXG5cdCAgICAgICAgICAgIGlzRGVmID0gY29tcHV0ZWQgIT09IHVuZGVmaW5lZCxcblx0ICAgICAgICAgICAgaXNSZWZsZXhpdmUgPSBjb21wdXRlZCA9PT0gY29tcHV0ZWQ7XG5cdFxuXHQgICAgICAgIGlmICh2YWxJc05hTikge1xuXHQgICAgICAgICAgdmFyIHNldExvdyA9IGlzUmVmbGV4aXZlIHx8IHJldEhpZ2hlc3Q7XG5cdCAgICAgICAgfSBlbHNlIGlmICh2YWxJc051bGwpIHtcblx0ICAgICAgICAgIHNldExvdyA9IGlzUmVmbGV4aXZlICYmIGlzRGVmICYmIChyZXRIaWdoZXN0IHx8IGNvbXB1dGVkICE9IG51bGwpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAodmFsSXNVbmRlZikge1xuXHQgICAgICAgICAgc2V0TG93ID0gaXNSZWZsZXhpdmUgJiYgKHJldEhpZ2hlc3QgfHwgaXNEZWYpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoY29tcHV0ZWQgPT0gbnVsbCkge1xuXHQgICAgICAgICAgc2V0TG93ID0gZmFsc2U7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHNldExvdyA9IHJldEhpZ2hlc3QgPyAoY29tcHV0ZWQgPD0gdmFsdWUpIDogKGNvbXB1dGVkIDwgdmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoc2V0TG93KSB7XG5cdCAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBoaWdoID0gbWlkO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gbmF0aXZlTWluKGhpZ2gsIE1BWF9BUlJBWV9JTkRFWCk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VDYWxsYmFja2Agd2hpY2ggb25seSBzdXBwb3J0cyBgdGhpc2AgYmluZGluZ1xuXHQgICAgICogYW5kIHNwZWNpZnlpbmcgdGhlIG51bWJlciBvZiBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG5cdCAgICAgKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cblx0ICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJnQ291bnRdIFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuXHQgICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjYWxsYmFjay5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gYmluZENhbGxiYWNrKGZ1bmMsIHRoaXNBcmcsIGFyZ0NvdW50KSB7XG5cdCAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgcmV0dXJuIGlkZW50aXR5O1xuXHQgICAgICB9XG5cdCAgICAgIGlmICh0aGlzQXJnID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICByZXR1cm4gZnVuYztcblx0ICAgICAgfVxuXHQgICAgICBzd2l0Y2ggKGFyZ0NvdW50KSB7XG5cdCAgICAgICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgdmFsdWUpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG5cdCAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBjYXNlIDQ6IHJldHVybiBmdW5jdGlvbihhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG5cdCAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgY2FzZSA1OiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG90aGVyLCBrZXksIG9iamVjdCwgc291cmNlKSB7XG5cdCAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlLCBvdGhlciwga2V5LCBvYmplY3QsIHNvdXJjZSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzKTtcblx0ICAgICAgfTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgZ2l2ZW4gYXJyYXkgYnVmZmVyLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBidWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cblx0ICAgICAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gYnVmZmVyQ2xvbmUoYnVmZmVyKSB7XG5cdCAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXlCdWZmZXIoYnVmZmVyLmJ5dGVMZW5ndGgpLFxuXHQgICAgICAgICAgdmlldyA9IG5ldyBVaW50OEFycmF5KHJlc3VsdCk7XG5cdFxuXHQgICAgICB2aWV3LnNldChuZXcgVWludDhBcnJheShidWZmZXIpKTtcblx0ICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLFxuXHQgICAgICogcGxhY2Vob2xkZXJzLCBhbmQgcHJvdmlkZWQgYXJndW1lbnRzIGludG8gYSBzaW5nbGUgYXJyYXkgb2YgYXJndW1lbnRzLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gYXJncyBUaGUgcHJvdmlkZWQgYXJndW1lbnRzLlxuXHQgICAgICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkLlxuXHQgICAgICogQHBhcmFtIHtBcnJheX0gaG9sZGVycyBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuXHQgICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tcG9zZWQgYXJndW1lbnRzLlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBjb21wb3NlQXJncyhhcmdzLCBwYXJ0aWFscywgaG9sZGVycykge1xuXHQgICAgICB2YXIgaG9sZGVyc0xlbmd0aCA9IGhvbGRlcnMubGVuZ3RoLFxuXHQgICAgICAgICAgYXJnc0luZGV4ID0gLTEsXG5cdCAgICAgICAgICBhcmdzTGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gaG9sZGVyc0xlbmd0aCwgMCksXG5cdCAgICAgICAgICBsZWZ0SW5kZXggPSAtMSxcblx0ICAgICAgICAgIGxlZnRMZW5ndGggPSBwYXJ0aWFscy5sZW5ndGgsXG5cdCAgICAgICAgICByZXN1bHQgPSBBcnJheShsZWZ0TGVuZ3RoICsgYXJnc0xlbmd0aCk7XG5cdFxuXHQgICAgICB3aGlsZSAoKytsZWZ0SW5kZXggPCBsZWZ0TGVuZ3RoKSB7XG5cdCAgICAgICAgcmVzdWx0W2xlZnRJbmRleF0gPSBwYXJ0aWFsc1tsZWZ0SW5kZXhdO1xuXHQgICAgICB9XG5cdCAgICAgIHdoaWxlICgrK2FyZ3NJbmRleCA8IGhvbGRlcnNMZW5ndGgpIHtcblx0ICAgICAgICByZXN1bHRbaG9sZGVyc1thcmdzSW5kZXhdXSA9IGFyZ3NbYXJnc0luZGV4XTtcblx0ICAgICAgfVxuXHQgICAgICB3aGlsZSAoYXJnc0xlbmd0aC0tKSB7XG5cdCAgICAgICAgcmVzdWx0W2xlZnRJbmRleCsrXSA9IGFyZ3NbYXJnc0luZGV4KytdO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGNvbXBvc2VBcmdzYCBleGNlcHQgdGhhdCB0aGUgYXJndW1lbnRzIGNvbXBvc2l0aW9uXG5cdCAgICAgKiBpcyB0YWlsb3JlZCBmb3IgYF8ucGFydGlhbFJpZ2h0YC5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGFyZ3MgVGhlIHByb3ZpZGVkIGFyZ3VtZW50cy5cblx0ICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gYXBwZW5kIHRvIHRob3NlIHByb3ZpZGVkLlxuXHQgICAgICogQHBhcmFtIHtBcnJheX0gaG9sZGVycyBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuXHQgICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tcG9zZWQgYXJndW1lbnRzLlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBjb21wb3NlQXJnc1JpZ2h0KGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzKSB7XG5cdCAgICAgIHZhciBob2xkZXJzSW5kZXggPSAtMSxcblx0ICAgICAgICAgIGhvbGRlcnNMZW5ndGggPSBob2xkZXJzLmxlbmd0aCxcblx0ICAgICAgICAgIGFyZ3NJbmRleCA9IC0xLFxuXHQgICAgICAgICAgYXJnc0xlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIGhvbGRlcnNMZW5ndGgsIDApLFxuXHQgICAgICAgICAgcmlnaHRJbmRleCA9IC0xLFxuXHQgICAgICAgICAgcmlnaHRMZW5ndGggPSBwYXJ0aWFscy5sZW5ndGgsXG5cdCAgICAgICAgICByZXN1bHQgPSBBcnJheShhcmdzTGVuZ3RoICsgcmlnaHRMZW5ndGgpO1xuXHRcblx0ICAgICAgd2hpbGUgKCsrYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuXHQgICAgICAgIHJlc3VsdFthcmdzSW5kZXhdID0gYXJnc1thcmdzSW5kZXhdO1xuXHQgICAgICB9XG5cdCAgICAgIHZhciBvZmZzZXQgPSBhcmdzSW5kZXg7XG5cdCAgICAgIHdoaWxlICgrK3JpZ2h0SW5kZXggPCByaWdodExlbmd0aCkge1xuXHQgICAgICAgIHJlc3VsdFtvZmZzZXQgKyByaWdodEluZGV4XSA9IHBhcnRpYWxzW3JpZ2h0SW5kZXhdO1xuXHQgICAgICB9XG5cdCAgICAgIHdoaWxlICgrK2hvbGRlcnNJbmRleCA8IGhvbGRlcnNMZW5ndGgpIHtcblx0ICAgICAgICByZXN1bHRbb2Zmc2V0ICsgaG9sZGVyc1tob2xkZXJzSW5kZXhdXSA9IGFyZ3NbYXJnc0luZGV4KytdO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGEgYF8uY291bnRCeWAsIGBfLmdyb3VwQnlgLCBgXy5pbmRleEJ5YCwgb3IgYF8ucGFydGl0aW9uYCBmdW5jdGlvbi5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQga2V5cyBhbmQgdmFsdWVzIG9mIHRoZSBhY2N1bXVsYXRvciBvYmplY3QuXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaW5pdGlhbGl6ZXJdIFRoZSBmdW5jdGlvbiB0byBpbml0aWFsaXplIHRoZSBhY2N1bXVsYXRvciBvYmplY3QuXG5cdCAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhZ2dyZWdhdG9yIGZ1bmN0aW9uLlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBjcmVhdGVBZ2dyZWdhdG9yKHNldHRlciwgaW5pdGlhbGl6ZXIpIHtcblx0ICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IGluaXRpYWxpemVyID8gaW5pdGlhbGl6ZXIoKSA6IHt9O1xuXHQgICAgICAgIGl0ZXJhdGVlID0gZ2V0Q2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDMpO1xuXHRcblx0ICAgICAgICBpZiAoaXNBcnJheShjb2xsZWN0aW9uKSkge1xuXHQgICAgICAgICAgdmFyIGluZGV4ID0gLTEsXG5cdCAgICAgICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cdFxuXHQgICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0ICAgICAgICAgICAgdmFyIHZhbHVlID0gY29sbGVjdGlvbltpbmRleF07XG5cdCAgICAgICAgICAgIHNldHRlcihyZXN1bHQsIHZhbHVlLCBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pLCBjb2xsZWN0aW9uKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuXHQgICAgICAgICAgICBzZXR0ZXIocmVzdWx0LCB2YWx1ZSwgaXRlcmF0ZWUodmFsdWUsIGtleSwgY29sbGVjdGlvbiksIGNvbGxlY3Rpb24pO1xuXHQgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgIH07XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGEgYF8uYXNzaWduYCwgYF8uZGVmYXVsdHNgLCBvciBgXy5tZXJnZWAgZnVuY3Rpb24uXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuXHQgICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG5cdCAgICAgIHJldHVybiByZXN0UGFyYW0oZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG5cdCAgICAgICAgdmFyIGluZGV4ID0gLTEsXG5cdCAgICAgICAgICAgIGxlbmd0aCA9IG9iamVjdCA9PSBudWxsID8gMCA6IHNvdXJjZXMubGVuZ3RoLFxuXHQgICAgICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbbGVuZ3RoIC0gMl0gOiB1bmRlZmluZWQsXG5cdCAgICAgICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQsXG5cdCAgICAgICAgICAgIHRoaXNBcmcgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcblx0XG5cdCAgICAgICAgaWYgKHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgIGN1c3RvbWl6ZXIgPSBiaW5kQ2FsbGJhY2soY3VzdG9taXplciwgdGhpc0FyZywgNSk7XG5cdCAgICAgICAgICBsZW5ndGggLT0gMjtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgY3VzdG9taXplciA9IHR5cGVvZiB0aGlzQXJnID09ICdmdW5jdGlvbicgPyB0aGlzQXJnIDogdW5kZWZpbmVkO1xuXHQgICAgICAgICAgbGVuZ3RoIC09IChjdXN0b21pemVyID8gMSA6IDApO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG5cdCAgICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XG5cdCAgICAgICAgICBsZW5ndGggPSAxO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHQgICAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuXHQgICAgICAgICAgaWYgKHNvdXJjZSkge1xuXHQgICAgICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplcik7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBvYmplY3Q7XG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cblx0ICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuXHQgICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuXHQgICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcblx0ICAgICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGdldExlbmd0aChjb2xsZWN0aW9uKSA6IDA7XG5cdCAgICAgICAgaWYgKCFpc0xlbmd0aChsZW5ndGgpKSB7XG5cdCAgICAgICAgICByZXR1cm4gZWFjaEZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcblx0ICAgICAgICAgICAgaXRlcmFibGUgPSB0b09iamVjdChjb2xsZWN0aW9uKTtcblx0XG5cdCAgICAgICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcblx0ICAgICAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcblx0ICAgICAgfTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBgXy5mb3JJbmAgb3IgYF8uZm9ySW5SaWdodGAuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuXHQgICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcblx0ICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG5cdCAgICAgICAgdmFyIGl0ZXJhYmxlID0gdG9PYmplY3Qob2JqZWN0KSxcblx0ICAgICAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuXHQgICAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG5cdCAgICAgICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTE7XG5cdFxuXHQgICAgICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG5cdCAgICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXHQgICAgICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIG9iamVjdDtcblx0ICAgICAgfTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCBhbmQgaW52b2tlcyBpdCB3aXRoIHRoZSBgdGhpc2Bcblx0ICAgICAqIGJpbmRpbmcgb2YgYHRoaXNBcmdgLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBiaW5kLlxuXHQgICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cblx0ICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBjcmVhdGVCaW5kV3JhcHBlcihmdW5jLCB0aGlzQXJnKSB7XG5cdCAgICAgIHZhciBDdG9yID0gY3JlYXRlQ3RvcldyYXBwZXIoZnVuYyk7XG5cdFxuXHQgICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuXHQgICAgICAgIHZhciBmbiA9ICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpID8gQ3RvciA6IGZ1bmM7XG5cdCAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50cyk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHdyYXBwZXI7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGEgYFNldGAgY2FjaGUgb2JqZWN0IHRvIG9wdGltaXplIGxpbmVhciBzZWFyY2hlcyBvZiBsYXJnZSBhcnJheXMuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG5cdCAgICAgKiBAcmV0dXJucyB7bnVsbHxPYmplY3R9IFJldHVybnMgdGhlIG5ldyBjYWNoZSBvYmplY3QgaWYgYFNldGAgaXMgc3VwcG9ydGVkLCBlbHNlIGBudWxsYC5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gY3JlYXRlQ2FjaGUodmFsdWVzKSB7XG5cdCAgICAgIHJldHVybiAobmF0aXZlQ3JlYXRlICYmIFNldCkgPyBuZXcgU2V0Q2FjaGUodmFsdWVzKSA6IG51bGw7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBjb21wb3VuZCB3b3JkcyBvdXQgb2YgdGhlIHdvcmRzIGluIGFcblx0ICAgICAqIGdpdmVuIHN0cmluZy5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmUgZWFjaCB3b3JkLlxuXHQgICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG91bmRlciBmdW5jdGlvbi5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gY3JlYXRlQ29tcG91bmRlcihjYWxsYmFjaykge1xuXHQgICAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG5cdCAgICAgICAgdmFyIGluZGV4ID0gLTEsXG5cdCAgICAgICAgICAgIGFycmF5ID0gd29yZHMoZGVidXJyKHN0cmluZykpLFxuXHQgICAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG5cdCAgICAgICAgICAgIHJlc3VsdCA9ICcnO1xuXHRcblx0ICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHQgICAgICAgICAgcmVzdWx0ID0gY2FsbGJhY2socmVzdWx0LCBhcnJheVtpbmRleF0sIGluZGV4KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgfTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHByb2R1Y2VzIGFuIGluc3RhbmNlIG9mIGBDdG9yYCByZWdhcmRsZXNzIG9mXG5cdCAgICAgKiB3aGV0aGVyIGl0IHdhcyBpbnZva2VkIGFzIHBhcnQgb2YgYSBgbmV3YCBleHByZXNzaW9uIG9yIGJ5IGBjYWxsYCBvciBgYXBwbHlgLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBDdG9yIFRoZSBjb25zdHJ1Y3RvciB0byB3cmFwLlxuXHQgICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gY3JlYXRlQ3RvcldyYXBwZXIoQ3Rvcikge1xuXHQgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgLy8gVXNlIGEgYHN3aXRjaGAgc3RhdGVtZW50IHRvIHdvcmsgd2l0aCBjbGFzcyBjb25zdHJ1Y3RvcnMuXG5cdCAgICAgICAgLy8gU2VlIGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWVjbWFzY3JpcHQtZnVuY3Rpb24tb2JqZWN0cy1jYWxsLXRoaXNhcmd1bWVudC1hcmd1bWVudHNsaXN0XG5cdCAgICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cblx0ICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcblx0ICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG5cdCAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQ3Rvcjtcblx0ICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0pO1xuXHQgICAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSk7XG5cdCAgICAgICAgICBjYXNlIDM6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcblx0ICAgICAgICAgIGNhc2UgNDogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuXHQgICAgICAgICAgY2FzZSA1OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSk7XG5cdCAgICAgICAgICBjYXNlIDY6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdKTtcblx0ICAgICAgICAgIGNhc2UgNzogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0sIGFyZ3NbNV0sIGFyZ3NbNl0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBiYXNlQ3JlYXRlKEN0b3IucHJvdG90eXBlKSxcblx0ICAgICAgICAgICAgcmVzdWx0ID0gQ3Rvci5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG5cdFxuXHQgICAgICAgIC8vIE1pbWljIHRoZSBjb25zdHJ1Y3RvcidzIGByZXR1cm5gIGJlaGF2aW9yLlxuXHQgICAgICAgIC8vIFNlZSBodHRwczovL2VzNS5naXRodWIuaW8vI3gxMy4yLjIgZm9yIG1vcmUgZGV0YWlscy5cblx0ICAgICAgICByZXR1cm4gaXNPYmplY3QocmVzdWx0KSA/IHJlc3VsdCA6IHRoaXNCaW5kaW5nO1xuXHQgICAgICB9O1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ3JlYXRlcyBhIGBfLmN1cnJ5YCBvciBgXy5jdXJyeVJpZ2h0YCBmdW5jdGlvbi5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHtib29sZWFufSBmbGFnIFRoZSBjdXJyeSBiaXQgZmxhZy5cblx0ICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGN1cnJ5IGZ1bmN0aW9uLlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBjcmVhdGVDdXJyeShmbGFnKSB7XG5cdCAgICAgIGZ1bmN0aW9uIGN1cnJ5RnVuYyhmdW5jLCBhcml0eSwgZ3VhcmQpIHtcblx0ICAgICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoZnVuYywgYXJpdHksIGd1YXJkKSkge1xuXHQgICAgICAgICAgYXJpdHkgPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVXcmFwcGVyKGZ1bmMsIGZsYWcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcml0eSk7XG5cdCAgICAgICAgcmVzdWx0LnBsYWNlaG9sZGVyID0gY3VycnlGdW5jLnBsYWNlaG9sZGVyO1xuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGN1cnJ5RnVuYztcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIENyZWF0ZXMgYSBgXy5kZWZhdWx0c2Agb3IgYF8uZGVmYXVsdHNEZWVwYCBmdW5jdGlvbi5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuXHQgICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVmYXVsdHMgZnVuY3Rpb24uXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRzKGFzc2lnbmVyLCBjdXN0b21pemVyKSB7XG5cdCAgICAgIHJldHVybiByZXN0UGFyYW0oZnVuY3Rpb24oYXJncykge1xuXHQgICAgICAgIHZhciBvYmplY3QgPSBhcmdzWzBdO1xuXHQgICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuXHQgICAgICAgICAgcmV0dXJuIG9iamVjdDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgYXJncy5wdXNoKGN1c3RvbWl6ZXIpO1xuXHQgICAgICAgIHJldHVybiBhc3NpZ25lci5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuXHQgICAgICB9KTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIENyZWF0ZXMgYSBgXy5tYXhgIG9yIGBfLm1pbmAgZnVuY3Rpb24uXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGZ1bmN0aW9uIHVzZWQgdG8gY29tcGFyZSB2YWx1ZXMuXG5cdCAgICAgKiBAcGFyYW0geyp9IGV4VmFsdWUgVGhlIGluaXRpYWwgZXh0cmVtdW0gdmFsdWUuXG5cdCAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBleHRyZW11bSBmdW5jdGlvbi5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gY3JlYXRlRXh0cmVtdW0oY29tcGFyYXRvciwgZXhWYWx1ZSkge1xuXHQgICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcblx0ICAgICAgICBpZiAodGhpc0FyZyAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBpdGVyYXRlZSwgdGhpc0FyZykpIHtcblx0ICAgICAgICAgIGl0ZXJhdGVlID0gdW5kZWZpbmVkO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpdGVyYXRlZSA9IGdldENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCAzKTtcblx0ICAgICAgICBpZiAoaXRlcmF0ZWUubGVuZ3RoID09IDEpIHtcblx0ICAgICAgICAgIGNvbGxlY3Rpb24gPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gY29sbGVjdGlvbiA6IHRvSXRlcmFibGUoY29sbGVjdGlvbik7XG5cdCAgICAgICAgICB2YXIgcmVzdWx0ID0gYXJyYXlFeHRyZW11bShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgY29tcGFyYXRvciwgZXhWYWx1ZSk7XG5cdCAgICAgICAgICBpZiAoIShjb2xsZWN0aW9uLmxlbmd0aCAmJiByZXN1bHQgPT09IGV4VmFsdWUpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBiYXNlRXh0cmVtdW0oY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IsIGV4VmFsdWUpO1xuXHQgICAgICB9O1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ3JlYXRlcyBhIGBfLmZpbmRgIG9yIGBfLmZpbmRMYXN0YCBmdW5jdGlvbi5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG5cdCAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cblx0ICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZpbmQgZnVuY3Rpb24uXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGNyZWF0ZUZpbmQoZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuXHQgICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG5cdCAgICAgICAgcHJlZGljYXRlID0gZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKTtcblx0ICAgICAgICBpZiAoaXNBcnJheShjb2xsZWN0aW9uKSkge1xuXHQgICAgICAgICAgdmFyIGluZGV4ID0gYmFzZUZpbmRJbmRleChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21SaWdodCk7XG5cdCAgICAgICAgICByZXR1cm4gaW5kZXggPiAtMSA/IGNvbGxlY3Rpb25baW5kZXhdIDogdW5kZWZpbmVkO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gYmFzZUZpbmQoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBlYWNoRnVuYyk7XG5cdCAgICAgIH07XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGEgYF8uZmluZEluZGV4YCBvciBgXy5maW5kTGFzdEluZGV4YCBmdW5jdGlvbi5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG5cdCAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmaW5kIGZ1bmN0aW9uLlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBjcmVhdGVGaW5kSW5kZXgoZnJvbVJpZ2h0KSB7XG5cdCAgICAgIHJldHVybiBmdW5jdGlvbihhcnJheSwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG5cdCAgICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuXHQgICAgICAgICAgcmV0dXJuIC0xO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBwcmVkaWNhdGUgPSBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpO1xuXHQgICAgICAgIHJldHVybiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21SaWdodCk7XG5cdCAgICAgIH07XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGEgYF8uZmluZEtleWAgb3IgYF8uZmluZExhc3RLZXlgIGZ1bmN0aW9uLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvYmplY3RGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYW4gb2JqZWN0LlxuXHQgICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmluZCBmdW5jdGlvbi5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gY3JlYXRlRmluZEtleShvYmplY3RGdW5jKSB7XG5cdCAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuXHQgICAgICAgIHByZWRpY2F0ZSA9IGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyk7XG5cdCAgICAgICAgcmV0dXJuIGJhc2VGaW5kKG9iamVjdCwgcHJlZGljYXRlLCBvYmplY3RGdW5jLCB0cnVlKTtcblx0ICAgICAgfTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIENyZWF0ZXMgYSBgXy5mbG93YCBvciBgXy5mbG93UmlnaHRgIGZ1bmN0aW9uLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cblx0ICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZsb3cgZnVuY3Rpb24uXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGNyZWF0ZUZsb3coZnJvbVJpZ2h0KSB7XG5cdCAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgICAgICB2YXIgd3JhcHBlcixcblx0ICAgICAgICAgICAgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcblx0ICAgICAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcblx0ICAgICAgICAgICAgbGVmdEluZGV4ID0gMCxcblx0ICAgICAgICAgICAgZnVuY3MgPSBBcnJheShsZW5ndGgpO1xuXHRcblx0ICAgICAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuXHQgICAgICAgICAgdmFyIGZ1bmMgPSBmdW5jc1tsZWZ0SW5kZXgrK10gPSBhcmd1bWVudHNbaW5kZXhdO1xuXHQgICAgICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgaWYgKCF3cmFwcGVyICYmIExvZGFzaFdyYXBwZXIucHJvdG90eXBlLnRocnUgJiYgZ2V0RnVuY05hbWUoZnVuYykgPT0gJ3dyYXBwZXInKSB7XG5cdCAgICAgICAgICAgIHdyYXBwZXIgPSBuZXcgTG9kYXNoV3JhcHBlcihbXSwgdHJ1ZSk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGluZGV4ID0gd3JhcHBlciA/IC0xIDogbGVuZ3RoO1xuXHQgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdCAgICAgICAgICBmdW5jID0gZnVuY3NbaW5kZXhdO1xuXHRcblx0ICAgICAgICAgIHZhciBmdW5jTmFtZSA9IGdldEZ1bmNOYW1lKGZ1bmMpLFxuXHQgICAgICAgICAgICAgIGRhdGEgPSBmdW5jTmFtZSA9PSAnd3JhcHBlcicgPyBnZXREYXRhKGZ1bmMpIDogdW5kZWZpbmVkO1xuXHRcblx0ICAgICAgICAgIGlmIChkYXRhICYmIGlzTGF6aWFibGUoZGF0YVswXSkgJiYgZGF0YVsxXSA9PSAoQVJZX0ZMQUcgfCBDVVJSWV9GTEFHIHwgUEFSVElBTF9GTEFHIHwgUkVBUkdfRkxBRykgJiYgIWRhdGFbNF0ubGVuZ3RoICYmIGRhdGFbOV0gPT0gMSkge1xuXHQgICAgICAgICAgICB3cmFwcGVyID0gd3JhcHBlcltnZXRGdW5jTmFtZShkYXRhWzBdKV0uYXBwbHkod3JhcHBlciwgZGF0YVszXSk7XG5cdCAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB3cmFwcGVyID0gKGZ1bmMubGVuZ3RoID09IDEgJiYgaXNMYXppYWJsZShmdW5jKSkgPyB3cmFwcGVyW2Z1bmNOYW1lXSgpIDogd3JhcHBlci50aHJ1KGZ1bmMpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcblx0ICAgICAgICAgICAgICB2YWx1ZSA9IGFyZ3NbMF07XG5cdFxuXHQgICAgICAgICAgaWYgKHdyYXBwZXIgJiYgYXJncy5sZW5ndGggPT0gMSAmJiBpc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPj0gTEFSR0VfQVJSQVlfU0laRSkge1xuXHQgICAgICAgICAgICByZXR1cm4gd3JhcHBlci5wbGFudCh2YWx1ZSkudmFsdWUoKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIHZhciBpbmRleCA9IDAsXG5cdCAgICAgICAgICAgICAgcmVzdWx0ID0gbGVuZ3RoID8gZnVuY3NbaW5kZXhdLmFwcGx5KHRoaXMsIGFyZ3MpIDogdmFsdWU7XG5cdFxuXHQgICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0ICAgICAgICAgICAgcmVzdWx0ID0gZnVuY3NbaW5kZXhdLmNhbGwodGhpcywgcmVzdWx0KTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgfTtcblx0ICAgICAgfTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBmb3IgYF8uZm9yRWFjaGAgb3IgYF8uZm9yRWFjaFJpZ2h0YC5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYXJyYXlGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYW4gYXJyYXkuXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cblx0ICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGVhY2ggZnVuY3Rpb24uXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGNyZWF0ZUZvckVhY2goYXJyYXlGdW5jLCBlYWNoRnVuYykge1xuXHQgICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcblx0ICAgICAgICByZXR1cm4gKHR5cGVvZiBpdGVyYXRlZSA9PSAnZnVuY3Rpb24nICYmIHRoaXNBcmcgPT09IHVuZGVmaW5lZCAmJiBpc0FycmF5KGNvbGxlY3Rpb24pKVxuXHQgICAgICAgICAgPyBhcnJheUZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUpXG5cdCAgICAgICAgICA6IGVhY2hGdW5jKGNvbGxlY3Rpb24sIGJpbmRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMykpO1xuXHQgICAgICB9O1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGZvciBgXy5mb3JJbmAgb3IgYF8uZm9ySW5SaWdodGAuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9iamVjdEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhbiBvYmplY3QuXG5cdCAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBlYWNoIGZ1bmN0aW9uLlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBjcmVhdGVGb3JJbihvYmplY3RGdW5jKSB7XG5cdCAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiBpdGVyYXRlZSAhPSAnZnVuY3Rpb24nIHx8IHRoaXNBcmcgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgaXRlcmF0ZWUgPSBiaW5kQ2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gb2JqZWN0RnVuYyhvYmplY3QsIGl0ZXJhdGVlLCBrZXlzSW4pO1xuXHQgICAgICB9O1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGZvciBgXy5mb3JPd25gIG9yIGBfLmZvck93blJpZ2h0YC5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb2JqZWN0RnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGFuIG9iamVjdC5cblx0ICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGVhY2ggZnVuY3Rpb24uXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGNyZWF0ZUZvck93bihvYmplY3RGdW5jKSB7XG5cdCAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiBpdGVyYXRlZSAhPSAnZnVuY3Rpb24nIHx8IHRoaXNBcmcgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgaXRlcmF0ZWUgPSBiaW5kQ2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gb2JqZWN0RnVuYyhvYmplY3QsIGl0ZXJhdGVlKTtcblx0ICAgICAgfTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBmb3IgYF8ubWFwS2V5c2Agb3IgYF8ubWFwVmFsdWVzYC5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHtib29sZWFufSBbaXNNYXBLZXlzXSBTcGVjaWZ5IG1hcHBpbmcga2V5cyBpbnN0ZWFkIG9mIHZhbHVlcy5cblx0ICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1hcCBmdW5jdGlvbi5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0TWFwcGVyKGlzTWFwS2V5cykge1xuXHQgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwgdGhpc0FyZykge1xuXHQgICAgICAgIHZhciByZXN1bHQgPSB7fTtcblx0ICAgICAgICBpdGVyYXRlZSA9IGdldENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCAzKTtcblx0XG5cdCAgICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuXHQgICAgICAgICAgdmFyIG1hcHBlZCA9IGl0ZXJhdGVlKHZhbHVlLCBrZXksIG9iamVjdCk7XG5cdCAgICAgICAgICBrZXkgPSBpc01hcEtleXMgPyBtYXBwZWQgOiBrZXk7XG5cdCAgICAgICAgICB2YWx1ZSA9IGlzTWFwS2V5cyA/IHZhbHVlIDogbWFwcGVkO1xuXHQgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICB9O1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGZvciBgXy5wYWRMZWZ0YCBvciBgXy5wYWRSaWdodGAuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBwYWRkaW5nIGZyb20gdGhlIHJpZ2h0LlxuXHQgICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFkIGZ1bmN0aW9uLlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBjcmVhdGVQYWREaXIoZnJvbVJpZ2h0KSB7XG5cdCAgICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcsIGxlbmd0aCwgY2hhcnMpIHtcblx0ICAgICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcblx0ICAgICAgICByZXR1cm4gKGZyb21SaWdodCA/IHN0cmluZyA6ICcnKSArIGNyZWF0ZVBhZGRpbmcoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSArIChmcm9tUmlnaHQgPyAnJyA6IHN0cmluZyk7XG5cdCAgICAgIH07XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGEgYF8ucGFydGlhbGAgb3IgYF8ucGFydGlhbFJpZ2h0YCBmdW5jdGlvbi5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHtib29sZWFufSBmbGFnIFRoZSBwYXJ0aWFsIGJpdCBmbGFnLlxuXHQgICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFydGlhbCBmdW5jdGlvbi5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gY3JlYXRlUGFydGlhbChmbGFnKSB7XG5cdCAgICAgIHZhciBwYXJ0aWFsRnVuYyA9IHJlc3RQYXJhbShmdW5jdGlvbihmdW5jLCBwYXJ0aWFscykge1xuXHQgICAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIHBhcnRpYWxGdW5jLnBsYWNlaG9sZGVyKTtcblx0ICAgICAgICByZXR1cm4gY3JlYXRlV3JhcHBlcihmdW5jLCBmbGFnLCB1bmRlZmluZWQsIHBhcnRpYWxzLCBob2xkZXJzKTtcblx0ICAgICAgfSk7XG5cdCAgICAgIHJldHVybiBwYXJ0aWFsRnVuYztcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBmb3IgYF8ucmVkdWNlYCBvciBgXy5yZWR1Y2VSaWdodGAuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFycmF5RnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGFuIGFycmF5LlxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG5cdCAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBlYWNoIGZ1bmN0aW9uLlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBjcmVhdGVSZWR1Y2UoYXJyYXlGdW5jLCBlYWNoRnVuYykge1xuXHQgICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCB0aGlzQXJnKSB7XG5cdCAgICAgICAgdmFyIGluaXRGcm9tQXJyYXkgPSBhcmd1bWVudHMubGVuZ3RoIDwgMztcblx0ICAgICAgICByZXR1cm4gKHR5cGVvZiBpdGVyYXRlZSA9PSAnZnVuY3Rpb24nICYmIHRoaXNBcmcgPT09IHVuZGVmaW5lZCAmJiBpc0FycmF5KGNvbGxlY3Rpb24pKVxuXHQgICAgICAgICAgPyBhcnJheUZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0RnJvbUFycmF5KVxuXHQgICAgICAgICAgOiBiYXNlUmVkdWNlKGNvbGxlY3Rpb24sIGdldENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCA0KSwgYWNjdW11bGF0b3IsIGluaXRGcm9tQXJyYXksIGVhY2hGdW5jKTtcblx0ICAgICAgfTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCBhbmQgaW52b2tlcyBpdCB3aXRoIG9wdGlvbmFsIGB0aGlzYFxuXHQgICAgICogYmluZGluZyBvZiwgcGFydGlhbCBhcHBsaWNhdGlvbiwgYW5kIGN1cnJ5aW5nLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gZnVuYyBUaGUgZnVuY3Rpb24gb3IgbWV0aG9kIG5hbWUgdG8gcmVmZXJlbmNlLlxuXHQgICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgb2YgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcHBlcmAgZm9yIG1vcmUgZGV0YWlscy5cblx0ICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuXHQgICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNdIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNSaWdodF0gVGhlIGFyZ3VtZW50cyB0byBhcHBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi5cblx0ICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzUmlnaHRdIFRoZSBgcGFydGlhbHNSaWdodGAgcGxhY2Vob2xkZXIgaW5kZXhlcy5cblx0ICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcmdQb3NdIFRoZSBhcmd1bWVudCBwb3NpdGlvbnMgb2YgdGhlIG5ldyBmdW5jdGlvbi5cblx0ICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJ5XSBUaGUgYXJpdHkgY2FwIG9mIGBmdW5jYC5cblx0ICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG5cdCAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBjcmVhdGVIeWJyaWRXcmFwcGVyKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBwYXJ0aWFsc1JpZ2h0LCBob2xkZXJzUmlnaHQsIGFyZ1BvcywgYXJ5LCBhcml0eSkge1xuXHQgICAgICB2YXIgaXNBcnkgPSBiaXRtYXNrICYgQVJZX0ZMQUcsXG5cdCAgICAgICAgICBpc0JpbmQgPSBiaXRtYXNrICYgQklORF9GTEFHLFxuXHQgICAgICAgICAgaXNCaW5kS2V5ID0gYml0bWFzayAmIEJJTkRfS0VZX0ZMQUcsXG5cdCAgICAgICAgICBpc0N1cnJ5ID0gYml0bWFzayAmIENVUlJZX0ZMQUcsXG5cdCAgICAgICAgICBpc0N1cnJ5Qm91bmQgPSBiaXRtYXNrICYgQ1VSUllfQk9VTkRfRkxBRyxcblx0ICAgICAgICAgIGlzQ3VycnlSaWdodCA9IGJpdG1hc2sgJiBDVVJSWV9SSUdIVF9GTEFHLFxuXHQgICAgICAgICAgQ3RvciA9IGlzQmluZEtleSA/IHVuZGVmaW5lZCA6IGNyZWF0ZUN0b3JXcmFwcGVyKGZ1bmMpO1xuXHRcblx0ICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcblx0ICAgICAgICAvLyBBdm9pZCBgYXJndW1lbnRzYCBvYmplY3QgdXNlIGRpc3F1YWxpZnlpbmcgb3B0aW1pemF0aW9ucyBieVxuXHQgICAgICAgIC8vIGNvbnZlcnRpbmcgaXQgdG8gYW4gYXJyYXkgYmVmb3JlIHByb3ZpZGluZyBpdCB0byBvdGhlciBmdW5jdGlvbnMuXG5cdCAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdCAgICAgICAgICAgIGluZGV4ID0gbGVuZ3RoLFxuXHQgICAgICAgICAgICBhcmdzID0gQXJyYXkobGVuZ3RoKTtcblx0XG5cdCAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcblx0ICAgICAgICAgIGFyZ3NbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4XTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHBhcnRpYWxzKSB7XG5cdCAgICAgICAgICBhcmdzID0gY29tcG9zZUFyZ3MoYXJncywgcGFydGlhbHMsIGhvbGRlcnMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAocGFydGlhbHNSaWdodCkge1xuXHQgICAgICAgICAgYXJncyA9IGNvbXBvc2VBcmdzUmlnaHQoYXJncywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGlzQ3VycnkgfHwgaXNDdXJyeVJpZ2h0KSB7XG5cdCAgICAgICAgICB2YXIgcGxhY2Vob2xkZXIgPSB3cmFwcGVyLnBsYWNlaG9sZGVyLFxuXHQgICAgICAgICAgICAgIGFyZ3NIb2xkZXJzID0gcmVwbGFjZUhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuXHRcblx0ICAgICAgICAgIGxlbmd0aCAtPSBhcmdzSG9sZGVycy5sZW5ndGg7XG5cdCAgICAgICAgICBpZiAobGVuZ3RoIDwgYXJpdHkpIHtcblx0ICAgICAgICAgICAgdmFyIG5ld0FyZ1BvcyA9IGFyZ1BvcyA/IGFycmF5Q29weShhcmdQb3MpIDogdW5kZWZpbmVkLFxuXHQgICAgICAgICAgICAgICAgbmV3QXJpdHkgPSBuYXRpdmVNYXgoYXJpdHkgLSBsZW5ndGgsIDApLFxuXHQgICAgICAgICAgICAgICAgbmV3c0hvbGRlcnMgPSBpc0N1cnJ5ID8gYXJnc0hvbGRlcnMgOiB1bmRlZmluZWQsXG5cdCAgICAgICAgICAgICAgICBuZXdIb2xkZXJzUmlnaHQgPSBpc0N1cnJ5ID8gdW5kZWZpbmVkIDogYXJnc0hvbGRlcnMsXG5cdCAgICAgICAgICAgICAgICBuZXdQYXJ0aWFscyA9IGlzQ3VycnkgPyBhcmdzIDogdW5kZWZpbmVkLFxuXHQgICAgICAgICAgICAgICAgbmV3UGFydGlhbHNSaWdodCA9IGlzQ3VycnkgPyB1bmRlZmluZWQgOiBhcmdzO1xuXHRcblx0ICAgICAgICAgICAgYml0bWFzayB8PSAoaXNDdXJyeSA/IFBBUlRJQUxfRkxBRyA6IFBBUlRJQUxfUklHSFRfRkxBRyk7XG5cdCAgICAgICAgICAgIGJpdG1hc2sgJj0gfihpc0N1cnJ5ID8gUEFSVElBTF9SSUdIVF9GTEFHIDogUEFSVElBTF9GTEFHKTtcblx0XG5cdCAgICAgICAgICAgIGlmICghaXNDdXJyeUJvdW5kKSB7XG5cdCAgICAgICAgICAgICAgYml0bWFzayAmPSB+KEJJTkRfRkxBRyB8IEJJTkRfS0VZX0ZMQUcpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBuZXdEYXRhID0gW2Z1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIG5ld1BhcnRpYWxzLCBuZXdzSG9sZGVycywgbmV3UGFydGlhbHNSaWdodCwgbmV3SG9sZGVyc1JpZ2h0LCBuZXdBcmdQb3MsIGFyeSwgbmV3QXJpdHldLFxuXHQgICAgICAgICAgICAgICAgcmVzdWx0ID0gY3JlYXRlSHlicmlkV3JhcHBlci5hcHBseSh1bmRlZmluZWQsIG5ld0RhdGEpO1xuXHRcblx0ICAgICAgICAgICAgaWYgKGlzTGF6aWFibGUoZnVuYykpIHtcblx0ICAgICAgICAgICAgICBzZXREYXRhKHJlc3VsdCwgbmV3RGF0YSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmVzdWx0LnBsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXI7XG5cdCAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciB0aGlzQmluZGluZyA9IGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLFxuXHQgICAgICAgICAgICBmbiA9IGlzQmluZEtleSA/IHRoaXNCaW5kaW5nW2Z1bmNdIDogZnVuYztcblx0XG5cdCAgICAgICAgaWYgKGFyZ1Bvcykge1xuXHQgICAgICAgICAgYXJncyA9IHJlb3JkZXIoYXJncywgYXJnUG9zKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGlzQXJ5ICYmIGFyeSA8IGFyZ3MubGVuZ3RoKSB7XG5cdCAgICAgICAgICBhcmdzLmxlbmd0aCA9IGFyeTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikge1xuXHQgICAgICAgICAgZm4gPSBDdG9yIHx8IGNyZWF0ZUN0b3JXcmFwcGVyKGZ1bmMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiB3cmFwcGVyO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ3JlYXRlcyB0aGUgcGFkZGluZyByZXF1aXJlZCBmb3IgYHN0cmluZ2AgYmFzZWQgb24gdGhlIGdpdmVuIGBsZW5ndGhgLlxuXHQgICAgICogVGhlIGBjaGFyc2Agc3RyaW5nIGlzIHRydW5jYXRlZCBpZiB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgZXhjZWVkcyBgbGVuZ3RoYC5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNyZWF0ZSBwYWRkaW5nIGZvci5cblx0ICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cblx0ICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cblx0ICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZCBmb3IgYHN0cmluZ2AuXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGNyZWF0ZVBhZGRpbmcoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XG5cdCAgICAgIHZhciBzdHJMZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXHQgICAgICBsZW5ndGggPSArbGVuZ3RoO1xuXHRcblx0ICAgICAgaWYgKHN0ckxlbmd0aCA+PSBsZW5ndGggfHwgIW5hdGl2ZUlzRmluaXRlKGxlbmd0aCkpIHtcblx0ICAgICAgICByZXR1cm4gJyc7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIHBhZExlbmd0aCA9IGxlbmd0aCAtIHN0ckxlbmd0aDtcblx0ICAgICAgY2hhcnMgPSBjaGFycyA9PSBudWxsID8gJyAnIDogKGNoYXJzICsgJycpO1xuXHQgICAgICByZXR1cm4gcmVwZWF0KGNoYXJzLCBuYXRpdmVDZWlsKHBhZExlbmd0aCAvIGNoYXJzLmxlbmd0aCkpLnNsaWNlKDAsIHBhZExlbmd0aCk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgYW5kIGludm9rZXMgaXQgd2l0aCB0aGUgb3B0aW9uYWwgYHRoaXNgXG5cdCAgICAgKiBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGBwYXJ0aWFsc2AgcHJlcGVuZGVkIHRvIHRob3NlIHByb3ZpZGVkIHRvXG5cdCAgICAgKiB0aGUgd3JhcHBlci5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5IGFyZ3VtZW50cyB0by5cblx0ICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIG9mIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBwZXJgIGZvciBtb3JlIGRldGFpbHMuXG5cdCAgICAgKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cblx0ICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuXHQgICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGNyZWF0ZVBhcnRpYWxXcmFwcGVyKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzKSB7XG5cdCAgICAgIHZhciBpc0JpbmQgPSBiaXRtYXNrICYgQklORF9GTEFHLFxuXHQgICAgICAgICAgQ3RvciA9IGNyZWF0ZUN0b3JXcmFwcGVyKGZ1bmMpO1xuXHRcblx0ICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcblx0ICAgICAgICAvLyBBdm9pZCBgYXJndW1lbnRzYCBvYmplY3QgdXNlIGRpc3F1YWxpZnlpbmcgb3B0aW1pemF0aW9ucyBieVxuXHQgICAgICAgIC8vIGNvbnZlcnRpbmcgaXQgdG8gYW4gYXJyYXkgYmVmb3JlIHByb3ZpZGluZyBpdCBgZnVuY2AuXG5cdCAgICAgICAgdmFyIGFyZ3NJbmRleCA9IC0xLFxuXHQgICAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcblx0ICAgICAgICAgICAgbGVmdEluZGV4ID0gLTEsXG5cdCAgICAgICAgICAgIGxlZnRMZW5ndGggPSBwYXJ0aWFscy5sZW5ndGgsXG5cdCAgICAgICAgICAgIGFyZ3MgPSBBcnJheShsZWZ0TGVuZ3RoICsgYXJnc0xlbmd0aCk7XG5cdFxuXHQgICAgICAgIHdoaWxlICgrK2xlZnRJbmRleCA8IGxlZnRMZW5ndGgpIHtcblx0ICAgICAgICAgIGFyZ3NbbGVmdEluZGV4XSA9IHBhcnRpYWxzW2xlZnRJbmRleF07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHdoaWxlIChhcmdzTGVuZ3RoLS0pIHtcblx0ICAgICAgICAgIGFyZ3NbbGVmdEluZGV4KytdID0gYXJndW1lbnRzWysrYXJnc0luZGV4XTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGZuID0gKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikgPyBDdG9yIDogZnVuYztcblx0ICAgICAgICByZXR1cm4gZm4uYXBwbHkoaXNCaW5kID8gdGhpc0FyZyA6IHRoaXMsIGFyZ3MpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiB3cmFwcGVyO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ3JlYXRlcyBhIGBfLmNlaWxgLCBgXy5mbG9vcmAsIG9yIGBfLnJvdW5kYCBmdW5jdGlvbi5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIGBNYXRoYCBtZXRob2QgdG8gdXNlIHdoZW4gcm91bmRpbmcuXG5cdCAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByb3VuZCBmdW5jdGlvbi5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gY3JlYXRlUm91bmQobWV0aG9kTmFtZSkge1xuXHQgICAgICB2YXIgZnVuYyA9IE1hdGhbbWV0aG9kTmFtZV07XG5cdCAgICAgIHJldHVybiBmdW5jdGlvbihudW1iZXIsIHByZWNpc2lvbikge1xuXHQgICAgICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiA9PT0gdW5kZWZpbmVkID8gMCA6ICgrcHJlY2lzaW9uIHx8IDApO1xuXHQgICAgICAgIGlmIChwcmVjaXNpb24pIHtcblx0ICAgICAgICAgIHByZWNpc2lvbiA9IHBvdygxMCwgcHJlY2lzaW9uKTtcblx0ICAgICAgICAgIHJldHVybiBmdW5jKG51bWJlciAqIHByZWNpc2lvbikgLyBwcmVjaXNpb247XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBmdW5jKG51bWJlcik7XG5cdCAgICAgIH07XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGEgYF8uc29ydGVkSW5kZXhgIG9yIGBfLnNvcnRlZExhc3RJbmRleGAgZnVuY3Rpb24uXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldEhpZ2hlc3RdIFNwZWNpZnkgcmV0dXJuaW5nIHRoZSBoaWdoZXN0IHF1YWxpZmllZCBpbmRleC5cblx0ICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGluZGV4IGZ1bmN0aW9uLlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBjcmVhdGVTb3J0ZWRJbmRleChyZXRIaWdoZXN0KSB7XG5cdCAgICAgIHJldHVybiBmdW5jdGlvbihhcnJheSwgdmFsdWUsIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG5cdCAgICAgICAgdmFyIGNhbGxiYWNrID0gZ2V0Q2FsbGJhY2soaXRlcmF0ZWUpO1xuXHQgICAgICAgIHJldHVybiAoaXRlcmF0ZWUgPT0gbnVsbCAmJiBjYWxsYmFjayA9PT0gYmFzZUNhbGxiYWNrKVxuXHQgICAgICAgICAgPyBiaW5hcnlJbmRleChhcnJheSwgdmFsdWUsIHJldEhpZ2hlc3QpXG5cdCAgICAgICAgICA6IGJpbmFyeUluZGV4QnkoYXJyYXksIHZhbHVlLCBjYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgMSksIHJldEhpZ2hlc3QpO1xuXHQgICAgICB9O1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgZWl0aGVyIGN1cnJpZXMgb3IgaW52b2tlcyBgZnVuY2Agd2l0aCBvcHRpb25hbFxuXHQgICAgICogYHRoaXNgIGJpbmRpbmcgYW5kIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IGZ1bmMgVGhlIGZ1bmN0aW9uIG9yIG1ldGhvZCBuYW1lIHRvIHJlZmVyZW5jZS5cblx0ICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIG9mIGZsYWdzLlxuXHQgICAgICogIFRoZSBiaXRtYXNrIG1heSBiZSBjb21wb3NlZCBvZiB0aGUgZm9sbG93aW5nIGZsYWdzOlxuXHQgICAgICogICAgIDEgLSBgXy5iaW5kYFxuXHQgICAgICogICAgIDIgLSBgXy5iaW5kS2V5YFxuXHQgICAgICogICAgIDQgLSBgXy5jdXJyeWAgb3IgYF8uY3VycnlSaWdodGAgb2YgYSBib3VuZCBmdW5jdGlvblxuXHQgICAgICogICAgIDggLSBgXy5jdXJyeWBcblx0ICAgICAqICAgIDE2IC0gYF8uY3VycnlSaWdodGBcblx0ICAgICAqICAgIDMyIC0gYF8ucGFydGlhbGBcblx0ICAgICAqICAgIDY0IC0gYF8ucGFydGlhbFJpZ2h0YFxuXHQgICAgICogICAxMjggLSBgXy5yZWFyZ2Bcblx0ICAgICAqICAgMjU2IC0gYF8uYXJ5YFxuXHQgICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cblx0ICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cblx0ICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuXHQgICAgICogQHBhcmFtIHtBcnJheX0gW2FyZ1Bvc10gVGhlIGFyZ3VtZW50IHBvc2l0aW9ucyBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuXHQgICAgICogQHBhcmFtIHtudW1iZXJ9IFthcnldIFRoZSBhcml0eSBjYXAgb2YgYGZ1bmNgLlxuXHQgICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cblx0ICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGNyZWF0ZVdyYXBwZXIoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIGFyZ1BvcywgYXJ5LCBhcml0eSkge1xuXHQgICAgICB2YXIgaXNCaW5kS2V5ID0gYml0bWFzayAmIEJJTkRfS0VZX0ZMQUc7XG5cdCAgICAgIGlmICghaXNCaW5kS2V5ICYmIHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIGxlbmd0aCA9IHBhcnRpYWxzID8gcGFydGlhbHMubGVuZ3RoIDogMDtcblx0ICAgICAgaWYgKCFsZW5ndGgpIHtcblx0ICAgICAgICBiaXRtYXNrICY9IH4oUEFSVElBTF9GTEFHIHwgUEFSVElBTF9SSUdIVF9GTEFHKTtcblx0ICAgICAgICBwYXJ0aWFscyA9IGhvbGRlcnMgPSB1bmRlZmluZWQ7XG5cdCAgICAgIH1cblx0ICAgICAgbGVuZ3RoIC09IChob2xkZXJzID8gaG9sZGVycy5sZW5ndGggOiAwKTtcblx0ICAgICAgaWYgKGJpdG1hc2sgJiBQQVJUSUFMX1JJR0hUX0ZMQUcpIHtcblx0ICAgICAgICB2YXIgcGFydGlhbHNSaWdodCA9IHBhcnRpYWxzLFxuXHQgICAgICAgICAgICBob2xkZXJzUmlnaHQgPSBob2xkZXJzO1xuXHRcblx0ICAgICAgICBwYXJ0aWFscyA9IGhvbGRlcnMgPSB1bmRlZmluZWQ7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIGRhdGEgPSBpc0JpbmRLZXkgPyB1bmRlZmluZWQgOiBnZXREYXRhKGZ1bmMpLFxuXHQgICAgICAgICAgbmV3RGF0YSA9IFtmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0LCBhcmdQb3MsIGFyeSwgYXJpdHldO1xuXHRcblx0ICAgICAgaWYgKGRhdGEpIHtcblx0ICAgICAgICBtZXJnZURhdGEobmV3RGF0YSwgZGF0YSk7XG5cdCAgICAgICAgYml0bWFzayA9IG5ld0RhdGFbMV07XG5cdCAgICAgICAgYXJpdHkgPSBuZXdEYXRhWzldO1xuXHQgICAgICB9XG5cdCAgICAgIG5ld0RhdGFbOV0gPSBhcml0eSA9PSBudWxsXG5cdCAgICAgICAgPyAoaXNCaW5kS2V5ID8gMCA6IGZ1bmMubGVuZ3RoKVxuXHQgICAgICAgIDogKG5hdGl2ZU1heChhcml0eSAtIGxlbmd0aCwgMCkgfHwgMCk7XG5cdFxuXHQgICAgICBpZiAoYml0bWFzayA9PSBCSU5EX0ZMQUcpIHtcblx0ICAgICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlQmluZFdyYXBwZXIobmV3RGF0YVswXSwgbmV3RGF0YVsyXSk7XG5cdCAgICAgIH0gZWxzZSBpZiAoKGJpdG1hc2sgPT0gUEFSVElBTF9GTEFHIHx8IGJpdG1hc2sgPT0gKEJJTkRfRkxBRyB8IFBBUlRJQUxfRkxBRykpICYmICFuZXdEYXRhWzRdLmxlbmd0aCkge1xuXHQgICAgICAgIHJlc3VsdCA9IGNyZWF0ZVBhcnRpYWxXcmFwcGVyLmFwcGx5KHVuZGVmaW5lZCwgbmV3RGF0YSk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmVzdWx0ID0gY3JlYXRlSHlicmlkV3JhcHBlci5hcHBseSh1bmRlZmluZWQsIG5ld0RhdGEpO1xuXHQgICAgICB9XG5cdCAgICAgIHZhciBzZXR0ZXIgPSBkYXRhID8gYmFzZVNldERhdGEgOiBzZXREYXRhO1xuXHQgICAgICByZXR1cm4gc2V0dGVyKHJlc3VsdCwgbmV3RGF0YSk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG5cdCAgICAgKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuXHQgICAgICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpbmcgYXJyYXlzLlxuXHQgICAgICogQHBhcmFtIHtib29sZWFufSBbaXNMb29zZV0gU3BlY2lmeSBwZXJmb3JtaW5nIHBhcnRpYWwgY29tcGFyaXNvbnMuXG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgb2JqZWN0cy5cblx0ICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0JdIFRyYWNrcyB0cmF2ZXJzZWQgYG90aGVyYCBvYmplY3RzLlxuXHQgICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKSB7XG5cdCAgICAgIHZhciBpbmRleCA9IC0xLFxuXHQgICAgICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuXHQgICAgICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXHRcblx0ICAgICAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc0xvb3NlICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgIH1cblx0ICAgICAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuXHQgICAgICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuXHQgICAgICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcblx0ICAgICAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF0sXG5cdCAgICAgICAgICAgIHJlc3VsdCA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKGlzTG9vc2UgPyBvdGhWYWx1ZSA6IGFyclZhbHVlLCBpc0xvb3NlID8gYXJyVmFsdWUgOiBvdGhWYWx1ZSwgaW5kZXgpIDogdW5kZWZpbmVkO1xuXHRcblx0ICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgIGlmIChyZXN1bHQpIHtcblx0ICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG5cdCAgICAgICAgaWYgKGlzTG9vc2UpIHtcblx0ICAgICAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBjdXN0b21pemVyLCBpc0xvb3NlLCBzdGFja0EsIHN0YWNrQik7XG5cdCAgICAgICAgICAgICAgfSkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSBpZiAoIShhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgY3VzdG9taXplciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpKSkge1xuXHQgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2Zcblx0ICAgICAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG5cdCAgICAgKlxuXHQgICAgICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuXHQgICAgICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cblx0ICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cblx0ICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZykge1xuXHQgICAgICBzd2l0Y2ggKHRhZykge1xuXHQgICAgICAgIGNhc2UgYm9vbFRhZzpcblx0ICAgICAgICBjYXNlIGRhdGVUYWc6XG5cdCAgICAgICAgICAvLyBDb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWJlcnMsIGRhdGVzIHRvIG1pbGxpc2Vjb25kcyBhbmQgYm9vbGVhbnNcblx0ICAgICAgICAgIC8vIHRvIGAxYCBvciBgMGAgdHJlYXRpbmcgaW52YWxpZCBkYXRlcyBjb2VyY2VkIHRvIGBOYU5gIGFzIG5vdCBlcXVhbC5cblx0ICAgICAgICAgIHJldHVybiArb2JqZWN0ID09ICtvdGhlcjtcblx0XG5cdCAgICAgICAgY2FzZSBlcnJvclRhZzpcblx0ICAgICAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cdFxuXHQgICAgICAgIGNhc2UgbnVtYmVyVGFnOlxuXHQgICAgICAgICAgLy8gVHJlYXQgYE5hTmAgdnMuIGBOYU5gIGFzIGVxdWFsLlxuXHQgICAgICAgICAgcmV0dXJuIChvYmplY3QgIT0gK29iamVjdClcblx0ICAgICAgICAgICAgPyBvdGhlciAhPSArb3RoZXJcblx0ICAgICAgICAgICAgOiBvYmplY3QgPT0gK290aGVyO1xuXHRcblx0ICAgICAgICBjYXNlIHJlZ2V4cFRhZzpcblx0ICAgICAgICBjYXNlIHN0cmluZ1RhZzpcblx0ICAgICAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MgcHJpbWl0aXZlcyBhbmQgc3RyaW5nXG5cdCAgICAgICAgICAvLyBvYmplY3RzIGFzIGVxdWFsLiBTZWUgaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMTAuNi40IGZvciBtb3JlIGRldGFpbHMuXG5cdCAgICAgICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvclxuXHQgICAgICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpbmcgdmFsdWVzLlxuXHQgICAgICogQHBhcmFtIHtib29sZWFufSBbaXNMb29zZV0gU3BlY2lmeSBwZXJmb3JtaW5nIHBhcnRpYWwgY29tcGFyaXNvbnMuXG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgb2JqZWN0cy5cblx0ICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0JdIFRyYWNrcyB0cmF2ZXJzZWQgYG90aGVyYCBvYmplY3RzLlxuXHQgICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGlzTG9vc2UsIHN0YWNrQSwgc3RhY2tCKSB7XG5cdCAgICAgIHZhciBvYmpQcm9wcyA9IGtleXMob2JqZWN0KSxcblx0ICAgICAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcblx0ICAgICAgICAgIG90aFByb3BzID0ga2V5cyhvdGhlciksXG5cdCAgICAgICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cdFxuXHQgICAgICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNMb29zZSkge1xuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgfVxuXHQgICAgICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG5cdCAgICAgIHdoaWxlIChpbmRleC0tKSB7XG5cdCAgICAgICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcblx0ICAgICAgICBpZiAoIShpc0xvb3NlID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcblx0ICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIHNraXBDdG9yID0gaXNMb29zZTtcblx0ICAgICAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcblx0ICAgICAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG5cdCAgICAgICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG5cdCAgICAgICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XSxcblx0ICAgICAgICAgICAgcmVzdWx0ID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIoaXNMb29zZSA/IG90aFZhbHVlIDogb2JqVmFsdWUsIGlzTG9vc2U/IG9ialZhbHVlIDogb3RoVmFsdWUsIGtleSkgOiB1bmRlZmluZWQ7XG5cdFxuXHQgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuXHQgICAgICAgIGlmICghKHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgY3VzdG9taXplciwgaXNMb29zZSwgc3RhY2tBLCBzdGFja0IpIDogcmVzdWx0KSkge1xuXHQgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKCFza2lwQ3Rvcikge1xuXHQgICAgICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuXHQgICAgICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7XG5cdFxuXHQgICAgICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuXHQgICAgICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcblx0ICAgICAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG5cdCAgICAgICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuXHQgICAgICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG5cdCAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogR2V0cyB0aGUgYXBwcm9wcmlhdGUgXCJjYWxsYmFja1wiIGZ1bmN0aW9uLiBJZiB0aGUgYF8uY2FsbGJhY2tgIG1ldGhvZCBpc1xuXHQgICAgICogY3VzdG9taXplZCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGN1c3RvbSBtZXRob2QsIG90aGVyd2lzZSBpdCByZXR1cm5zXG5cdCAgICAgKiB0aGUgYGJhc2VDYWxsYmFja2AgZnVuY3Rpb24uIElmIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdGhlIGNob3NlbiBmdW5jdGlvblxuXHQgICAgICogaXMgaW52b2tlZCB3aXRoIHRoZW0gYW5kIGl0cyByZXN1bHQgaXMgcmV0dXJuZWQuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY2hvc2VuIGZ1bmN0aW9uIG9yIGl0cyByZXN1bHQuXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGdldENhbGxiYWNrKGZ1bmMsIHRoaXNBcmcsIGFyZ0NvdW50KSB7XG5cdCAgICAgIHZhciByZXN1bHQgPSBsb2Rhc2guY2FsbGJhY2sgfHwgY2FsbGJhY2s7XG5cdCAgICAgIHJlc3VsdCA9IHJlc3VsdCA9PT0gY2FsbGJhY2sgPyBiYXNlQ2FsbGJhY2sgOiByZXN1bHQ7XG5cdCAgICAgIHJldHVybiBhcmdDb3VudCA/IHJlc3VsdChmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCkgOiByZXN1bHQ7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBHZXRzIG1ldGFkYXRhIGZvciBgZnVuY2AuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHF1ZXJ5LlxuXHQgICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1ldGFkYXRhIGZvciBgZnVuY2AuXG5cdCAgICAgKi9cblx0ICAgIHZhciBnZXREYXRhID0gIW1ldGFNYXAgPyBub29wIDogZnVuY3Rpb24oZnVuYykge1xuXHQgICAgICByZXR1cm4gbWV0YU1hcC5nZXQoZnVuYyk7XG5cdCAgICB9O1xuXHRcblx0ICAgIC8qKlxuXHQgICAgICogR2V0cyB0aGUgbmFtZSBvZiBgZnVuY2AuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHF1ZXJ5LlxuXHQgICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZnVuY3Rpb24gbmFtZS5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gZ2V0RnVuY05hbWUoZnVuYykge1xuXHQgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5uYW1lLFxuXHQgICAgICAgICAgYXJyYXkgPSByZWFsTmFtZXNbcmVzdWx0XSxcblx0ICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblx0XG5cdCAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuXHQgICAgICAgIHZhciBkYXRhID0gYXJyYXlbbGVuZ3RoXSxcblx0ICAgICAgICAgICAgb3RoZXJGdW5jID0gZGF0YS5mdW5jO1xuXHQgICAgICAgIGlmIChvdGhlckZ1bmMgPT0gbnVsbCB8fCBvdGhlckZ1bmMgPT0gZnVuYykge1xuXHQgICAgICAgICAgcmV0dXJuIGRhdGEubmFtZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIEdldHMgdGhlIGFwcHJvcHJpYXRlIFwiaW5kZXhPZlwiIGZ1bmN0aW9uLiBJZiB0aGUgYF8uaW5kZXhPZmAgbWV0aG9kIGlzXG5cdCAgICAgKiBjdXN0b21pemVkIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgY3VzdG9tIG1ldGhvZCwgb3RoZXJ3aXNlIGl0IHJldHVybnNcblx0ICAgICAqIHRoZSBgYmFzZUluZGV4T2ZgIGZ1bmN0aW9uLiBJZiBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRoZSBjaG9zZW4gZnVuY3Rpb25cblx0ICAgICAqIGlzIGludm9rZWQgd2l0aCB0aGVtIGFuZCBpdHMgcmVzdWx0IGlzIHJldHVybmVkLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb258bnVtYmVyfSBSZXR1cm5zIHRoZSBjaG9zZW4gZnVuY3Rpb24gb3IgaXRzIHJlc3VsdC5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gZ2V0SW5kZXhPZihjb2xsZWN0aW9uLCB0YXJnZXQsIGZyb21JbmRleCkge1xuXHQgICAgICB2YXIgcmVzdWx0ID0gbG9kYXNoLmluZGV4T2YgfHwgaW5kZXhPZjtcblx0ICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSBpbmRleE9mID8gYmFzZUluZGV4T2YgOiByZXN1bHQ7XG5cdCAgICAgIHJldHVybiBjb2xsZWN0aW9uID8gcmVzdWx0KGNvbGxlY3Rpb24sIHRhcmdldCwgZnJvbUluZGV4KSA6IHJlc3VsdDtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIEdldHMgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgdmFsdWUgb2YgYG9iamVjdGAuXG5cdCAgICAgKlxuXHQgICAgICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBhdm9pZCBhIFtKSVQgYnVnXShodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQyNzkyKVxuXHQgICAgICogdGhhdCBhZmZlY3RzIFNhZmFyaSBvbiBhdCBsZWFzdCBpT1MgOC4xLTguMyBBUk02NC5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuXHQgICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIFwibGVuZ3RoXCIgdmFsdWUuXG5cdCAgICAgKi9cblx0ICAgIHZhciBnZXRMZW5ndGggPSBiYXNlUHJvcGVydHkoJ2xlbmd0aCcpO1xuXHRcblx0ICAgIC8qKlxuXHQgICAgICogR2V0cyB0aGUgcHJvcGVyeSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyBvZiBgb2JqZWN0YC5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuXHQgICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBnZXRNYXRjaERhdGEob2JqZWN0KSB7XG5cdCAgICAgIHZhciByZXN1bHQgPSBwYWlycyhvYmplY3QpLFxuXHQgICAgICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblx0XG5cdCAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuXHQgICAgICAgIHJlc3VsdFtsZW5ndGhdWzJdID0gaXNTdHJpY3RDb21wYXJhYmxlKHJlc3VsdFtsZW5ndGhdWzFdKTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG5cdCAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuXHQgICAgICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuXHQgICAgICByZXR1cm4gaXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBHZXRzIHRoZSB2aWV3LCBhcHBseWluZyBhbnkgYHRyYW5zZm9ybXNgIHRvIHRoZSBgc3RhcnRgIGFuZCBgZW5kYCBwb3NpdGlvbnMuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgb2YgdGhlIHZpZXcuXG5cdCAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHZpZXcuXG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fSB0cmFuc2Zvcm1zIFRoZSB0cmFuc2Zvcm1hdGlvbnMgdG8gYXBwbHkgdG8gdGhlIHZpZXcuXG5cdCAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBgc3RhcnRgIGFuZCBgZW5kYFxuXHQgICAgICogIHBvc2l0aW9ucyBvZiB0aGUgdmlldy5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gZ2V0VmlldyhzdGFydCwgZW5kLCB0cmFuc2Zvcm1zKSB7XG5cdCAgICAgIHZhciBpbmRleCA9IC0xLFxuXHQgICAgICAgICAgbGVuZ3RoID0gdHJhbnNmb3Jtcy5sZW5ndGg7XG5cdFxuXHQgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHQgICAgICAgIHZhciBkYXRhID0gdHJhbnNmb3Jtc1tpbmRleF0sXG5cdCAgICAgICAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cdFxuXHQgICAgICAgIHN3aXRjaCAoZGF0YS50eXBlKSB7XG5cdCAgICAgICAgICBjYXNlICdkcm9wJzogICAgICBzdGFydCArPSBzaXplOyBicmVhaztcblx0ICAgICAgICAgIGNhc2UgJ2Ryb3BSaWdodCc6IGVuZCAtPSBzaXplOyBicmVhaztcblx0ICAgICAgICAgIGNhc2UgJ3Rha2UnOiAgICAgIGVuZCA9IG5hdGl2ZU1pbihlbmQsIHN0YXJ0ICsgc2l6ZSk7IGJyZWFrO1xuXHQgICAgICAgICAgY2FzZSAndGFrZVJpZ2h0Jzogc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQsIGVuZCAtIHNpemUpOyBicmVhaztcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHsgJ3N0YXJ0Jzogc3RhcnQsICdlbmQnOiBlbmQgfTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIEluaXRpYWxpemVzIGFuIGFycmF5IGNsb25lLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY2xvbmUuXG5cdCAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBpbml0Q2xvbmVBcnJheShhcnJheSkge1xuXHQgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuXHQgICAgICAgICAgcmVzdWx0ID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cdFxuXHQgICAgICAvLyBBZGQgYXJyYXkgcHJvcGVydGllcyBhc3NpZ25lZCBieSBgUmVnRXhwI2V4ZWNgLlxuXHQgICAgICBpZiAobGVuZ3RoICYmIHR5cGVvZiBhcnJheVswXSA9PSAnc3RyaW5nJyAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCAnaW5kZXgnKSkge1xuXHQgICAgICAgIHJlc3VsdC5pbmRleCA9IGFycmF5LmluZGV4O1xuXHQgICAgICAgIHJlc3VsdC5pbnB1dCA9IGFycmF5LmlucHV0O1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cblx0ICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG5cdCAgICAgIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuXHQgICAgICBpZiAoISh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yKSkge1xuXHQgICAgICAgIEN0b3IgPSBPYmplY3Q7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lIGJhc2VkIG9uIGl0cyBgdG9TdHJpbmdUYWdgLlxuXHQgICAgICpcblx0ICAgICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY2xvbmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG5cdCAgICAgKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuXHQgICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cblx0ICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgaXNEZWVwKSB7XG5cdCAgICAgIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuXHQgICAgICBzd2l0Y2ggKHRhZykge1xuXHQgICAgICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG5cdCAgICAgICAgICByZXR1cm4gYnVmZmVyQ2xvbmUob2JqZWN0KTtcblx0XG5cdCAgICAgICAgY2FzZSBib29sVGFnOlxuXHQgICAgICAgIGNhc2UgZGF0ZVRhZzpcblx0ICAgICAgICAgIHJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtcblx0XG5cdCAgICAgICAgY2FzZSBmbG9hdDMyVGFnOiBjYXNlIGZsb2F0NjRUYWc6XG5cdCAgICAgICAgY2FzZSBpbnQ4VGFnOiBjYXNlIGludDE2VGFnOiBjYXNlIGludDMyVGFnOlxuXHQgICAgICAgIGNhc2UgdWludDhUYWc6IGNhc2UgdWludDhDbGFtcGVkVGFnOiBjYXNlIHVpbnQxNlRhZzogY2FzZSB1aW50MzJUYWc6XG5cdCAgICAgICAgICB2YXIgYnVmZmVyID0gb2JqZWN0LmJ1ZmZlcjtcblx0ICAgICAgICAgIHJldHVybiBuZXcgQ3Rvcihpc0RlZXAgPyBidWZmZXJDbG9uZShidWZmZXIpIDogYnVmZmVyLCBvYmplY3QuYnl0ZU9mZnNldCwgb2JqZWN0Lmxlbmd0aCk7XG5cdFxuXHQgICAgICAgIGNhc2UgbnVtYmVyVGFnOlxuXHQgICAgICAgIGNhc2Ugc3RyaW5nVGFnOlxuXHQgICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKG9iamVjdCk7XG5cdFxuXHQgICAgICAgIGNhc2UgcmVnZXhwVGFnOlxuXHQgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBDdG9yKG9iamVjdC5zb3VyY2UsIHJlRmxhZ3MuZXhlYyhvYmplY3QpKTtcblx0ICAgICAgICAgIHJlc3VsdC5sYXN0SW5kZXggPSBvYmplY3QubGFzdEluZGV4O1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBJbnZva2VzIHRoZSBtZXRob2QgYXQgYHBhdGhgIG9uIGBvYmplY3RgLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbWV0aG9kIHRvIGludm9rZS5cblx0ICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuXHQgICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgaW52b2tlZCBtZXRob2QuXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGludm9rZVBhdGgob2JqZWN0LCBwYXRoLCBhcmdzKSB7XG5cdCAgICAgIGlmIChvYmplY3QgIT0gbnVsbCAmJiAhaXNLZXkocGF0aCwgb2JqZWN0KSkge1xuXHQgICAgICAgIHBhdGggPSB0b1BhdGgocGF0aCk7XG5cdCAgICAgICAgb2JqZWN0ID0gcGF0aC5sZW5ndGggPT0gMSA/IG9iamVjdCA6IGJhc2VHZXQob2JqZWN0LCBiYXNlU2xpY2UocGF0aCwgMCwgLTEpKTtcblx0ICAgICAgICBwYXRoID0gbGFzdChwYXRoKTtcblx0ICAgICAgfVxuXHQgICAgICB2YXIgZnVuYyA9IG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogb2JqZWN0W3BhdGhdO1xuXHQgICAgICByZXR1cm4gZnVuYyA9PSBudWxsID8gdW5kZWZpbmVkIDogZnVuYy5hcHBseShvYmplY3QsIGFyZ3MpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG5cdCAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKGdldExlbmd0aCh2YWx1ZSkpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cblx0ICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cblx0ICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG5cdCAgICAgIHZhbHVlID0gKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCByZUlzVWludC50ZXN0KHZhbHVlKSkgPyArdmFsdWUgOiAtMTtcblx0ICAgICAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXHQgICAgICByZXR1cm4gdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aDtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIENoZWNrcyBpZiB0aGUgcHJvdmlkZWQgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cblx0ICAgICAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG5cdCAgICAgKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cblx0ICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsIGVsc2UgYGZhbHNlYC5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcblx0ICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICB9XG5cdCAgICAgIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuXHQgICAgICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xuXHQgICAgICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcblx0ICAgICAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KSkge1xuXHQgICAgICAgIHZhciBvdGhlciA9IG9iamVjdFtpbmRleF07XG5cdCAgICAgICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/ICh2YWx1ZSA9PT0gb3RoZXIpIDogKG90aGVyICE9PSBvdGhlcik7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lIGFuZCBub3QgYSBwcm9wZXJ0eSBwYXRoLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG5cdCAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuXHQgICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblx0ICAgICAgaWYgKCh0eXBlID09ICdzdHJpbmcnICYmIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkpIHx8IHR5cGUgPT0gJ251bWJlcicpIHtcblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIHJlc3VsdCA9ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSk7XG5cdCAgICAgIHJldHVybiByZXN1bHQgfHwgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIHRvT2JqZWN0KG9iamVjdCkpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgYSBsYXp5IGNvdW50ZXJwYXJ0LlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cblx0ICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaGFzIGEgbGF6eSBjb3VudGVycGFydCwgZWxzZSBgZmFsc2VgLlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBpc0xhemlhYmxlKGZ1bmMpIHtcblx0ICAgICAgdmFyIGZ1bmNOYW1lID0gZ2V0RnVuY05hbWUoZnVuYyk7XG5cdCAgICAgIGlmICghKGZ1bmNOYW1lIGluIExhenlXcmFwcGVyLnByb3RvdHlwZSkpIHtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIG90aGVyID0gbG9kYXNoW2Z1bmNOYW1lXTtcblx0ICAgICAgaWYgKGZ1bmMgPT09IG90aGVyKSB7XG5cdCAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIGRhdGEgPSBnZXREYXRhKG90aGVyKTtcblx0ICAgICAgcmV0dXJuICEhZGF0YSAmJiBmdW5jID09PSBkYXRhWzBdO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cblx0ICAgICAqXG5cdCAgICAgKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyBiYXNlZCBvbiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtdG9sZW5ndGgpLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cblx0ICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG5cdCAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG5cdCAgICAgKiAgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGVsc2UgYGZhbHNlYC5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG5cdCAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgIWlzT2JqZWN0KHZhbHVlKTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIE1lcmdlcyB0aGUgZnVuY3Rpb24gbWV0YWRhdGEgb2YgYHNvdXJjZWAgaW50byBgZGF0YWAuXG5cdCAgICAgKlxuXHQgICAgICogTWVyZ2luZyBtZXRhZGF0YSByZWR1Y2VzIHRoZSBudW1iZXIgb2Ygd3JhcHBlcnMgcmVxdWlyZWQgdG8gaW52b2tlIGEgZnVuY3Rpb24uXG5cdCAgICAgKiBUaGlzIGlzIHBvc3NpYmxlIGJlY2F1c2UgbWV0aG9kcyBsaWtlIGBfLmJpbmRgLCBgXy5jdXJyeWAsIGFuZCBgXy5wYXJ0aWFsYFxuXHQgICAgICogbWF5IGJlIGFwcGxpZWQgcmVnYXJkbGVzcyBvZiBleGVjdXRpb24gb3JkZXIuIE1ldGhvZHMgbGlrZSBgXy5hcnlgIGFuZCBgXy5yZWFyZ2Bcblx0ICAgICAqIGF1Z21lbnQgZnVuY3Rpb24gYXJndW1lbnRzLCBtYWtpbmcgdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgYXJlIGV4ZWN1dGVkIGltcG9ydGFudCxcblx0ICAgICAqIHByZXZlbnRpbmcgdGhlIG1lcmdpbmcgb2YgbWV0YWRhdGEuIEhvd2V2ZXIsIHdlIG1ha2UgYW4gZXhjZXB0aW9uIGZvciBhIHNhZmVcblx0ICAgICAqIGNvbW1vbiBjYXNlIHdoZXJlIGN1cnJpZWQgZnVuY3Rpb25zIGhhdmUgYF8uYXJ5YCBhbmQgb3IgYF8ucmVhcmdgIGFwcGxpZWQuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgVGhlIGRlc3RpbmF0aW9uIG1ldGFkYXRhLlxuXHQgICAgICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBzb3VyY2UgbWV0YWRhdGEuXG5cdCAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGRhdGFgLlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBtZXJnZURhdGEoZGF0YSwgc291cmNlKSB7XG5cdCAgICAgIHZhciBiaXRtYXNrID0gZGF0YVsxXSxcblx0ICAgICAgICAgIHNyY0JpdG1hc2sgPSBzb3VyY2VbMV0sXG5cdCAgICAgICAgICBuZXdCaXRtYXNrID0gYml0bWFzayB8IHNyY0JpdG1hc2ssXG5cdCAgICAgICAgICBpc0NvbW1vbiA9IG5ld0JpdG1hc2sgPCBBUllfRkxBRztcblx0XG5cdCAgICAgIHZhciBpc0NvbWJvID1cblx0ICAgICAgICAoc3JjQml0bWFzayA9PSBBUllfRkxBRyAmJiBiaXRtYXNrID09IENVUlJZX0ZMQUcpIHx8XG5cdCAgICAgICAgKHNyY0JpdG1hc2sgPT0gQVJZX0ZMQUcgJiYgYml0bWFzayA9PSBSRUFSR19GTEFHICYmIGRhdGFbN10ubGVuZ3RoIDw9IHNvdXJjZVs4XSkgfHxcblx0ICAgICAgICAoc3JjQml0bWFzayA9PSAoQVJZX0ZMQUcgfCBSRUFSR19GTEFHKSAmJiBiaXRtYXNrID09IENVUlJZX0ZMQUcpO1xuXHRcblx0ICAgICAgLy8gRXhpdCBlYXJseSBpZiBtZXRhZGF0YSBjYW4ndCBiZSBtZXJnZWQuXG5cdCAgICAgIGlmICghKGlzQ29tbW9uIHx8IGlzQ29tYm8pKSB7XG5cdCAgICAgICAgcmV0dXJuIGRhdGE7XG5cdCAgICAgIH1cblx0ICAgICAgLy8gVXNlIHNvdXJjZSBgdGhpc0FyZ2AgaWYgYXZhaWxhYmxlLlxuXHQgICAgICBpZiAoc3JjQml0bWFzayAmIEJJTkRfRkxBRykge1xuXHQgICAgICAgIGRhdGFbMl0gPSBzb3VyY2VbMl07XG5cdCAgICAgICAgLy8gU2V0IHdoZW4gY3VycnlpbmcgYSBib3VuZCBmdW5jdGlvbi5cblx0ICAgICAgICBuZXdCaXRtYXNrIHw9IChiaXRtYXNrICYgQklORF9GTEFHKSA/IDAgOiBDVVJSWV9CT1VORF9GTEFHO1xuXHQgICAgICB9XG5cdCAgICAgIC8vIENvbXBvc2UgcGFydGlhbCBhcmd1bWVudHMuXG5cdCAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVszXTtcblx0ICAgICAgaWYgKHZhbHVlKSB7XG5cdCAgICAgICAgdmFyIHBhcnRpYWxzID0gZGF0YVszXTtcblx0ICAgICAgICBkYXRhWzNdID0gcGFydGlhbHMgPyBjb21wb3NlQXJncyhwYXJ0aWFscywgdmFsdWUsIHNvdXJjZVs0XSkgOiBhcnJheUNvcHkodmFsdWUpO1xuXHQgICAgICAgIGRhdGFbNF0gPSBwYXJ0aWFscyA/IHJlcGxhY2VIb2xkZXJzKGRhdGFbM10sIFBMQUNFSE9MREVSKSA6IGFycmF5Q29weShzb3VyY2VbNF0pO1xuXHQgICAgICB9XG5cdCAgICAgIC8vIENvbXBvc2UgcGFydGlhbCByaWdodCBhcmd1bWVudHMuXG5cdCAgICAgIHZhbHVlID0gc291cmNlWzVdO1xuXHQgICAgICBpZiAodmFsdWUpIHtcblx0ICAgICAgICBwYXJ0aWFscyA9IGRhdGFbNV07XG5cdCAgICAgICAgZGF0YVs1XSA9IHBhcnRpYWxzID8gY29tcG9zZUFyZ3NSaWdodChwYXJ0aWFscywgdmFsdWUsIHNvdXJjZVs2XSkgOiBhcnJheUNvcHkodmFsdWUpO1xuXHQgICAgICAgIGRhdGFbNl0gPSBwYXJ0aWFscyA/IHJlcGxhY2VIb2xkZXJzKGRhdGFbNV0sIFBMQUNFSE9MREVSKSA6IGFycmF5Q29weShzb3VyY2VbNl0pO1xuXHQgICAgICB9XG5cdCAgICAgIC8vIFVzZSBzb3VyY2UgYGFyZ1Bvc2AgaWYgYXZhaWxhYmxlLlxuXHQgICAgICB2YWx1ZSA9IHNvdXJjZVs3XTtcblx0ICAgICAgaWYgKHZhbHVlKSB7XG5cdCAgICAgICAgZGF0YVs3XSA9IGFycmF5Q29weSh2YWx1ZSk7XG5cdCAgICAgIH1cblx0ICAgICAgLy8gVXNlIHNvdXJjZSBgYXJ5YCBpZiBpdCdzIHNtYWxsZXIuXG5cdCAgICAgIGlmIChzcmNCaXRtYXNrICYgQVJZX0ZMQUcpIHtcblx0ICAgICAgICBkYXRhWzhdID0gZGF0YVs4XSA9PSBudWxsID8gc291cmNlWzhdIDogbmF0aXZlTWluKGRhdGFbOF0sIHNvdXJjZVs4XSk7XG5cdCAgICAgIH1cblx0ICAgICAgLy8gVXNlIHNvdXJjZSBgYXJpdHlgIGlmIG9uZSBpcyBub3QgcHJvdmlkZWQuXG5cdCAgICAgIGlmIChkYXRhWzldID09IG51bGwpIHtcblx0ICAgICAgICBkYXRhWzldID0gc291cmNlWzldO1xuXHQgICAgICB9XG5cdCAgICAgIC8vIFVzZSBzb3VyY2UgYGZ1bmNgIGFuZCBtZXJnZSBiaXRtYXNrcy5cblx0ICAgICAgZGF0YVswXSA9IHNvdXJjZVswXTtcblx0ICAgICAgZGF0YVsxXSA9IG5ld0JpdG1hc2s7XG5cdFxuXHQgICAgICByZXR1cm4gZGF0YTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFVzZWQgYnkgYF8uZGVmYXVsdHNEZWVwYCB0byBjdXN0b21pemUgaXRzIGBfLm1lcmdlYCB1c2UuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7Kn0gb2JqZWN0VmFsdWUgVGhlIGRlc3RpbmF0aW9uIG9iamVjdCBwcm9wZXJ0eSB2YWx1ZS5cblx0ICAgICAqIEBwYXJhbSB7Kn0gc291cmNlVmFsdWUgVGhlIHNvdXJjZSBvYmplY3QgcHJvcGVydHkgdmFsdWUuXG5cdCAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgdG8gYXNzaWduIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIG1lcmdlRGVmYXVsdHMob2JqZWN0VmFsdWUsIHNvdXJjZVZhbHVlKSB7XG5cdCAgICAgIHJldHVybiBvYmplY3RWYWx1ZSA9PT0gdW5kZWZpbmVkID8gc291cmNlVmFsdWUgOiBtZXJnZShvYmplY3RWYWx1ZSwgc291cmNlVmFsdWUsIG1lcmdlRGVmYXVsdHMpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnBpY2tgIHdoaWNoIHBpY2tzIGBvYmplY3RgIHByb3BlcnRpZXMgc3BlY2lmaWVkXG5cdCAgICAgKiBieSBgcHJvcHNgLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuXHQgICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIHBpY2suXG5cdCAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBwaWNrQnlBcnJheShvYmplY3QsIHByb3BzKSB7XG5cdCAgICAgIG9iamVjdCA9IHRvT2JqZWN0KG9iamVjdCk7XG5cdFxuXHQgICAgICB2YXIgaW5kZXggPSAtMSxcblx0ICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcblx0ICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXHRcblx0ICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0ICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXHQgICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG5cdCAgICAgICAgICByZXN1bHRba2V5XSA9IG9iamVjdFtrZXldO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnBpY2tgIHdoaWNoIHBpY2tzIGBvYmplY3RgIHByb3BlcnRpZXMgYHByZWRpY2F0ZWBcblx0ICAgICAqIHJldHVybnMgdHJ1dGh5IGZvci5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuXHQgICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gcGlja0J5Q2FsbGJhY2sob2JqZWN0LCBwcmVkaWNhdGUpIHtcblx0ICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuXHQgICAgICBiYXNlRm9ySW4ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcblx0ICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBrZXksIG9iamVjdCkpIHtcblx0ICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG5cdCAgICAgICAgfVxuXHQgICAgICB9KTtcblx0ICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFJlb3JkZXIgYGFycmF5YCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBpbmRleGVzIHdoZXJlIHRoZSBlbGVtZW50IGF0XG5cdCAgICAgKiB0aGUgZmlyc3QgaW5kZXggaXMgYXNzaWduZWQgYXMgdGhlIGZpcnN0IGVsZW1lbnQsIHRoZSBlbGVtZW50IGF0XG5cdCAgICAgKiB0aGUgc2Vjb25kIGluZGV4IGlzIGFzc2lnbmVkIGFzIHRoZSBzZWNvbmQgZWxlbWVudCwgYW5kIHNvIG9uLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcmVvcmRlci5cblx0ICAgICAqIEBwYXJhbSB7QXJyYXl9IGluZGV4ZXMgVGhlIGFycmFuZ2VkIGFycmF5IGluZGV4ZXMuXG5cdCAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gcmVvcmRlcihhcnJheSwgaW5kZXhlcykge1xuXHQgICAgICB2YXIgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuXHQgICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWluKGluZGV4ZXMubGVuZ3RoLCBhcnJMZW5ndGgpLFxuXHQgICAgICAgICAgb2xkQXJyYXkgPSBhcnJheUNvcHkoYXJyYXkpO1xuXHRcblx0ICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG5cdCAgICAgICAgdmFyIGluZGV4ID0gaW5kZXhlc1tsZW5ndGhdO1xuXHQgICAgICAgIGFycmF5W2xlbmd0aF0gPSBpc0luZGV4KGluZGV4LCBhcnJMZW5ndGgpID8gb2xkQXJyYXlbaW5kZXhdIDogdW5kZWZpbmVkO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBhcnJheTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFNldHMgbWV0YWRhdGEgZm9yIGBmdW5jYC5cblx0ICAgICAqXG5cdCAgICAgKiAqKk5vdGU6KiogSWYgdGhpcyBmdW5jdGlvbiBiZWNvbWVzIGhvdCwgaS5lLiBpcyBpbnZva2VkIGEgbG90IGluIGEgc2hvcnRcblx0ICAgICAqIHBlcmlvZCBvZiB0aW1lLCBpdCB3aWxsIHRyaXAgaXRzIGJyZWFrZXIgYW5kIHRyYW5zaXRpb24gdG8gYW4gaWRlbnRpdHkgZnVuY3Rpb25cblx0ICAgICAqIHRvIGF2b2lkIGdhcmJhZ2UgY29sbGVjdGlvbiBwYXVzZXMgaW4gVjguIFNlZSBbVjggaXNzdWUgMjA3MF0oaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIwNzApXG5cdCAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NvY2lhdGUgbWV0YWRhdGEgd2l0aC5cblx0ICAgICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWV0YWRhdGEuXG5cdCAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuXHQgICAgICovXG5cdCAgICB2YXIgc2V0RGF0YSA9IChmdW5jdGlvbigpIHtcblx0ICAgICAgdmFyIGNvdW50ID0gMCxcblx0ICAgICAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXHRcblx0ICAgICAgcmV0dXJuIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcblx0ICAgICAgICB2YXIgc3RhbXAgPSBub3coKSxcblx0ICAgICAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcblx0XG5cdCAgICAgICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuXHQgICAgICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG5cdCAgICAgICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGtleTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgY291bnQgPSAwO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gYmFzZVNldERhdGEoa2V5LCB2YWx1ZSk7XG5cdCAgICAgIH07XG5cdCAgICB9KCkpO1xuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQSBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbiBvZiBgT2JqZWN0LmtleXNgIHdoaWNoIGNyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlXG5cdCAgICAgKiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuXHQgICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gc2hpbUtleXMob2JqZWN0KSB7XG5cdCAgICAgIHZhciBwcm9wcyA9IGtleXNJbihvYmplY3QpLFxuXHQgICAgICAgICAgcHJvcHNMZW5ndGggPSBwcm9wcy5sZW5ndGgsXG5cdCAgICAgICAgICBsZW5ndGggPSBwcm9wc0xlbmd0aCAmJiBvYmplY3QubGVuZ3RoO1xuXHRcblx0ICAgICAgdmFyIGFsbG93SW5kZXhlcyA9ICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiZcblx0ICAgICAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xuXHRcblx0ICAgICAgdmFyIGluZGV4ID0gLTEsXG5cdCAgICAgICAgICByZXN1bHQgPSBbXTtcblx0XG5cdCAgICAgIHdoaWxlICgrK2luZGV4IDwgcHJvcHNMZW5ndGgpIHtcblx0ICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXHQgICAgICAgIGlmICgoYWxsb3dJbmRleGVzICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpKSB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuXHQgICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gYXJyYXktbGlrZSBvYmplY3QgaWYgaXQncyBub3Qgb25lLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuXHQgICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyB0aGUgYXJyYXktbGlrZSBvYmplY3QuXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIHRvSXRlcmFibGUodmFsdWUpIHtcblx0ICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcblx0ICAgICAgICByZXR1cm4gW107XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKCFpc0FycmF5TGlrZSh2YWx1ZSkpIHtcblx0ICAgICAgICByZXR1cm4gdmFsdWVzKHZhbHVlKTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpID8gdmFsdWUgOiBPYmplY3QodmFsdWUpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBvYmplY3QgaWYgaXQncyBub3Qgb25lLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuXHQgICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgb2JqZWN0LlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiB0b09iamVjdCh2YWx1ZSkge1xuXHQgICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpID8gdmFsdWUgOiBPYmplY3QodmFsdWUpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ29udmVydHMgYHZhbHVlYCB0byBwcm9wZXJ0eSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cblx0ICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gdG9QYXRoKHZhbHVlKSB7XG5cdCAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuXHQgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgfVxuXHQgICAgICB2YXIgcmVzdWx0ID0gW107XG5cdCAgICAgIGJhc2VUb1N0cmluZyh2YWx1ZSkucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3RyaW5nKSB7XG5cdCAgICAgICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuXHQgICAgICB9KTtcblx0ICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgd3JhcHBlcmAuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSB3cmFwcGVyIFRoZSB3cmFwcGVyIHRvIGNsb25lLlxuXHQgICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHdyYXBwZXIuXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIHdyYXBwZXJDbG9uZSh3cmFwcGVyKSB7XG5cdCAgICAgIHJldHVybiB3cmFwcGVyIGluc3RhbmNlb2YgTGF6eVdyYXBwZXJcblx0ICAgICAgICA/IHdyYXBwZXIuY2xvbmUoKVxuXHQgICAgICAgIDogbmV3IExvZGFzaFdyYXBwZXIod3JhcHBlci5fX3dyYXBwZWRfXywgd3JhcHBlci5fX2NoYWluX18sIGFycmF5Q29weSh3cmFwcGVyLl9fYWN0aW9uc19fKSk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cyBzcGxpdCBpbnRvIGdyb3VwcyB0aGUgbGVuZ3RoIG9mIGBzaXplYC5cblx0ICAgICAqIElmIGBjb2xsZWN0aW9uYCBjYW4ndCBiZSBzcGxpdCBldmVubHksIHRoZSBmaW5hbCBjaHVuayB3aWxsIGJlIHRoZSByZW1haW5pbmdcblx0ICAgICAqIGVsZW1lbnRzLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcblx0ICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBwcm9jZXNzLlxuXHQgICAgICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPTFdIFRoZSBsZW5ndGggb2YgZWFjaCBjaHVuay5cblx0ICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuXHQgICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgY29udGFpbmluZyBjaHVua3MuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIF8uY2h1bmsoWydhJywgJ2InLCAnYycsICdkJ10sIDIpO1xuXHQgICAgICogLy8gPT4gW1snYScsICdiJ10sIFsnYycsICdkJ11dXG5cdCAgICAgKlxuXHQgICAgICogXy5jaHVuayhbJ2EnLCAnYicsICdjJywgJ2QnXSwgMyk7XG5cdCAgICAgKiAvLyA9PiBbWydhJywgJ2InLCAnYyddLCBbJ2QnXV1cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gY2h1bmsoYXJyYXksIHNpemUsIGd1YXJkKSB7XG5cdCAgICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBzaXplLCBndWFyZCkgOiBzaXplID09IG51bGwpIHtcblx0ICAgICAgICBzaXplID0gMTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBzaXplID0gbmF0aXZlTWF4KG5hdGl2ZUZsb29yKHNpemUpIHx8IDEsIDEpO1xuXHQgICAgICB9XG5cdCAgICAgIHZhciBpbmRleCA9IDAsXG5cdCAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG5cdCAgICAgICAgICByZXNJbmRleCA9IC0xLFxuXHQgICAgICAgICAgcmVzdWx0ID0gQXJyYXkobmF0aXZlQ2VpbChsZW5ndGggLyBzaXplKSk7XG5cdFxuXHQgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcblx0ICAgICAgICByZXN1bHRbKytyZXNJbmRleF0gPSBiYXNlU2xpY2UoYXJyYXksIGluZGV4LCAoaW5kZXggKz0gc2l6ZSkpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGFuIGFycmF5IHdpdGggYWxsIGZhbHNleSB2YWx1ZXMgcmVtb3ZlZC4gVGhlIHZhbHVlcyBgZmFsc2VgLCBgbnVsbGAsXG5cdCAgICAgKiBgMGAsIGBcIlwiYCwgYHVuZGVmaW5lZGAsIGFuZCBgTmFOYCBhcmUgZmFsc2V5LlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcblx0ICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYWN0LlxuXHQgICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBfLmNvbXBhY3QoWzAsIDEsIGZhbHNlLCAyLCAnJywgM10pO1xuXHQgICAgICogLy8gPT4gWzEsIDIsIDNdXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGNvbXBhY3QoYXJyYXkpIHtcblx0ICAgICAgdmFyIGluZGV4ID0gLTEsXG5cdCAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG5cdCAgICAgICAgICByZXNJbmRleCA9IC0xLFxuXHQgICAgICAgICAgcmVzdWx0ID0gW107XG5cdFxuXHQgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHQgICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcblx0ICAgICAgICBpZiAodmFsdWUpIHtcblx0ICAgICAgICAgIHJlc3VsdFsrK3Jlc0luZGV4XSA9IHZhbHVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgYGFycmF5YCB2YWx1ZXMgbm90IGluY2x1ZGVkIGluIHRoZSBvdGhlclxuXHQgICAgICogcHJvdmlkZWQgYXJyYXlzIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG5cdCAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBBcnJheVxuXHQgICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG5cdCAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbdmFsdWVzXSBUaGUgYXJyYXlzIG9mIHZhbHVlcyB0byBleGNsdWRlLlxuXHQgICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBfLmRpZmZlcmVuY2UoWzEsIDIsIDNdLCBbNCwgMl0pO1xuXHQgICAgICogLy8gPT4gWzEsIDNdXG5cdCAgICAgKi9cblx0ICAgIHZhciBkaWZmZXJlbmNlID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcblx0ICAgICAgcmV0dXJuIChpc09iamVjdExpa2UoYXJyYXkpICYmIGlzQXJyYXlMaWtlKGFycmF5KSlcblx0ICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlRmxhdHRlbih2YWx1ZXMsIGZhbHNlLCB0cnVlKSlcblx0ICAgICAgICA6IFtdO1xuXHQgICAgfSk7XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGJlZ2lubmluZy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IEFycmF5XG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG5cdCAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBkcm9wLlxuXHQgICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG5cdCAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIF8uZHJvcChbMSwgMiwgM10pO1xuXHQgICAgICogLy8gPT4gWzIsIDNdXG5cdCAgICAgKlxuXHQgICAgICogXy5kcm9wKFsxLCAyLCAzXSwgMik7XG5cdCAgICAgKiAvLyA9PiBbM11cblx0ICAgICAqXG5cdCAgICAgKiBfLmRyb3AoWzEsIDIsIDNdLCA1KTtcblx0ICAgICAqIC8vID0+IFtdXG5cdCAgICAgKlxuXHQgICAgICogXy5kcm9wKFsxLCAyLCAzXSwgMCk7XG5cdCAgICAgKiAvLyA9PiBbMSwgMiwgM11cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gZHJvcChhcnJheSwgbiwgZ3VhcmQpIHtcblx0ICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblx0ICAgICAgaWYgKCFsZW5ndGgpIHtcblx0ICAgICAgICByZXR1cm4gW107XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoYXJyYXksIG4sIGd1YXJkKSA6IG4gPT0gbnVsbCkge1xuXHQgICAgICAgIG4gPSAxO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIG4gPCAwID8gMCA6IG4pO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBlbmQuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBBcnJheVxuXHQgICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuXHQgICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gZHJvcC5cblx0ICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuXHQgICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10pO1xuXHQgICAgICogLy8gPT4gWzEsIDJdXG5cdCAgICAgKlxuXHQgICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCAyKTtcblx0ICAgICAqIC8vID0+IFsxXVxuXHQgICAgICpcblx0ICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSwgNSk7XG5cdCAgICAgKiAvLyA9PiBbXVxuXHQgICAgICpcblx0ICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSwgMCk7XG5cdCAgICAgKiAvLyA9PiBbMSwgMiwgM11cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gZHJvcFJpZ2h0KGFycmF5LCBuLCBndWFyZCkge1xuXHQgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXHQgICAgICBpZiAoIWxlbmd0aCkge1xuXHQgICAgICAgIHJldHVybiBbXTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgbiwgZ3VhcmQpIDogbiA9PSBudWxsKSB7XG5cdCAgICAgICAgbiA9IDE7XG5cdCAgICAgIH1cblx0ICAgICAgbiA9IGxlbmd0aCAtICgrbiB8fCAwKTtcblx0ICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgMCwgbiA8IDAgPyAwIDogbik7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCBleGNsdWRpbmcgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBlbmQuXG5cdCAgICAgKiBFbGVtZW50cyBhcmUgZHJvcHBlZCB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpc1xuXHQgICAgICogYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG5cdCAgICAgKlxuXHQgICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcblx0ICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuXHQgICAgICpcblx0ICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcblx0ICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuXHQgICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cblx0ICAgICAqXG5cdCAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG5cdCAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBtYXRjaCB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cblx0ICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcblx0ICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuXHQgICAgICogIHBlciBpdGVyYXRpb24uXG5cdCAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG5cdCAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIF8uZHJvcFJpZ2h0V2hpbGUoWzEsIDIsIDNdLCBmdW5jdGlvbihuKSB7XG5cdCAgICAgKiAgIHJldHVybiBuID4gMTtcblx0ICAgICAqIH0pO1xuXHQgICAgICogLy8gPT4gWzFdXG5cdCAgICAgKlxuXHQgICAgICogdmFyIHVzZXJzID0gW1xuXHQgICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogdHJ1ZSB9LFxuXHQgICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcblx0ICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH1cblx0ICAgICAqIF07XG5cdCAgICAgKlxuXHQgICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNgIGNhbGxiYWNrIHNob3J0aGFuZFxuXHQgICAgICogXy5wbHVjayhfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfSksICd1c2VyJyk7XG5cdCAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cblx0ICAgICAqXG5cdCAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcblx0ICAgICAqIF8ucGx1Y2soXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgJ2FjdGl2ZScsIGZhbHNlKSwgJ3VzZXInKTtcblx0ICAgICAqIC8vID0+IFsnYmFybmV5J11cblx0ICAgICAqXG5cdCAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuXHQgICAgICogXy5wbHVjayhfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCAnYWN0aXZlJyksICd1c2VyJyk7XG5cdCAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJywgJ3BlYmJsZXMnXVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBkcm9wUmlnaHRXaGlsZShhcnJheSwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG5cdCAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuXHQgICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpLCB0cnVlLCB0cnVlKVxuXHQgICAgICAgIDogW107XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCBleGNsdWRpbmcgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBiZWdpbm5pbmcuXG5cdCAgICAgKiBFbGVtZW50cyBhcmUgZHJvcHBlZCB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpc1xuXHQgICAgICogYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG5cdCAgICAgKlxuXHQgICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcblx0ICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuXHQgICAgICpcblx0ICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcblx0ICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuXHQgICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cblx0ICAgICAqXG5cdCAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG5cdCAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuXHQgICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBBcnJheVxuXHQgICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG5cdCAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cblx0ICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cblx0ICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogXy5kcm9wV2hpbGUoWzEsIDIsIDNdLCBmdW5jdGlvbihuKSB7XG5cdCAgICAgKiAgIHJldHVybiBuIDwgMztcblx0ICAgICAqIH0pO1xuXHQgICAgICogLy8gPT4gWzNdXG5cdCAgICAgKlxuXHQgICAgICogdmFyIHVzZXJzID0gW1xuXHQgICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcblx0ICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG5cdCAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cblx0ICAgICAqIF07XG5cdCAgICAgKlxuXHQgICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNgIGNhbGxiYWNrIHNob3J0aGFuZFxuXHQgICAgICogXy5wbHVjayhfLmRyb3BXaGlsZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSksICd1c2VyJyk7XG5cdCAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAncGViYmxlcyddXG5cdCAgICAgKlxuXHQgICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG5cdCAgICAgKiBfLnBsdWNrKF8uZHJvcFdoaWxlKHVzZXJzLCAnYWN0aXZlJywgZmFsc2UpLCAndXNlcicpO1xuXHQgICAgICogLy8gPT4gWydwZWJibGVzJ11cblx0ICAgICAqXG5cdCAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuXHQgICAgICogXy5wbHVjayhfLmRyb3BXaGlsZSh1c2VycywgJ2FjdGl2ZScpLCAndXNlcicpO1xuXHQgICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCcsICdwZWJibGVzJ11cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gZHJvcFdoaWxlKGFycmF5LCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcblx0ICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG5cdCAgICAgICAgPyBiYXNlV2hpbGUoYXJyYXksIGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyksIHRydWUpXG5cdCAgICAgICAgOiBbXTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIEZpbGxzIGVsZW1lbnRzIG9mIGBhcnJheWAgd2l0aCBgdmFsdWVgIGZyb20gYHN0YXJ0YCB1cCB0bywgYnV0IG5vdFxuXHQgICAgICogaW5jbHVkaW5nLCBgZW5kYC5cblx0ICAgICAqXG5cdCAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcblx0ICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmaWxsLlxuXHQgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZmlsbCBgYXJyYXlgIHdpdGguXG5cdCAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cblx0ICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cblx0ICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG5cdCAgICAgKlxuXHQgICAgICogXy5maWxsKGFycmF5LCAnYScpO1xuXHQgICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuXHQgICAgICogLy8gPT4gWydhJywgJ2EnLCAnYSddXG5cdCAgICAgKlxuXHQgICAgICogXy5maWxsKEFycmF5KDMpLCAyKTtcblx0ICAgICAqIC8vID0+IFsyLCAyLCAyXVxuXHQgICAgICpcblx0ICAgICAqIF8uZmlsbChbNCwgNiwgOF0sICcqJywgMSwgMik7XG5cdCAgICAgKiAvLyA9PiBbNCwgJyonLCA4XVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBmaWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQsIGVuZCkge1xuXHQgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXHQgICAgICBpZiAoIWxlbmd0aCkge1xuXHQgICAgICAgIHJldHVybiBbXTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoc3RhcnQgJiYgdHlwZW9mIHN0YXJ0ICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQpKSB7XG5cdCAgICAgICAgc3RhcnQgPSAwO1xuXHQgICAgICAgIGVuZCA9IGxlbmd0aDtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gYmFzZUZpbGwoYXJyYXksIHZhbHVlLCBzdGFydCwgZW5kKTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0XG5cdCAgICAgKiBlbGVtZW50IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cblx0ICAgICAqXG5cdCAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuXHQgICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG5cdCAgICAgKlxuXHQgICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuXHQgICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG5cdCAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuXHQgICAgICpcblx0ICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcblx0ICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG5cdCAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IEFycmF5XG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG5cdCAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cblx0ICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cblx0ICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIHZhciB1c2VycyA9IFtcblx0ICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG5cdCAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuXHQgICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG5cdCAgICAgKiBdO1xuXHQgICAgICpcblx0ICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCBmdW5jdGlvbihjaHIpIHtcblx0ICAgICAqICAgcmV0dXJuIGNoci51c2VyID09ICdiYXJuZXknO1xuXHQgICAgICogfSk7XG5cdCAgICAgKiAvLyA9PiAwXG5cdCAgICAgKlxuXHQgICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNgIGNhbGxiYWNrIHNob3J0aGFuZFxuXHQgICAgICogXy5maW5kSW5kZXgodXNlcnMsIHsgJ3VzZXInOiAnZnJlZCcsICdhY3RpdmUnOiBmYWxzZSB9KTtcblx0ICAgICAqIC8vID0+IDFcblx0ICAgICAqXG5cdCAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcblx0ICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCAnYWN0aXZlJywgZmFsc2UpO1xuXHQgICAgICogLy8gPT4gMFxuXHQgICAgICpcblx0ICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG5cdCAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgJ2FjdGl2ZScpO1xuXHQgICAgICogLy8gPT4gMlxuXHQgICAgICovXG5cdCAgICB2YXIgZmluZEluZGV4ID0gY3JlYXRlRmluZEluZGV4KCk7XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRJbmRleGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuXHQgICAgICogb2YgYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cblx0ICAgICAqXG5cdCAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuXHQgICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG5cdCAgICAgKlxuXHQgICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuXHQgICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG5cdCAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuXHQgICAgICpcblx0ICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcblx0ICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG5cdCAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IEFycmF5XG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG5cdCAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cblx0ICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cblx0ICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIHZhciB1c2VycyA9IFtcblx0ICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IHRydWUgfSxcblx0ICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG5cdCAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9XG5cdCAgICAgKiBdO1xuXHQgICAgICpcblx0ICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgZnVuY3Rpb24oY2hyKSB7XG5cdCAgICAgKiAgIHJldHVybiBjaHIudXNlciA9PSAncGViYmxlcyc7XG5cdCAgICAgKiB9KTtcblx0ICAgICAqIC8vID0+IDJcblx0ICAgICAqXG5cdCAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG5cdCAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IHRydWUgfSk7XG5cdCAgICAgKiAvLyA9PiAwXG5cdCAgICAgKlxuXHQgICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG5cdCAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsICdhY3RpdmUnLCBmYWxzZSk7XG5cdCAgICAgKiAvLyA9PiAyXG5cdCAgICAgKlxuXHQgICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcblx0ICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgJ2FjdGl2ZScpO1xuXHQgICAgICogLy8gPT4gMFxuXHQgICAgICovXG5cdCAgICB2YXIgZmluZExhc3RJbmRleCA9IGNyZWF0ZUZpbmRJbmRleCh0cnVlKTtcblx0XG5cdCAgICAvKipcblx0ICAgICAqIEdldHMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGFsaWFzIGhlYWRcblx0ICAgICAqIEBjYXRlZ29yeSBBcnJheVxuXHQgICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuXHQgICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogXy5maXJzdChbMSwgMiwgM10pO1xuXHQgICAgICogLy8gPT4gMVxuXHQgICAgICpcblx0ICAgICAqIF8uZmlyc3QoW10pO1xuXHQgICAgICogLy8gPT4gdW5kZWZpbmVkXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGZpcnN0KGFycmF5KSB7XG5cdCAgICAgIHJldHVybiBhcnJheSA/IGFycmF5WzBdIDogdW5kZWZpbmVkO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogRmxhdHRlbnMgYSBuZXN0ZWQgYXJyYXkuIElmIGBpc0RlZXBgIGlzIGB0cnVlYCB0aGUgYXJyYXkgaXMgcmVjdXJzaXZlbHlcblx0ICAgICAqIGZsYXR0ZW5lZCwgb3RoZXJ3aXNlIGl0IGlzIG9ubHkgZmxhdHRlbmVkIGEgc2luZ2xlIGxldmVsLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcblx0ICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuXHQgICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBmbGF0dGVuLlxuXHQgICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG5cdCAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIF8uZmxhdHRlbihbMSwgWzIsIDMsIFs0XV1dKTtcblx0ICAgICAqIC8vID0+IFsxLCAyLCAzLCBbNF1dXG5cdCAgICAgKlxuXHQgICAgICogLy8gdXNpbmcgYGlzRGVlcGBcblx0ICAgICAqIF8uZmxhdHRlbihbMSwgWzIsIDMsIFs0XV1dLCB0cnVlKTtcblx0ICAgICAqIC8vID0+IFsxLCAyLCAzLCA0XVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBmbGF0dGVuKGFycmF5LCBpc0RlZXAsIGd1YXJkKSB7XG5cdCAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cdCAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgaXNEZWVwLCBndWFyZCkpIHtcblx0ICAgICAgICBpc0RlZXAgPSBmYWxzZTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZUZsYXR0ZW4oYXJyYXksIGlzRGVlcCkgOiBbXTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIGEgbmVzdGVkIGFycmF5LlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcblx0ICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byByZWN1cnNpdmVseSBmbGF0dGVuLlxuXHQgICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBfLmZsYXR0ZW5EZWVwKFsxLCBbMiwgMywgWzRdXV0pO1xuXHQgICAgICogLy8gPT4gWzEsIDIsIDMsIDRdXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGZsYXR0ZW5EZWVwKGFycmF5KSB7XG5cdCAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cdCAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlRmxhdHRlbihhcnJheSwgdHJ1ZSkgOiBbXTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGB2YWx1ZWAgaXMgZm91bmQgaW4gYGFycmF5YFxuXHQgICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtc2FtZXZhbHVlemVybylcblx0ICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0IGlzIHVzZWQgYXMgdGhlIG9mZnNldFxuXHQgICAgICogZnJvbSB0aGUgZW5kIG9mIGBhcnJheWAuIElmIGBhcnJheWAgaXMgc29ydGVkIHByb3ZpZGluZyBgdHJ1ZWAgZm9yIGBmcm9tSW5kZXhgXG5cdCAgICAgKiBwZXJmb3JtcyBhIGZhc3RlciBiaW5hcnkgc2VhcmNoLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcblx0ICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG5cdCAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuXHQgICAgICogQHBhcmFtIHtib29sZWFufG51bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20gb3IgYHRydWVgXG5cdCAgICAgKiAgdG8gcGVyZm9ybSBhIGJpbmFyeSBzZWFyY2ggb24gYSBzb3J0ZWQgYXJyYXkuXG5cdCAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBfLmluZGV4T2YoWzEsIDIsIDEsIDJdLCAyKTtcblx0ICAgICAqIC8vID0+IDFcblx0ICAgICAqXG5cdCAgICAgKiAvLyB1c2luZyBgZnJvbUluZGV4YFxuXHQgICAgICogXy5pbmRleE9mKFsxLCAyLCAxLCAyXSwgMiwgMik7XG5cdCAgICAgKiAvLyA9PiAzXG5cdCAgICAgKlxuXHQgICAgICogLy8gcGVyZm9ybWluZyBhIGJpbmFyeSBzZWFyY2hcblx0ICAgICAqIF8uaW5kZXhPZihbMSwgMSwgMiwgMl0sIDIsIHRydWUpO1xuXHQgICAgICogLy8gPT4gMlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG5cdCAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cdCAgICAgIGlmICghbGVuZ3RoKSB7XG5cdCAgICAgICAgcmV0dXJuIC0xO1xuXHQgICAgICB9XG5cdCAgICAgIGlmICh0eXBlb2YgZnJvbUluZGV4ID09ICdudW1iZXInKSB7XG5cdCAgICAgICAgZnJvbUluZGV4ID0gZnJvbUluZGV4IDwgMCA/IG5hdGl2ZU1heChsZW5ndGggKyBmcm9tSW5kZXgsIDApIDogZnJvbUluZGV4O1xuXHQgICAgICB9IGVsc2UgaWYgKGZyb21JbmRleCkge1xuXHQgICAgICAgIHZhciBpbmRleCA9IGJpbmFyeUluZGV4KGFycmF5LCB2YWx1ZSk7XG5cdCAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoICYmXG5cdCAgICAgICAgICAgICh2YWx1ZSA9PT0gdmFsdWUgPyAodmFsdWUgPT09IGFycmF5W2luZGV4XSkgOiAoYXJyYXlbaW5kZXhdICE9PSBhcnJheVtpbmRleF0pKSkge1xuXHQgICAgICAgICAgcmV0dXJuIGluZGV4O1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gLTE7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4IHx8IDApO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogR2V0cyBhbGwgYnV0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IEFycmF5XG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG5cdCAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIF8uaW5pdGlhbChbMSwgMiwgM10pO1xuXHQgICAgICogLy8gPT4gWzEsIDJdXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGluaXRpYWwoYXJyYXkpIHtcblx0ICAgICAgcmV0dXJuIGRyb3BSaWdodChhcnJheSwgMSk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMgdGhhdCBhcmUgaW5jbHVkZWQgaW4gYWxsIG9mIHRoZSBwcm92aWRlZFxuXHQgICAgICogYXJyYXlzIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG5cdCAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBBcnJheVxuXHQgICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuXHQgICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2Ygc2hhcmVkIHZhbHVlcy5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKiBfLmludGVyc2VjdGlvbihbMSwgMl0sIFs0LCAyXSwgWzIsIDFdKTtcblx0ICAgICAqIC8vID0+IFsyXVxuXHQgICAgICovXG5cdCAgICB2YXIgaW50ZXJzZWN0aW9uID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGFycmF5cykge1xuXHQgICAgICB2YXIgb3RoTGVuZ3RoID0gYXJyYXlzLmxlbmd0aCxcblx0ICAgICAgICAgIG90aEluZGV4ID0gb3RoTGVuZ3RoLFxuXHQgICAgICAgICAgY2FjaGVzID0gQXJyYXkobGVuZ3RoKSxcblx0ICAgICAgICAgIGluZGV4T2YgPSBnZXRJbmRleE9mKCksXG5cdCAgICAgICAgICBpc0NvbW1vbiA9IGluZGV4T2YgPT0gYmFzZUluZGV4T2YsXG5cdCAgICAgICAgICByZXN1bHQgPSBbXTtcblx0XG5cdCAgICAgIHdoaWxlIChvdGhJbmRleC0tKSB7XG5cdCAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlzW290aEluZGV4XSA9IGlzQXJyYXlMaWtlKHZhbHVlID0gYXJyYXlzW290aEluZGV4XSkgPyB2YWx1ZSA6IFtdO1xuXHQgICAgICAgIGNhY2hlc1tvdGhJbmRleF0gPSAoaXNDb21tb24gJiYgdmFsdWUubGVuZ3RoID49IDEyMCkgPyBjcmVhdGVDYWNoZShvdGhJbmRleCAmJiB2YWx1ZSkgOiBudWxsO1xuXHQgICAgICB9XG5cdCAgICAgIHZhciBhcnJheSA9IGFycmF5c1swXSxcblx0ICAgICAgICAgIGluZGV4ID0gLTEsXG5cdCAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG5cdCAgICAgICAgICBzZWVuID0gY2FjaGVzWzBdO1xuXHRcblx0ICAgICAgb3V0ZXI6XG5cdCAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdCAgICAgICAgdmFsdWUgPSBhcnJheVtpbmRleF07XG5cdCAgICAgICAgaWYgKChzZWVuID8gY2FjaGVJbmRleE9mKHNlZW4sIHZhbHVlKSA6IGluZGV4T2YocmVzdWx0LCB2YWx1ZSwgMCkpIDwgMCkge1xuXHQgICAgICAgICAgdmFyIG90aEluZGV4ID0gb3RoTGVuZ3RoO1xuXHQgICAgICAgICAgd2hpbGUgKC0tb3RoSW5kZXgpIHtcblx0ICAgICAgICAgICAgdmFyIGNhY2hlID0gY2FjaGVzW290aEluZGV4XTtcblx0ICAgICAgICAgICAgaWYgKChjYWNoZSA/IGNhY2hlSW5kZXhPZihjYWNoZSwgdmFsdWUpIDogaW5kZXhPZihhcnJheXNbb3RoSW5kZXhdLCB2YWx1ZSwgMCkpIDwgMCkge1xuXHQgICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICBpZiAoc2Vlbikge1xuXHQgICAgICAgICAgICBzZWVuLnB1c2godmFsdWUpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfSk7XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBHZXRzIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IEFycmF5XG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG5cdCAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIF8ubGFzdChbMSwgMiwgM10pO1xuXHQgICAgICogLy8gPT4gM1xuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBsYXN0KGFycmF5KSB7XG5cdCAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cdCAgICAgIHJldHVybiBsZW5ndGggPyBhcnJheVtsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuXHQgICAgICogYGFycmF5YCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBBcnJheVxuXHQgICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cblx0ICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG5cdCAgICAgKiBAcGFyYW0ge2Jvb2xlYW58bnVtYmVyfSBbZnJvbUluZGV4PWFycmF5Lmxlbmd0aC0xXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb21cblx0ICAgICAqICBvciBgdHJ1ZWAgdG8gcGVyZm9ybSBhIGJpbmFyeSBzZWFyY2ggb24gYSBzb3J0ZWQgYXJyYXkuXG5cdCAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBfLmxhc3RJbmRleE9mKFsxLCAyLCAxLCAyXSwgMik7XG5cdCAgICAgKiAvLyA9PiAzXG5cdCAgICAgKlxuXHQgICAgICogLy8gdXNpbmcgYGZyb21JbmRleGBcblx0ICAgICAqIF8ubGFzdEluZGV4T2YoWzEsIDIsIDEsIDJdLCAyLCAyKTtcblx0ICAgICAqIC8vID0+IDFcblx0ICAgICAqXG5cdCAgICAgKiAvLyBwZXJmb3JtaW5nIGEgYmluYXJ5IHNlYXJjaFxuXHQgICAgICogXy5sYXN0SW5kZXhPZihbMSwgMSwgMiwgMl0sIDIsIHRydWUpO1xuXHQgICAgICogLy8gPT4gM1xuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBsYXN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuXHQgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXHQgICAgICBpZiAoIWxlbmd0aCkge1xuXHQgICAgICAgIHJldHVybiAtMTtcblx0ICAgICAgfVxuXHQgICAgICB2YXIgaW5kZXggPSBsZW5ndGg7XG5cdCAgICAgIGlmICh0eXBlb2YgZnJvbUluZGV4ID09ICdudW1iZXInKSB7XG5cdCAgICAgICAgaW5kZXggPSAoZnJvbUluZGV4IDwgMCA/IG5hdGl2ZU1heChsZW5ndGggKyBmcm9tSW5kZXgsIDApIDogbmF0aXZlTWluKGZyb21JbmRleCB8fCAwLCBsZW5ndGggLSAxKSkgKyAxO1xuXHQgICAgICB9IGVsc2UgaWYgKGZyb21JbmRleCkge1xuXHQgICAgICAgIGluZGV4ID0gYmluYXJ5SW5kZXgoYXJyYXksIHZhbHVlLCB0cnVlKSAtIDE7XG5cdCAgICAgICAgdmFyIG90aGVyID0gYXJyYXlbaW5kZXhdO1xuXHQgICAgICAgIGlmICh2YWx1ZSA9PT0gdmFsdWUgPyAodmFsdWUgPT09IG90aGVyKSA6IChvdGhlciAhPT0gb3RoZXIpKSB7XG5cdCAgICAgICAgICByZXR1cm4gaW5kZXg7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiAtMTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAodmFsdWUgIT09IHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIGluZGV4T2ZOYU4oYXJyYXksIGluZGV4LCB0cnVlKTtcblx0ICAgICAgfVxuXHQgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuXHQgICAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG5cdCAgICAgICAgICByZXR1cm4gaW5kZXg7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiAtMTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFJlbW92ZXMgYWxsIHByb3ZpZGVkIHZhbHVlcyBmcm9tIGBhcnJheWAgdXNpbmdcblx0ICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG5cdCAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG5cdCAgICAgKlxuXHQgICAgICogKipOb3RlOioqIFVubGlrZSBgXy53aXRob3V0YCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcblx0ICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG5cdCAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuXHQgICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzLCAxLCAyLCAzXTtcblx0ICAgICAqXG5cdCAgICAgKiBfLnB1bGwoYXJyYXksIDIsIDMpO1xuXHQgICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuXHQgICAgICogLy8gPT4gWzEsIDFdXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIHB1bGwoKSB7XG5cdCAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuXHQgICAgICAgICAgYXJyYXkgPSBhcmdzWzBdO1xuXHRcblx0ICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuXHQgICAgICAgIHJldHVybiBhcnJheTtcblx0ICAgICAgfVxuXHQgICAgICB2YXIgaW5kZXggPSAwLFxuXHQgICAgICAgICAgaW5kZXhPZiA9IGdldEluZGV4T2YoKSxcblx0ICAgICAgICAgIGxlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuXHRcblx0ICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0ICAgICAgICB2YXIgZnJvbUluZGV4ID0gMCxcblx0ICAgICAgICAgICAgdmFsdWUgPSBhcmdzW2luZGV4XTtcblx0XG5cdCAgICAgICAgd2hpbGUgKChmcm9tSW5kZXggPSBpbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSkgPiAtMSkge1xuXHQgICAgICAgICAgc3BsaWNlLmNhbGwoYXJyYXksIGZyb21JbmRleCwgMSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBhcnJheTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFJlbW92ZXMgZWxlbWVudHMgZnJvbSBgYXJyYXlgIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGluZGV4ZXMgYW5kIHJldHVybnNcblx0ICAgICAqIGFuIGFycmF5IG9mIHRoZSByZW1vdmVkIGVsZW1lbnRzLiBJbmRleGVzIG1heSBiZSBzcGVjaWZpZWQgYXMgYW4gYXJyYXkgb2Zcblx0ICAgICAqIGluZGV4ZXMgb3IgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMuXG5cdCAgICAgKlxuXHQgICAgICogKipOb3RlOioqIFVubGlrZSBgXy5hdGAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IEFycmF5XG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuXHQgICAgICogQHBhcmFtIHsuLi4obnVtYmVyfG51bWJlcltdKX0gW2luZGV4ZXNdIFRoZSBpbmRleGVzIG9mIGVsZW1lbnRzIHRvIHJlbW92ZSxcblx0ICAgICAqICBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBpbmRleGVzIG9yIGFycmF5cyBvZiBpbmRleGVzLlxuXHQgICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogdmFyIGFycmF5ID0gWzUsIDEwLCAxNSwgMjBdO1xuXHQgICAgICogdmFyIGV2ZW5zID0gXy5wdWxsQXQoYXJyYXksIDEsIDMpO1xuXHQgICAgICpcblx0ICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcblx0ICAgICAqIC8vID0+IFs1LCAxNV1cblx0ICAgICAqXG5cdCAgICAgKiBjb25zb2xlLmxvZyhldmVucyk7XG5cdCAgICAgKiAvLyA9PiBbMTAsIDIwXVxuXHQgICAgICovXG5cdCAgICB2YXIgcHVsbEF0ID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGFycmF5LCBpbmRleGVzKSB7XG5cdCAgICAgIGluZGV4ZXMgPSBiYXNlRmxhdHRlbihpbmRleGVzKTtcblx0XG5cdCAgICAgIHZhciByZXN1bHQgPSBiYXNlQXQoYXJyYXksIGluZGV4ZXMpO1xuXHQgICAgICBiYXNlUHVsbEF0KGFycmF5LCBpbmRleGVzLnNvcnQoYmFzZUNvbXBhcmVBc2NlbmRpbmcpKTtcblx0ICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH0pO1xuXHRcblx0ICAgIC8qKlxuXHQgICAgICogUmVtb3ZlcyBhbGwgZWxlbWVudHMgZnJvbSBgYXJyYXlgIHRoYXQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yXG5cdCAgICAgKiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcmVtb3ZlZCBlbGVtZW50cy4gVGhlIHByZWRpY2F0ZSBpcyBib3VuZCB0b1xuXHQgICAgICogYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG5cdCAgICAgKlxuXHQgICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcblx0ICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuXHQgICAgICpcblx0ICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcblx0ICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuXHQgICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cblx0ICAgICAqXG5cdCAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG5cdCAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuXHQgICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG5cdCAgICAgKlxuXHQgICAgICogKipOb3RlOioqIFVubGlrZSBgXy5maWx0ZXJgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBBcnJheVxuXHQgICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuXHQgICAgICogIHBlciBpdGVyYXRpb24uXG5cdCAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG5cdCAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgMywgNF07XG5cdCAgICAgKiB2YXIgZXZlbnMgPSBfLnJlbW92ZShhcnJheSwgZnVuY3Rpb24obikge1xuXHQgICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcblx0ICAgICAqIH0pO1xuXHQgICAgICpcblx0ICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcblx0ICAgICAqIC8vID0+IFsxLCAzXVxuXHQgICAgICpcblx0ICAgICAqIGNvbnNvbGUubG9nKGV2ZW5zKTtcblx0ICAgICAqIC8vID0+IFsyLCA0XVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiByZW1vdmUoYXJyYXksIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuXHQgICAgICB2YXIgcmVzdWx0ID0gW107XG5cdCAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICB9XG5cdCAgICAgIHZhciBpbmRleCA9IC0xLFxuXHQgICAgICAgICAgaW5kZXhlcyA9IFtdLFxuXHQgICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcblx0ICAgICAgcHJlZGljYXRlID0gZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKTtcblx0ICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0ICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG5cdCAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuXHQgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuXHQgICAgICAgICAgaW5kZXhlcy5wdXNoKGluZGV4KTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgYmFzZVB1bGxBdChhcnJheSwgaW5kZXhlcyk7XG5cdCAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBHZXRzIGFsbCBidXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGFsaWFzIHRhaWxcblx0ICAgICAqIEBjYXRlZ29yeSBBcnJheVxuXHQgICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuXHQgICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBfLnJlc3QoWzEsIDIsIDNdKTtcblx0ICAgICAqIC8vID0+IFsyLCAzXVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiByZXN0KGFycmF5KSB7XG5cdCAgICAgIHJldHVybiBkcm9wKGFycmF5LCAxKTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIGZyb20gYHN0YXJ0YCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsIGBlbmRgLlxuXHQgICAgICpcblx0ICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyB1c2VkIGluc3RlYWQgb2YgYEFycmF5I3NsaWNlYCB0byBzdXBwb3J0IG5vZGVcblx0ICAgICAqIGxpc3RzIGluIElFIDwgOSBhbmQgdG8gZW5zdXJlIGRlbnNlIGFycmF5cyBhcmUgcmV0dXJuZWQuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBBcnJheVxuXHQgICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuXHQgICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG5cdCAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG5cdCAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIHNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG5cdCAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cdCAgICAgIGlmICghbGVuZ3RoKSB7XG5cdCAgICAgICAgcmV0dXJuIFtdO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChlbmQgJiYgdHlwZW9mIGVuZCAhPSAnbnVtYmVyJyAmJiBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgc3RhcnQsIGVuZCkpIHtcblx0ICAgICAgICBzdGFydCA9IDA7XG5cdCAgICAgICAgZW5kID0gbGVuZ3RoO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogVXNlcyBhIGJpbmFyeSBzZWFyY2ggdG8gZGV0ZXJtaW5lIHRoZSBsb3dlc3QgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGRcblx0ICAgICAqIGJlIGluc2VydGVkIGludG8gYGFycmF5YCBpbiBvcmRlciB0byBtYWludGFpbiBpdHMgc29ydCBvcmRlci4gSWYgYW4gaXRlcmF0ZWVcblx0ICAgICAqIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIGl0IGlzIGludm9rZWQgZm9yIGB2YWx1ZWAgYW5kIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgXG5cdCAgICAgKiB0byBjb21wdXRlIHRoZWlyIHNvcnQgcmFua2luZy4gVGhlIGl0ZXJhdGVlIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmRcblx0ICAgICAqIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7ICh2YWx1ZSkuXG5cdCAgICAgKlxuXHQgICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuXHQgICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG5cdCAgICAgKlxuXHQgICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuXHQgICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG5cdCAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuXHQgICAgICpcblx0ICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuXHQgICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cblx0ICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcblx0ICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cblx0ICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcblx0ICAgICAqICBwZXIgaXRlcmF0aW9uLlxuXHQgICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG5cdCAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuXHQgICAgICogIGludG8gYGFycmF5YC5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogXy5zb3J0ZWRJbmRleChbMzAsIDUwXSwgNDApO1xuXHQgICAgICogLy8gPT4gMVxuXHQgICAgICpcblx0ICAgICAqIF8uc29ydGVkSW5kZXgoWzQsIDQsIDUsIDVdLCA1KTtcblx0ICAgICAqIC8vID0+IDJcblx0ICAgICAqXG5cdCAgICAgKiB2YXIgZGljdCA9IHsgJ2RhdGEnOiB7ICd0aGlydHknOiAzMCwgJ2ZvcnR5JzogNDAsICdmaWZ0eSc6IDUwIH0gfTtcblx0ICAgICAqXG5cdCAgICAgKiAvLyB1c2luZyBhbiBpdGVyYXRlZSBmdW5jdGlvblxuXHQgICAgICogXy5zb3J0ZWRJbmRleChbJ3RoaXJ0eScsICdmaWZ0eSddLCAnZm9ydHknLCBmdW5jdGlvbih3b3JkKSB7XG5cdCAgICAgKiAgIHJldHVybiB0aGlzLmRhdGFbd29yZF07XG5cdCAgICAgKiB9LCBkaWN0KTtcblx0ICAgICAqIC8vID0+IDFcblx0ICAgICAqXG5cdCAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuXHQgICAgICogXy5zb3J0ZWRJbmRleChbeyAneCc6IDMwIH0sIHsgJ3gnOiA1MCB9XSwgeyAneCc6IDQwIH0sICd4Jyk7XG5cdCAgICAgKiAvLyA9PiAxXG5cdCAgICAgKi9cblx0ICAgIHZhciBzb3J0ZWRJbmRleCA9IGNyZWF0ZVNvcnRlZEluZGV4KCk7XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRlZEluZGV4YCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBoaWdoZXN0XG5cdCAgICAgKiBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGBhcnJheWAgaW4gb3JkZXIgdG9cblx0ICAgICAqIG1haW50YWluIGl0cyBzb3J0IG9yZGVyLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcblx0ICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cblx0ICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcblx0ICAgICAqICBwZXIgaXRlcmF0aW9uLlxuXHQgICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG5cdCAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuXHQgICAgICogIGludG8gYGFycmF5YC5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogXy5zb3J0ZWRMYXN0SW5kZXgoWzQsIDQsIDUsIDVdLCA1KTtcblx0ICAgICAqIC8vID0+IDRcblx0ICAgICAqL1xuXHQgICAgdmFyIHNvcnRlZExhc3RJbmRleCA9IGNyZWF0ZVNvcnRlZEluZGV4KHRydWUpO1xuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgYmVnaW5uaW5nLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcblx0ICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cblx0ICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHRha2UuXG5cdCAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cblx0ICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogXy50YWtlKFsxLCAyLCAzXSk7XG5cdCAgICAgKiAvLyA9PiBbMV1cblx0ICAgICAqXG5cdCAgICAgKiBfLnRha2UoWzEsIDIsIDNdLCAyKTtcblx0ICAgICAqIC8vID0+IFsxLCAyXVxuXHQgICAgICpcblx0ICAgICAqIF8udGFrZShbMSwgMiwgM10sIDUpO1xuXHQgICAgICogLy8gPT4gWzEsIDIsIDNdXG5cdCAgICAgKlxuXHQgICAgICogXy50YWtlKFsxLCAyLCAzXSwgMCk7XG5cdCAgICAgKiAvLyA9PiBbXVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiB0YWtlKGFycmF5LCBuLCBndWFyZCkge1xuXHQgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXHQgICAgICBpZiAoIWxlbmd0aCkge1xuXHQgICAgICAgIHJldHVybiBbXTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgbiwgZ3VhcmQpIDogbiA9PSBudWxsKSB7XG5cdCAgICAgICAgbiA9IDE7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgMCwgbiA8IDAgPyAwIDogbik7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBlbmQuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBBcnJheVxuXHQgICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuXHQgICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gdGFrZS5cblx0ICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuXHQgICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10pO1xuXHQgICAgICogLy8gPT4gWzNdXG5cdCAgICAgKlxuXHQgICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdLCAyKTtcblx0ICAgICAqIC8vID0+IFsyLCAzXVxuXHQgICAgICpcblx0ICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSwgNSk7XG5cdCAgICAgKiAvLyA9PiBbMSwgMiwgM11cblx0ICAgICAqXG5cdCAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10sIDApO1xuXHQgICAgICogLy8gPT4gW11cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gdGFrZVJpZ2h0KGFycmF5LCBuLCBndWFyZCkge1xuXHQgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXHQgICAgICBpZiAoIWxlbmd0aCkge1xuXHQgICAgICAgIHJldHVybiBbXTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgbiwgZ3VhcmQpIDogbiA9PSBudWxsKSB7XG5cdCAgICAgICAgbiA9IDE7XG5cdCAgICAgIH1cblx0ICAgICAgbiA9IGxlbmd0aCAtICgrbiB8fCAwKTtcblx0ICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgbiA8IDAgPyAwIDogbik7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGVuZC4gRWxlbWVudHMgYXJlXG5cdCAgICAgKiB0YWtlbiB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpcyBib3VuZCB0byBgdGhpc0FyZ2Bcblx0ICAgICAqIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG5cdCAgICAgKlxuXHQgICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcblx0ICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuXHQgICAgICpcblx0ICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcblx0ICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuXHQgICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cblx0ICAgICAqXG5cdCAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG5cdCAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuXHQgICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBBcnJheVxuXHQgICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG5cdCAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cblx0ICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgcHJlZGljYXRlYC5cblx0ICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogXy50YWtlUmlnaHRXaGlsZShbMSwgMiwgM10sIGZ1bmN0aW9uKG4pIHtcblx0ICAgICAqICAgcmV0dXJuIG4gPiAxO1xuXHQgICAgICogfSk7XG5cdCAgICAgKiAvLyA9PiBbMiwgM11cblx0ICAgICAqXG5cdCAgICAgKiB2YXIgdXNlcnMgPSBbXG5cdCAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiB0cnVlIH0sXG5cdCAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuXHQgICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfVxuXHQgICAgICogXTtcblx0ICAgICAqXG5cdCAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG5cdCAgICAgKiBfLnBsdWNrKF8udGFrZVJpZ2h0V2hpbGUodXNlcnMsIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9KSwgJ3VzZXInKTtcblx0ICAgICAqIC8vID0+IFsncGViYmxlcyddXG5cdCAgICAgKlxuXHQgICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG5cdCAgICAgKiBfLnBsdWNrKF8udGFrZVJpZ2h0V2hpbGUodXNlcnMsICdhY3RpdmUnLCBmYWxzZSksICd1c2VyJyk7XG5cdCAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAncGViYmxlcyddXG5cdCAgICAgKlxuXHQgICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcblx0ICAgICAqIF8ucGx1Y2soXy50YWtlUmlnaHRXaGlsZSh1c2VycywgJ2FjdGl2ZScpLCAndXNlcicpO1xuXHQgICAgICogLy8gPT4gW11cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gdGFrZVJpZ2h0V2hpbGUoYXJyYXksIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuXHQgICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcblx0ICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKSwgZmFsc2UsIHRydWUpXG5cdCAgICAgICAgOiBbXTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgYmVnaW5uaW5nLiBFbGVtZW50c1xuXHQgICAgICogYXJlIHRha2VuIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzIGJvdW5kIHRvXG5cdCAgICAgKiBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cblx0ICAgICAqXG5cdCAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuXHQgICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG5cdCAgICAgKlxuXHQgICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuXHQgICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG5cdCAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuXHQgICAgICpcblx0ICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcblx0ICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG5cdCAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IEFycmF5XG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcblx0ICAgICAqICBwZXIgaXRlcmF0aW9uLlxuXHQgICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuXHQgICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBfLnRha2VXaGlsZShbMSwgMiwgM10sIGZ1bmN0aW9uKG4pIHtcblx0ICAgICAqICAgcmV0dXJuIG4gPCAzO1xuXHQgICAgICogfSk7XG5cdCAgICAgKiAvLyA9PiBbMSwgMl1cblx0ICAgICAqXG5cdCAgICAgKiB2YXIgdXNlcnMgPSBbXG5cdCAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuXHQgICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2V9LFxuXHQgICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG5cdCAgICAgKiBdO1xuXHQgICAgICpcblx0ICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcblx0ICAgICAqIF8ucGx1Y2soXy50YWtlV2hpbGUodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pLCAndXNlcicpO1xuXHQgICAgICogLy8gPT4gWydiYXJuZXknXVxuXHQgICAgICpcblx0ICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuXHQgICAgICogXy5wbHVjayhfLnRha2VXaGlsZSh1c2VycywgJ2FjdGl2ZScsIGZhbHNlKSwgJ3VzZXInKTtcblx0ICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuXHQgICAgICpcblx0ICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG5cdCAgICAgKiBfLnBsdWNrKF8udGFrZVdoaWxlKHVzZXJzLCAnYWN0aXZlJyksICd1c2VyJyk7XG5cdCAgICAgKiAvLyA9PiBbXVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiB0YWtlV2hpbGUoYXJyYXksIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuXHQgICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcblx0ICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKSlcblx0ICAgICAgICA6IFtdO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzLCBpbiBvcmRlciwgZnJvbSBhbGwgb2YgdGhlIHByb3ZpZGVkIGFycmF5c1xuXHQgICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtc2FtZXZhbHVlemVybylcblx0ICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IEFycmF5XG5cdCAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG5cdCAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIF8udW5pb24oWzEsIDJdLCBbNCwgMl0sIFsyLCAxXSk7XG5cdCAgICAgKiAvLyA9PiBbMSwgMiwgNF1cblx0ICAgICAqL1xuXHQgICAgdmFyIHVuaW9uID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGFycmF5cykge1xuXHQgICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJyYXlzLCBmYWxzZSwgdHJ1ZSkpO1xuXHQgICAgfSk7XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGEgZHVwbGljYXRlLWZyZWUgdmVyc2lvbiBvZiBhbiBhcnJheSwgdXNpbmdcblx0ICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG5cdCAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGluIHdoaWNoIG9ubHkgdGhlIGZpcnN0IG9jY3VyZW5jZSBvZiBlYWNoIGVsZW1lbnRcblx0ICAgICAqIGlzIGtlcHQuIFByb3ZpZGluZyBgdHJ1ZWAgZm9yIGBpc1NvcnRlZGAgcGVyZm9ybXMgYSBmYXN0ZXIgc2VhcmNoIGFsZ29yaXRobVxuXHQgICAgICogZm9yIHNvcnRlZCBhcnJheXMuIElmIGFuIGl0ZXJhdGVlIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIGl0IGlzIGludm9rZWQgZm9yXG5cdCAgICAgKiBlYWNoIGVsZW1lbnQgaW4gdGhlIGFycmF5IHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2ggdW5pcXVlbmVzc1xuXHQgICAgICogaXMgY29tcHV0ZWQuIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG5cdCAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cblx0ICAgICAqXG5cdCAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG5cdCAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cblx0ICAgICAqXG5cdCAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG5cdCAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcblx0ICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG5cdCAgICAgKlxuXHQgICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG5cdCAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuXHQgICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBhbGlhcyB1bmlxdWVcblx0ICAgICAqIEBjYXRlZ29yeSBBcnJheVxuXHQgICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG5cdCAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1NvcnRlZF0gU3BlY2lmeSB0aGUgYXJyYXkgaXMgc29ydGVkLlxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG5cdCAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cblx0ICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZS12YWx1ZS1mcmVlIGFycmF5LlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBfLnVuaXEoWzIsIDEsIDJdKTtcblx0ICAgICAqIC8vID0+IFsyLCAxXVxuXHQgICAgICpcblx0ICAgICAqIC8vIHVzaW5nIGBpc1NvcnRlZGBcblx0ICAgICAqIF8udW5pcShbMSwgMSwgMl0sIHRydWUpO1xuXHQgICAgICogLy8gPT4gWzEsIDJdXG5cdCAgICAgKlxuXHQgICAgICogLy8gdXNpbmcgYW4gaXRlcmF0ZWUgZnVuY3Rpb25cblx0ICAgICAqIF8udW5pcShbMSwgMi41LCAxLjUsIDJdLCBmdW5jdGlvbihuKSB7XG5cdCAgICAgKiAgIHJldHVybiB0aGlzLmZsb29yKG4pO1xuXHQgICAgICogfSwgTWF0aCk7XG5cdCAgICAgKiAvLyA9PiBbMSwgMi41XVxuXHQgICAgICpcblx0ICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG5cdCAgICAgKiBfLnVuaXEoW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuXHQgICAgICogLy8gPT4gW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH1dXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIHVuaXEoYXJyYXksIGlzU29ydGVkLCBpdGVyYXRlZSwgdGhpc0FyZykge1xuXHQgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXHQgICAgICBpZiAoIWxlbmd0aCkge1xuXHQgICAgICAgIHJldHVybiBbXTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoaXNTb3J0ZWQgIT0gbnVsbCAmJiB0eXBlb2YgaXNTb3J0ZWQgIT0gJ2Jvb2xlYW4nKSB7XG5cdCAgICAgICAgdGhpc0FyZyA9IGl0ZXJhdGVlO1xuXHQgICAgICAgIGl0ZXJhdGVlID0gaXNJdGVyYXRlZUNhbGwoYXJyYXksIGlzU29ydGVkLCB0aGlzQXJnKSA/IHVuZGVmaW5lZCA6IGlzU29ydGVkO1xuXHQgICAgICAgIGlzU29ydGVkID0gZmFsc2U7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIGNhbGxiYWNrID0gZ2V0Q2FsbGJhY2soKTtcblx0ICAgICAgaWYgKCEoaXRlcmF0ZWUgPT0gbnVsbCAmJiBjYWxsYmFjayA9PT0gYmFzZUNhbGxiYWNrKSkge1xuXHQgICAgICAgIGl0ZXJhdGVlID0gY2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDMpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiAoaXNTb3J0ZWQgJiYgZ2V0SW5kZXhPZigpID09IGJhc2VJbmRleE9mKVxuXHQgICAgICAgID8gc29ydGVkVW5pcShhcnJheSwgaXRlcmF0ZWUpXG5cdCAgICAgICAgOiBiYXNlVW5pcShhcnJheSwgaXRlcmF0ZWUpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy56aXBgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYW4gYXJyYXkgb2YgZ3JvdXBlZFxuXHQgICAgICogZWxlbWVudHMgYW5kIGNyZWF0ZXMgYW4gYXJyYXkgcmVncm91cGluZyB0aGUgZWxlbWVudHMgdG8gdGhlaXIgcHJlLXppcFxuXHQgICAgICogY29uZmlndXJhdGlvbi5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IEFycmF5XG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cyB0byBwcm9jZXNzLlxuXHQgICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVncm91cGVkIGVsZW1lbnRzLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiB2YXIgemlwcGVkID0gXy56aXAoWydmcmVkJywgJ2Jhcm5leSddLCBbMzAsIDQwXSwgW3RydWUsIGZhbHNlXSk7XG5cdCAgICAgKiAvLyA9PiBbWydmcmVkJywgMzAsIHRydWVdLCBbJ2Jhcm5leScsIDQwLCBmYWxzZV1dXG5cdCAgICAgKlxuXHQgICAgICogXy51bnppcCh6aXBwZWQpO1xuXHQgICAgICogLy8gPT4gW1snZnJlZCcsICdiYXJuZXknXSwgWzMwLCA0MF0sIFt0cnVlLCBmYWxzZV1dXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIHVuemlwKGFycmF5KSB7XG5cdCAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcblx0ICAgICAgICByZXR1cm4gW107XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIGluZGV4ID0gLTEsXG5cdCAgICAgICAgICBsZW5ndGggPSAwO1xuXHRcblx0ICAgICAgYXJyYXkgPSBhcnJheUZpbHRlcihhcnJheSwgZnVuY3Rpb24oZ3JvdXApIHtcblx0ICAgICAgICBpZiAoaXNBcnJheUxpa2UoZ3JvdXApKSB7XG5cdCAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoZ3JvdXAubGVuZ3RoLCBsZW5ndGgpO1xuXHQgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgICB9KTtcblx0ICAgICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cdCAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdCAgICAgICAgcmVzdWx0W2luZGV4XSA9IGFycmF5TWFwKGFycmF5LCBiYXNlUHJvcGVydHkoaW5kZXgpKTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bnppcGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhbiBpdGVyYXRlZSB0byBzcGVjaWZ5XG5cdCAgICAgKiBob3cgcmVncm91cGVkIHZhbHVlcyBzaG91bGQgYmUgY29tYmluZWQuIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYFxuXHQgICAgICogYW5kIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czogKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGdyb3VwKS5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IEFycmF5XG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cyB0byBwcm9jZXNzLlxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgZnVuY3Rpb24gdG8gY29tYmluZSByZWdyb3VwZWQgdmFsdWVzLlxuXHQgICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG5cdCAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZWdyb3VwZWQgZWxlbWVudHMuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIHZhciB6aXBwZWQgPSBfLnppcChbMSwgMl0sIFsxMCwgMjBdLCBbMTAwLCAyMDBdKTtcblx0ICAgICAqIC8vID0+IFtbMSwgMTAsIDEwMF0sIFsyLCAyMCwgMjAwXV1cblx0ICAgICAqXG5cdCAgICAgKiBfLnVuemlwV2l0aCh6aXBwZWQsIF8uYWRkKTtcblx0ICAgICAqIC8vID0+IFszLCAzMCwgMzAwXVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiB1bnppcFdpdGgoYXJyYXksIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG5cdCAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cdCAgICAgIGlmICghbGVuZ3RoKSB7XG5cdCAgICAgICAgcmV0dXJuIFtdO1xuXHQgICAgICB9XG5cdCAgICAgIHZhciByZXN1bHQgPSB1bnppcChhcnJheSk7XG5cdCAgICAgIGlmIChpdGVyYXRlZSA9PSBudWxsKSB7XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgfVxuXHQgICAgICBpdGVyYXRlZSA9IGJpbmRDYWxsYmFjayhpdGVyYXRlZSwgdGhpc0FyZywgNCk7XG5cdCAgICAgIHJldHVybiBhcnJheU1hcChyZXN1bHQsIGZ1bmN0aW9uKGdyb3VwKSB7XG5cdCAgICAgICAgcmV0dXJuIGFycmF5UmVkdWNlKGdyb3VwLCBpdGVyYXRlZSwgdW5kZWZpbmVkLCB0cnVlKTtcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGV4Y2x1ZGluZyBhbGwgcHJvdmlkZWQgdmFsdWVzIHVzaW5nXG5cdCAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuXHQgICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcblx0ICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmaWx0ZXIuXG5cdCAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cblx0ICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogXy53aXRob3V0KFsxLCAyLCAxLCAzXSwgMSwgMik7XG5cdCAgICAgKiAvLyA9PiBbM11cblx0ICAgICAqL1xuXHQgICAgdmFyIHdpdGhvdXQgPSByZXN0UGFyYW0oZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuXHQgICAgICByZXR1cm4gaXNBcnJheUxpa2UoYXJyYXkpXG5cdCAgICAgICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgdmFsdWVzKVxuXHQgICAgICAgIDogW107XG5cdCAgICB9KTtcblx0XG5cdCAgICAvKipcblx0ICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcyB0aGF0IGlzIHRoZSBbc3ltbWV0cmljIGRpZmZlcmVuY2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N5bW1ldHJpY19kaWZmZXJlbmNlKVxuXHQgICAgICogb2YgdGhlIHByb3ZpZGVkIGFycmF5cy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IEFycmF5XG5cdCAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG5cdCAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiB2YWx1ZXMuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIF8ueG9yKFsxLCAyXSwgWzQsIDJdKTtcblx0ICAgICAqIC8vID0+IFsxLCA0XVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiB4b3IoKSB7XG5cdCAgICAgIHZhciBpbmRleCA9IC0xLFxuXHQgICAgICAgICAgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcblx0XG5cdCAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdCAgICAgICAgdmFyIGFycmF5ID0gYXJndW1lbnRzW2luZGV4XTtcblx0ICAgICAgICBpZiAoaXNBcnJheUxpa2UoYXJyYXkpKSB7XG5cdCAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVzdWx0XG5cdCAgICAgICAgICAgID8gYXJyYXlQdXNoKGJhc2VEaWZmZXJlbmNlKHJlc3VsdCwgYXJyYXkpLCBiYXNlRGlmZmVyZW5jZShhcnJheSwgcmVzdWx0KSlcblx0ICAgICAgICAgICAgOiBhcnJheTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHJlc3VsdCA/IGJhc2VVbmlxKHJlc3VsdCkgOiBbXTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cywgdGhlIGZpcnN0IG9mIHdoaWNoIGNvbnRhaW5zIHRoZSBmaXJzdFxuXHQgICAgICogZWxlbWVudHMgb2YgdGhlIGdpdmVuIGFycmF5cywgdGhlIHNlY29uZCBvZiB3aGljaCBjb250YWlucyB0aGUgc2Vjb25kIGVsZW1lbnRzXG5cdCAgICAgKiBvZiB0aGUgZ2l2ZW4gYXJyYXlzLCBhbmQgc28gb24uXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBBcnJheVxuXHQgICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBwcm9jZXNzLlxuXHQgICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogXy56aXAoWydmcmVkJywgJ2Jhcm5leSddLCBbMzAsIDQwXSwgW3RydWUsIGZhbHNlXSk7XG5cdCAgICAgKiAvLyA9PiBbWydmcmVkJywgMzAsIHRydWVdLCBbJ2Jhcm5leScsIDQwLCBmYWxzZV1dXG5cdCAgICAgKi9cblx0ICAgIHZhciB6aXAgPSByZXN0UGFyYW0odW56aXApO1xuXHRcblx0ICAgIC8qKlxuXHQgICAgICogVGhlIGludmVyc2Ugb2YgYF8ucGFpcnNgOyB0aGlzIG1ldGhvZCByZXR1cm5zIGFuIG9iamVjdCBjb21wb3NlZCBmcm9tIGFycmF5c1xuXHQgICAgICogb2YgcHJvcGVydHkgbmFtZXMgYW5kIHZhbHVlcy4gUHJvdmlkZSBlaXRoZXIgYSBzaW5nbGUgdHdvIGRpbWVuc2lvbmFsIGFycmF5LFxuXHQgICAgICogZS5nLiBgW1trZXkxLCB2YWx1ZTFdLCBba2V5MiwgdmFsdWUyXV1gIG9yIHR3byBhcnJheXMsIG9uZSBvZiBwcm9wZXJ0eSBuYW1lc1xuXHQgICAgICogYW5kIG9uZSBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGFsaWFzIG9iamVjdFxuXHQgICAgICogQGNhdGVnb3J5IEFycmF5XG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMuXG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzPVtdXSBUaGUgcHJvcGVydHkgdmFsdWVzLlxuXHQgICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogXy56aXBPYmplY3QoW1snZnJlZCcsIDMwXSwgWydiYXJuZXknLCA0MF1dKTtcblx0ICAgICAqIC8vID0+IHsgJ2ZyZWQnOiAzMCwgJ2Jhcm5leSc6IDQwIH1cblx0ICAgICAqXG5cdCAgICAgKiBfLnppcE9iamVjdChbJ2ZyZWQnLCAnYmFybmV5J10sIFszMCwgNDBdKTtcblx0ICAgICAqIC8vID0+IHsgJ2ZyZWQnOiAzMCwgJ2Jhcm5leSc6IDQwIH1cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gemlwT2JqZWN0KHByb3BzLCB2YWx1ZXMpIHtcblx0ICAgICAgdmFyIGluZGV4ID0gLTEsXG5cdCAgICAgICAgICBsZW5ndGggPSBwcm9wcyA/IHByb3BzLmxlbmd0aCA6IDAsXG5cdCAgICAgICAgICByZXN1bHQgPSB7fTtcblx0XG5cdCAgICAgIGlmIChsZW5ndGggJiYgIXZhbHVlcyAmJiAhaXNBcnJheShwcm9wc1swXSkpIHtcblx0ICAgICAgICB2YWx1ZXMgPSBbXTtcblx0ICAgICAgfVxuXHQgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHQgICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cdCAgICAgICAgaWYgKHZhbHVlcykge1xuXHQgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZXNbaW5kZXhdO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoa2V5KSB7XG5cdCAgICAgICAgICByZXN1bHRba2V5WzBdXSA9IGtleVsxXTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uemlwYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGFuIGl0ZXJhdGVlIHRvIHNwZWNpZnlcblx0ICAgICAqIGhvdyBncm91cGVkIHZhbHVlcyBzaG91bGQgYmUgY29tYmluZWQuIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYFxuXHQgICAgICogYW5kIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czogKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGdyb3VwKS5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IEFycmF5XG5cdCAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIHByb2Nlc3MuXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBmdW5jdGlvbiB0byBjb21iaW5lIGdyb3VwZWQgdmFsdWVzLlxuXHQgICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG5cdCAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBfLnppcFdpdGgoWzEsIDJdLCBbMTAsIDIwXSwgWzEwMCwgMjAwXSwgXy5hZGQpO1xuXHQgICAgICogLy8gPT4gWzExMSwgMjIyXVxuXHQgICAgICovXG5cdCAgICB2YXIgemlwV2l0aCA9IHJlc3RQYXJhbShmdW5jdGlvbihhcnJheXMpIHtcblx0ICAgICAgdmFyIGxlbmd0aCA9IGFycmF5cy5sZW5ndGgsXG5cdCAgICAgICAgICBpdGVyYXRlZSA9IGxlbmd0aCA+IDIgPyBhcnJheXNbbGVuZ3RoIC0gMl0gOiB1bmRlZmluZWQsXG5cdCAgICAgICAgICB0aGlzQXJnID0gbGVuZ3RoID4gMSA/IGFycmF5c1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcblx0XG5cdCAgICAgIGlmIChsZW5ndGggPiAyICYmIHR5cGVvZiBpdGVyYXRlZSA9PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgbGVuZ3RoIC09IDI7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgaXRlcmF0ZWUgPSAobGVuZ3RoID4gMSAmJiB0eXBlb2YgdGhpc0FyZyA9PSAnZnVuY3Rpb24nKSA/ICgtLWxlbmd0aCwgdGhpc0FyZykgOiB1bmRlZmluZWQ7XG5cdCAgICAgICAgdGhpc0FyZyA9IHVuZGVmaW5lZDtcblx0ICAgICAgfVxuXHQgICAgICBhcnJheXMubGVuZ3RoID0gbGVuZ3RoO1xuXHQgICAgICByZXR1cm4gdW56aXBXaXRoKGFycmF5cywgaXRlcmF0ZWUsIHRoaXNBcmcpO1xuXHQgICAgfSk7XG5cdFxuXHQgICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIG9iamVjdCB0aGF0IHdyYXBzIGB2YWx1ZWAgd2l0aCBleHBsaWNpdCBtZXRob2Rcblx0ICAgICAqIGNoYWluaW5nIGVuYWJsZWQuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBDaGFpblxuXHQgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cblx0ICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiB2YXIgdXNlcnMgPSBbXG5cdCAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiB9LFxuXHQgICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAgfSxcblx0ICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuXHQgICAgICogXTtcblx0ICAgICAqXG5cdCAgICAgKiB2YXIgeW91bmdlc3QgPSBfLmNoYWluKHVzZXJzKVxuXHQgICAgICogICAuc29ydEJ5KCdhZ2UnKVxuXHQgICAgICogICAubWFwKGZ1bmN0aW9uKGNocikge1xuXHQgICAgICogICAgIHJldHVybiBjaHIudXNlciArICcgaXMgJyArIGNoci5hZ2U7XG5cdCAgICAgKiAgIH0pXG5cdCAgICAgKiAgIC5maXJzdCgpXG5cdCAgICAgKiAgIC52YWx1ZSgpO1xuXHQgICAgICogLy8gPT4gJ3BlYmJsZXMgaXMgMSdcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gY2hhaW4odmFsdWUpIHtcblx0ICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaCh2YWx1ZSk7XG5cdCAgICAgIHJlc3VsdC5fX2NoYWluX18gPSB0cnVlO1xuXHQgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogVGhpcyBtZXRob2QgaW52b2tlcyBgaW50ZXJjZXB0b3JgIGFuZCByZXR1cm5zIGB2YWx1ZWAuIFRoZSBpbnRlcmNlcHRvciBpc1xuXHQgICAgICogYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLiBUaGUgcHVycG9zZSBvZlxuXHQgICAgICogdGhpcyBtZXRob2QgaXMgdG8gXCJ0YXAgaW50b1wiIGEgbWV0aG9kIGNoYWluIGluIG9yZGVyIHRvIHBlcmZvcm0gb3BlcmF0aW9uc1xuXHQgICAgICogb24gaW50ZXJtZWRpYXRlIHJlc3VsdHMgd2l0aGluIHRoZSBjaGFpbi5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IENoYWluXG5cdCAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm92aWRlIHRvIGBpbnRlcmNlcHRvcmAuXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnRlcmNlcHRvciBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuXHQgICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpbnRlcmNlcHRvcmAuXG5cdCAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBfKFsxLCAyLCAzXSlcblx0ICAgICAqICAudGFwKGZ1bmN0aW9uKGFycmF5KSB7XG5cdCAgICAgKiAgICBhcnJheS5wb3AoKTtcblx0ICAgICAqICB9KVxuXHQgICAgICogIC5yZXZlcnNlKClcblx0ICAgICAqICAudmFsdWUoKTtcblx0ICAgICAqIC8vID0+IFsyLCAxXVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiB0YXAodmFsdWUsIGludGVyY2VwdG9yLCB0aGlzQXJnKSB7XG5cdCAgICAgIGludGVyY2VwdG9yLmNhbGwodGhpc0FyZywgdmFsdWUpO1xuXHQgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnRhcGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGBpbnRlcmNlcHRvcmAuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBDaGFpblxuXHQgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvdmlkZSB0byBgaW50ZXJjZXB0b3JgLlxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaW50ZXJjZXB0b3IgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cblx0ICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaW50ZXJjZXB0b3JgLlxuXHQgICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgaW50ZXJjZXB0b3JgLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBfKCcgIGFiYyAgJylcblx0ICAgICAqICAuY2hhaW4oKVxuXHQgICAgICogIC50cmltKClcblx0ICAgICAqICAudGhydShmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICogICAgcmV0dXJuIFt2YWx1ZV07XG5cdCAgICAgKiAgfSlcblx0ICAgICAqICAudmFsdWUoKTtcblx0ICAgICAqIC8vID0+IFsnYWJjJ11cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gdGhydSh2YWx1ZSwgaW50ZXJjZXB0b3IsIHRoaXNBcmcpIHtcblx0ICAgICAgcmV0dXJuIGludGVyY2VwdG9yLmNhbGwodGhpc0FyZywgdmFsdWUpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogRW5hYmxlcyBleHBsaWNpdCBtZXRob2QgY2hhaW5pbmcgb24gdGhlIHdyYXBwZXIgb2JqZWN0LlxuXHQgICAgICpcblx0ICAgICAqIEBuYW1lIGNoYWluXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IENoYWluXG5cdCAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogdmFyIHVzZXJzID0gW1xuXHQgICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuXHQgICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG5cdCAgICAgKiBdO1xuXHQgICAgICpcblx0ICAgICAqIC8vIHdpdGhvdXQgZXhwbGljaXQgY2hhaW5pbmdcblx0ICAgICAqIF8odXNlcnMpLmZpcnN0KCk7XG5cdCAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG5cdCAgICAgKlxuXHQgICAgICogLy8gd2l0aCBleHBsaWNpdCBjaGFpbmluZ1xuXHQgICAgICogXyh1c2VycykuY2hhaW4oKVxuXHQgICAgICogICAuZmlyc3QoKVxuXHQgICAgICogICAucGljaygndXNlcicpXG5cdCAgICAgKiAgIC52YWx1ZSgpO1xuXHQgICAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknIH1cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gd3JhcHBlckNoYWluKCkge1xuXHQgICAgICByZXR1cm4gY2hhaW4odGhpcyk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBFeGVjdXRlcyB0aGUgY2hhaW5lZCBzZXF1ZW5jZSBhbmQgcmV0dXJucyB0aGUgd3JhcHBlZCByZXN1bHQuXG5cdCAgICAgKlxuXHQgICAgICogQG5hbWUgY29tbWl0XG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IENoYWluXG5cdCAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogdmFyIGFycmF5ID0gWzEsIDJdO1xuXHQgICAgICogdmFyIHdyYXBwZWQgPSBfKGFycmF5KS5wdXNoKDMpO1xuXHQgICAgICpcblx0ICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcblx0ICAgICAqIC8vID0+IFsxLCAyXVxuXHQgICAgICpcblx0ICAgICAqIHdyYXBwZWQgPSB3cmFwcGVkLmNvbW1pdCgpO1xuXHQgICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuXHQgICAgICogLy8gPT4gWzEsIDIsIDNdXG5cdCAgICAgKlxuXHQgICAgICogd3JhcHBlZC5sYXN0KCk7XG5cdCAgICAgKiAvLyA9PiAzXG5cdCAgICAgKlxuXHQgICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuXHQgICAgICogLy8gPT4gWzEsIDIsIDNdXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIHdyYXBwZXJDb21taXQoKSB7XG5cdCAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih0aGlzLnZhbHVlKCksIHRoaXMuX19jaGFpbl9fKTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIENyZWF0ZXMgYSBuZXcgYXJyYXkgam9pbmluZyBhIHdyYXBwZWQgYXJyYXkgd2l0aCBhbnkgYWRkaXRpb25hbCBhcnJheXNcblx0ICAgICAqIGFuZC9vciB2YWx1ZXMuXG5cdCAgICAgKlxuXHQgICAgICogQG5hbWUgY29uY2F0XG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IENoYWluXG5cdCAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY29uY2F0ZW5hdGUuXG5cdCAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBjb25jYXRlbmF0ZWQgYXJyYXkuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIHZhciBhcnJheSA9IFsxXTtcblx0ICAgICAqIHZhciB3cmFwcGVkID0gXyhhcnJheSkuY29uY2F0KDIsIFszXSwgW1s0XV0pO1xuXHQgICAgICpcblx0ICAgICAqIGNvbnNvbGUubG9nKHdyYXBwZWQudmFsdWUoKSk7XG5cdCAgICAgKiAvLyA9PiBbMSwgMiwgMywgWzRdXVxuXHQgICAgICpcblx0ICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcblx0ICAgICAqIC8vID0+IFsxXVxuXHQgICAgICovXG5cdCAgICB2YXIgd3JhcHBlckNvbmNhdCA9IHJlc3RQYXJhbShmdW5jdGlvbih2YWx1ZXMpIHtcblx0ICAgICAgdmFsdWVzID0gYmFzZUZsYXR0ZW4odmFsdWVzKTtcblx0ICAgICAgcmV0dXJuIHRoaXMudGhydShmdW5jdGlvbihhcnJheSkge1xuXHQgICAgICAgIHJldHVybiBhcnJheUNvbmNhdChpc0FycmF5KGFycmF5KSA/IGFycmF5IDogW3RvT2JqZWN0KGFycmF5KV0sIHZhbHVlcyk7XG5cdCAgICAgIH0pO1xuXHQgICAgfSk7XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGNoYWluZWQgc2VxdWVuY2UgcGxhbnRpbmcgYHZhbHVlYCBhcyB0aGUgd3JhcHBlZCB2YWx1ZS5cblx0ICAgICAqXG5cdCAgICAgKiBAbmFtZSBwbGFudFxuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBDaGFpblxuXHQgICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIHZhciBhcnJheSA9IFsxLCAyXTtcblx0ICAgICAqIHZhciB3cmFwcGVkID0gXyhhcnJheSkubWFwKGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgKiAgIHJldHVybiBNYXRoLnBvdyh2YWx1ZSwgMik7XG5cdCAgICAgKiB9KTtcblx0ICAgICAqXG5cdCAgICAgKiB2YXIgb3RoZXIgPSBbMywgNF07XG5cdCAgICAgKiB2YXIgb3RoZXJXcmFwcGVkID0gd3JhcHBlZC5wbGFudChvdGhlcik7XG5cdCAgICAgKlxuXHQgICAgICogb3RoZXJXcmFwcGVkLnZhbHVlKCk7XG5cdCAgICAgKiAvLyA9PiBbOSwgMTZdXG5cdCAgICAgKlxuXHQgICAgICogd3JhcHBlZC52YWx1ZSgpO1xuXHQgICAgICogLy8gPT4gWzEsIDRdXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIHdyYXBwZXJQbGFudCh2YWx1ZSkge1xuXHQgICAgICB2YXIgcmVzdWx0LFxuXHQgICAgICAgICAgcGFyZW50ID0gdGhpcztcblx0XG5cdCAgICAgIHdoaWxlIChwYXJlbnQgaW5zdGFuY2VvZiBiYXNlTG9kYXNoKSB7XG5cdCAgICAgICAgdmFyIGNsb25lID0gd3JhcHBlckNsb25lKHBhcmVudCk7XG5cdCAgICAgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgICAgICAgcHJldmlvdXMuX193cmFwcGVkX18gPSBjbG9uZTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgcmVzdWx0ID0gY2xvbmU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBwcmV2aW91cyA9IGNsb25lO1xuXHQgICAgICAgIHBhcmVudCA9IHBhcmVudC5fX3dyYXBwZWRfXztcblx0ICAgICAgfVxuXHQgICAgICBwcmV2aW91cy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuXHQgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogUmV2ZXJzZXMgdGhlIHdyYXBwZWQgYXJyYXkgc28gdGhlIGZpcnN0IGVsZW1lbnQgYmVjb21lcyB0aGUgbGFzdCwgdGhlXG5cdCAgICAgKiBzZWNvbmQgZWxlbWVudCBiZWNvbWVzIHRoZSBzZWNvbmQgdG8gbGFzdCwgYW5kIHNvIG9uLlxuXHQgICAgICpcblx0ICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIHRoZSB3cmFwcGVkIGFycmF5LlxuXHQgICAgICpcblx0ICAgICAqIEBuYW1lIHJldmVyc2Vcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5cblx0ICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyByZXZlcnNlZCBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG5cdCAgICAgKlxuXHQgICAgICogXyhhcnJheSkucmV2ZXJzZSgpLnZhbHVlKClcblx0ICAgICAqIC8vID0+IFszLCAyLCAxXVxuXHQgICAgICpcblx0ICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcblx0ICAgICAqIC8vID0+IFszLCAyLCAxXVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiB3cmFwcGVyUmV2ZXJzZSgpIHtcblx0ICAgICAgdmFyIHZhbHVlID0gdGhpcy5fX3dyYXBwZWRfXztcblx0XG5cdCAgICAgIHZhciBpbnRlcmNlcHRvciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuICh3cmFwcGVkICYmIHdyYXBwZWQuX19kaXJfXyA8IDApID8gdmFsdWUgOiB2YWx1ZS5yZXZlcnNlKCk7XG5cdCAgICAgIH07XG5cdCAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB7XG5cdCAgICAgICAgdmFyIHdyYXBwZWQgPSB2YWx1ZTtcblx0ICAgICAgICBpZiAodGhpcy5fX2FjdGlvbnNfXy5sZW5ndGgpIHtcblx0ICAgICAgICAgIHdyYXBwZWQgPSBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHdyYXBwZWQgPSB3cmFwcGVkLnJldmVyc2UoKTtcblx0ICAgICAgICB3cmFwcGVkLl9fYWN0aW9uc19fLnB1c2goeyAnZnVuYyc6IHRocnUsICdhcmdzJzogW2ludGVyY2VwdG9yXSwgJ3RoaXNBcmcnOiB1bmRlZmluZWQgfSk7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHdyYXBwZWQsIHRoaXMuX19jaGFpbl9fKTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gdGhpcy50aHJ1KGludGVyY2VwdG9yKTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFByb2R1Y2VzIHRoZSByZXN1bHQgb2YgY29lcmNpbmcgdGhlIHVud3JhcHBlZCB2YWx1ZSB0byBhIHN0cmluZy5cblx0ICAgICAqXG5cdCAgICAgKiBAbmFtZSB0b1N0cmluZ1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBDaGFpblxuXHQgICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29lcmNlZCBzdHJpbmcgdmFsdWUuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIF8oWzEsIDIsIDNdKS50b1N0cmluZygpO1xuXHQgICAgICogLy8gPT4gJzEsMiwzJ1xuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiB3cmFwcGVyVG9TdHJpbmcoKSB7XG5cdCAgICAgIHJldHVybiAodGhpcy52YWx1ZSgpICsgJycpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogRXhlY3V0ZXMgdGhlIGNoYWluZWQgc2VxdWVuY2UgdG8gZXh0cmFjdCB0aGUgdW53cmFwcGVkIHZhbHVlLlxuXHQgICAgICpcblx0ICAgICAqIEBuYW1lIHZhbHVlXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGFsaWFzIHJ1biwgdG9KU09OLCB2YWx1ZU9mXG5cdCAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5cblx0ICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB1bndyYXBwZWQgdmFsdWUuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIF8oWzEsIDIsIDNdKS52YWx1ZSgpO1xuXHQgICAgICogLy8gPT4gWzEsIDIsIDNdXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIHdyYXBwZXJWYWx1ZSgpIHtcblx0ICAgICAgcmV0dXJuIGJhc2VXcmFwcGVyVmFsdWUodGhpcy5fX3dyYXBwZWRfXywgdGhpcy5fX2FjdGlvbnNfXyk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cyBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBrZXlzLCBvciBpbmRleGVzLFxuXHQgICAgICogb2YgYGNvbGxlY3Rpb25gLiBLZXlzIG1heSBiZSBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMgb3IgYXMgYXJyYXlzXG5cdCAgICAgKiBvZiBrZXlzLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuXHQgICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cblx0ICAgICAqIEBwYXJhbSB7Li4uKG51bWJlcnxudW1iZXJbXXxzdHJpbmd8c3RyaW5nW10pfSBbcHJvcHNdIFRoZSBwcm9wZXJ0eSBuYW1lc1xuXHQgICAgICogIG9yIGluZGV4ZXMgb2YgZWxlbWVudHMgdG8gcGljaywgc3BlY2lmaWVkIGluZGl2aWR1YWxseSBvciBpbiBhcnJheXMuXG5cdCAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBwaWNrZWQgZWxlbWVudHMuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIF8uYXQoWydhJywgJ2InLCAnYyddLCBbMCwgMl0pO1xuXHQgICAgICogLy8gPT4gWydhJywgJ2MnXVxuXHQgICAgICpcblx0ICAgICAqIF8uYXQoWydiYXJuZXknLCAnZnJlZCcsICdwZWJibGVzJ10sIDAsIDIpO1xuXHQgICAgICogLy8gPT4gWydiYXJuZXknLCAncGViYmxlcyddXG5cdCAgICAgKi9cblx0ICAgIHZhciBhdCA9IHJlc3RQYXJhbShmdW5jdGlvbihjb2xsZWN0aW9uLCBwcm9wcykge1xuXHQgICAgICByZXR1cm4gYmFzZUF0KGNvbGxlY3Rpb24sIGJhc2VGbGF0dGVuKHByb3BzKSk7XG5cdCAgICB9KTtcblx0XG5cdCAgICAvKipcblx0ICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuXHQgICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJvdWdoIGBpdGVyYXRlZWAuIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlXG5cdCAgICAgKiBvZiBlYWNoIGtleSBpcyB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZSBrZXkgd2FzIHJldHVybmVkIGJ5IGBpdGVyYXRlZWAuXG5cdCAgICAgKiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG5cdCAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG5cdCAgICAgKlxuXHQgICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuXHQgICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG5cdCAgICAgKlxuXHQgICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuXHQgICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG5cdCAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuXHQgICAgICpcblx0ICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuXHQgICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cblx0ICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuXHQgICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG5cdCAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cblx0ICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuXHQgICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogXy5jb3VudEJ5KFs0LjMsIDYuMSwgNi40XSwgZnVuY3Rpb24obikge1xuXHQgICAgICogICByZXR1cm4gTWF0aC5mbG9vcihuKTtcblx0ICAgICAqIH0pO1xuXHQgICAgICogLy8gPT4geyAnNCc6IDEsICc2JzogMiB9XG5cdCAgICAgKlxuXHQgICAgICogXy5jb3VudEJ5KFs0LjMsIDYuMSwgNi40XSwgZnVuY3Rpb24obikge1xuXHQgICAgICogICByZXR1cm4gdGhpcy5mbG9vcihuKTtcblx0ICAgICAqIH0sIE1hdGgpO1xuXHQgICAgICogLy8gPT4geyAnNCc6IDEsICc2JzogMiB9XG5cdCAgICAgKlxuXHQgICAgICogXy5jb3VudEJ5KFsnb25lJywgJ3R3bycsICd0aHJlZSddLCAnbGVuZ3RoJyk7XG5cdCAgICAgKiAvLyA9PiB7ICczJzogMiwgJzUnOiAxIH1cblx0ICAgICAqL1xuXHQgICAgdmFyIGNvdW50QnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuXHQgICAgICBoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSA/ICsrcmVzdWx0W2tleV0gOiAocmVzdWx0W2tleV0gPSAxKTtcblx0ICAgIH0pO1xuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ2hlY2tzIGlmIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciAqKmFsbCoqIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYC5cblx0ICAgICAqIFRoZSBwcmVkaWNhdGUgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuXHQgICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuXHQgICAgICpcblx0ICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG5cdCAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cblx0ICAgICAqXG5cdCAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG5cdCAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcblx0ICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG5cdCAgICAgKlxuXHQgICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuXHQgICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cblx0ICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAYWxpYXMgYWxsXG5cdCAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuXHQgICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuXHQgICAgICogIHBlciBpdGVyYXRpb24uXG5cdCAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG5cdCAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcblx0ICAgICAqICBlbHNlIGBmYWxzZWAuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIF8uZXZlcnkoW3RydWUsIDEsIG51bGwsICd5ZXMnXSwgQm9vbGVhbik7XG5cdCAgICAgKiAvLyA9PiBmYWxzZVxuXHQgICAgICpcblx0ICAgICAqIHZhciB1c2VycyA9IFtcblx0ICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSxcblx0ICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWN0aXZlJzogZmFsc2UgfVxuXHQgICAgICogXTtcblx0ICAgICAqXG5cdCAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG5cdCAgICAgKiBfLmV2ZXJ5KHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcblx0ICAgICAqIC8vID0+IGZhbHNlXG5cdCAgICAgKlxuXHQgICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG5cdCAgICAgKiBfLmV2ZXJ5KHVzZXJzLCAnYWN0aXZlJywgZmFsc2UpO1xuXHQgICAgICogLy8gPT4gdHJ1ZVxuXHQgICAgICpcblx0ICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG5cdCAgICAgKiBfLmV2ZXJ5KHVzZXJzLCAnYWN0aXZlJyk7XG5cdCAgICAgKiAvLyA9PiBmYWxzZVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBldmVyeShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcblx0ICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFdmVyeSA6IGJhc2VFdmVyeTtcblx0ICAgICAgaWYgKHRoaXNBcmcgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgcHJlZGljYXRlLCB0aGlzQXJnKSkge1xuXHQgICAgICAgIHByZWRpY2F0ZSA9IHVuZGVmaW5lZDtcblx0ICAgICAgfVxuXHQgICAgICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPSAnZnVuY3Rpb24nIHx8IHRoaXNBcmcgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIHByZWRpY2F0ZSA9IGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgcHJlZGljYXRlKTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgYWxsIGVsZW1lbnRzXG5cdCAgICAgKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZFxuXHQgICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuXHQgICAgICpcblx0ICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG5cdCAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cblx0ICAgICAqXG5cdCAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG5cdCAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcblx0ICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG5cdCAgICAgKlxuXHQgICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuXHQgICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cblx0ICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAYWxpYXMgc2VsZWN0XG5cdCAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuXHQgICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuXHQgICAgICogIHBlciBpdGVyYXRpb24uXG5cdCAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG5cdCAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogXy5maWx0ZXIoWzQsIDUsIDZdLCBmdW5jdGlvbihuKSB7XG5cdCAgICAgKiAgIHJldHVybiBuICUgMiA9PSAwO1xuXHQgICAgICogfSk7XG5cdCAgICAgKiAvLyA9PiBbNCwgNl1cblx0ICAgICAqXG5cdCAgICAgKiB2YXIgdXNlcnMgPSBbXG5cdCAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuXHQgICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cblx0ICAgICAqIF07XG5cdCAgICAgKlxuXHQgICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNgIGNhbGxiYWNrIHNob3J0aGFuZFxuXHQgICAgICogXy5wbHVjayhfLmZpbHRlcih1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0pLCAndXNlcicpO1xuXHQgICAgICogLy8gPT4gWydiYXJuZXknXVxuXHQgICAgICpcblx0ICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuXHQgICAgICogXy5wbHVjayhfLmZpbHRlcih1c2VycywgJ2FjdGl2ZScsIGZhbHNlKSwgJ3VzZXInKTtcblx0ICAgICAqIC8vID0+IFsnZnJlZCddXG5cdCAgICAgKlxuXHQgICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcblx0ICAgICAqIF8ucGx1Y2soXy5maWx0ZXIodXNlcnMsICdhY3RpdmUnKSwgJ3VzZXInKTtcblx0ICAgICAqIC8vID0+IFsnYmFybmV5J11cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gZmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuXHQgICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUZpbHRlciA6IGJhc2VGaWx0ZXI7XG5cdCAgICAgIHByZWRpY2F0ZSA9IGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMyk7XG5cdCAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIHRoZSBmaXJzdCBlbGVtZW50XG5cdCAgICAgKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZFxuXHQgICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuXHQgICAgICpcblx0ICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG5cdCAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cblx0ICAgICAqXG5cdCAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG5cdCAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcblx0ICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG5cdCAgICAgKlxuXHQgICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuXHQgICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cblx0ICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAYWxpYXMgZGV0ZWN0XG5cdCAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuXHQgICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNlYXJjaC5cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuXHQgICAgICogIHBlciBpdGVyYXRpb24uXG5cdCAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG5cdCAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF0Y2hlZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiB2YXIgdXNlcnMgPSBbXG5cdCAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcblx0ICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcblx0ICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYWN0aXZlJzogdHJ1ZSB9XG5cdCAgICAgKiBdO1xuXHQgICAgICpcblx0ICAgICAqIF8ucmVzdWx0KF8uZmluZCh1c2VycywgZnVuY3Rpb24oY2hyKSB7XG5cdCAgICAgKiAgIHJldHVybiBjaHIuYWdlIDwgNDA7XG5cdCAgICAgKiB9KSwgJ3VzZXInKTtcblx0ICAgICAqIC8vID0+ICdiYXJuZXknXG5cdCAgICAgKlxuXHQgICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNgIGNhbGxiYWNrIHNob3J0aGFuZFxuXHQgICAgICogXy5yZXN1bHQoXy5maW5kKHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogdHJ1ZSB9KSwgJ3VzZXInKTtcblx0ICAgICAqIC8vID0+ICdwZWJibGVzJ1xuXHQgICAgICpcblx0ICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuXHQgICAgICogXy5yZXN1bHQoXy5maW5kKHVzZXJzLCAnYWN0aXZlJywgZmFsc2UpLCAndXNlcicpO1xuXHQgICAgICogLy8gPT4gJ2ZyZWQnXG5cdCAgICAgKlxuXHQgICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcblx0ICAgICAqIF8ucmVzdWx0KF8uZmluZCh1c2VycywgJ2FjdGl2ZScpLCAndXNlcicpO1xuXHQgICAgICogLy8gPT4gJ2Jhcm5leSdcblx0ICAgICAqL1xuXHQgICAgdmFyIGZpbmQgPSBjcmVhdGVGaW5kKGJhc2VFYWNoKTtcblx0XG5cdCAgICAvKipcblx0ICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuXHQgICAgICogYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cblx0ICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzZWFyY2guXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcblx0ICAgICAqICBwZXIgaXRlcmF0aW9uLlxuXHQgICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuXHQgICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogXy5maW5kTGFzdChbMSwgMiwgMywgNF0sIGZ1bmN0aW9uKG4pIHtcblx0ICAgICAqICAgcmV0dXJuIG4gJSAyID09IDE7XG5cdCAgICAgKiB9KTtcblx0ICAgICAqIC8vID0+IDNcblx0ICAgICAqL1xuXHQgICAgdmFyIGZpbmRMYXN0ID0gY3JlYXRlRmluZChiYXNlRWFjaFJpZ2h0LCB0cnVlKTtcblx0XG5cdCAgICAvKipcblx0ICAgICAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCBhbmQgdGhlXG5cdCAgICAgKiBzb3VyY2Ugb2JqZWN0LCByZXR1cm5pbmcgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBoYXMgZXF1aXZhbGVudCBwcm9wZXJ0eVxuXHQgICAgICogdmFsdWVzLlxuXHQgICAgICpcblx0ICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBib29sZWFucywgYERhdGVgIG9iamVjdHMsXG5cdCAgICAgKiBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLCBhbmQgc3RyaW5ncy4gT2JqZWN0cyBhcmUgY29tcGFyZWQgYnlcblx0ICAgICAqIHRoZWlyIG93biwgbm90IGluaGVyaXRlZCwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLiBGb3IgY29tcGFyaW5nIGEgc2luZ2xlXG5cdCAgICAgKiBvd24gb3IgaW5oZXJpdGVkIHByb3BlcnR5IHZhbHVlIHNlZSBgXy5tYXRjaGVzUHJvcGVydHlgLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuXHQgICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNlYXJjaC5cblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG5cdCAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF0Y2hlZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiB2YXIgdXNlcnMgPSBbXG5cdCAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuXHQgICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cblx0ICAgICAqIF07XG5cdCAgICAgKlxuXHQgICAgICogXy5yZXN1bHQoXy5maW5kV2hlcmUodXNlcnMsIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9KSwgJ3VzZXInKTtcblx0ICAgICAqIC8vID0+ICdiYXJuZXknXG5cdCAgICAgKlxuXHQgICAgICogXy5yZXN1bHQoXy5maW5kV2hlcmUodXNlcnMsIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSksICd1c2VyJyk7XG5cdCAgICAgKiAvLyA9PiAnZnJlZCdcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gZmluZFdoZXJlKGNvbGxlY3Rpb24sIHNvdXJjZSkge1xuXHQgICAgICByZXR1cm4gZmluZChjb2xsZWN0aW9uLCBiYXNlTWF0Y2hlcyhzb3VyY2UpKTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gIGludm9raW5nIGBpdGVyYXRlZWAgZm9yIGVhY2ggZWxlbWVudC5cblx0ICAgICAqIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcblx0ICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS4gSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseVxuXHQgICAgICogYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cblx0ICAgICAqXG5cdCAgICAgKiAqKk5vdGU6KiogQXMgd2l0aCBvdGhlciBcIkNvbGxlY3Rpb25zXCIgbWV0aG9kcywgb2JqZWN0cyB3aXRoIGEgXCJsZW5ndGhcIiBwcm9wZXJ0eVxuXHQgICAgICogYXJlIGl0ZXJhdGVkIGxpa2UgYXJyYXlzLiBUbyBhdm9pZCB0aGlzIGJlaGF2aW9yIGBfLmZvckluYCBvciBgXy5mb3JPd25gXG5cdCAgICAgKiBtYXkgYmUgdXNlZCBmb3Igb2JqZWN0IGl0ZXJhdGlvbi5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGFsaWFzIGVhY2hcblx0ICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG5cdCAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cblx0ICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R8c3RyaW5nfSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogXyhbMSwgMl0pLmZvckVhY2goZnVuY3Rpb24obikge1xuXHQgICAgICogICBjb25zb2xlLmxvZyhuKTtcblx0ICAgICAqIH0pLnZhbHVlKCk7XG5cdCAgICAgKiAvLyA9PiBsb2dzIGVhY2ggdmFsdWUgZnJvbSBsZWZ0IHRvIHJpZ2h0IGFuZCByZXR1cm5zIHRoZSBhcnJheVxuXHQgICAgICpcblx0ICAgICAqIF8uZm9yRWFjaCh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKG4sIGtleSkge1xuXHQgICAgICogICBjb25zb2xlLmxvZyhuLCBrZXkpO1xuXHQgICAgICogfSk7XG5cdCAgICAgKiAvLyA9PiBsb2dzIGVhY2ggdmFsdWUta2V5IHBhaXIgYW5kIHJldHVybnMgdGhlIG9iamVjdCAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuXHQgICAgICovXG5cdCAgICB2YXIgZm9yRWFjaCA9IGNyZWF0ZUZvckVhY2goYXJyYXlFYWNoLCBiYXNlRWFjaCk7XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckVhY2hgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2Zcblx0ICAgICAqIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBhbGlhcyBlYWNoUmlnaHRcblx0ICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG5cdCAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cblx0ICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R8c3RyaW5nfSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogXyhbMSwgMl0pLmZvckVhY2hSaWdodChmdW5jdGlvbihuKSB7XG5cdCAgICAgKiAgIGNvbnNvbGUubG9nKG4pO1xuXHQgICAgICogfSkudmFsdWUoKTtcblx0ICAgICAqIC8vID0+IGxvZ3MgZWFjaCB2YWx1ZSBmcm9tIHJpZ2h0IHRvIGxlZnQgYW5kIHJldHVybnMgdGhlIGFycmF5XG5cdCAgICAgKi9cblx0ICAgIHZhciBmb3JFYWNoUmlnaHQgPSBjcmVhdGVGb3JFYWNoKGFycmF5RWFjaFJpZ2h0LCBiYXNlRWFjaFJpZ2h0KTtcblx0XG5cdCAgICAvKipcblx0ICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuXHQgICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJvdWdoIGBpdGVyYXRlZWAuIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlXG5cdCAgICAgKiBvZiBlYWNoIGtleSBpcyBhbiBhcnJheSBvZiB0aGUgZWxlbWVudHMgcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlIGtleS5cblx0ICAgICAqIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcblx0ICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cblx0ICAgICAqXG5cdCAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG5cdCAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cblx0ICAgICAqXG5cdCAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG5cdCAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcblx0ICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG5cdCAgICAgKlxuXHQgICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG5cdCAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuXHQgICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcblx0ICAgICAqICBwZXIgaXRlcmF0aW9uLlxuXHQgICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG5cdCAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBfLmdyb3VwQnkoWzQuMiwgNi4xLCA2LjRdLCBmdW5jdGlvbihuKSB7XG5cdCAgICAgKiAgIHJldHVybiBNYXRoLmZsb29yKG4pO1xuXHQgICAgICogfSk7XG5cdCAgICAgKiAvLyA9PiB7ICc0JzogWzQuMl0sICc2JzogWzYuMSwgNi40XSB9XG5cdCAgICAgKlxuXHQgICAgICogXy5ncm91cEJ5KFs0LjIsIDYuMSwgNi40XSwgZnVuY3Rpb24obikge1xuXHQgICAgICogICByZXR1cm4gdGhpcy5mbG9vcihuKTtcblx0ICAgICAqIH0sIE1hdGgpO1xuXHQgICAgICogLy8gPT4geyAnNCc6IFs0LjJdLCAnNic6IFs2LjEsIDYuNF0gfVxuXHQgICAgICpcblx0ICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG5cdCAgICAgKiBfLmdyb3VwQnkoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sICdsZW5ndGgnKTtcblx0ICAgICAqIC8vID0+IHsgJzMnOiBbJ29uZScsICd0d28nXSwgJzUnOiBbJ3RocmVlJ10gfVxuXHQgICAgICovXG5cdCAgICB2YXIgZ3JvdXBCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG5cdCAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSkge1xuXHQgICAgICAgIHJlc3VsdFtrZXldLnB1c2godmFsdWUpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJlc3VsdFtrZXldID0gW3ZhbHVlXTtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiBgY29sbGVjdGlvbmAgdXNpbmdcblx0ICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG5cdCAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIElmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBpdCBpcyB1c2VkIGFzIHRoZSBvZmZzZXRcblx0ICAgICAqIGZyb20gdGhlIGVuZCBvZiBgY29sbGVjdGlvbmAuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBhbGlhcyBjb250YWlucywgaW5jbHVkZVxuXHQgICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cblx0ICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzZWFyY2guXG5cdCAgICAgKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cblx0ICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cblx0ICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5yZWR1Y2VgLlxuXHQgICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGEgbWF0Y2hpbmcgZWxlbWVudCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBfLmluY2x1ZGVzKFsxLCAyLCAzXSwgMSk7XG5cdCAgICAgKiAvLyA9PiB0cnVlXG5cdCAgICAgKlxuXHQgICAgICogXy5pbmNsdWRlcyhbMSwgMiwgM10sIDEsIDIpO1xuXHQgICAgICogLy8gPT4gZmFsc2Vcblx0ICAgICAqXG5cdCAgICAgKiBfLmluY2x1ZGVzKHsgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiA0MCB9LCAnZnJlZCcpO1xuXHQgICAgICogLy8gPT4gdHJ1ZVxuXHQgICAgICpcblx0ICAgICAqIF8uaW5jbHVkZXMoJ3BlYmJsZXMnLCAnZWInKTtcblx0ICAgICAqIC8vID0+IHRydWVcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gaW5jbHVkZXMoY29sbGVjdGlvbiwgdGFyZ2V0LCBmcm9tSW5kZXgsIGd1YXJkKSB7XG5cdCAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uID8gZ2V0TGVuZ3RoKGNvbGxlY3Rpb24pIDogMDtcblx0ICAgICAgaWYgKCFpc0xlbmd0aChsZW5ndGgpKSB7XG5cdCAgICAgICAgY29sbGVjdGlvbiA9IHZhbHVlcyhjb2xsZWN0aW9uKTtcblx0ICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblx0ICAgICAgfVxuXHQgICAgICBpZiAodHlwZW9mIGZyb21JbmRleCAhPSAnbnVtYmVyJyB8fCAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwodGFyZ2V0LCBmcm9tSW5kZXgsIGd1YXJkKSkpIHtcblx0ICAgICAgICBmcm9tSW5kZXggPSAwO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGZyb21JbmRleCA9IGZyb21JbmRleCA8IDAgPyBuYXRpdmVNYXgobGVuZ3RoICsgZnJvbUluZGV4LCAwKSA6IChmcm9tSW5kZXggfHwgMCk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuICh0eXBlb2YgY29sbGVjdGlvbiA9PSAnc3RyaW5nJyB8fCAhaXNBcnJheShjb2xsZWN0aW9uKSAmJiBpc1N0cmluZyhjb2xsZWN0aW9uKSlcblx0ICAgICAgICA/IChmcm9tSW5kZXggPD0gbGVuZ3RoICYmIGNvbGxlY3Rpb24uaW5kZXhPZih0YXJnZXQsIGZyb21JbmRleCkgPiAtMSlcblx0ICAgICAgICA6ICghIWxlbmd0aCAmJiBnZXRJbmRleE9mKGNvbGxlY3Rpb24sIHRhcmdldCwgZnJvbUluZGV4KSA+IC0xKTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuXHQgICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJvdWdoIGBpdGVyYXRlZWAuIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlXG5cdCAgICAgKiBvZiBlYWNoIGtleSBpcyB0aGUgbGFzdCBlbGVtZW50IHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZSBrZXkuIFRoZVxuXHQgICAgICogaXRlcmF0ZWUgZnVuY3Rpb24gaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuXHQgICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuXHQgICAgICpcblx0ICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcblx0ICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuXHQgICAgICpcblx0ICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcblx0ICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuXHQgICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cblx0ICAgICAqXG5cdCAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcblx0ICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG5cdCAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cblx0ICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuXHQgICAgICogIHBlciBpdGVyYXRpb24uXG5cdCAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cblx0ICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIHZhciBrZXlEYXRhID0gW1xuXHQgICAgICogICB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSxcblx0ICAgICAqICAgeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfVxuXHQgICAgICogXTtcblx0ICAgICAqXG5cdCAgICAgKiBfLmluZGV4Qnkoa2V5RGF0YSwgJ2RpcicpO1xuXHQgICAgICogLy8gPT4geyAnbGVmdCc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAncmlnaHQnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cblx0ICAgICAqXG5cdCAgICAgKiBfLmluZGV4Qnkoa2V5RGF0YSwgZnVuY3Rpb24ob2JqZWN0KSB7XG5cdCAgICAgKiAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG9iamVjdC5jb2RlKTtcblx0ICAgICAqIH0pO1xuXHQgICAgICogLy8gPT4geyAnYSc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAnZCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuXHQgICAgICpcblx0ICAgICAqIF8uaW5kZXhCeShrZXlEYXRhLCBmdW5jdGlvbihvYmplY3QpIHtcblx0ICAgICAqICAgcmV0dXJuIHRoaXMuZnJvbUNoYXJDb2RlKG9iamVjdC5jb2RlKTtcblx0ICAgICAqIH0sIFN0cmluZyk7XG5cdCAgICAgKiAvLyA9PiB7ICdhJzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdkJzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG5cdCAgICAgKi9cblx0ICAgIHZhciBpbmRleEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcblx0ICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcblx0ICAgIH0pO1xuXHRcblx0ICAgIC8qKlxuXHQgICAgICogSW52b2tlcyB0aGUgbWV0aG9kIGF0IGBwYXRoYCBvZiBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gLCByZXR1cm5pbmdcblx0ICAgICAqIGFuIGFycmF5IG9mIHRoZSByZXN1bHRzIG9mIGVhY2ggaW52b2tlZCBtZXRob2QuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50c1xuXHQgICAgICogYXJlIHByb3ZpZGVkIHRvIGVhY2ggaW52b2tlZCBtZXRob2QuIElmIGBtZXRob2ROYW1lYCBpcyBhIGZ1bmN0aW9uIGl0IGlzXG5cdCAgICAgKiBpbnZva2VkIGZvciwgYW5kIGB0aGlzYCBib3VuZCB0bywgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cblx0ICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbWV0aG9kIHRvIGludm9rZSBvclxuXHQgICAgICogIHRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG5cdCAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG5cdCAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIF8uaW52b2tlKFtbNSwgMSwgN10sIFszLCAyLCAxXV0sICdzb3J0Jyk7XG5cdCAgICAgKiAvLyA9PiBbWzEsIDUsIDddLCBbMSwgMiwgM11dXG5cdCAgICAgKlxuXHQgICAgICogXy5pbnZva2UoWzEyMywgNDU2XSwgU3RyaW5nLnByb3RvdHlwZS5zcGxpdCwgJycpO1xuXHQgICAgICogLy8gPT4gW1snMScsICcyJywgJzMnXSwgWyc0JywgJzUnLCAnNiddXVxuXHQgICAgICovXG5cdCAgICB2YXIgaW52b2tlID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHBhdGgsIGFyZ3MpIHtcblx0ICAgICAgdmFyIGluZGV4ID0gLTEsXG5cdCAgICAgICAgICBpc0Z1bmMgPSB0eXBlb2YgcGF0aCA9PSAnZnVuY3Rpb24nLFxuXHQgICAgICAgICAgaXNQcm9wID0gaXNLZXkocGF0aCksXG5cdCAgICAgICAgICByZXN1bHQgPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IEFycmF5KGNvbGxlY3Rpb24ubGVuZ3RoKSA6IFtdO1xuXHRcblx0ICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgICB2YXIgZnVuYyA9IGlzRnVuYyA/IHBhdGggOiAoKGlzUHJvcCAmJiB2YWx1ZSAhPSBudWxsKSA/IHZhbHVlW3BhdGhdIDogdW5kZWZpbmVkKTtcblx0ICAgICAgICByZXN1bHRbKytpbmRleF0gPSBmdW5jID8gZnVuYy5hcHBseSh2YWx1ZSwgYXJncykgOiBpbnZva2VQYXRoKHZhbHVlLCBwYXRoLCBhcmdzKTtcblx0ICAgICAgfSk7XG5cdCAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9KTtcblx0XG5cdCAgICAvKipcblx0ICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJvdWdoXG5cdCAgICAgKiBgaXRlcmF0ZWVgLiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuXHQgICAgICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG5cdCAgICAgKlxuXHQgICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuXHQgICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG5cdCAgICAgKlxuXHQgICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuXHQgICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG5cdCAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuXHQgICAgICpcblx0ICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuXHQgICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cblx0ICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuXHQgICAgICpcblx0ICAgICAqIE1hbnkgbG9kYXNoIG1ldGhvZHMgYXJlIGd1YXJkZWQgdG8gd29yayBhcyBpdGVyYXRlZXMgZm9yIG1ldGhvZHMgbGlrZVxuXHQgICAgICogYF8uZXZlcnlgLCBgXy5maWx0ZXJgLCBgXy5tYXBgLCBgXy5tYXBWYWx1ZXNgLCBgXy5yZWplY3RgLCBhbmQgYF8uc29tZWAuXG5cdCAgICAgKlxuXHQgICAgICogVGhlIGd1YXJkZWQgbWV0aG9kcyBhcmU6XG5cdCAgICAgKiBgYXJ5YCwgYGNhbGxiYWNrYCwgYGNodW5rYCwgYGNsb25lYCwgYGNyZWF0ZWAsIGBjdXJyeWAsIGBjdXJyeVJpZ2h0YCxcblx0ICAgICAqIGBkcm9wYCwgYGRyb3BSaWdodGAsIGBldmVyeWAsIGBmaWxsYCwgYGZsYXR0ZW5gLCBgaW52ZXJ0YCwgYG1heGAsIGBtaW5gLFxuXHQgICAgICogYHBhcnNlSW50YCwgYHNsaWNlYCwgYHNvcnRCeWAsIGB0YWtlYCwgYHRha2VSaWdodGAsIGB0ZW1wbGF0ZWAsIGB0cmltYCxcblx0ICAgICAqIGB0cmltTGVmdGAsIGB0cmltUmlnaHRgLCBgdHJ1bmNgLCBgcmFuZG9tYCwgYHJhbmdlYCwgYHNhbXBsZWAsIGBzb21lYCxcblx0ICAgICAqIGBzdW1gLCBgdW5pcWAsIGFuZCBgd29yZHNgXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBhbGlhcyBjb2xsZWN0XG5cdCAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuXHQgICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkXG5cdCAgICAgKiAgcGVyIGl0ZXJhdGlvbi5cblx0ICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuXHQgICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBmdW5jdGlvbiB0aW1lc1RocmVlKG4pIHtcblx0ICAgICAqICAgcmV0dXJuIG4gKiAzO1xuXHQgICAgICogfVxuXHQgICAgICpcblx0ICAgICAqIF8ubWFwKFsxLCAyXSwgdGltZXNUaHJlZSk7XG5cdCAgICAgKiAvLyA9PiBbMywgNl1cblx0ICAgICAqXG5cdCAgICAgKiBfLm1hcCh7ICdhJzogMSwgJ2InOiAyIH0sIHRpbWVzVGhyZWUpO1xuXHQgICAgICogLy8gPT4gWzMsIDZdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG5cdCAgICAgKlxuXHQgICAgICogdmFyIHVzZXJzID0gW1xuXHQgICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScgfSxcblx0ICAgICAqICAgeyAndXNlcic6ICdmcmVkJyB9XG5cdCAgICAgKiBdO1xuXHQgICAgICpcblx0ICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG5cdCAgICAgKiBfLm1hcCh1c2VycywgJ3VzZXInKTtcblx0ICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIHRoaXNBcmcpIHtcblx0ICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlNYXAgOiBiYXNlTWFwO1xuXHQgICAgICBpdGVyYXRlZSA9IGdldENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCAzKTtcblx0ICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cyBzcGxpdCBpbnRvIHR3byBncm91cHMsIHRoZSBmaXJzdCBvZiB3aGljaFxuXHQgICAgICogY29udGFpbnMgZWxlbWVudHMgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLCB3aGlsZSB0aGUgc2Vjb25kIG9mIHdoaWNoXG5cdCAgICAgKiBjb250YWlucyBlbGVtZW50cyBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgYm91bmRcblx0ICAgICAqIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuXHQgICAgICpcblx0ICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG5cdCAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cblx0ICAgICAqXG5cdCAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG5cdCAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcblx0ICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG5cdCAgICAgKlxuXHQgICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuXHQgICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cblx0ICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuXHQgICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuXHQgICAgICogIHBlciBpdGVyYXRpb24uXG5cdCAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG5cdCAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIF8ucGFydGl0aW9uKFsxLCAyLCAzXSwgZnVuY3Rpb24obikge1xuXHQgICAgICogICByZXR1cm4gbiAlIDI7XG5cdCAgICAgKiB9KTtcblx0ICAgICAqIC8vID0+IFtbMSwgM10sIFsyXV1cblx0ICAgICAqXG5cdCAgICAgKiBfLnBhcnRpdGlvbihbMS4yLCAyLjMsIDMuNF0sIGZ1bmN0aW9uKG4pIHtcblx0ICAgICAqICAgcmV0dXJuIHRoaXMuZmxvb3IobikgJSAyO1xuXHQgICAgICogfSwgTWF0aCk7XG5cdCAgICAgKiAvLyA9PiBbWzEuMiwgMy40XSwgWzIuM11dXG5cdCAgICAgKlxuXHQgICAgICogdmFyIHVzZXJzID0gW1xuXHQgICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxuXHQgICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlIH0sXG5cdCAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IGZhbHNlIH1cblx0ICAgICAqIF07XG5cdCAgICAgKlxuXHQgICAgICogdmFyIG1hcHBlciA9IGZ1bmN0aW9uKGFycmF5KSB7XG5cdCAgICAgKiAgIHJldHVybiBfLnBsdWNrKGFycmF5LCAndXNlcicpO1xuXHQgICAgICogfTtcblx0ICAgICAqXG5cdCAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG5cdCAgICAgKiBfLm1hcChfLnBhcnRpdGlvbih1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IGZhbHNlIH0pLCBtYXBwZXIpO1xuXHQgICAgICogLy8gPT4gW1sncGViYmxlcyddLCBbJ2Jhcm5leScsICdmcmVkJ11dXG5cdCAgICAgKlxuXHQgICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG5cdCAgICAgKiBfLm1hcChfLnBhcnRpdGlvbih1c2VycywgJ2FjdGl2ZScsIGZhbHNlKSwgbWFwcGVyKTtcblx0ICAgICAqIC8vID0+IFtbJ2Jhcm5leScsICdwZWJibGVzJ10sIFsnZnJlZCddXVxuXHQgICAgICpcblx0ICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG5cdCAgICAgKiBfLm1hcChfLnBhcnRpdGlvbih1c2VycywgJ2FjdGl2ZScpLCBtYXBwZXIpO1xuXHQgICAgICogLy8gPT4gW1snZnJlZCddLCBbJ2Jhcm5leScsICdwZWJibGVzJ11dXG5cdCAgICAgKi9cblx0ICAgIHZhciBwYXJ0aXRpb24gPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuXHQgICAgICByZXN1bHRba2V5ID8gMCA6IDFdLnB1c2godmFsdWUpO1xuXHQgICAgfSwgZnVuY3Rpb24oKSB7IHJldHVybiBbW10sIFtdXTsgfSk7XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBHZXRzIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiBgcGF0aGAgZnJvbSBhbGwgZWxlbWVudHMgaW4gYGNvbGxlY3Rpb25gLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuXHQgICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cblx0ICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBwbHVjay5cblx0ICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWVzLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiB2YXIgdXNlcnMgPSBbXG5cdCAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG5cdCAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cblx0ICAgICAqIF07XG5cdCAgICAgKlxuXHQgICAgICogXy5wbHVjayh1c2VycywgJ3VzZXInKTtcblx0ICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuXHQgICAgICpcblx0ICAgICAqIHZhciB1c2VySW5kZXggPSBfLmluZGV4QnkodXNlcnMsICd1c2VyJyk7XG5cdCAgICAgKiBfLnBsdWNrKHVzZXJJbmRleCwgJ2FnZScpO1xuXHQgICAgICogLy8gPT4gWzM2LCA0MF0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gcGx1Y2soY29sbGVjdGlvbiwgcGF0aCkge1xuXHQgICAgICByZXR1cm4gbWFwKGNvbGxlY3Rpb24sIHByb3BlcnR5KHBhdGgpKTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFJlZHVjZXMgYGNvbGxlY3Rpb25gIHRvIGEgdmFsdWUgd2hpY2ggaXMgdGhlIGFjY3VtdWxhdGVkIHJlc3VsdCBvZiBydW5uaW5nXG5cdCAgICAgKiBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gIHRocm91Z2ggYGl0ZXJhdGVlYCwgd2hlcmUgZWFjaCBzdWNjZXNzaXZlXG5cdCAgICAgKiBpbnZvY2F0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLiBJZiBgYWNjdW11bGF0b3JgXG5cdCAgICAgKiBpcyBub3QgcHJvdmlkZWQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIGlzIHVzZWQgYXMgdGhlIGluaXRpYWxcblx0ICAgICAqIHZhbHVlLiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czpcblx0ICAgICAqIChhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG5cdCAgICAgKlxuXHQgICAgICogTWFueSBsb2Rhc2ggbWV0aG9kcyBhcmUgZ3VhcmRlZCB0byB3b3JrIGFzIGl0ZXJhdGVlcyBmb3IgbWV0aG9kcyBsaWtlXG5cdCAgICAgKiBgXy5yZWR1Y2VgLCBgXy5yZWR1Y2VSaWdodGAsIGFuZCBgXy50cmFuc2Zvcm1gLlxuXHQgICAgICpcblx0ICAgICAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuXHQgICAgICogYGFzc2lnbmAsIGBkZWZhdWx0c2AsIGBkZWZhdWx0c0RlZXBgLCBgaW5jbHVkZXNgLCBgbWVyZ2VgLCBgc29ydEJ5QWxsYCxcblx0ICAgICAqIGFuZCBgc29ydEJ5T3JkZXJgXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBhbGlhcyBmb2xkbCwgaW5qZWN0XG5cdCAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuXHQgICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuXHQgICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuXHQgICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG5cdCAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIF8ucmVkdWNlKFsxLCAyXSwgZnVuY3Rpb24odG90YWwsIG4pIHtcblx0ICAgICAqICAgcmV0dXJuIHRvdGFsICsgbjtcblx0ICAgICAqIH0pO1xuXHQgICAgICogLy8gPT4gM1xuXHQgICAgICpcblx0ICAgICAqIF8ucmVkdWNlKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24ocmVzdWx0LCBuLCBrZXkpIHtcblx0ICAgICAqICAgcmVzdWx0W2tleV0gPSBuICogMztcblx0ICAgICAqICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAqIH0sIHt9KTtcblx0ICAgICAqIC8vID0+IHsgJ2EnOiAzLCAnYic6IDYgfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuXHQgICAgICovXG5cdCAgICB2YXIgcmVkdWNlID0gY3JlYXRlUmVkdWNlKGFycmF5UmVkdWNlLCBiYXNlRWFjaCk7XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnJlZHVjZWAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuXHQgICAgICogYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGFsaWFzIGZvbGRyXG5cdCAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuXHQgICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuXHQgICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuXHQgICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG5cdCAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIHZhciBhcnJheSA9IFtbMCwgMV0sIFsyLCAzXSwgWzQsIDVdXTtcblx0ICAgICAqXG5cdCAgICAgKiBfLnJlZHVjZVJpZ2h0KGFycmF5LCBmdW5jdGlvbihmbGF0dGVuZWQsIG90aGVyKSB7XG5cdCAgICAgKiAgIHJldHVybiBmbGF0dGVuZWQuY29uY2F0KG90aGVyKTtcblx0ICAgICAqIH0sIFtdKTtcblx0ICAgICAqIC8vID0+IFs0LCA1LCAyLCAzLCAwLCAxXVxuXHQgICAgICovXG5cdCAgICB2YXIgcmVkdWNlUmlnaHQgPSBjcmVhdGVSZWR1Y2UoYXJyYXlSZWR1Y2VSaWdodCwgYmFzZUVhY2hSaWdodCk7XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8uZmlsdGVyYDsgdGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gXG5cdCAgICAgKiB0aGF0IGBwcmVkaWNhdGVgIGRvZXMgKipub3QqKiByZXR1cm4gdHJ1dGh5IGZvci5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cblx0ICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcblx0ICAgICAqICBwZXIgaXRlcmF0aW9uLlxuXHQgICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuXHQgICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIF8ucmVqZWN0KFsxLCAyLCAzLCA0XSwgZnVuY3Rpb24obikge1xuXHQgICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcblx0ICAgICAqIH0pO1xuXHQgICAgICogLy8gPT4gWzEsIDNdXG5cdCAgICAgKlxuXHQgICAgICogdmFyIHVzZXJzID0gW1xuXHQgICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG5cdCAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9XG5cdCAgICAgKiBdO1xuXHQgICAgICpcblx0ICAgICAqIC8vIHVzaW5nIHRoZSBgXy5tYXRjaGVzYCBjYWxsYmFjayBzaG9ydGhhbmRcblx0ICAgICAqIF8ucGx1Y2soXy5yZWplY3QodXNlcnMsIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9KSwgJ3VzZXInKTtcblx0ICAgICAqIC8vID0+IFsnYmFybmV5J11cblx0ICAgICAqXG5cdCAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcblx0ICAgICAqIF8ucGx1Y2soXy5yZWplY3QodXNlcnMsICdhY3RpdmUnLCBmYWxzZSksICd1c2VyJyk7XG5cdCAgICAgKiAvLyA9PiBbJ2ZyZWQnXVxuXHQgICAgICpcblx0ICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG5cdCAgICAgKiBfLnBsdWNrKF8ucmVqZWN0KHVzZXJzLCAnYWN0aXZlJyksICd1c2VyJyk7XG5cdCAgICAgKiAvLyA9PiBbJ2Jhcm5leSddXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIHJlamVjdChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcblx0ICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlGaWx0ZXIgOiBiYXNlRmlsdGVyO1xuXHQgICAgICBwcmVkaWNhdGUgPSBnZXRDYWxsYmFjayhwcmVkaWNhdGUsIHRoaXNBcmcsIDMpO1xuXHQgICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcblx0ICAgICAgICByZXR1cm4gIXByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuXHQgICAgICB9KTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIEdldHMgYSByYW5kb20gZWxlbWVudCBvciBgbmAgcmFuZG9tIGVsZW1lbnRzIGZyb20gYSBjb2xsZWN0aW9uLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuXHQgICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cblx0ICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbl0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzYW1wbGUuXG5cdCAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cblx0ICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByYW5kb20gc2FtcGxlKHMpLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBfLnNhbXBsZShbMSwgMiwgMywgNF0pO1xuXHQgICAgICogLy8gPT4gMlxuXHQgICAgICpcblx0ICAgICAqIF8uc2FtcGxlKFsxLCAyLCAzLCA0XSwgMik7XG5cdCAgICAgKiAvLyA9PiBbMywgMV1cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gc2FtcGxlKGNvbGxlY3Rpb24sIG4sIGd1YXJkKSB7XG5cdCAgICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIG4sIGd1YXJkKSA6IG4gPT0gbnVsbCkge1xuXHQgICAgICAgIGNvbGxlY3Rpb24gPSB0b0l0ZXJhYmxlKGNvbGxlY3Rpb24pO1xuXHQgICAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblx0ICAgICAgICByZXR1cm4gbGVuZ3RoID4gMCA/IGNvbGxlY3Rpb25bYmFzZVJhbmRvbSgwLCBsZW5ndGggLSAxKV0gOiB1bmRlZmluZWQ7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIGluZGV4ID0gLTEsXG5cdCAgICAgICAgICByZXN1bHQgPSB0b0FycmF5KGNvbGxlY3Rpb24pLFxuXHQgICAgICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aCxcblx0ICAgICAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG5cdFxuXHQgICAgICBuID0gbmF0aXZlTWluKG4gPCAwID8gMCA6ICgrbiB8fCAwKSwgbGVuZ3RoKTtcblx0ICAgICAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG5cdCAgICAgICAgdmFyIHJhbmQgPSBiYXNlUmFuZG9tKGluZGV4LCBsYXN0SW5kZXgpLFxuXHQgICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdFtyYW5kXTtcblx0XG5cdCAgICAgICAgcmVzdWx0W3JhbmRdID0gcmVzdWx0W2luZGV4XTtcblx0ICAgICAgICByZXN1bHRbaW5kZXhdID0gdmFsdWU7XG5cdCAgICAgIH1cblx0ICAgICAgcmVzdWx0Lmxlbmd0aCA9IG47XG5cdCAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHNodWZmbGVkIHZhbHVlcywgdXNpbmcgYSB2ZXJzaW9uIG9mIHRoZVxuXHQgICAgICogW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXItWWF0ZXNfc2h1ZmZsZSkuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cblx0ICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBfLnNodWZmbGUoWzEsIDIsIDMsIDRdKTtcblx0ICAgICAqIC8vID0+IFs0LCAxLCAzLCAyXVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBzaHVmZmxlKGNvbGxlY3Rpb24pIHtcblx0ICAgICAgcmV0dXJuIHNhbXBsZShjb2xsZWN0aW9uLCBQT1NJVElWRV9JTkZJTklUWSk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBHZXRzIHRoZSBzaXplIG9mIGBjb2xsZWN0aW9uYCBieSByZXR1cm5pbmcgaXRzIGxlbmd0aCBmb3IgYXJyYXktbGlrZVxuXHQgICAgICogdmFsdWVzIG9yIHRoZSBudW1iZXIgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBmb3Igb2JqZWN0cy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cblx0ICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuXHQgICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc2l6ZSBvZiBgY29sbGVjdGlvbmAuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIF8uc2l6ZShbMSwgMiwgM10pO1xuXHQgICAgICogLy8gPT4gM1xuXHQgICAgICpcblx0ICAgICAqIF8uc2l6ZSh7ICdhJzogMSwgJ2InOiAyIH0pO1xuXHQgICAgICogLy8gPT4gMlxuXHQgICAgICpcblx0ICAgICAqIF8uc2l6ZSgncGViYmxlcycpO1xuXHQgICAgICogLy8gPT4gN1xuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBzaXplKGNvbGxlY3Rpb24pIHtcblx0ICAgICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBnZXRMZW5ndGgoY29sbGVjdGlvbikgOiAwO1xuXHQgICAgICByZXR1cm4gaXNMZW5ndGgobGVuZ3RoKSA/IGxlbmd0aCA6IGtleXMoY29sbGVjdGlvbikubGVuZ3RoO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ2hlY2tzIGlmIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciAqKmFueSoqIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gLlxuXHQgICAgICogVGhlIGZ1bmN0aW9uIHJldHVybnMgYXMgc29vbiBhcyBpdCBmaW5kcyBhIHBhc3NpbmcgdmFsdWUgYW5kIGRvZXMgbm90IGl0ZXJhdGVcblx0ICAgICAqIG92ZXIgdGhlIGVudGlyZSBjb2xsZWN0aW9uLiBUaGUgcHJlZGljYXRlIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZFxuXHQgICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cblx0ICAgICAqXG5cdCAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuXHQgICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG5cdCAgICAgKlxuXHQgICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuXHQgICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG5cdCAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuXHQgICAgICpcblx0ICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcblx0ICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG5cdCAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGFsaWFzIGFueVxuXHQgICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cblx0ICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcblx0ICAgICAqICBwZXIgaXRlcmF0aW9uLlxuXHQgICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuXHQgICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuXHQgICAgICogIGVsc2UgYGZhbHNlYC5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogXy5zb21lKFtudWxsLCAwLCAneWVzJywgZmFsc2VdLCBCb29sZWFuKTtcblx0ICAgICAqIC8vID0+IHRydWVcblx0ICAgICAqXG5cdCAgICAgKiB2YXIgdXNlcnMgPSBbXG5cdCAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IHRydWUgfSxcblx0ICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWN0aXZlJzogZmFsc2UgfVxuXHQgICAgICogXTtcblx0ICAgICAqXG5cdCAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG5cdCAgICAgKiBfLnNvbWUodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuXHQgICAgICogLy8gPT4gZmFsc2Vcblx0ICAgICAqXG5cdCAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcblx0ICAgICAqIF8uc29tZSh1c2VycywgJ2FjdGl2ZScsIGZhbHNlKTtcblx0ICAgICAqIC8vID0+IHRydWVcblx0ICAgICAqXG5cdCAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuXHQgICAgICogXy5zb21lKHVzZXJzLCAnYWN0aXZlJyk7XG5cdCAgICAgKiAvLyA9PiB0cnVlXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIHNvbWUoY29sbGVjdGlvbiwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG5cdCAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U29tZSA6IGJhc2VTb21lO1xuXHQgICAgICBpZiAodGhpc0FyZyAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIHRoaXNBcmcpKSB7XG5cdCAgICAgICAgcHJlZGljYXRlID0gdW5kZWZpbmVkO1xuXHQgICAgICB9XG5cdCAgICAgIGlmICh0eXBlb2YgcHJlZGljYXRlICE9ICdmdW5jdGlvbicgfHwgdGhpc0FyZyAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgcHJlZGljYXRlID0gZ2V0Q2FsbGJhY2socHJlZGljYXRlLCB0aGlzQXJnLCAzKTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBwcmVkaWNhdGUpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cywgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlciBieSB0aGUgcmVzdWx0cyBvZlxuXHQgICAgICogcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYSBjb2xsZWN0aW9uIHRocm91Z2ggYGl0ZXJhdGVlYC4gVGhpcyBtZXRob2QgcGVyZm9ybXNcblx0ICAgICAqIGEgc3RhYmxlIHNvcnQsIHRoYXQgaXMsIGl0IHByZXNlcnZlcyB0aGUgb3JpZ2luYWwgc29ydCBvcmRlciBvZiBlcXVhbCBlbGVtZW50cy5cblx0ICAgICAqIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcblx0ICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cblx0ICAgICAqXG5cdCAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG5cdCAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cblx0ICAgICAqXG5cdCAgICAgKiBJZiBhIHZhbHVlIGlzIGFsc28gcHJvdmlkZWQgZm9yIGB0aGlzQXJnYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzUHJvcGVydHlgXG5cdCAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGEgbWF0Y2hpbmcgcHJvcGVydHlcblx0ICAgICAqIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG5cdCAgICAgKlxuXHQgICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG5cdCAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuXHQgICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcblx0ICAgICAqICBwZXIgaXRlcmF0aW9uLlxuXHQgICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG5cdCAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIF8uc29ydEJ5KFsxLCAyLCAzXSwgZnVuY3Rpb24obikge1xuXHQgICAgICogICByZXR1cm4gTWF0aC5zaW4obik7XG5cdCAgICAgKiB9KTtcblx0ICAgICAqIC8vID0+IFszLCAxLCAyXVxuXHQgICAgICpcblx0ICAgICAqIF8uc29ydEJ5KFsxLCAyLCAzXSwgZnVuY3Rpb24obikge1xuXHQgICAgICogICByZXR1cm4gdGhpcy5zaW4obik7XG5cdCAgICAgKiB9LCBNYXRoKTtcblx0ICAgICAqIC8vID0+IFszLCAxLCAyXVxuXHQgICAgICpcblx0ICAgICAqIHZhciB1c2VycyA9IFtcblx0ICAgICAqICAgeyAndXNlcic6ICdmcmVkJyB9LFxuXHQgICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnIH0sXG5cdCAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JyB9XG5cdCAgICAgKiBdO1xuXHQgICAgICpcblx0ICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG5cdCAgICAgKiBfLnBsdWNrKF8uc29ydEJ5KHVzZXJzLCAndXNlcicpLCAndXNlcicpO1xuXHQgICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCcsICdwZWJibGVzJ11cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gc29ydEJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG5cdCAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcblx0ICAgICAgICByZXR1cm4gW107XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHRoaXNBcmcgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIHRoaXNBcmcpKSB7XG5cdCAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIGluZGV4ID0gLTE7XG5cdCAgICAgIGl0ZXJhdGVlID0gZ2V0Q2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDMpO1xuXHRcblx0ICAgICAgdmFyIHJlc3VsdCA9IGJhc2VNYXAoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuXHQgICAgICAgIHJldHVybiB7ICdjcml0ZXJpYSc6IGl0ZXJhdGVlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pLCAnaW5kZXgnOiArK2luZGV4LCAndmFsdWUnOiB2YWx1ZSB9O1xuXHQgICAgICB9KTtcblx0ICAgICAgcmV0dXJuIGJhc2VTb3J0QnkocmVzdWx0LCBjb21wYXJlQXNjZW5kaW5nKTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydEJ5YCBleGNlcHQgdGhhdCBpdCBjYW4gc29ydCBieSBtdWx0aXBsZSBpdGVyYXRlZXNcblx0ICAgICAqIG9yIHByb3BlcnR5IG5hbWVzLlxuXHQgICAgICpcblx0ICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYW4gaXRlcmF0ZWUgdGhlIGNyZWF0ZWQgYF8ucHJvcGVydHlgXG5cdCAgICAgKiBzdHlsZSBjYWxsYmFjayByZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cblx0ICAgICAqXG5cdCAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGFuIGl0ZXJhdGVlIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG5cdCAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuXHQgICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuXHQgICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXXxPYmplY3R8T2JqZWN0W118c3RyaW5nfHN0cmluZ1tdKX0gaXRlcmF0ZWVzXG5cdCAgICAgKiAgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LCBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCB2YWx1ZXMgb3IgYXJyYXlzIG9mIHZhbHVlcy5cblx0ICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogdmFyIHVzZXJzID0gW1xuXHQgICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0OCB9LFxuXHQgICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuXHQgICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MiB9LFxuXHQgICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNCB9XG5cdCAgICAgKiBdO1xuXHQgICAgICpcblx0ICAgICAqIF8ubWFwKF8uc29ydEJ5QWxsKHVzZXJzLCBbJ3VzZXInLCAnYWdlJ10pLCBfLnZhbHVlcyk7XG5cdCAgICAgKiAvLyA9PiBbWydiYXJuZXknLCAzNF0sIFsnYmFybmV5JywgMzZdLCBbJ2ZyZWQnLCA0Ml0sIFsnZnJlZCcsIDQ4XV1cblx0ICAgICAqXG5cdCAgICAgKiBfLm1hcChfLnNvcnRCeUFsbCh1c2VycywgJ3VzZXInLCBmdW5jdGlvbihjaHIpIHtcblx0ICAgICAqICAgcmV0dXJuIE1hdGguZmxvb3IoY2hyLmFnZSAvIDEwKTtcblx0ICAgICAqIH0pLCBfLnZhbHVlcyk7XG5cdCAgICAgKiAvLyA9PiBbWydiYXJuZXknLCAzNl0sIFsnYmFybmV5JywgMzRdLCBbJ2ZyZWQnLCA0OF0sIFsnZnJlZCcsIDQyXV1cblx0ICAgICAqL1xuXHQgICAgdmFyIHNvcnRCeUFsbCA9IHJlc3RQYXJhbShmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZXMpIHtcblx0ICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuXHQgICAgICAgIHJldHVybiBbXTtcblx0ICAgICAgfVxuXHQgICAgICB2YXIgZ3VhcmQgPSBpdGVyYXRlZXNbMl07XG5cdCAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChpdGVyYXRlZXNbMF0sIGl0ZXJhdGVlc1sxXSwgZ3VhcmQpKSB7XG5cdCAgICAgICAgaXRlcmF0ZWVzLmxlbmd0aCA9IDE7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGJhc2VTb3J0QnlPcmRlcihjb2xsZWN0aW9uLCBiYXNlRmxhdHRlbihpdGVyYXRlZXMpLCBbXSk7XG5cdCAgICB9KTtcblx0XG5cdCAgICAvKipcblx0ICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydEJ5QWxsYCBleGNlcHQgdGhhdCBpdCBhbGxvd3Mgc3BlY2lmeWluZyB0aGVcblx0ICAgICAqIHNvcnQgb3JkZXJzIG9mIHRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS4gSWYgYG9yZGVyc2AgaXMgdW5zcGVjaWZpZWQsIGFsbFxuXHQgICAgICogdmFsdWVzIGFyZSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyLiBPdGhlcndpc2UsIGEgdmFsdWUgaXMgc29ydGVkIGluXG5cdCAgICAgKiBhc2NlbmRpbmcgb3JkZXIgaWYgaXRzIGNvcnJlc3BvbmRpbmcgb3JkZXIgaXMgXCJhc2NcIiwgYW5kIGRlc2NlbmRpbmcgaWYgXCJkZXNjXCIuXG5cdCAgICAgKlxuXHQgICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBhbiBpdGVyYXRlZSB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcblx0ICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuXHQgICAgICpcblx0ICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYW4gaXRlcmF0ZWUgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcblx0ICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG5cdCAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cblx0ICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uW118T2JqZWN0W118c3RyaW5nW119IGl0ZXJhdGVlcyBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG5cdCAgICAgKiBAcGFyYW0ge2Jvb2xlYW5bXX0gW29yZGVyc10gVGhlIHNvcnQgb3JkZXJzIG9mIGBpdGVyYXRlZXNgLlxuXHQgICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLnJlZHVjZWAuXG5cdCAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIHZhciB1c2VycyA9IFtcblx0ICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDggfSxcblx0ICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzQgfSxcblx0ICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDIgfSxcblx0ICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuXHQgICAgICogXTtcblx0ICAgICAqXG5cdCAgICAgKiAvLyBzb3J0IGJ5IGB1c2VyYCBpbiBhc2NlbmRpbmcgb3JkZXIgYW5kIGJ5IGBhZ2VgIGluIGRlc2NlbmRpbmcgb3JkZXJcblx0ICAgICAqIF8ubWFwKF8uc29ydEJ5T3JkZXIodXNlcnMsIFsndXNlcicsICdhZ2UnXSwgWydhc2MnLCAnZGVzYyddKSwgXy52YWx1ZXMpO1xuXHQgICAgICogLy8gPT4gW1snYmFybmV5JywgMzZdLCBbJ2Jhcm5leScsIDM0XSwgWydmcmVkJywgNDhdLCBbJ2ZyZWQnLCA0Ml1dXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIHNvcnRCeU9yZGVyKGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzLCBndWFyZCkge1xuXHQgICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG5cdCAgICAgICAgcmV0dXJuIFtdO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChpdGVyYXRlZXMsIG9yZGVycywgZ3VhcmQpKSB7XG5cdCAgICAgICAgb3JkZXJzID0gdW5kZWZpbmVkO1xuXHQgICAgICB9XG5cdCAgICAgIGlmICghaXNBcnJheShpdGVyYXRlZXMpKSB7XG5cdCAgICAgICAgaXRlcmF0ZWVzID0gaXRlcmF0ZWVzID09IG51bGwgPyBbXSA6IFtpdGVyYXRlZXNdO1xuXHQgICAgICB9XG5cdCAgICAgIGlmICghaXNBcnJheShvcmRlcnMpKSB7XG5cdCAgICAgICAgb3JkZXJzID0gb3JkZXJzID09IG51bGwgPyBbXSA6IFtvcmRlcnNdO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBiYXNlU29ydEJ5T3JkZXIoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogUGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gIGFuZCB0aGVcblx0ICAgICAqIHNvdXJjZSBvYmplY3QsIHJldHVybmluZyBhbiBhcnJheSBvZiBhbGwgZWxlbWVudHMgdGhhdCBoYXZlIGVxdWl2YWxlbnRcblx0ICAgICAqIHByb3BlcnR5IHZhbHVlcy5cblx0ICAgICAqXG5cdCAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2Qgc3VwcG9ydHMgY29tcGFyaW5nIGFycmF5cywgYm9vbGVhbnMsIGBEYXRlYCBvYmplY3RzLFxuXHQgICAgICogbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgYW5kIHN0cmluZ3MuIE9iamVjdHMgYXJlIGNvbXBhcmVkIGJ5XG5cdCAgICAgKiB0aGVpciBvd24sIG5vdCBpbmhlcml0ZWQsIGVudW1lcmFibGUgcHJvcGVydGllcy4gRm9yIGNvbXBhcmluZyBhIHNpbmdsZVxuXHQgICAgICogb3duIG9yIGluaGVyaXRlZCBwcm9wZXJ0eSB2YWx1ZSBzZWUgYF8ubWF0Y2hlc1Byb3BlcnR5YC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cblx0ICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzZWFyY2guXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuXHQgICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIHZhciB1c2VycyA9IFtcblx0ICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSwgJ3BldHMnOiBbJ2hvcHB5J10gfSxcblx0ICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlLCAncGV0cyc6IFsnYmFieSBwdXNzJywgJ2Rpbm8nXSB9XG5cdCAgICAgKiBdO1xuXHQgICAgICpcblx0ICAgICAqIF8ucGx1Y2soXy53aGVyZSh1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9KSwgJ3VzZXInKTtcblx0ICAgICAqIC8vID0+IFsnYmFybmV5J11cblx0ICAgICAqXG5cdCAgICAgKiBfLnBsdWNrKF8ud2hlcmUodXNlcnMsIHsgJ3BldHMnOiBbJ2Rpbm8nXSB9KSwgJ3VzZXInKTtcblx0ICAgICAqIC8vID0+IFsnZnJlZCddXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIHdoZXJlKGNvbGxlY3Rpb24sIHNvdXJjZSkge1xuXHQgICAgICByZXR1cm4gZmlsdGVyKGNvbGxlY3Rpb24sIGJhc2VNYXRjaGVzKHNvdXJjZSkpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblx0XG5cdCAgICAvKipcblx0ICAgICAqIEdldHMgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIFVuaXggZXBvY2hcblx0ICAgICAqICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgRGF0ZVxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG5cdCAgICAgKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG5cdCAgICAgKiB9LCBfLm5vdygpKTtcblx0ICAgICAqIC8vID0+IGxvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGZ1bmN0aW9uIHRvIGJlIGludm9rZWRcblx0ICAgICAqL1xuXHQgICAgdmFyIG5vdyA9IG5hdGl2ZU5vdyB8fCBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXHQgICAgfTtcblx0XG5cdCAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8uYmVmb3JlYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlc1xuXHQgICAgICogYGZ1bmNgIG9uY2UgaXQgaXMgY2FsbGVkIGBuYCBvciBtb3JlIHRpbWVzLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cblx0ICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY2FsbHMgYmVmb3JlIGBmdW5jYCBpcyBpbnZva2VkLlxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG5cdCAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiB2YXIgc2F2ZXMgPSBbJ3Byb2ZpbGUnLCAnc2V0dGluZ3MnXTtcblx0ICAgICAqXG5cdCAgICAgKiB2YXIgZG9uZSA9IF8uYWZ0ZXIoc2F2ZXMubGVuZ3RoLCBmdW5jdGlvbigpIHtcblx0ICAgICAqICAgY29uc29sZS5sb2coJ2RvbmUgc2F2aW5nIScpO1xuXHQgICAgICogfSk7XG5cdCAgICAgKlxuXHQgICAgICogXy5mb3JFYWNoKHNhdmVzLCBmdW5jdGlvbih0eXBlKSB7XG5cdCAgICAgKiAgIGFzeW5jU2F2ZSh7ICd0eXBlJzogdHlwZSwgJ2NvbXBsZXRlJzogZG9uZSB9KTtcblx0ICAgICAqIH0pO1xuXHQgICAgICogLy8gPT4gbG9ncyAnZG9uZSBzYXZpbmchJyBhZnRlciB0aGUgdHdvIGFzeW5jIHNhdmVzIGhhdmUgY29tcGxldGVkXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGFmdGVyKG4sIGZ1bmMpIHtcblx0ICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICBpZiAodHlwZW9mIG4gPT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgdmFyIHRlbXAgPSBuO1xuXHQgICAgICAgICAgbiA9IGZ1bmM7XG5cdCAgICAgICAgICBmdW5jID0gdGVtcDtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICBuID0gbmF0aXZlSXNGaW5pdGUobiA9ICtuKSA/IG4gOiAwO1xuXHQgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgaWYgKC0tbiA8IDEpIHtcblx0ICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9O1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB1cCB0byBgbmAgYXJndW1lbnRzIGlnbm9yaW5nIGFueVxuXHQgICAgICogYWRkaXRpb25hbCBhcmd1bWVudHMuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG5cdCAgICAgKiBAcGFyYW0ge251bWJlcn0gW249ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBjYXAuXG5cdCAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cblx0ICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBfLm1hcChbJzYnLCAnOCcsICcxMCddLCBfLmFyeShwYXJzZUludCwgMSkpO1xuXHQgICAgICogLy8gPT4gWzYsIDgsIDEwXVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBhcnkoZnVuYywgbiwgZ3VhcmQpIHtcblx0ICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGZ1bmMsIG4sIGd1YXJkKSkge1xuXHQgICAgICAgIG4gPSB1bmRlZmluZWQ7XG5cdCAgICAgIH1cblx0ICAgICAgbiA9IChmdW5jICYmIG4gPT0gbnVsbCkgPyBmdW5jLmxlbmd0aCA6IG5hdGl2ZU1heCgrbiB8fCAwLCAwKTtcblx0ICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIoZnVuYywgQVJZX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgbik7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCwgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50c1xuXHQgICAgICogb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24sIHdoaWxlIGl0IGlzIGNhbGxlZCBsZXNzIHRoYW4gYG5gIHRpbWVzLiBTdWJzZXF1ZW50XG5cdCAgICAgKiBjYWxscyB0byB0aGUgY3JlYXRlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgaW52b2NhdGlvbi5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG5cdCAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGNhbGxzIGF0IHdoaWNoIGBmdW5jYCBpcyBubyBsb25nZXIgaW52b2tlZC5cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuXHQgICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogalF1ZXJ5KCcjYWRkJykub24oJ2NsaWNrJywgXy5iZWZvcmUoNSwgYWRkQ29udGFjdFRvTGlzdCkpO1xuXHQgICAgICogLy8gPT4gYWxsb3dzIGFkZGluZyB1cCB0byA0IGNvbnRhY3RzIHRvIHRoZSBsaXN0XG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGJlZm9yZShuLCBmdW5jKSB7XG5cdCAgICAgIHZhciByZXN1bHQ7XG5cdCAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiBuID09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgIHZhciB0ZW1wID0gbjtcblx0ICAgICAgICAgIG4gPSBmdW5jO1xuXHQgICAgICAgICAgZnVuYyA9IHRlbXA7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIGlmICgtLW4gPiAwKSB7XG5cdCAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChuIDw9IDEpIHtcblx0ICAgICAgICAgIGZ1bmMgPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgIH07XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2Bcblx0ICAgICAqIGFuZCBwcmVwZW5kcyBhbnkgYWRkaXRpb25hbCBgXy5iaW5kYCBhcmd1bWVudHMgdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlXG5cdCAgICAgKiBib3VuZCBmdW5jdGlvbi5cblx0ICAgICAqXG5cdCAgICAgKiBUaGUgYF8uYmluZC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljIGJ1aWxkcyxcblx0ICAgICAqIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cblx0ICAgICAqXG5cdCAgICAgKiAqKk5vdGU6KiogVW5saWtlIG5hdGl2ZSBgRnVuY3Rpb24jYmluZGAgdGhpcyBtZXRob2QgZG9lcyBub3Qgc2V0IHRoZSBcImxlbmd0aFwiXG5cdCAgICAgKiBwcm9wZXJ0eSBvZiBib3VuZCBmdW5jdGlvbnMuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYmluZC5cblx0ICAgICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuXHQgICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG5cdCAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogdmFyIGdyZWV0ID0gZnVuY3Rpb24oZ3JlZXRpbmcsIHB1bmN0dWF0aW9uKSB7XG5cdCAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xuXHQgICAgICogfTtcblx0ICAgICAqXG5cdCAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJyB9O1xuXHQgICAgICpcblx0ICAgICAqIHZhciBib3VuZCA9IF8uYmluZChncmVldCwgb2JqZWN0LCAnaGknKTtcblx0ICAgICAqIGJvdW5kKCchJyk7XG5cdCAgICAgKiAvLyA9PiAnaGkgZnJlZCEnXG5cdCAgICAgKlxuXHQgICAgICogLy8gdXNpbmcgcGxhY2Vob2xkZXJzXG5cdCAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmQoZ3JlZXQsIG9iamVjdCwgXywgJyEnKTtcblx0ICAgICAqIGJvdW5kKCdoaScpO1xuXHQgICAgICogLy8gPT4gJ2hpIGZyZWQhJ1xuXHQgICAgICovXG5cdCAgICB2YXIgYmluZCA9IHJlc3RQYXJhbShmdW5jdGlvbihmdW5jLCB0aGlzQXJnLCBwYXJ0aWFscykge1xuXHQgICAgICB2YXIgYml0bWFzayA9IEJJTkRfRkxBRztcblx0ICAgICAgaWYgKHBhcnRpYWxzLmxlbmd0aCkge1xuXHQgICAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGJpbmQucGxhY2Vob2xkZXIpO1xuXHQgICAgICAgIGJpdG1hc2sgfD0gUEFSVElBTF9GTEFHO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzKTtcblx0ICAgIH0pO1xuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQmluZHMgbWV0aG9kcyBvZiBhbiBvYmplY3QgdG8gdGhlIG9iamVjdCBpdHNlbGYsIG92ZXJ3cml0aW5nIHRoZSBleGlzdGluZ1xuXHQgICAgICogbWV0aG9kLiBNZXRob2QgbmFtZXMgbWF5IGJlIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGFyZ3VtZW50cyBvciBhcyBhcnJheXNcblx0ICAgICAqIG9mIG1ldGhvZCBuYW1lcy4gSWYgbm8gbWV0aG9kIG5hbWVzIGFyZSBwcm92aWRlZCBhbGwgZW51bWVyYWJsZSBmdW5jdGlvblxuXHQgICAgICogcHJvcGVydGllcywgb3duIGFuZCBpbmhlcml0ZWQsIG9mIGBvYmplY3RgIGFyZSBib3VuZC5cblx0ICAgICAqXG5cdCAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lcyBub3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIGJvdW5kIGZ1bmN0aW9ucy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmluZCBhbmQgYXNzaWduIHRoZSBib3VuZCBtZXRob2RzIHRvLlxuXHQgICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW21ldGhvZE5hbWVzXSBUaGUgb2JqZWN0IG1ldGhvZCBuYW1lcyB0byBiaW5kLFxuXHQgICAgICogIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIG1ldGhvZCBuYW1lcyBvciBhcnJheXMgb2YgbWV0aG9kIG5hbWVzLlxuXHQgICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogdmFyIHZpZXcgPSB7XG5cdCAgICAgKiAgICdsYWJlbCc6ICdkb2NzJyxcblx0ICAgICAqICAgJ29uQ2xpY2snOiBmdW5jdGlvbigpIHtcblx0ICAgICAqICAgICBjb25zb2xlLmxvZygnY2xpY2tlZCAnICsgdGhpcy5sYWJlbCk7XG5cdCAgICAgKiAgIH1cblx0ICAgICAqIH07XG5cdCAgICAgKlxuXHQgICAgICogXy5iaW5kQWxsKHZpZXcpO1xuXHQgICAgICogalF1ZXJ5KCcjZG9jcycpLm9uKCdjbGljaycsIHZpZXcub25DbGljayk7XG5cdCAgICAgKiAvLyA9PiBsb2dzICdjbGlja2VkIGRvY3MnIHdoZW4gdGhlIGVsZW1lbnQgaXMgY2xpY2tlZFxuXHQgICAgICovXG5cdCAgICB2YXIgYmluZEFsbCA9IHJlc3RQYXJhbShmdW5jdGlvbihvYmplY3QsIG1ldGhvZE5hbWVzKSB7XG5cdCAgICAgIG1ldGhvZE5hbWVzID0gbWV0aG9kTmFtZXMubGVuZ3RoID8gYmFzZUZsYXR0ZW4obWV0aG9kTmFtZXMpIDogZnVuY3Rpb25zKG9iamVjdCk7XG5cdFxuXHQgICAgICB2YXIgaW5kZXggPSAtMSxcblx0ICAgICAgICAgIGxlbmd0aCA9IG1ldGhvZE5hbWVzLmxlbmd0aDtcblx0XG5cdCAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdCAgICAgICAgdmFyIGtleSA9IG1ldGhvZE5hbWVzW2luZGV4XTtcblx0ICAgICAgICBvYmplY3Rba2V5XSA9IGNyZWF0ZVdyYXBwZXIob2JqZWN0W2tleV0sIEJJTkRfRkxBRywgb2JqZWN0KTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gb2JqZWN0O1xuXHQgICAgfSk7XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSBtZXRob2QgYXQgYG9iamVjdFtrZXldYCBhbmQgcHJlcGVuZHNcblx0ICAgICAqIGFueSBhZGRpdGlvbmFsIGBfLmJpbmRLZXlgIGFyZ3VtZW50cyB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgYm91bmQgZnVuY3Rpb24uXG5cdCAgICAgKlxuXHQgICAgICogVGhpcyBtZXRob2QgZGlmZmVycyBmcm9tIGBfLmJpbmRgIGJ5IGFsbG93aW5nIGJvdW5kIGZ1bmN0aW9ucyB0byByZWZlcmVuY2Vcblx0ICAgICAqIG1ldGhvZHMgdGhhdCBtYXkgYmUgcmVkZWZpbmVkIG9yIGRvbid0IHlldCBleGlzdC5cblx0ICAgICAqIFNlZSBbUGV0ZXIgTWljaGF1eCdzIGFydGljbGVdKGh0dHA6Ly9wZXRlci5taWNoYXV4LmNhL2FydGljbGVzL2xhenktZnVuY3Rpb24tZGVmaW5pdGlvbi1wYXR0ZXJuKVxuXHQgICAgICogZm9yIG1vcmUgZGV0YWlscy5cblx0ICAgICAqXG5cdCAgICAgKiBUaGUgYF8uYmluZEtleS5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG5cdCAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdGhlIG1ldGhvZCBiZWxvbmdzIHRvLlxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QuXG5cdCAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cblx0ICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiB2YXIgb2JqZWN0ID0ge1xuXHQgICAgICogICAndXNlcic6ICdmcmVkJyxcblx0ICAgICAqICAgJ2dyZWV0JzogZnVuY3Rpb24oZ3JlZXRpbmcsIHB1bmN0dWF0aW9uKSB7XG5cdCAgICAgKiAgICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgdGhpcy51c2VyICsgcHVuY3R1YXRpb247XG5cdCAgICAgKiAgIH1cblx0ICAgICAqIH07XG5cdCAgICAgKlxuXHQgICAgICogdmFyIGJvdW5kID0gXy5iaW5kS2V5KG9iamVjdCwgJ2dyZWV0JywgJ2hpJyk7XG5cdCAgICAgKiBib3VuZCgnIScpO1xuXHQgICAgICogLy8gPT4gJ2hpIGZyZWQhJ1xuXHQgICAgICpcblx0ICAgICAqIG9iamVjdC5ncmVldCA9IGZ1bmN0aW9uKGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuXHQgICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAneWEgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xuXHQgICAgICogfTtcblx0ICAgICAqXG5cdCAgICAgKiBib3VuZCgnIScpO1xuXHQgICAgICogLy8gPT4gJ2hpeWEgZnJlZCEnXG5cdCAgICAgKlxuXHQgICAgICogLy8gdXNpbmcgcGxhY2Vob2xkZXJzXG5cdCAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmRLZXkob2JqZWN0LCAnZ3JlZXQnLCBfLCAnIScpO1xuXHQgICAgICogYm91bmQoJ2hpJyk7XG5cdCAgICAgKiAvLyA9PiAnaGl5YSBmcmVkISdcblx0ICAgICAqL1xuXHQgICAgdmFyIGJpbmRLZXkgPSByZXN0UGFyYW0oZnVuY3Rpb24ob2JqZWN0LCBrZXksIHBhcnRpYWxzKSB7XG5cdCAgICAgIHZhciBiaXRtYXNrID0gQklORF9GTEFHIHwgQklORF9LRVlfRkxBRztcblx0ICAgICAgaWYgKHBhcnRpYWxzLmxlbmd0aCkge1xuXHQgICAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGJpbmRLZXkucGxhY2Vob2xkZXIpO1xuXHQgICAgICAgIGJpdG1hc2sgfD0gUEFSVElBTF9GTEFHO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKGtleSwgYml0bWFzaywgb2JqZWN0LCBwYXJ0aWFscywgaG9sZGVycyk7XG5cdCAgICB9KTtcblx0XG5cdCAgICAvKipcblx0ICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgb25lIG9yIG1vcmUgYXJndW1lbnRzIG9mIGBmdW5jYCB0aGF0IHdoZW5cblx0ICAgICAqIGNhbGxlZCBlaXRoZXIgaW52b2tlcyBgZnVuY2AgcmV0dXJuaW5nIGl0cyByZXN1bHQsIGlmIGFsbCBgZnVuY2AgYXJndW1lbnRzXG5cdCAgICAgKiBoYXZlIGJlZW4gcHJvdmlkZWQsIG9yIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgb25lIG9yIG1vcmUgb2YgdGhlXG5cdCAgICAgKiByZW1haW5pbmcgYGZ1bmNgIGFyZ3VtZW50cywgYW5kIHNvIG9uLiBUaGUgYXJpdHkgb2YgYGZ1bmNgIG1heSBiZSBzcGVjaWZpZWRcblx0ICAgICAqIGlmIGBmdW5jLmxlbmd0aGAgaXMgbm90IHN1ZmZpY2llbnQuXG5cdCAgICAgKlxuXHQgICAgICogVGhlIGBfLmN1cnJ5LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWMgYnVpbGRzLFxuXHQgICAgICogbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcHJvdmlkZWQgYXJndW1lbnRzLlxuXHQgICAgICpcblx0ICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgY3VycmllZCBmdW5jdGlvbnMuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG5cdCAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5PWZ1bmMubGVuZ3RoXSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuXHQgICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG5cdCAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjdXJyaWVkIGZ1bmN0aW9uLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiB2YXIgYWJjID0gZnVuY3Rpb24oYSwgYiwgYykge1xuXHQgICAgICogICByZXR1cm4gW2EsIGIsIGNdO1xuXHQgICAgICogfTtcblx0ICAgICAqXG5cdCAgICAgKiB2YXIgY3VycmllZCA9IF8uY3VycnkoYWJjKTtcblx0ICAgICAqXG5cdCAgICAgKiBjdXJyaWVkKDEpKDIpKDMpO1xuXHQgICAgICogLy8gPT4gWzEsIDIsIDNdXG5cdCAgICAgKlxuXHQgICAgICogY3VycmllZCgxLCAyKSgzKTtcblx0ICAgICAqIC8vID0+IFsxLCAyLCAzXVxuXHQgICAgICpcblx0ICAgICAqIGN1cnJpZWQoMSwgMiwgMyk7XG5cdCAgICAgKiAvLyA9PiBbMSwgMiwgM11cblx0ICAgICAqXG5cdCAgICAgKiAvLyB1c2luZyBwbGFjZWhvbGRlcnNcblx0ICAgICAqIGN1cnJpZWQoMSkoXywgMykoMik7XG5cdCAgICAgKiAvLyA9PiBbMSwgMiwgM11cblx0ICAgICAqL1xuXHQgICAgdmFyIGN1cnJ5ID0gY3JlYXRlQ3VycnkoQ1VSUllfRkxBRyk7XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmN1cnJ5YCBleGNlcHQgdGhhdCBhcmd1bWVudHMgYXJlIGFwcGxpZWQgdG8gYGZ1bmNgXG5cdCAgICAgKiBpbiB0aGUgbWFubmVyIG9mIGBfLnBhcnRpYWxSaWdodGAgaW5zdGVhZCBvZiBgXy5wYXJ0aWFsYC5cblx0ICAgICAqXG5cdCAgICAgKiBUaGUgYF8uY3VycnlSaWdodC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG5cdCAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHByb3ZpZGVkIGFyZ3VtZW50cy5cblx0ICAgICAqXG5cdCAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lcyBub3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIGN1cnJpZWQgZnVuY3Rpb25zLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuXHQgICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eT1mdW5jLmxlbmd0aF0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cblx0ICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuXHQgICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY3VycmllZCBmdW5jdGlvbi5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogdmFyIGFiYyA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcblx0ICAgICAqICAgcmV0dXJuIFthLCBiLCBjXTtcblx0ICAgICAqIH07XG5cdCAgICAgKlxuXHQgICAgICogdmFyIGN1cnJpZWQgPSBfLmN1cnJ5UmlnaHQoYWJjKTtcblx0ICAgICAqXG5cdCAgICAgKiBjdXJyaWVkKDMpKDIpKDEpO1xuXHQgICAgICogLy8gPT4gWzEsIDIsIDNdXG5cdCAgICAgKlxuXHQgICAgICogY3VycmllZCgyLCAzKSgxKTtcblx0ICAgICAqIC8vID0+IFsxLCAyLCAzXVxuXHQgICAgICpcblx0ICAgICAqIGN1cnJpZWQoMSwgMiwgMyk7XG5cdCAgICAgKiAvLyA9PiBbMSwgMiwgM11cblx0ICAgICAqXG5cdCAgICAgKiAvLyB1c2luZyBwbGFjZWhvbGRlcnNcblx0ICAgICAqIGN1cnJpZWQoMykoMSwgXykoMik7XG5cdCAgICAgKiAvLyA9PiBbMSwgMiwgM11cblx0ICAgICAqL1xuXHQgICAgdmFyIGN1cnJ5UmlnaHQgPSBjcmVhdGVDdXJyeShDVVJSWV9SSUdIVF9GTEFHKTtcblx0XG5cdCAgICAvKipcblx0ICAgICAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuXHQgICAgICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG5cdCAgICAgKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG5cdCAgICAgKiBkZWxheWVkIGludm9jYXRpb25zLiBQcm92aWRlIGFuIG9wdGlvbnMgb2JqZWN0IHRvIGluZGljYXRlIHRoYXQgYGZ1bmNgXG5cdCAgICAgKiBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuXG5cdCAgICAgKiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3Rcblx0ICAgICAqIGBmdW5jYCBpbnZvY2F0aW9uLlxuXHQgICAgICpcblx0ICAgICAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXMgaW52b2tlZFxuXHQgICAgICogb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiBpc1xuXHQgICAgICogaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuXHQgICAgICpcblx0ICAgICAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwOi8vZHJ1cGFsbW90aW9uLmNvbS9hcnRpY2xlL2RlYm91bmNlLWFuZC10aHJvdHRsZS12aXN1YWwtZXhwbGFuYXRpb24pXG5cdCAgICAgKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuXHQgICAgICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3QuXG5cdCAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmdcblx0ICAgICAqICBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuXHQgICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmVcblx0ICAgICAqICBkZWxheWVkIGJlZm9yZSBpdCBpcyBpbnZva2VkLlxuXHQgICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXSBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZ1xuXHQgICAgICogIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG5cdCAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIC8vIGF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXhcblx0ICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG5cdCAgICAgKlxuXHQgICAgICogLy8gaW52b2tlIGBzZW5kTWFpbGAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxsc1xuXHQgICAgICogalF1ZXJ5KCcjcG9zdGJveCcpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuXHQgICAgICogICAnbGVhZGluZyc6IHRydWUsXG5cdCAgICAgKiAgICd0cmFpbGluZyc6IGZhbHNlXG5cdCAgICAgKiB9KSk7XG5cdCAgICAgKlxuXHQgICAgICogLy8gZW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxsc1xuXHQgICAgICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuXHQgICAgICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHtcblx0ICAgICAqICAgJ21heFdhaXQnOiAxMDAwXG5cdCAgICAgKiB9KSk7XG5cdCAgICAgKlxuXHQgICAgICogLy8gY2FuY2VsIGEgZGVib3VuY2VkIGNhbGxcblx0ICAgICAqIHZhciB0b2RvQ2hhbmdlcyA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDEwMDApO1xuXHQgICAgICogT2JqZWN0Lm9ic2VydmUobW9kZWxzLnRvZG8sIHRvZG9DaGFuZ2VzKTtcblx0ICAgICAqXG5cdCAgICAgKiBPYmplY3Qub2JzZXJ2ZShtb2RlbHMsIGZ1bmN0aW9uKGNoYW5nZXMpIHtcblx0ICAgICAqICAgaWYgKF8uZmluZChjaGFuZ2VzLCB7ICd1c2VyJzogJ3RvZG8nLCAndHlwZSc6ICdkZWxldGUnfSkpIHtcblx0ICAgICAqICAgICB0b2RvQ2hhbmdlcy5jYW5jZWwoKTtcblx0ICAgICAqICAgfVxuXHQgICAgICogfSwgWydkZWxldGUnXSk7XG5cdCAgICAgKlxuXHQgICAgICogLy8gLi4uYXQgc29tZSBwb2ludCBgbW9kZWxzLnRvZG9gIGlzIGNoYW5nZWRcblx0ICAgICAqIG1vZGVscy50b2RvLmNvbXBsZXRlZCA9IHRydWU7XG5cdCAgICAgKlxuXHQgICAgICogLy8gLi4uYmVmb3JlIDEgc2Vjb25kIGhhcyBwYXNzZWQgYG1vZGVscy50b2RvYCBpcyBkZWxldGVkXG5cdCAgICAgKiAvLyB3aGljaCBjYW5jZWxzIHRoZSBkZWJvdW5jZWQgYHRvZG9DaGFuZ2VzYCBjYWxsXG5cdCAgICAgKiBkZWxldGUgbW9kZWxzLnRvZG87XG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcblx0ICAgICAgdmFyIGFyZ3MsXG5cdCAgICAgICAgICBtYXhUaW1lb3V0SWQsXG5cdCAgICAgICAgICByZXN1bHQsXG5cdCAgICAgICAgICBzdGFtcCxcblx0ICAgICAgICAgIHRoaXNBcmcsXG5cdCAgICAgICAgICB0aW1lb3V0SWQsXG5cdCAgICAgICAgICB0cmFpbGluZ0NhbGwsXG5cdCAgICAgICAgICBsYXN0Q2FsbGVkID0gMCxcblx0ICAgICAgICAgIG1heFdhaXQgPSBmYWxzZSxcblx0ICAgICAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblx0XG5cdCAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuXHQgICAgICB9XG5cdCAgICAgIHdhaXQgPSB3YWl0IDwgMCA/IDAgOiAoK3dhaXQgfHwgMCk7XG5cdCAgICAgIGlmIChvcHRpb25zID09PSB0cnVlKSB7XG5cdCAgICAgICAgdmFyIGxlYWRpbmcgPSB0cnVlO1xuXHQgICAgICAgIHRyYWlsaW5nID0gZmFsc2U7XG5cdCAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcblx0ICAgICAgICBsZWFkaW5nID0gISFvcHRpb25zLmxlYWRpbmc7XG5cdCAgICAgICAgbWF4V2FpdCA9ICdtYXhXYWl0JyBpbiBvcHRpb25zICYmIG5hdGl2ZU1heCgrb3B0aW9ucy5tYXhXYWl0IHx8IDAsIHdhaXQpO1xuXHQgICAgICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIGZ1bmN0aW9uIGNhbmNlbCgpIHtcblx0ICAgICAgICBpZiAodGltZW91dElkKSB7XG5cdCAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKG1heFRpbWVvdXRJZCkge1xuXHQgICAgICAgICAgY2xlYXJUaW1lb3V0KG1heFRpbWVvdXRJZCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXHQgICAgICAgIG1heFRpbWVvdXRJZCA9IHRpbWVvdXRJZCA9IHRyYWlsaW5nQ2FsbCA9IHVuZGVmaW5lZDtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgZnVuY3Rpb24gY29tcGxldGUoaXNDYWxsZWQsIGlkKSB7XG5cdCAgICAgICAgaWYgKGlkKSB7XG5cdCAgICAgICAgICBjbGVhclRpbWVvdXQoaWQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBtYXhUaW1lb3V0SWQgPSB0aW1lb3V0SWQgPSB0cmFpbGluZ0NhbGwgPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgaWYgKGlzQ2FsbGVkKSB7XG5cdCAgICAgICAgICBsYXN0Q2FsbGVkID0gbm93KCk7XG5cdCAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuXHQgICAgICAgICAgaWYgKCF0aW1lb3V0SWQgJiYgIW1heFRpbWVvdXRJZCkge1xuXHQgICAgICAgICAgICBhcmdzID0gdGhpc0FyZyA9IHVuZGVmaW5lZDtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIGZ1bmN0aW9uIGRlbGF5ZWQoKSB7XG5cdCAgICAgICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAobm93KCkgLSBzdGFtcCk7XG5cdCAgICAgICAgaWYgKHJlbWFpbmluZyA8PSAwIHx8IHJlbWFpbmluZyA+IHdhaXQpIHtcblx0ICAgICAgICAgIGNvbXBsZXRlKHRyYWlsaW5nQ2FsbCwgbWF4VGltZW91dElkKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChkZWxheWVkLCByZW1haW5pbmcpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHRcblx0ICAgICAgZnVuY3Rpb24gbWF4RGVsYXllZCgpIHtcblx0ICAgICAgICBjb21wbGV0ZSh0cmFpbGluZywgdGltZW91dElkKTtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuXHQgICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG5cdCAgICAgICAgc3RhbXAgPSBub3coKTtcblx0ICAgICAgICB0aGlzQXJnID0gdGhpcztcblx0ICAgICAgICB0cmFpbGluZ0NhbGwgPSB0cmFpbGluZyAmJiAodGltZW91dElkIHx8ICFsZWFkaW5nKTtcblx0XG5cdCAgICAgICAgaWYgKG1heFdhaXQgPT09IGZhbHNlKSB7XG5cdCAgICAgICAgICB2YXIgbGVhZGluZ0NhbGwgPSBsZWFkaW5nICYmICF0aW1lb3V0SWQ7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIGlmICghbWF4VGltZW91dElkICYmICFsZWFkaW5nKSB7XG5cdCAgICAgICAgICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIHZhciByZW1haW5pbmcgPSBtYXhXYWl0IC0gKHN0YW1wIC0gbGFzdENhbGxlZCksXG5cdCAgICAgICAgICAgICAgaXNDYWxsZWQgPSByZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiBtYXhXYWl0O1xuXHRcblx0ICAgICAgICAgIGlmIChpc0NhbGxlZCkge1xuXHQgICAgICAgICAgICBpZiAobWF4VGltZW91dElkKSB7XG5cdCAgICAgICAgICAgICAgbWF4VGltZW91dElkID0gY2xlYXJUaW1lb3V0KG1heFRpbWVvdXRJZCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuXHQgICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgZWxzZSBpZiAoIW1heFRpbWVvdXRJZCkge1xuXHQgICAgICAgICAgICBtYXhUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KG1heERlbGF5ZWQsIHJlbWFpbmluZyk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChpc0NhbGxlZCAmJiB0aW1lb3V0SWQpIHtcblx0ICAgICAgICAgIHRpbWVvdXRJZCA9IGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmICghdGltZW91dElkICYmIHdhaXQgIT09IG1heFdhaXQpIHtcblx0ICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZGVsYXllZCwgd2FpdCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChsZWFkaW5nQ2FsbCkge1xuXHQgICAgICAgICAgaXNDYWxsZWQgPSB0cnVlO1xuXHQgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGlzQ2FsbGVkICYmICF0aW1lb3V0SWQgJiYgIW1heFRpbWVvdXRJZCkge1xuXHQgICAgICAgICAgYXJncyA9IHRoaXNBcmcgPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgIH1cblx0ICAgICAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcblx0ICAgICAgcmV0dXJuIGRlYm91bmNlZDtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIERlZmVycyBpbnZva2luZyB0aGUgYGZ1bmNgIHVudGlsIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgaGFzIGNsZWFyZWQuIEFueVxuXHQgICAgICogYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0IGlzIGludm9rZWQuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVmZXIuXG5cdCAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aC5cblx0ICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVyIGlkLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBfLmRlZmVyKGZ1bmN0aW9uKHRleHQpIHtcblx0ICAgICAqICAgY29uc29sZS5sb2codGV4dCk7XG5cdCAgICAgKiB9LCAnZGVmZXJyZWQnKTtcblx0ICAgICAqIC8vIGxvZ3MgJ2RlZmVycmVkJyBhZnRlciBvbmUgb3IgbW9yZSBtaWxsaXNlY29uZHNcblx0ICAgICAqL1xuXHQgICAgdmFyIGRlZmVyID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGZ1bmMsIGFyZ3MpIHtcblx0ICAgICAgcmV0dXJuIGJhc2VEZWxheShmdW5jLCAxLCBhcmdzKTtcblx0ICAgIH0pO1xuXHRcblx0ICAgIC8qKlxuXHQgICAgICogSW52b2tlcyBgZnVuY2AgYWZ0ZXIgYHdhaXRgIG1pbGxpc2Vjb25kcy4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZVxuXHQgICAgICogcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQgaXMgaW52b2tlZC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWxheS5cblx0ICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGludm9jYXRpb24uXG5cdCAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aC5cblx0ICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVyIGlkLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBfLmRlbGF5KGZ1bmN0aW9uKHRleHQpIHtcblx0ICAgICAqICAgY29uc29sZS5sb2codGV4dCk7XG5cdCAgICAgKiB9LCAxMDAwLCAnbGF0ZXInKTtcblx0ICAgICAqIC8vID0+IGxvZ3MgJ2xhdGVyJyBhZnRlciBvbmUgc2Vjb25kXG5cdCAgICAgKi9cblx0ICAgIHZhciBkZWxheSA9IHJlc3RQYXJhbShmdW5jdGlvbihmdW5jLCB3YWl0LCBhcmdzKSB7XG5cdCAgICAgIHJldHVybiBiYXNlRGVsYXkoZnVuYywgd2FpdCwgYXJncyk7XG5cdCAgICB9KTtcblx0XG5cdCAgICAvKipcblx0ICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHJlc3VsdCBvZiBpbnZva2luZyB0aGUgcHJvdmlkZWRcblx0ICAgICAqIGZ1bmN0aW9ucyB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbiwgd2hlcmUgZWFjaFxuXHQgICAgICogc3VjY2Vzc2l2ZSBpbnZvY2F0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cblx0ICAgICAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IFtmdW5jc10gRnVuY3Rpb25zIHRvIGludm9rZS5cblx0ICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuXHQgICAgICogICByZXR1cm4gbiAqIG47XG5cdCAgICAgKiB9XG5cdCAgICAgKlxuXHQgICAgICogdmFyIGFkZFNxdWFyZSA9IF8uZmxvdyhfLmFkZCwgc3F1YXJlKTtcblx0ICAgICAqIGFkZFNxdWFyZSgxLCAyKTtcblx0ICAgICAqIC8vID0+IDlcblx0ICAgICAqL1xuXHQgICAgdmFyIGZsb3cgPSBjcmVhdGVGbG93KCk7XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZsb3dgIGV4Y2VwdCB0aGF0IGl0IGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0XG5cdCAgICAgKiBpbnZva2VzIHRoZSBwcm92aWRlZCBmdW5jdGlvbnMgZnJvbSByaWdodCB0byBsZWZ0LlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAYWxpYXMgYmFja2Zsb3csIGNvbXBvc2Vcblx0ICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuXHQgICAgICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gW2Z1bmNzXSBGdW5jdGlvbnMgdG8gaW52b2tlLlxuXHQgICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG5cdCAgICAgKiAgIHJldHVybiBuICogbjtcblx0ICAgICAqIH1cblx0ICAgICAqXG5cdCAgICAgKiB2YXIgYWRkU3F1YXJlID0gXy5mbG93UmlnaHQoc3F1YXJlLCBfLmFkZCk7XG5cdCAgICAgKiBhZGRTcXVhcmUoMSwgMik7XG5cdCAgICAgKiAvLyA9PiA5XG5cdCAgICAgKi9cblx0ICAgIHZhciBmbG93UmlnaHQgPSBjcmVhdGVGbG93KHRydWUpO1xuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcblx0ICAgICAqIHByb3ZpZGVkIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuXHQgICAgICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG5cdCAgICAgKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgY29lcmNlZCB0byBhIHN0cmluZyBhbmQgdXNlZCBhcyB0aGVcblx0ICAgICAqIGNhY2hlIGtleS4gVGhlIGBmdW5jYCBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZFxuXHQgICAgICogZnVuY3Rpb24uXG5cdCAgICAgKlxuXHQgICAgICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuXHQgICAgICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG5cdCAgICAgKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZSBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuXHQgICAgICogbWV0aG9kIGludGVyZmFjZSBvZiBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG5cdCAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXppbmcgZnVuY3Rpb24uXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIHZhciB1cHBlckNhc2UgPSBfLm1lbW9pemUoZnVuY3Rpb24oc3RyaW5nKSB7XG5cdCAgICAgKiAgIHJldHVybiBzdHJpbmcudG9VcHBlckNhc2UoKTtcblx0ICAgICAqIH0pO1xuXHQgICAgICpcblx0ICAgICAqIHVwcGVyQ2FzZSgnZnJlZCcpO1xuXHQgICAgICogLy8gPT4gJ0ZSRUQnXG5cdCAgICAgKlxuXHQgICAgICogLy8gbW9kaWZ5aW5nIHRoZSByZXN1bHQgY2FjaGVcblx0ICAgICAqIHVwcGVyQ2FzZS5jYWNoZS5zZXQoJ2ZyZWQnLCAnQkFSTkVZJyk7XG5cdCAgICAgKiB1cHBlckNhc2UoJ2ZyZWQnKTtcblx0ICAgICAqIC8vID0+ICdCQVJORVknXG5cdCAgICAgKlxuXHQgICAgICogLy8gcmVwbGFjaW5nIGBfLm1lbW9pemUuQ2FjaGVgXG5cdCAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJyB9O1xuXHQgICAgICogdmFyIG90aGVyID0geyAndXNlcic6ICdiYXJuZXknIH07XG5cdCAgICAgKiB2YXIgaWRlbnRpdHkgPSBfLm1lbW9pemUoXy5pZGVudGl0eSk7XG5cdCAgICAgKlxuXHQgICAgICogaWRlbnRpdHkob2JqZWN0KTtcblx0ICAgICAqIC8vID0+IHsgJ3VzZXInOiAnZnJlZCcgfVxuXHQgICAgICogaWRlbnRpdHkob3RoZXIpO1xuXHQgICAgICogLy8gPT4geyAndXNlcic6ICdmcmVkJyB9XG5cdCAgICAgKlxuXHQgICAgICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcblx0ICAgICAqIHZhciBpZGVudGl0eSA9IF8ubWVtb2l6ZShfLmlkZW50aXR5KTtcblx0ICAgICAqXG5cdCAgICAgKiBpZGVudGl0eShvYmplY3QpO1xuXHQgICAgICogLy8gPT4geyAndXNlcic6ICdmcmVkJyB9XG5cdCAgICAgKiBpZGVudGl0eShvdGhlcik7XG5cdCAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScgfVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG5cdCAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG5cdCAgICAgICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuXHQgICAgICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXHRcblx0ICAgICAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcblx0ICAgICAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG5cdCAgICAgICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpO1xuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgIH07XG5cdCAgICAgIG1lbW9pemVkLmNhY2hlID0gbmV3IG1lbW9pemUuQ2FjaGU7XG5cdCAgICAgIHJldHVybiBtZW1vaXplZDtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJ1bnMgZWFjaCBhcmd1bWVudCB0aHJvdWdoIGEgY29ycmVzcG9uZGluZ1xuXHQgICAgICogdHJhbnNmb3JtIGZ1bmN0aW9uLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG5cdCAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW3RyYW5zZm9ybXNdIFRoZSBmdW5jdGlvbnMgdG8gdHJhbnNmb3JtXG5cdCAgICAgKiBhcmd1bWVudHMsIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGZ1bmN0aW9ucyBvciBhcnJheXMgb2YgZnVuY3Rpb25zLlxuXHQgICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIGZ1bmN0aW9uIGRvdWJsZWQobikge1xuXHQgICAgICogICByZXR1cm4gbiAqIDI7XG5cdCAgICAgKiB9XG5cdCAgICAgKlxuXHQgICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcblx0ICAgICAqICAgcmV0dXJuIG4gKiBuO1xuXHQgICAgICogfVxuXHQgICAgICpcblx0ICAgICAqIHZhciBtb2RkZWQgPSBfLm1vZEFyZ3MoZnVuY3Rpb24oeCwgeSkge1xuXHQgICAgICogICByZXR1cm4gW3gsIHldO1xuXHQgICAgICogfSwgc3F1YXJlLCBkb3VibGVkKTtcblx0ICAgICAqXG5cdCAgICAgKiBtb2RkZWQoMSwgMik7XG5cdCAgICAgKiAvLyA9PiBbMSwgNF1cblx0ICAgICAqXG5cdCAgICAgKiBtb2RkZWQoNSwgMTApO1xuXHQgICAgICogLy8gPT4gWzI1LCAyMF1cblx0ICAgICAqL1xuXHQgICAgdmFyIG1vZEFyZ3MgPSByZXN0UGFyYW0oZnVuY3Rpb24oZnVuYywgdHJhbnNmb3Jtcykge1xuXHQgICAgICB0cmFuc2Zvcm1zID0gYmFzZUZsYXR0ZW4odHJhbnNmb3Jtcyk7XG5cdCAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8ICFhcnJheUV2ZXJ5KHRyYW5zZm9ybXMsIGJhc2VJc0Z1bmN0aW9uKSkge1xuXHQgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcblx0ICAgICAgfVxuXHQgICAgICB2YXIgbGVuZ3RoID0gdHJhbnNmb3Jtcy5sZW5ndGg7XG5cdCAgICAgIHJldHVybiByZXN0UGFyYW0oZnVuY3Rpb24oYXJncykge1xuXHQgICAgICAgIHZhciBpbmRleCA9IG5hdGl2ZU1pbihhcmdzLmxlbmd0aCwgbGVuZ3RoKTtcblx0ICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuXHQgICAgICAgICAgYXJnc1tpbmRleF0gPSB0cmFuc2Zvcm1zW2luZGV4XShhcmdzW2luZGV4XSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHQgICAgICB9KTtcblx0ICAgIH0pO1xuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbmVnYXRlcyB0aGUgcmVzdWx0IG9mIHRoZSBwcmVkaWNhdGUgYGZ1bmNgLiBUaGVcblx0ICAgICAqIGBmdW5jYCBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzIG9mIHRoZVxuXHQgICAgICogY3JlYXRlZCBmdW5jdGlvbi5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIHByZWRpY2F0ZSB0byBuZWdhdGUuXG5cdCAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogZnVuY3Rpb24gaXNFdmVuKG4pIHtcblx0ICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG5cdCAgICAgKiB9XG5cdCAgICAgKlxuXHQgICAgICogXy5maWx0ZXIoWzEsIDIsIDMsIDQsIDUsIDZdLCBfLm5lZ2F0ZShpc0V2ZW4pKTtcblx0ICAgICAqIC8vID0+IFsxLCAzLCA1XVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBuZWdhdGUocHJlZGljYXRlKSB7XG5cdCAgICAgIGlmICh0eXBlb2YgcHJlZGljYXRlICE9ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIHJldHVybiAhcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgIH07XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpcyByZXN0cmljdGVkIHRvIGludm9raW5nIGBmdW5jYCBvbmNlLiBSZXBlYXQgY2FsbHNcblx0ICAgICAqIHRvIHRoZSBmdW5jdGlvbiByZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBjYWxsLiBUaGUgYGZ1bmNgIGlzIGludm9rZWRcblx0ICAgICAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG5cdCAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiB2YXIgaW5pdGlhbGl6ZSA9IF8ub25jZShjcmVhdGVBcHBsaWNhdGlvbik7XG5cdCAgICAgKiBpbml0aWFsaXplKCk7XG5cdCAgICAgKiBpbml0aWFsaXplKCk7XG5cdCAgICAgKiAvLyBgaW5pdGlhbGl6ZWAgaW52b2tlcyBgY3JlYXRlQXBwbGljYXRpb25gIG9uY2Vcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gb25jZShmdW5jKSB7XG5cdCAgICAgIHJldHVybiBiZWZvcmUoMiwgZnVuYyk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGBwYXJ0aWFsYCBhcmd1bWVudHMgcHJlcGVuZGVkXG5cdCAgICAgKiB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgbmV3IGZ1bmN0aW9uLiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmJpbmRgIGV4Y2VwdFxuXHQgICAgICogaXQgZG9lcyAqKm5vdCoqIGFsdGVyIHRoZSBgdGhpc2AgYmluZGluZy5cblx0ICAgICAqXG5cdCAgICAgKiBUaGUgYF8ucGFydGlhbC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG5cdCAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cblx0ICAgICAqXG5cdCAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lcyBub3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIHBhcnRpYWxseVxuXHQgICAgICogYXBwbGllZCBmdW5jdGlvbnMuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5IGFyZ3VtZW50cyB0by5cblx0ICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuXHQgICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24uXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIHZhciBncmVldCA9IGZ1bmN0aW9uKGdyZWV0aW5nLCBuYW1lKSB7XG5cdCAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIG5hbWU7XG5cdCAgICAgKiB9O1xuXHQgICAgICpcblx0ICAgICAqIHZhciBzYXlIZWxsb1RvID0gXy5wYXJ0aWFsKGdyZWV0LCAnaGVsbG8nKTtcblx0ICAgICAqIHNheUhlbGxvVG8oJ2ZyZWQnKTtcblx0ICAgICAqIC8vID0+ICdoZWxsbyBmcmVkJ1xuXHQgICAgICpcblx0ICAgICAqIC8vIHVzaW5nIHBsYWNlaG9sZGVyc1xuXHQgICAgICogdmFyIGdyZWV0RnJlZCA9IF8ucGFydGlhbChncmVldCwgXywgJ2ZyZWQnKTtcblx0ICAgICAqIGdyZWV0RnJlZCgnaGknKTtcblx0ICAgICAqIC8vID0+ICdoaSBmcmVkJ1xuXHQgICAgICovXG5cdCAgICB2YXIgcGFydGlhbCA9IGNyZWF0ZVBhcnRpYWwoUEFSVElBTF9GTEFHKTtcblx0XG5cdCAgICAvKipcblx0ICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucGFydGlhbGAgZXhjZXB0IHRoYXQgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzXG5cdCAgICAgKiBhcmUgYXBwZW5kZWQgdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi5cblx0ICAgICAqXG5cdCAgICAgKiBUaGUgYF8ucGFydGlhbFJpZ2h0LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcblx0ICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuXHQgICAgICpcblx0ICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgcGFydGlhbGx5XG5cdCAgICAgKiBhcHBsaWVkIGZ1bmN0aW9ucy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkgYXJndW1lbnRzIHRvLlxuXHQgICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG5cdCAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbi5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogdmFyIGdyZWV0ID0gZnVuY3Rpb24oZ3JlZXRpbmcsIG5hbWUpIHtcblx0ICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgbmFtZTtcblx0ICAgICAqIH07XG5cdCAgICAgKlxuXHQgICAgICogdmFyIGdyZWV0RnJlZCA9IF8ucGFydGlhbFJpZ2h0KGdyZWV0LCAnZnJlZCcpO1xuXHQgICAgICogZ3JlZXRGcmVkKCdoaScpO1xuXHQgICAgICogLy8gPT4gJ2hpIGZyZWQnXG5cdCAgICAgKlxuXHQgICAgICogLy8gdXNpbmcgcGxhY2Vob2xkZXJzXG5cdCAgICAgKiB2YXIgc2F5SGVsbG9UbyA9IF8ucGFydGlhbFJpZ2h0KGdyZWV0LCAnaGVsbG8nLCBfKTtcblx0ICAgICAqIHNheUhlbGxvVG8oJ2ZyZWQnKTtcblx0ICAgICAqIC8vID0+ICdoZWxsbyBmcmVkJ1xuXHQgICAgICovXG5cdCAgICB2YXIgcGFydGlhbFJpZ2h0ID0gY3JlYXRlUGFydGlhbChQQVJUSUFMX1JJR0hUX0ZMQUcpO1xuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBhcmd1bWVudHMgYXJyYW5nZWQgYWNjb3JkaW5nXG5cdCAgICAgKiB0byB0aGUgc3BlY2lmaWVkIGluZGV4ZXMgd2hlcmUgdGhlIGFyZ3VtZW50IHZhbHVlIGF0IHRoZSBmaXJzdCBpbmRleCBpc1xuXHQgICAgICogcHJvdmlkZWQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LCB0aGUgYXJndW1lbnQgdmFsdWUgYXQgdGhlIHNlY29uZCBpbmRleCBpc1xuXHQgICAgICogcHJvdmlkZWQgYXMgdGhlIHNlY29uZCBhcmd1bWVudCwgYW5kIHNvIG9uLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlYXJyYW5nZSBhcmd1bWVudHMgZm9yLlxuXHQgICAgICogQHBhcmFtIHsuLi4obnVtYmVyfG51bWJlcltdKX0gaW5kZXhlcyBUaGUgYXJyYW5nZWQgYXJndW1lbnQgaW5kZXhlcyxcblx0ICAgICAqICBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBpbmRleGVzIG9yIGFycmF5cyBvZiBpbmRleGVzLlxuXHQgICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIHZhciByZWFyZ2VkID0gXy5yZWFyZyhmdW5jdGlvbihhLCBiLCBjKSB7XG5cdCAgICAgKiAgIHJldHVybiBbYSwgYiwgY107XG5cdCAgICAgKiB9LCAyLCAwLCAxKTtcblx0ICAgICAqXG5cdCAgICAgKiByZWFyZ2VkKCdiJywgJ2MnLCAnYScpXG5cdCAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cblx0ICAgICAqXG5cdCAgICAgKiB2YXIgbWFwID0gXy5yZWFyZyhfLm1hcCwgWzEsIDBdKTtcblx0ICAgICAqIG1hcChmdW5jdGlvbihuKSB7XG5cdCAgICAgKiAgIHJldHVybiBuICogMztcblx0ICAgICAqIH0sIFsxLCAyLCAzXSk7XG5cdCAgICAgKiAvLyA9PiBbMywgNiwgOV1cblx0ICAgICAqL1xuXHQgICAgdmFyIHJlYXJnID0gcmVzdFBhcmFtKGZ1bmN0aW9uKGZ1bmMsIGluZGV4ZXMpIHtcblx0ICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIoZnVuYywgUkVBUkdfRkxBRywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYmFzZUZsYXR0ZW4oaW5kZXhlcykpO1xuXHQgICAgfSk7XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGVcblx0ICAgICAqIGNyZWF0ZWQgZnVuY3Rpb24gYW5kIGFyZ3VtZW50cyBmcm9tIGBzdGFydGAgYW5kIGJleW9uZCBwcm92aWRlZCBhcyBhbiBhcnJheS5cblx0ICAgICAqXG5cdCAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb24gdGhlIFtyZXN0IHBhcmFtZXRlcl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvRnVuY3Rpb25zL3Jlc3RfcGFyYW1ldGVycykuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cblx0ICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cblx0ICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiB2YXIgc2F5ID0gXy5yZXN0UGFyYW0oZnVuY3Rpb24od2hhdCwgbmFtZXMpIHtcblx0ICAgICAqICAgcmV0dXJuIHdoYXQgKyAnICcgKyBfLmluaXRpYWwobmFtZXMpLmpvaW4oJywgJykgK1xuXHQgICAgICogICAgIChfLnNpemUobmFtZXMpID4gMSA/ICcsICYgJyA6ICcnKSArIF8ubGFzdChuYW1lcyk7XG5cdCAgICAgKiB9KTtcblx0ICAgICAqXG5cdCAgICAgKiBzYXkoJ2hlbGxvJywgJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnKTtcblx0ICAgICAqIC8vID0+ICdoZWxsbyBmcmVkLCBiYXJuZXksICYgcGViYmxlcydcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gcmVzdFBhcmFtKGZ1bmMsIHN0YXJ0KSB7XG5cdCAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuXHQgICAgICB9XG5cdCAgICAgIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6ICgrc3RhcnQgfHwgMCksIDApO1xuXHQgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG5cdCAgICAgICAgICAgIGluZGV4ID0gLTEsXG5cdCAgICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcblx0ICAgICAgICAgICAgcmVzdCA9IEFycmF5KGxlbmd0aCk7XG5cdFxuXHQgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdCAgICAgICAgICByZXN0W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHN3aXRjaCAoc3RhcnQpIHtcblx0ICAgICAgICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzLCByZXN0KTtcblx0ICAgICAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzLCBhcmdzWzBdLCByZXN0KTtcblx0ICAgICAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzLCBhcmdzWzBdLCBhcmdzWzFdLCByZXN0KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG5cdCAgICAgICAgaW5kZXggPSAtMTtcblx0ICAgICAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG5cdCAgICAgICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIG90aGVyQXJnc1tzdGFydF0gPSByZXN0O1xuXHQgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIG90aGVyQXJncyk7XG5cdCAgICAgIH07XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZFxuXHQgICAgICogZnVuY3Rpb24gYW5kIGFuIGFycmF5IG9mIGFyZ3VtZW50cyBtdWNoIGxpa2UgW2BGdW5jdGlvbiNhcHBseWBdKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjMuNC4zKS5cblx0ICAgICAqXG5cdCAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb24gdGhlIFtzcHJlYWQgb3BlcmF0b3JdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL09wZXJhdG9ycy9TcHJlYWRfb3BlcmF0b3IpLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHNwcmVhZCBhcmd1bWVudHMgb3Zlci5cblx0ICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiB2YXIgc2F5ID0gXy5zcHJlYWQoZnVuY3Rpb24od2hvLCB3aGF0KSB7XG5cdCAgICAgKiAgIHJldHVybiB3aG8gKyAnIHNheXMgJyArIHdoYXQ7XG5cdCAgICAgKiB9KTtcblx0ICAgICAqXG5cdCAgICAgKiBzYXkoWydmcmVkJywgJ2hlbGxvJ10pO1xuXHQgICAgICogLy8gPT4gJ2ZyZWQgc2F5cyBoZWxsbydcblx0ICAgICAqXG5cdCAgICAgKiAvLyB3aXRoIGEgUHJvbWlzZVxuXHQgICAgICogdmFyIG51bWJlcnMgPSBQcm9taXNlLmFsbChbXG5cdCAgICAgKiAgIFByb21pc2UucmVzb2x2ZSg0MCksXG5cdCAgICAgKiAgIFByb21pc2UucmVzb2x2ZSgzNilcblx0ICAgICAqIF0pO1xuXHQgICAgICpcblx0ICAgICAqIG51bWJlcnMudGhlbihfLnNwcmVhZChmdW5jdGlvbih4LCB5KSB7XG5cdCAgICAgKiAgIHJldHVybiB4ICsgeTtcblx0ICAgICAqIH0pKTtcblx0ICAgICAqIC8vID0+IGEgUHJvbWlzZSBvZiA3NlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBzcHJlYWQoZnVuYykge1xuXHQgICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXkpIHtcblx0ICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcnJheSk7XG5cdCAgICAgIH07XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGEgdGhyb3R0bGVkIGZ1bmN0aW9uIHRoYXQgb25seSBpbnZva2VzIGBmdW5jYCBhdCBtb3N0IG9uY2UgcGVyXG5cdCAgICAgKiBldmVyeSBgd2FpdGAgbWlsbGlzZWNvbmRzLiBUaGUgdGhyb3R0bGVkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYFxuXHQgICAgICogbWV0aG9kIHRvIGNhbmNlbCBkZWxheWVkIGludm9jYXRpb25zLiBQcm92aWRlIGFuIG9wdGlvbnMgb2JqZWN0IHRvIGluZGljYXRlXG5cdCAgICAgKiB0aGF0IGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGVcblx0ICAgICAqIGB3YWl0YCB0aW1lb3V0LiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gcmV0dXJuIHRoZVxuXHQgICAgICogcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBjYWxsLlxuXHQgICAgICpcblx0ICAgICAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXMgaW52b2tlZFxuXHQgICAgICogb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhlIHRocm90dGxlZCBmdW5jdGlvbiBpc1xuXHQgICAgICogaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuXHQgICAgICpcblx0ICAgICAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwOi8vZHJ1cGFsbW90aW9uLmNvbS9hcnRpY2xlL2RlYm91bmNlLWFuZC10aHJvdHRsZS12aXN1YWwtZXhwbGFuYXRpb24pXG5cdCAgICAgKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLnRocm90dGxlYCBhbmQgYF8uZGVib3VuY2VgLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHRocm90dGxlLlxuXHQgICAgICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGludm9jYXRpb25zIHRvLlxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3QuXG5cdCAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9dHJ1ZV0gU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZ1xuXHQgICAgICogIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG5cdCAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nXG5cdCAgICAgKiAgZWRnZSBvZiB0aGUgdGltZW91dC5cblx0ICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogLy8gYXZvaWQgZXhjZXNzaXZlbHkgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIHNjcm9sbGluZ1xuXHQgICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3Njcm9sbCcsIF8udGhyb3R0bGUodXBkYXRlUG9zaXRpb24sIDEwMCkpO1xuXHQgICAgICpcblx0ICAgICAqIC8vIGludm9rZSBgcmVuZXdUb2tlbmAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGJ1dCBub3QgbW9yZSB0aGFuIG9uY2UgZXZlcnkgNSBtaW51dGVzXG5cdCAgICAgKiBqUXVlcnkoJy5pbnRlcmFjdGl2ZScpLm9uKCdjbGljaycsIF8udGhyb3R0bGUocmVuZXdUb2tlbiwgMzAwMDAwLCB7XG5cdCAgICAgKiAgICd0cmFpbGluZyc6IGZhbHNlXG5cdCAgICAgKiB9KSk7XG5cdCAgICAgKlxuXHQgICAgICogLy8gY2FuY2VsIGEgdHJhaWxpbmcgdGhyb3R0bGVkIGNhbGxcblx0ICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIHRocm90dGxlZC5jYW5jZWwpO1xuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG5cdCAgICAgIHZhciBsZWFkaW5nID0gdHJ1ZSxcblx0ICAgICAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblx0XG5cdCAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChvcHRpb25zID09PSBmYWxzZSkge1xuXHQgICAgICAgIGxlYWRpbmcgPSBmYWxzZTtcblx0ICAgICAgfSBlbHNlIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuXHQgICAgICAgIGxlYWRpbmcgPSAnbGVhZGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy5sZWFkaW5nIDogbGVhZGluZztcblx0ICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBkZWJvdW5jZShmdW5jLCB3YWl0LCB7ICdsZWFkaW5nJzogbGVhZGluZywgJ21heFdhaXQnOiArd2FpdCwgJ3RyYWlsaW5nJzogdHJhaWxpbmcgfSk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwcm92aWRlcyBgdmFsdWVgIHRvIHRoZSB3cmFwcGVyIGZ1bmN0aW9uIGFzIGl0c1xuXHQgICAgICogZmlyc3QgYXJndW1lbnQuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZnVuY3Rpb24gYXJlXG5cdCAgICAgKiBhcHBlbmRlZCB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgd3JhcHBlciBmdW5jdGlvbi4gVGhlIHdyYXBwZXIgaXMgaW52b2tlZFxuXHQgICAgICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuXHQgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHdyYXBwZXIgVGhlIHdyYXBwZXIgZnVuY3Rpb24uXG5cdCAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogdmFyIHAgPSBfLndyYXAoXy5lc2NhcGUsIGZ1bmN0aW9uKGZ1bmMsIHRleHQpIHtcblx0ICAgICAqICAgcmV0dXJuICc8cD4nICsgZnVuYyh0ZXh0KSArICc8L3A+Jztcblx0ICAgICAqIH0pO1xuXHQgICAgICpcblx0ICAgICAqIHAoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG5cdCAgICAgKiAvLyA9PiAnPHA+ZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzPC9wPidcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gd3JhcCh2YWx1ZSwgd3JhcHBlcikge1xuXHQgICAgICB3cmFwcGVyID0gd3JhcHBlciA9PSBudWxsID8gaWRlbnRpdHkgOiB3cmFwcGVyO1xuXHQgICAgICByZXR1cm4gY3JlYXRlV3JhcHBlcih3cmFwcGVyLCBQQVJUSUFMX0ZMQUcsIHVuZGVmaW5lZCwgW3ZhbHVlXSwgW10pO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblx0XG5cdCAgICAvKipcblx0ICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdmFsdWVgLiBJZiBgaXNEZWVwYCBpcyBgdHJ1ZWAgbmVzdGVkIG9iamVjdHMgYXJlIGNsb25lZCxcblx0ICAgICAqIG90aGVyd2lzZSB0aGV5IGFyZSBhc3NpZ25lZCBieSByZWZlcmVuY2UuIElmIGBjdXN0b21pemVyYCBpcyBwcm92aWRlZCBpdCBpc1xuXHQgICAgICogaW52b2tlZCB0byBwcm9kdWNlIHRoZSBjbG9uZWQgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYFxuXHQgICAgICogY2xvbmluZyBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBib3VuZCB0b1xuXHQgICAgICogYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50OyAodmFsdWUgWywgaW5kZXh8a2V5LCBvYmplY3RdKS5cblx0ICAgICAqXG5cdCAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbiB0aGVcblx0ICAgICAqIFtzdHJ1Y3R1cmVkIGNsb25lIGFsZ29yaXRobV0oaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5mcmFzdHJ1Y3R1cmUuaHRtbCNpbnRlcm5hbC1zdHJ1Y3R1cmVkLWNsb25pbmctYWxnb3JpdGhtKS5cblx0ICAgICAqIFRoZSBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYGFyZ3VtZW50c2Agb2JqZWN0cyBhbmQgb2JqZWN0cyBjcmVhdGVkIGJ5XG5cdCAgICAgKiBjb25zdHJ1Y3RvcnMgb3RoZXIgdGhhbiBgT2JqZWN0YCBhcmUgY2xvbmVkIHRvIHBsYWluIGBPYmplY3RgIG9iamVjdHMuIEFuXG5cdCAgICAgKiBlbXB0eSBvYmplY3QgaXMgcmV0dXJuZWQgZm9yIHVuY2xvbmVhYmxlIHZhbHVlcyBzdWNoIGFzIGZ1bmN0aW9ucywgRE9NIG5vZGVzLFxuXHQgICAgICogTWFwcywgU2V0cywgYW5kIFdlYWtNYXBzLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuXHQgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG5cdCAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZyB2YWx1ZXMuXG5cdCAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGN1c3RvbWl6ZXJgLlxuXHQgICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogdmFyIHVzZXJzID0gW1xuXHQgICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScgfSxcblx0ICAgICAqICAgeyAndXNlcic6ICdmcmVkJyB9XG5cdCAgICAgKiBdO1xuXHQgICAgICpcblx0ICAgICAqIHZhciBzaGFsbG93ID0gXy5jbG9uZSh1c2Vycyk7XG5cdCAgICAgKiBzaGFsbG93WzBdID09PSB1c2Vyc1swXTtcblx0ICAgICAqIC8vID0+IHRydWVcblx0ICAgICAqXG5cdCAgICAgKiB2YXIgZGVlcCA9IF8uY2xvbmUodXNlcnMsIHRydWUpO1xuXHQgICAgICogZGVlcFswXSA9PT0gdXNlcnNbMF07XG5cdCAgICAgKiAvLyA9PiBmYWxzZVxuXHQgICAgICpcblx0ICAgICAqIC8vIHVzaW5nIGEgY3VzdG9taXplciBjYWxsYmFja1xuXHQgICAgICogdmFyIGVsID0gXy5jbG9uZShkb2N1bWVudC5ib2R5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICogICBpZiAoXy5pc0VsZW1lbnQodmFsdWUpKSB7XG5cdCAgICAgKiAgICAgcmV0dXJuIHZhbHVlLmNsb25lTm9kZShmYWxzZSk7XG5cdCAgICAgKiAgIH1cblx0ICAgICAqIH0pO1xuXHQgICAgICpcblx0ICAgICAqIGVsID09PSBkb2N1bWVudC5ib2R5XG5cdCAgICAgKiAvLyA9PiBmYWxzZVxuXHQgICAgICogZWwubm9kZU5hbWVcblx0ICAgICAqIC8vID0+IEJPRFlcblx0ICAgICAqIGVsLmNoaWxkTm9kZXMubGVuZ3RoO1xuXHQgICAgICogLy8gPT4gMFxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBjbG9uZSh2YWx1ZSwgaXNEZWVwLCBjdXN0b21pemVyLCB0aGlzQXJnKSB7XG5cdCAgICAgIGlmIChpc0RlZXAgJiYgdHlwZW9mIGlzRGVlcCAhPSAnYm9vbGVhbicgJiYgaXNJdGVyYXRlZUNhbGwodmFsdWUsIGlzRGVlcCwgY3VzdG9taXplcikpIHtcblx0ICAgICAgICBpc0RlZXAgPSBmYWxzZTtcblx0ICAgICAgfVxuXHQgICAgICBlbHNlIGlmICh0eXBlb2YgaXNEZWVwID09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICB0aGlzQXJnID0gY3VzdG9taXplcjtcblx0ICAgICAgICBjdXN0b21pemVyID0gaXNEZWVwO1xuXHQgICAgICAgIGlzRGVlcCA9IGZhbHNlO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nXG5cdCAgICAgICAgPyBiYXNlQ2xvbmUodmFsdWUsIGlzRGVlcCwgYmluZENhbGxiYWNrKGN1c3RvbWl6ZXIsIHRoaXNBcmcsIDEpKVxuXHQgICAgICAgIDogYmFzZUNsb25lKHZhbHVlLCBpc0RlZXApO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ3JlYXRlcyBhIGRlZXAgY2xvbmUgb2YgYHZhbHVlYC4gSWYgYGN1c3RvbWl6ZXJgIGlzIHByb3ZpZGVkIGl0IGlzIGludm9rZWRcblx0ICAgICAqIHRvIHByb2R1Y2UgdGhlIGNsb25lZCB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgIGNsb25pbmdcblx0ICAgICAqIGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYFxuXHQgICAgICogYW5kIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnQ7ICh2YWx1ZSBbLCBpbmRleHxrZXksIG9iamVjdF0pLlxuXHQgICAgICpcblx0ICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uIHRoZVxuXHQgICAgICogW3N0cnVjdHVyZWQgY2xvbmUgYWxnb3JpdGhtXShodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmZyYXN0cnVjdHVyZS5odG1sI2ludGVybmFsLXN0cnVjdHVyZWQtY2xvbmluZy1hbGdvcml0aG0pLlxuXHQgICAgICogVGhlIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgYXJndW1lbnRzYCBvYmplY3RzIGFuZCBvYmplY3RzIGNyZWF0ZWQgYnlcblx0ICAgICAqIGNvbnN0cnVjdG9ycyBvdGhlciB0aGFuIGBPYmplY3RgIGFyZSBjbG9uZWQgdG8gcGxhaW4gYE9iamVjdGAgb2JqZWN0cy4gQW5cblx0ICAgICAqIGVtcHR5IG9iamVjdCBpcyByZXR1cm5lZCBmb3IgdW5jbG9uZWFibGUgdmFsdWVzIHN1Y2ggYXMgZnVuY3Rpb25zLCBET00gbm9kZXMsXG5cdCAgICAgKiBNYXBzLCBTZXRzLCBhbmQgV2Vha01hcHMuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBMYW5nXG5cdCAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBkZWVwIGNsb25lLlxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZyB2YWx1ZXMuXG5cdCAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGN1c3RvbWl6ZXJgLlxuXHQgICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGRlZXAgY2xvbmVkIHZhbHVlLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiB2YXIgdXNlcnMgPSBbXG5cdCAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JyB9LFxuXHQgICAgICogICB7ICd1c2VyJzogJ2ZyZWQnIH1cblx0ICAgICAqIF07XG5cdCAgICAgKlxuXHQgICAgICogdmFyIGRlZXAgPSBfLmNsb25lRGVlcCh1c2Vycyk7XG5cdCAgICAgKiBkZWVwWzBdID09PSB1c2Vyc1swXTtcblx0ICAgICAqIC8vID0+IGZhbHNlXG5cdCAgICAgKlxuXHQgICAgICogLy8gdXNpbmcgYSBjdXN0b21pemVyIGNhbGxiYWNrXG5cdCAgICAgKiB2YXIgZWwgPSBfLmNsb25lRGVlcChkb2N1bWVudC5ib2R5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICogICBpZiAoXy5pc0VsZW1lbnQodmFsdWUpKSB7XG5cdCAgICAgKiAgICAgcmV0dXJuIHZhbHVlLmNsb25lTm9kZSh0cnVlKTtcblx0ICAgICAqICAgfVxuXHQgICAgICogfSk7XG5cdCAgICAgKlxuXHQgICAgICogZWwgPT09IGRvY3VtZW50LmJvZHlcblx0ICAgICAqIC8vID0+IGZhbHNlXG5cdCAgICAgKiBlbC5ub2RlTmFtZVxuXHQgICAgICogLy8gPT4gQk9EWVxuXHQgICAgICogZWwuY2hpbGROb2Rlcy5sZW5ndGg7XG5cdCAgICAgKiAvLyA9PiAyMFxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBjbG9uZURlZXAodmFsdWUsIGN1c3RvbWl6ZXIsIHRoaXNBcmcpIHtcblx0ICAgICAgcmV0dXJuIHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbidcblx0ICAgICAgICA/IGJhc2VDbG9uZSh2YWx1ZSwgdHJ1ZSwgYmluZENhbGxiYWNrKGN1c3RvbWl6ZXIsIHRoaXNBcmcsIDEpKVxuXHQgICAgICAgIDogYmFzZUNsb25lKHZhbHVlLCB0cnVlKTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuXHQgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cblx0ICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG5cdCAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gYG90aGVyYCwgZWxzZSBgZmFsc2VgLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBfLmd0KDMsIDEpO1xuXHQgICAgICogLy8gPT4gdHJ1ZVxuXHQgICAgICpcblx0ICAgICAqIF8uZ3QoMywgMyk7XG5cdCAgICAgKiAvLyA9PiBmYWxzZVxuXHQgICAgICpcblx0ICAgICAqIF8uZ3QoMSwgMyk7XG5cdCAgICAgKiAvLyA9PiBmYWxzZVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBndCh2YWx1ZSwgb3RoZXIpIHtcblx0ICAgICAgcmV0dXJuIHZhbHVlID4gb3RoZXI7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYG90aGVyYC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IExhbmdcblx0ICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG5cdCAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuXHQgICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGBvdGhlcmAsIGVsc2UgYGZhbHNlYC5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogXy5ndGUoMywgMSk7XG5cdCAgICAgKiAvLyA9PiB0cnVlXG5cdCAgICAgKlxuXHQgICAgICogXy5ndGUoMywgMyk7XG5cdCAgICAgKiAvLyA9PiB0cnVlXG5cdCAgICAgKlxuXHQgICAgICogXy5ndGUoMSwgMyk7XG5cdCAgICAgKiAvLyA9PiBmYWxzZVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBndGUodmFsdWUsIG90aGVyKSB7XG5cdCAgICAgIHJldHVybiB2YWx1ZSA+PSBvdGhlcjtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuXHQgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuXHQgICAgICogLy8gPT4gdHJ1ZVxuXHQgICAgICpcblx0ICAgICAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcblx0ICAgICAqIC8vID0+IGZhbHNlXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdCAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKSAmJlxuXHQgICAgICAgIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJiAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IExhbmdcblx0ICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuXHQgICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG5cdCAgICAgKiAvLyA9PiB0cnVlXG5cdCAgICAgKlxuXHQgICAgICogXy5pc0FycmF5KGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuXHQgICAgICogLy8gPT4gZmFsc2Vcblx0ICAgICAqL1xuXHQgICAgdmFyIGlzQXJyYXkgPSBuYXRpdmVJc0FycmF5IHx8IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJyYXlUYWc7XG5cdCAgICB9O1xuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGJvb2xlYW4gcHJpbWl0aXZlIG9yIG9iamVjdC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IExhbmdcblx0ICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuXHQgICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogXy5pc0Jvb2xlYW4oZmFsc2UpO1xuXHQgICAgICogLy8gPT4gdHJ1ZVxuXHQgICAgICpcblx0ICAgICAqIF8uaXNCb29sZWFuKG51bGwpO1xuXHQgICAgICogLy8gPT4gZmFsc2Vcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG5cdCAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2UgfHwgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYm9vbFRhZyk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYERhdGVgIG9iamVjdC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IExhbmdcblx0ICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuXHQgICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogXy5pc0RhdGUobmV3IERhdGUpO1xuXHQgICAgICogLy8gPT4gdHJ1ZVxuXHQgICAgICpcblx0ICAgICAqIF8uaXNEYXRlKCdNb24gQXByaWwgMjMgMjAxMicpO1xuXHQgICAgICogLy8gPT4gZmFsc2Vcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gaXNEYXRlKHZhbHVlKSB7XG5cdCAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IGRhdGVUYWc7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIERPTSBlbGVtZW50LlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuXHQgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIERPTSBlbGVtZW50LCBlbHNlIGBmYWxzZWAuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIF8uaXNFbGVtZW50KGRvY3VtZW50LmJvZHkpO1xuXHQgICAgICogLy8gPT4gdHJ1ZVxuXHQgICAgICpcblx0ICAgICAqIF8uaXNFbGVtZW50KCc8Ym9keT4nKTtcblx0ICAgICAqIC8vID0+IGZhbHNlXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuXHQgICAgICByZXR1cm4gISF2YWx1ZSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMSAmJiBpc09iamVjdExpa2UodmFsdWUpICYmICFpc1BsYWluT2JqZWN0KHZhbHVlKTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGVtcHR5LiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgZW1wdHkgdW5sZXNzIGl0IGlzIGFuXG5cdCAgICAgKiBgYXJndW1lbnRzYCBvYmplY3QsIGFycmF5LCBzdHJpbmcsIG9yIGpRdWVyeS1saWtlIGNvbGxlY3Rpb24gd2l0aCBhIGxlbmd0aFxuXHQgICAgICogZ3JlYXRlciB0aGFuIGAwYCBvciBhbiBvYmplY3Qgd2l0aCBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuXHQgICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cblx0ICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGVtcHR5LCBlbHNlIGBmYWxzZWAuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIF8uaXNFbXB0eShudWxsKTtcblx0ICAgICAqIC8vID0+IHRydWVcblx0ICAgICAqXG5cdCAgICAgKiBfLmlzRW1wdHkodHJ1ZSk7XG5cdCAgICAgKiAvLyA9PiB0cnVlXG5cdCAgICAgKlxuXHQgICAgICogXy5pc0VtcHR5KDEpO1xuXHQgICAgICogLy8gPT4gdHJ1ZVxuXHQgICAgICpcblx0ICAgICAqIF8uaXNFbXB0eShbMSwgMiwgM10pO1xuXHQgICAgICogLy8gPT4gZmFsc2Vcblx0ICAgICAqXG5cdCAgICAgKiBfLmlzRW1wdHkoeyAnYSc6IDEgfSk7XG5cdCAgICAgKiAvLyA9PiBmYWxzZVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG5cdCAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG5cdCAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJiAoaXNBcnJheSh2YWx1ZSkgfHwgaXNTdHJpbmcodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fFxuXHQgICAgICAgICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNGdW5jdGlvbih2YWx1ZS5zcGxpY2UpKSkpIHtcblx0ICAgICAgICByZXR1cm4gIXZhbHVlLmxlbmd0aDtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gIWtleXModmFsdWUpLmxlbmd0aDtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmVcblx0ICAgICAqIGVxdWl2YWxlbnQuIElmIGBjdXN0b21pemVyYCBpcyBwcm92aWRlZCBpdCBpcyBpbnZva2VkIHRvIGNvbXBhcmUgdmFsdWVzLlxuXHQgICAgICogSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAgY29tcGFyaXNvbnMgYXJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZFxuXHQgICAgICogaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuXHQgICAgICogYXJndW1lbnRzOiAodmFsdWUsIG90aGVyIFssIGluZGV4fGtleV0pLlxuXHQgICAgICpcblx0ICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBib29sZWFucywgYERhdGVgIG9iamVjdHMsXG5cdCAgICAgKiBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLCBhbmQgc3RyaW5ncy4gT2JqZWN0cyBhcmUgY29tcGFyZWQgYnlcblx0ICAgICAqIHRoZWlyIG93biwgbm90IGluaGVyaXRlZCwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLiBGdW5jdGlvbnMgYW5kIERPTSBub2Rlc1xuXHQgICAgICogYXJlICoqbm90Kiogc3VwcG9ydGVkLiBQcm92aWRlIGEgY3VzdG9taXplciBmdW5jdGlvbiB0byBleHRlbmQgc3VwcG9ydFxuXHQgICAgICogZm9yIGNvbXBhcmluZyBvdGhlciB2YWx1ZXMuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBhbGlhcyBlcVxuXHQgICAgICogQGNhdGVnb3J5IExhbmdcblx0ICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG5cdCAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgdmFsdWUgY29tcGFyaXNvbnMuXG5cdCAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGN1c3RvbWl6ZXJgLlxuXHQgICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcblx0ICAgICAqIHZhciBvdGhlciA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcblx0ICAgICAqXG5cdCAgICAgKiBvYmplY3QgPT0gb3RoZXI7XG5cdCAgICAgKiAvLyA9PiBmYWxzZVxuXHQgICAgICpcblx0ICAgICAqIF8uaXNFcXVhbChvYmplY3QsIG90aGVyKTtcblx0ICAgICAqIC8vID0+IHRydWVcblx0ICAgICAqXG5cdCAgICAgKiAvLyB1c2luZyBhIGN1c3RvbWl6ZXIgY2FsbGJhY2tcblx0ICAgICAqIHZhciBhcnJheSA9IFsnaGVsbG8nLCAnZ29vZGJ5ZSddO1xuXHQgICAgICogdmFyIG90aGVyID0gWydoaScsICdnb29kYnllJ107XG5cdCAgICAgKlxuXHQgICAgICogXy5pc0VxdWFsKGFycmF5LCBvdGhlciwgZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG5cdCAgICAgKiAgIGlmIChfLmV2ZXJ5KFt2YWx1ZSwgb3RoZXJdLCBSZWdFeHAucHJvdG90eXBlLnRlc3QsIC9eaCg/Oml8ZWxsbykkLykpIHtcblx0ICAgICAqICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAqICAgfVxuXHQgICAgICogfSk7XG5cdCAgICAgKiAvLyA9PiB0cnVlXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGlzRXF1YWwodmFsdWUsIG90aGVyLCBjdXN0b21pemVyLCB0aGlzQXJnKSB7XG5cdCAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gYmluZENhbGxiYWNrKGN1c3RvbWl6ZXIsIHRoaXNBcmcsIDMpIDogdW5kZWZpbmVkO1xuXHQgICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIodmFsdWUsIG90aGVyKSA6IHVuZGVmaW5lZDtcblx0ICAgICAgcmV0dXJuICByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgY3VzdG9taXplcikgOiAhIXJlc3VsdDtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGBFcnJvcmAsIGBFdmFsRXJyb3JgLCBgUmFuZ2VFcnJvcmAsIGBSZWZlcmVuY2VFcnJvcmAsXG5cdCAgICAgKiBgU3ludGF4RXJyb3JgLCBgVHlwZUVycm9yYCwgb3IgYFVSSUVycm9yYCBvYmplY3QuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBMYW5nXG5cdCAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cblx0ICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGVycm9yIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBfLmlzRXJyb3IobmV3IEVycm9yKTtcblx0ICAgICAqIC8vID0+IHRydWVcblx0ICAgICAqXG5cdCAgICAgKiBfLmlzRXJyb3IoRXJyb3IpO1xuXHQgICAgICogLy8gPT4gZmFsc2Vcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gaXNFcnJvcih2YWx1ZSkge1xuXHQgICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUubWVzc2FnZSA9PSAnc3RyaW5nJyAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBlcnJvclRhZztcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmluaXRlIHByaW1pdGl2ZSBudW1iZXIuXG5cdCAgICAgKlxuXHQgICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uIFtgTnVtYmVyLmlzRmluaXRlYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLmlzZmluaXRlKS5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IExhbmdcblx0ICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuXHQgICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgbnVtYmVyLCBlbHNlIGBmYWxzZWAuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIF8uaXNGaW5pdGUoMTApO1xuXHQgICAgICogLy8gPT4gdHJ1ZVxuXHQgICAgICpcblx0ICAgICAqIF8uaXNGaW5pdGUoJzEwJyk7XG5cdCAgICAgKiAvLyA9PiBmYWxzZVxuXHQgICAgICpcblx0ICAgICAqIF8uaXNGaW5pdGUodHJ1ZSk7XG5cdCAgICAgKiAvLyA9PiBmYWxzZVxuXHQgICAgICpcblx0ICAgICAqIF8uaXNGaW5pdGUoT2JqZWN0KDEwKSk7XG5cdCAgICAgKiAvLyA9PiBmYWxzZVxuXHQgICAgICpcblx0ICAgICAqIF8uaXNGaW5pdGUoSW5maW5pdHkpO1xuXHQgICAgICogLy8gPT4gZmFsc2Vcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gaXNGaW5pdGUodmFsdWUpIHtcblx0ICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiBuYXRpdmVJc0Zpbml0ZSh2YWx1ZSk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBMYW5nXG5cdCAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cblx0ICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIF8uaXNGdW5jdGlvbihfKTtcblx0ICAgICAqIC8vID0+IHRydWVcblx0ICAgICAqXG5cdCAgICAgKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuXHQgICAgICogLy8gPT4gZmFsc2Vcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3Jcblx0ICAgICAgLy8gaW4gb2xkZXIgdmVyc2lvbnMgb2YgQ2hyb21lIGFuZCBTYWZhcmkgd2hpY2ggcmV0dXJuICdmdW5jdGlvbicgZm9yIHJlZ2V4ZXNcblx0ICAgICAgLy8gYW5kIFNhZmFyaSA4IGVxdWl2YWxlbnRzIHdoaWNoIHJldHVybiAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXkgY29uc3RydWN0b3JzLlxuXHQgICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IGZ1bmNUYWc7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUgW2xhbmd1YWdlIHR5cGVdKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDgpIG9mIGBPYmplY3RgLlxuXHQgICAgICogKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBMYW5nXG5cdCAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cblx0ICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBfLmlzT2JqZWN0KHt9KTtcblx0ICAgICAqIC8vID0+IHRydWVcblx0ICAgICAqXG5cdCAgICAgKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG5cdCAgICAgKiAvLyA9PiB0cnVlXG5cdCAgICAgKlxuXHQgICAgICogXy5pc09iamVjdCgxKTtcblx0ICAgICAqIC8vID0+IGZhbHNlXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG5cdCAgICAgIC8vIEF2b2lkIGEgVjggSklUIGJ1ZyBpbiBDaHJvbWUgMTktMjAuXG5cdCAgICAgIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MSBmb3IgbW9yZSBkZXRhaWxzLlxuXHQgICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblx0ICAgICAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gYG9iamVjdGAgYW5kIGBzb3VyY2VgIHRvIGRldGVybWluZSBpZlxuXHQgICAgICogYG9iamVjdGAgY29udGFpbnMgZXF1aXZhbGVudCBwcm9wZXJ0eSB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCBpcyBwcm92aWRlZFxuXHQgICAgICogaXQgaXMgaW52b2tlZCB0byBjb21wYXJlIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGBcblx0ICAgICAqIGNvbXBhcmlzb25zIGFyZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBib3VuZFxuXHQgICAgICogdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIG90aGVyLCBpbmRleHxrZXkpLlxuXHQgICAgICpcblx0ICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgcHJvcGVydGllcyBvZiBhcnJheXMsIGJvb2xlYW5zLFxuXHQgICAgICogYERhdGVgIG9iamVjdHMsIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsIGFuZCBzdHJpbmdzLiBGdW5jdGlvbnNcblx0ICAgICAqIGFuZCBET00gbm9kZXMgYXJlICoqbm90Kiogc3VwcG9ydGVkLiBQcm92aWRlIGEgY3VzdG9taXplciBmdW5jdGlvbiB0byBleHRlbmRcblx0ICAgICAqIHN1cHBvcnQgZm9yIGNvbXBhcmluZyBvdGhlciB2YWx1ZXMuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBMYW5nXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSB2YWx1ZSBjb21wYXJpc29ucy5cblx0ICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY3VzdG9taXplcmAuXG5cdCAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH07XG5cdCAgICAgKlxuXHQgICAgICogXy5pc01hdGNoKG9iamVjdCwgeyAnYWdlJzogNDAgfSk7XG5cdCAgICAgKiAvLyA9PiB0cnVlXG5cdCAgICAgKlxuXHQgICAgICogXy5pc01hdGNoKG9iamVjdCwgeyAnYWdlJzogMzYgfSk7XG5cdCAgICAgKiAvLyA9PiBmYWxzZVxuXHQgICAgICpcblx0ICAgICAqIC8vIHVzaW5nIGEgY3VzdG9taXplciBjYWxsYmFja1xuXHQgICAgICogdmFyIG9iamVjdCA9IHsgJ2dyZWV0aW5nJzogJ2hlbGxvJyB9O1xuXHQgICAgICogdmFyIHNvdXJjZSA9IHsgJ2dyZWV0aW5nJzogJ2hpJyB9O1xuXHQgICAgICpcblx0ICAgICAqIF8uaXNNYXRjaChvYmplY3QsIHNvdXJjZSwgZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG5cdCAgICAgKiAgIHJldHVybiBfLmV2ZXJ5KFt2YWx1ZSwgb3RoZXJdLCBSZWdFeHAucHJvdG90eXBlLnRlc3QsIC9eaCg/Oml8ZWxsbykkLykgfHwgdW5kZWZpbmVkO1xuXHQgICAgICogfSk7XG5cdCAgICAgKiAvLyA9PiB0cnVlXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIsIHRoaXNBcmcpIHtcblx0ICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBiaW5kQ2FsbGJhY2soY3VzdG9taXplciwgdGhpc0FyZywgMykgOiB1bmRlZmluZWQ7XG5cdCAgICAgIHJldHVybiBiYXNlSXNNYXRjaChvYmplY3QsIGdldE1hdGNoRGF0YShzb3VyY2UpLCBjdXN0b21pemVyKTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBOYU5gLlxuXHQgICAgICpcblx0ICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBub3QgdGhlIHNhbWUgYXMgW2Bpc05hTmBdKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEuMi40KVxuXHQgICAgICogd2hpY2ggcmV0dXJucyBgdHJ1ZWAgZm9yIGB1bmRlZmluZWRgIGFuZCBvdGhlciBub24tbnVtZXJpYyB2YWx1ZXMuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBMYW5nXG5cdCAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cblx0ICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIF8uaXNOYU4oTmFOKTtcblx0ICAgICAqIC8vID0+IHRydWVcblx0ICAgICAqXG5cdCAgICAgKiBfLmlzTmFOKG5ldyBOdW1iZXIoTmFOKSk7XG5cdCAgICAgKiAvLyA9PiB0cnVlXG5cdCAgICAgKlxuXHQgICAgICogaXNOYU4odW5kZWZpbmVkKTtcblx0ICAgICAqIC8vID0+IHRydWVcblx0ICAgICAqXG5cdCAgICAgKiBfLmlzTmFOKHVuZGVmaW5lZCk7XG5cdCAgICAgKiAvLyA9PiBmYWxzZVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBpc05hTih2YWx1ZSkge1xuXHQgICAgICAvLyBBbiBgTmFOYCBwcmltaXRpdmUgaXMgdGhlIG9ubHkgdmFsdWUgdGhhdCBpcyBub3QgZXF1YWwgdG8gaXRzZWxmLlxuXHQgICAgICAvLyBQZXJmb3JtIHRoZSBgdG9TdHJpbmdUYWdgIGNoZWNrIGZpcnN0IHRvIGF2b2lkIGVycm9ycyB3aXRoIHNvbWUgaG9zdCBvYmplY3RzIGluIElFLlxuXHQgICAgICByZXR1cm4gaXNOdW1iZXIodmFsdWUpICYmIHZhbHVlICE9ICt2YWx1ZTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuXHQgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBfLmlzTmF0aXZlKEFycmF5LnByb3RvdHlwZS5wdXNoKTtcblx0ICAgICAqIC8vID0+IHRydWVcblx0ICAgICAqXG5cdCAgICAgKiBfLmlzTmF0aXZlKF8pO1xuXHQgICAgICogLy8gPT4gZmFsc2Vcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gaXNOYXRpdmUodmFsdWUpIHtcblx0ICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG5cdCAgICAgICAgcmV0dXJuIHJlSXNOYXRpdmUudGVzdChmblRvU3RyaW5nLmNhbGwodmFsdWUpKTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiByZUlzSG9zdEN0b3IudGVzdCh2YWx1ZSk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgbnVsbGAuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBMYW5nXG5cdCAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cblx0ICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBudWxsYCwgZWxzZSBgZmFsc2VgLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBfLmlzTnVsbChudWxsKTtcblx0ICAgICAqIC8vID0+IHRydWVcblx0ICAgICAqXG5cdCAgICAgKiBfLmlzTnVsbCh2b2lkIDApO1xuXHQgICAgICogLy8gPT4gZmFsc2Vcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gaXNOdWxsKHZhbHVlKSB7XG5cdCAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTnVtYmVyYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuXHQgICAgICpcblx0ICAgICAqICoqTm90ZToqKiBUbyBleGNsdWRlIGBJbmZpbml0eWAsIGAtSW5maW5pdHlgLCBhbmQgYE5hTmAsIHdoaWNoIGFyZSBjbGFzc2lmaWVkXG5cdCAgICAgKiBhcyBudW1iZXJzLCB1c2UgdGhlIGBfLmlzRmluaXRlYCBtZXRob2QuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBMYW5nXG5cdCAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cblx0ICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIF8uaXNOdW1iZXIoOC40KTtcblx0ICAgICAqIC8vID0+IHRydWVcblx0ICAgICAqXG5cdCAgICAgKiBfLmlzTnVtYmVyKE5hTik7XG5cdCAgICAgKiAvLyA9PiB0cnVlXG5cdCAgICAgKlxuXHQgICAgICogXy5pc051bWJlcignOC40Jyk7XG5cdCAgICAgKiAvLyA9PiBmYWxzZVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuXHQgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IChpc09iamVjdExpa2UodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IG51bWJlclRhZyk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG5cdCAgICAgKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG5cdCAgICAgKlxuXHQgICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGFzc3VtZXMgb2JqZWN0cyBjcmVhdGVkIGJ5IHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3RvclxuXHQgICAgICogaGF2ZSBubyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuXHQgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG5cdCAgICAgKiAgIHRoaXMuYSA9IDE7XG5cdCAgICAgKiB9XG5cdCAgICAgKlxuXHQgICAgICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuXHQgICAgICogLy8gPT4gZmFsc2Vcblx0ICAgICAqXG5cdCAgICAgKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcblx0ICAgICAqIC8vID0+IGZhbHNlXG5cdCAgICAgKlxuXHQgICAgICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG5cdCAgICAgKiAvLyA9PiB0cnVlXG5cdCAgICAgKlxuXHQgICAgICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuXHQgICAgICogLy8gPT4gdHJ1ZVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG5cdCAgICAgIHZhciBDdG9yO1xuXHRcblx0ICAgICAgLy8gRXhpdCBlYXJseSBmb3Igbm9uIGBPYmplY3RgIG9iamVjdHMuXG5cdCAgICAgIGlmICghKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gb2JqZWN0VGFnICYmICFpc0FyZ3VtZW50cyh2YWx1ZSkpIHx8XG5cdCAgICAgICAgICAoIWhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjb25zdHJ1Y3RvcicpICYmIChDdG9yID0gdmFsdWUuY29uc3RydWN0b3IsIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgIShDdG9yIGluc3RhbmNlb2YgQ3RvcikpKSkge1xuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgfVxuXHQgICAgICAvLyBJRSA8IDkgaXRlcmF0ZXMgaW5oZXJpdGVkIHByb3BlcnRpZXMgYmVmb3JlIG93biBwcm9wZXJ0aWVzLiBJZiB0aGUgZmlyc3Rcblx0ICAgICAgLy8gaXRlcmF0ZWQgcHJvcGVydHkgaXMgYW4gb2JqZWN0J3Mgb3duIHByb3BlcnR5IHRoZW4gdGhlcmUgYXJlIG5vIGluaGVyaXRlZFxuXHQgICAgICAvLyBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG5cdCAgICAgIHZhciByZXN1bHQ7XG5cdCAgICAgIC8vIEluIG1vc3QgZW52aXJvbm1lbnRzIGFuIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzIGFyZSBpdGVyYXRlZCBiZWZvcmVcblx0ICAgICAgLy8gaXRzIGluaGVyaXRlZCBwcm9wZXJ0aWVzLiBJZiB0aGUgbGFzdCBpdGVyYXRlZCBwcm9wZXJ0eSBpcyBhbiBvYmplY3Qnc1xuXHQgICAgICAvLyBvd24gcHJvcGVydHkgdGhlbiB0aGVyZSBhcmUgbm8gaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cblx0ICAgICAgYmFzZUZvckluKHZhbHVlLCBmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG5cdCAgICAgICAgcmVzdWx0ID0ga2V5O1xuXHQgICAgICB9KTtcblx0ICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHJlc3VsdCk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFJlZ0V4cGAgb2JqZWN0LlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuXHQgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBfLmlzUmVnRXhwKC9hYmMvKTtcblx0ICAgICAqIC8vID0+IHRydWVcblx0ICAgICAqXG5cdCAgICAgKiBfLmlzUmVnRXhwKCcvYWJjLycpO1xuXHQgICAgICogLy8gPT4gZmFsc2Vcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gaXNSZWdFeHAodmFsdWUpIHtcblx0ICAgICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSByZWdleHBUYWc7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN0cmluZ2AgcHJpbWl0aXZlIG9yIG9iamVjdC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IExhbmdcblx0ICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuXHQgICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogXy5pc1N0cmluZygnYWJjJyk7XG5cdCAgICAgKiAvLyA9PiB0cnVlXG5cdCAgICAgKlxuXHQgICAgICogXy5pc1N0cmluZygxKTtcblx0ICAgICAqIC8vID0+IGZhbHNlXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG5cdCAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3RyaW5nVGFnKTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IExhbmdcblx0ICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuXHQgICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuXHQgICAgICogLy8gPT4gdHJ1ZVxuXHQgICAgICpcblx0ICAgICAqIF8uaXNUeXBlZEFycmF5KFtdKTtcblx0ICAgICAqIC8vID0+IGZhbHNlXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGlzVHlwZWRBcnJheSh2YWx1ZSkge1xuXHQgICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3Nbb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSldO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBMYW5nXG5cdCAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cblx0ICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLCBlbHNlIGBmYWxzZWAuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIF8uaXNVbmRlZmluZWQodm9pZCAwKTtcblx0ICAgICAqIC8vID0+IHRydWVcblx0ICAgICAqXG5cdCAgICAgKiBfLmlzVW5kZWZpbmVkKG51bGwpO1xuXHQgICAgICogLy8gPT4gZmFsc2Vcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcblx0ICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQ7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IExhbmdcblx0ICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG5cdCAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuXHQgICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIGBvdGhlcmAsIGVsc2UgYGZhbHNlYC5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogXy5sdCgxLCAzKTtcblx0ICAgICAqIC8vID0+IHRydWVcblx0ICAgICAqXG5cdCAgICAgKiBfLmx0KDMsIDMpO1xuXHQgICAgICogLy8gPT4gZmFsc2Vcblx0ICAgICAqXG5cdCAgICAgKiBfLmx0KDMsIDEpO1xuXHQgICAgICogLy8gPT4gZmFsc2Vcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gbHQodmFsdWUsIG90aGVyKSB7XG5cdCAgICAgIHJldHVybiB2YWx1ZSA8IG90aGVyO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBvdGhlcmAuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBMYW5nXG5cdCAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuXHQgICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cblx0ICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgb3RoZXJgLCBlbHNlIGBmYWxzZWAuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIF8ubHRlKDEsIDMpO1xuXHQgICAgICogLy8gPT4gdHJ1ZVxuXHQgICAgICpcblx0ICAgICAqIF8ubHRlKDMsIDMpO1xuXHQgICAgICogLy8gPT4gdHJ1ZVxuXHQgICAgICpcblx0ICAgICAqIF8ubHRlKDMsIDEpO1xuXHQgICAgICogLy8gPT4gZmFsc2Vcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gbHRlKHZhbHVlLCBvdGhlcikge1xuXHQgICAgICByZXR1cm4gdmFsdWUgPD0gb3RoZXI7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGFycmF5LlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuXHQgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cblx0ICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAoZnVuY3Rpb24oKSB7XG5cdCAgICAgKiAgIHJldHVybiBfLnRvQXJyYXkoYXJndW1lbnRzKS5zbGljZSgxKTtcblx0ICAgICAqIH0oMSwgMiwgMykpO1xuXHQgICAgICogLy8gPT4gWzIsIDNdXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIHRvQXJyYXkodmFsdWUpIHtcblx0ICAgICAgdmFyIGxlbmd0aCA9IHZhbHVlID8gZ2V0TGVuZ3RoKHZhbHVlKSA6IDA7XG5cdCAgICAgIGlmICghaXNMZW5ndGgobGVuZ3RoKSkge1xuXHQgICAgICAgIHJldHVybiB2YWx1ZXModmFsdWUpO1xuXHQgICAgICB9XG5cdCAgICAgIGlmICghbGVuZ3RoKSB7XG5cdCAgICAgICAgcmV0dXJuIFtdO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBhcnJheUNvcHkodmFsdWUpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHBsYWluIG9iamVjdCBmbGF0dGVuaW5nIGluaGVyaXRlZCBlbnVtZXJhYmxlXG5cdCAgICAgKiBwcm9wZXJ0aWVzIG9mIGB2YWx1ZWAgdG8gb3duIHByb3BlcnRpZXMgb2YgdGhlIHBsYWluIG9iamVjdC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IExhbmdcblx0ICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG5cdCAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgcGxhaW4gb2JqZWN0LlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG5cdCAgICAgKiAgIHRoaXMuYiA9IDI7XG5cdCAgICAgKiB9XG5cdCAgICAgKlxuXHQgICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcblx0ICAgICAqXG5cdCAgICAgKiBfLmFzc2lnbih7ICdhJzogMSB9LCBuZXcgRm9vKTtcblx0ICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuXHQgICAgICpcblx0ICAgICAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIF8udG9QbGFpbk9iamVjdChuZXcgRm9vKSk7XG5cdCAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiB0b1BsYWluT2JqZWN0KHZhbHVlKSB7XG5cdCAgICAgIHJldHVybiBiYXNlQ29weSh2YWx1ZSwga2V5c0luKHZhbHVlKSk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHRcblx0ICAgIC8qKlxuXHQgICAgICogUmVjdXJzaXZlbHkgbWVyZ2VzIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgdGhlIHNvdXJjZSBvYmplY3QocyksIHRoYXRcblx0ICAgICAqIGRvbid0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAgaW50byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LiBTdWJzZXF1ZW50IHNvdXJjZXNcblx0ICAgICAqIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLiBJZiBgY3VzdG9taXplcmAgaXNcblx0ICAgICAqIHByb3ZpZGVkIGl0IGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgbWVyZ2VkIHZhbHVlcyBvZiB0aGUgZGVzdGluYXRpb24gYW5kXG5cdCAgICAgKiBzb3VyY2UgcHJvcGVydGllcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAgbWVyZ2luZyBpcyBoYW5kbGVkXG5cdCAgICAgKiBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkXG5cdCAgICAgKiB3aXRoIGZpdmUgYXJndW1lbnRzOiAob2JqZWN0VmFsdWUsIHNvdXJjZVZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKS5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IE9iamVjdFxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuXHQgICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG5cdCAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGN1c3RvbWl6ZXJgLlxuXHQgICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogdmFyIHVzZXJzID0ge1xuXHQgICAgICogICAnZGF0YSc6IFt7ICd1c2VyJzogJ2Jhcm5leScgfSwgeyAndXNlcic6ICdmcmVkJyB9XVxuXHQgICAgICogfTtcblx0ICAgICAqXG5cdCAgICAgKiB2YXIgYWdlcyA9IHtcblx0ICAgICAqICAgJ2RhdGEnOiBbeyAnYWdlJzogMzYgfSwgeyAnYWdlJzogNDAgfV1cblx0ICAgICAqIH07XG5cdCAgICAgKlxuXHQgICAgICogXy5tZXJnZSh1c2VycywgYWdlcyk7XG5cdCAgICAgKiAvLyA9PiB7ICdkYXRhJzogW3sgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sIHsgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiA0MCB9XSB9XG5cdCAgICAgKlxuXHQgICAgICogLy8gdXNpbmcgYSBjdXN0b21pemVyIGNhbGxiYWNrXG5cdCAgICAgKiB2YXIgb2JqZWN0ID0ge1xuXHQgICAgICogICAnZnJ1aXRzJzogWydhcHBsZSddLFxuXHQgICAgICogICAndmVnZXRhYmxlcyc6IFsnYmVldCddXG5cdCAgICAgKiB9O1xuXHQgICAgICpcblx0ICAgICAqIHZhciBvdGhlciA9IHtcblx0ICAgICAqICAgJ2ZydWl0cyc6IFsnYmFuYW5hJ10sXG5cdCAgICAgKiAgICd2ZWdldGFibGVzJzogWydjYXJyb3QnXVxuXHQgICAgICogfTtcblx0ICAgICAqXG5cdCAgICAgKiBfLm1lcmdlKG9iamVjdCwgb3RoZXIsIGZ1bmN0aW9uKGEsIGIpIHtcblx0ICAgICAqICAgaWYgKF8uaXNBcnJheShhKSkge1xuXHQgICAgICogICAgIHJldHVybiBhLmNvbmNhdChiKTtcblx0ICAgICAqICAgfVxuXHQgICAgICogfSk7XG5cdCAgICAgKiAvLyA9PiB7ICdmcnVpdHMnOiBbJ2FwcGxlJywgJ2JhbmFuYSddLCAndmVnZXRhYmxlcyc6IFsnYmVldCcsICdjYXJyb3QnXSB9XG5cdCAgICAgKi9cblx0ICAgIHZhciBtZXJnZSA9IGNyZWF0ZUFzc2lnbmVyKGJhc2VNZXJnZSk7XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdChzKSB0byB0aGUgZGVzdGluYXRpb25cblx0ICAgICAqIG9iamVjdC4gU3Vic2VxdWVudCBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuXHQgICAgICogSWYgYGN1c3RvbWl6ZXJgIGlzIHByb3ZpZGVkIGl0IGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgYXNzaWduZWQgdmFsdWVzLlxuXHQgICAgICogVGhlIGBjdXN0b21pemVyYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCBmaXZlIGFyZ3VtZW50czpcblx0ICAgICAqIChvYmplY3RWYWx1ZSwgc291cmNlVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuXHQgICAgICpcblx0ICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgIGFuZCBpcyBiYXNlZCBvblxuXHQgICAgICogW2BPYmplY3QuYXNzaWduYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LmFzc2lnbikuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBhbGlhcyBleHRlbmRcblx0ICAgICAqIEBjYXRlZ29yeSBPYmplY3Rcblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cblx0ICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuXHQgICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjdXN0b21pemVyYC5cblx0ICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIF8uYXNzaWduKHsgJ3VzZXInOiAnYmFybmV5JyB9LCB7ICdhZ2UnOiA0MCB9LCB7ICd1c2VyJzogJ2ZyZWQnIH0pO1xuXHQgICAgICogLy8gPT4geyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH1cblx0ICAgICAqXG5cdCAgICAgKiAvLyB1c2luZyBhIGN1c3RvbWl6ZXIgY2FsbGJhY2tcblx0ICAgICAqIHZhciBkZWZhdWx0cyA9IF8ucGFydGlhbFJpZ2h0KF8uYXNzaWduLCBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcblx0ICAgICAqICAgcmV0dXJuIF8uaXNVbmRlZmluZWQodmFsdWUpID8gb3RoZXIgOiB2YWx1ZTtcblx0ICAgICAqIH0pO1xuXHQgICAgICpcblx0ICAgICAqIGRlZmF1bHRzKHsgJ3VzZXInOiAnYmFybmV5JyB9LCB7ICdhZ2UnOiAzNiB9LCB7ICd1c2VyJzogJ2ZyZWQnIH0pO1xuXHQgICAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuXHQgICAgICovXG5cdCAgICB2YXIgYXNzaWduID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpIHtcblx0ICAgICAgcmV0dXJuIGN1c3RvbWl6ZXJcblx0ICAgICAgICA/IGFzc2lnbldpdGgob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpXG5cdCAgICAgICAgOiBiYXNlQXNzaWduKG9iamVjdCwgc291cmNlKTtcblx0ICAgIH0pO1xuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoZSBnaXZlbiBgcHJvdG90eXBlYCBvYmplY3QuIElmIGFcblx0ICAgICAqIGBwcm9wZXJ0aWVzYCBvYmplY3QgaXMgcHJvdmlkZWQgaXRzIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgYXJlIGFzc2lnbmVkXG5cdCAgICAgKiB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBPYmplY3Rcblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdIFRoZSBwcm9wZXJ0aWVzIHRvIGFzc2lnbiB0byB0aGUgb2JqZWN0LlxuXHQgICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG5cdCAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBmdW5jdGlvbiBTaGFwZSgpIHtcblx0ICAgICAqICAgdGhpcy54ID0gMDtcblx0ICAgICAqICAgdGhpcy55ID0gMDtcblx0ICAgICAqIH1cblx0ICAgICAqXG5cdCAgICAgKiBmdW5jdGlvbiBDaXJjbGUoKSB7XG5cdCAgICAgKiAgIFNoYXBlLmNhbGwodGhpcyk7XG5cdCAgICAgKiB9XG5cdCAgICAgKlxuXHQgICAgICogQ2lyY2xlLnByb3RvdHlwZSA9IF8uY3JlYXRlKFNoYXBlLnByb3RvdHlwZSwge1xuXHQgICAgICogICAnY29uc3RydWN0b3InOiBDaXJjbGVcblx0ICAgICAqIH0pO1xuXHQgICAgICpcblx0ICAgICAqIHZhciBjaXJjbGUgPSBuZXcgQ2lyY2xlO1xuXHQgICAgICogY2lyY2xlIGluc3RhbmNlb2YgQ2lyY2xlO1xuXHQgICAgICogLy8gPT4gdHJ1ZVxuXHQgICAgICpcblx0ICAgICAqIGNpcmNsZSBpbnN0YW5jZW9mIFNoYXBlO1xuXHQgICAgICogLy8gPT4gdHJ1ZVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBjcmVhdGUocHJvdG90eXBlLCBwcm9wZXJ0aWVzLCBndWFyZCkge1xuXHQgICAgICB2YXIgcmVzdWx0ID0gYmFzZUNyZWF0ZShwcm90b3R5cGUpO1xuXHQgICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwocHJvdG90eXBlLCBwcm9wZXJ0aWVzLCBndWFyZCkpIHtcblx0ICAgICAgICBwcm9wZXJ0aWVzID0gdW5kZWZpbmVkO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBwcm9wZXJ0aWVzID8gYmFzZUFzc2lnbihyZXN1bHQsIHByb3BlcnRpZXMpIDogcmVzdWx0O1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQXNzaWducyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3QocykgdG8gdGhlIGRlc3RpbmF0aW9uXG5cdCAgICAgKiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC4gT25jZSBhXG5cdCAgICAgKiBwcm9wZXJ0eSBpcyBzZXQsIGFkZGl0aW9uYWwgdmFsdWVzIG9mIHRoZSBzYW1lIHByb3BlcnR5IGFyZSBpZ25vcmVkLlxuXHQgICAgICpcblx0ICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG5cdCAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cblx0ICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIF8uZGVmYXVsdHMoeyAndXNlcic6ICdiYXJuZXknIH0sIHsgJ2FnZSc6IDM2IH0sIHsgJ3VzZXInOiAnZnJlZCcgfSk7XG5cdCAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG5cdCAgICAgKi9cblx0ICAgIHZhciBkZWZhdWx0cyA9IGNyZWF0ZURlZmF1bHRzKGFzc2lnbiwgYXNzaWduRGVmYXVsdHMpO1xuXHRcblx0ICAgIC8qKlxuXHQgICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5kZWZhdWx0c2AgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgYXNzaWduc1xuXHQgICAgICogZGVmYXVsdCBwcm9wZXJ0aWVzLlxuXHQgICAgICpcblx0ICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG5cdCAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cblx0ICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIF8uZGVmYXVsdHNEZWVwKHsgJ3VzZXInOiB7ICduYW1lJzogJ2Jhcm5leScgfSB9LCB7ICd1c2VyJzogeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDM2IH0gfSk7XG5cdCAgICAgKiAvLyA9PiB7ICd1c2VyJzogeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSB9XG5cdCAgICAgKlxuXHQgICAgICovXG5cdCAgICB2YXIgZGVmYXVsdHNEZWVwID0gY3JlYXRlRGVmYXVsdHMobWVyZ2UsIG1lcmdlRGVmYXVsdHMpO1xuXHRcblx0ICAgIC8qKlxuXHQgICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBrZXkgb2YgdGhlIGZpcnN0XG5cdCAgICAgKiBlbGVtZW50IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cblx0ICAgICAqXG5cdCAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuXHQgICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG5cdCAgICAgKlxuXHQgICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuXHQgICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG5cdCAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuXHQgICAgICpcblx0ICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYHByZWRpY2F0ZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcblx0ICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG5cdCAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IE9iamVjdFxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHNlYXJjaC5cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuXHQgICAgICogIHBlciBpdGVyYXRpb24uXG5cdCAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG5cdCAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUga2V5IG9mIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIHZhciB1c2VycyA9IHtcblx0ICAgICAqICAgJ2Jhcm5leSc6ICB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcblx0ICAgICAqICAgJ2ZyZWQnOiAgICB7ICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG5cdCAgICAgKiAgICdwZWJibGVzJzogeyAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cblx0ICAgICAqIH07XG5cdCAgICAgKlxuXHQgICAgICogXy5maW5kS2V5KHVzZXJzLCBmdW5jdGlvbihjaHIpIHtcblx0ICAgICAqICAgcmV0dXJuIGNoci5hZ2UgPCA0MDtcblx0ICAgICAqIH0pO1xuXHQgICAgICogLy8gPT4gJ2Jhcm5leScgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcblx0ICAgICAqXG5cdCAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc2AgY2FsbGJhY2sgc2hvcnRoYW5kXG5cdCAgICAgKiBfLmZpbmRLZXkodXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiB0cnVlIH0pO1xuXHQgICAgICogLy8gPT4gJ3BlYmJsZXMnXG5cdCAgICAgKlxuXHQgICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG5cdCAgICAgKiBfLmZpbmRLZXkodXNlcnMsICdhY3RpdmUnLCBmYWxzZSk7XG5cdCAgICAgKiAvLyA9PiAnZnJlZCdcblx0ICAgICAqXG5cdCAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuXHQgICAgICogXy5maW5kS2V5KHVzZXJzLCAnYWN0aXZlJyk7XG5cdCAgICAgKiAvLyA9PiAnYmFybmV5J1xuXHQgICAgICovXG5cdCAgICB2YXIgZmluZEtleSA9IGNyZWF0ZUZpbmRLZXkoYmFzZUZvck93bik7XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRLZXlgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2Zcblx0ICAgICAqIGEgY29sbGVjdGlvbiBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG5cdCAgICAgKlxuXHQgICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgcHJlZGljYXRlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcblx0ICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuXHQgICAgICpcblx0ICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcblx0ICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuXHQgICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cblx0ICAgICAqXG5cdCAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBwcmVkaWNhdGVgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNgIHN0eWxlXG5cdCAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlblxuXHQgICAgICogb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBPYmplY3Rcblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBzZWFyY2guXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcblx0ICAgICAqICBwZXIgaXRlcmF0aW9uLlxuXHQgICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBwcmVkaWNhdGVgLlxuXHQgICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFJldHVybnMgdGhlIGtleSBvZiB0aGUgbWF0Y2hlZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiB2YXIgdXNlcnMgPSB7XG5cdCAgICAgKiAgICdiYXJuZXknOiAgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG5cdCAgICAgKiAgICdmcmVkJzogICAgeyAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuXHQgICAgICogICAncGViYmxlcyc6IHsgJ2FnZSc6IDEsICAnYWN0aXZlJzogdHJ1ZSB9XG5cdCAgICAgKiB9O1xuXHQgICAgICpcblx0ICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsIGZ1bmN0aW9uKGNocikge1xuXHQgICAgICogICByZXR1cm4gY2hyLmFnZSA8IDQwO1xuXHQgICAgICogfSk7XG5cdCAgICAgKiAvLyA9PiByZXR1cm5zIGBwZWJibGVzYCBhc3N1bWluZyBgXy5maW5kS2V5YCByZXR1cm5zIGBiYXJuZXlgXG5cdCAgICAgKlxuXHQgICAgICogLy8gdXNpbmcgdGhlIGBfLm1hdGNoZXNgIGNhbGxiYWNrIHNob3J0aGFuZFxuXHQgICAgICogXy5maW5kTGFzdEtleSh1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0pO1xuXHQgICAgICogLy8gPT4gJ2Jhcm5leSdcblx0ICAgICAqXG5cdCAgICAgKiAvLyB1c2luZyB0aGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcblx0ICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsICdhY3RpdmUnLCBmYWxzZSk7XG5cdCAgICAgKiAvLyA9PiAnZnJlZCdcblx0ICAgICAqXG5cdCAgICAgKiAvLyB1c2luZyB0aGUgYF8ucHJvcGVydHlgIGNhbGxiYWNrIHNob3J0aGFuZFxuXHQgICAgICogXy5maW5kTGFzdEtleSh1c2VycywgJ2FjdGl2ZScpO1xuXHQgICAgICogLy8gPT4gJ3BlYmJsZXMnXG5cdCAgICAgKi9cblx0ICAgIHZhciBmaW5kTGFzdEtleSA9IGNyZWF0ZUZpbmRLZXkoYmFzZUZvck93blJpZ2h0KTtcblx0XG5cdCAgICAvKipcblx0ICAgICAqIEl0ZXJhdGVzIG92ZXIgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdCBpbnZva2luZ1xuXHQgICAgICogYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkXG5cdCAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBrZXksIG9iamVjdCkuIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdFxuXHQgICAgICogaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBPYmplY3Rcblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cblx0ICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuXHQgICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogZnVuY3Rpb24gRm9vKCkge1xuXHQgICAgICogICB0aGlzLmEgPSAxO1xuXHQgICAgICogICB0aGlzLmIgPSAyO1xuXHQgICAgICogfVxuXHQgICAgICpcblx0ICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG5cdCAgICAgKlxuXHQgICAgICogXy5mb3JJbihuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5cdCAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG5cdCAgICAgKiB9KTtcblx0ICAgICAqIC8vID0+IGxvZ3MgJ2EnLCAnYicsIGFuZCAnYycgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcblx0ICAgICAqL1xuXHQgICAgdmFyIGZvckluID0gY3JlYXRlRm9ySW4oYmFzZUZvcik7XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckluYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIHByb3BlcnRpZXMgb2Zcblx0ICAgICAqIGBvYmplY3RgIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IE9iamVjdFxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuXHQgICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG5cdCAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG5cdCAgICAgKiAgIHRoaXMuYSA9IDE7XG5cdCAgICAgKiAgIHRoaXMuYiA9IDI7XG5cdCAgICAgKiB9XG5cdCAgICAgKlxuXHQgICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcblx0ICAgICAqXG5cdCAgICAgKiBfLmZvckluUmlnaHQobmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuXHQgICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuXHQgICAgICogfSk7XG5cdCAgICAgKiAvLyA9PiBsb2dzICdjJywgJ2InLCBhbmQgJ2EnIGFzc3VtaW5nIGBfLmZvckluIGAgbG9ncyAnYScsICdiJywgYW5kICdjJ1xuXHQgICAgICovXG5cdCAgICB2YXIgZm9ySW5SaWdodCA9IGNyZWF0ZUZvckluKGJhc2VGb3JSaWdodCk7XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBJdGVyYXRlcyBvdmVyIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0IGludm9raW5nIGBpdGVyYXRlZWBcblx0ICAgICAqIGZvciBlYWNoIHByb3BlcnR5LiBUaGUgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aFxuXHQgICAgICogdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGtleSwgb2JqZWN0KS4gSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvblxuXHQgICAgICogZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IE9iamVjdFxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuXHQgICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG5cdCAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG5cdCAgICAgKiAgIHRoaXMuYSA9IDE7XG5cdCAgICAgKiAgIHRoaXMuYiA9IDI7XG5cdCAgICAgKiB9XG5cdCAgICAgKlxuXHQgICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcblx0ICAgICAqXG5cdCAgICAgKiBfLmZvck93bihuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5cdCAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG5cdCAgICAgKiB9KTtcblx0ICAgICAqIC8vID0+IGxvZ3MgJ2EnIGFuZCAnYicgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcblx0ICAgICAqL1xuXHQgICAgdmFyIGZvck93biA9IGNyZWF0ZUZvck93bihiYXNlRm9yT3duKTtcblx0XG5cdCAgICAvKipcblx0ICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9yT3duYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIHByb3BlcnRpZXMgb2Zcblx0ICAgICAqIGBvYmplY3RgIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IE9iamVjdFxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuXHQgICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG5cdCAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG5cdCAgICAgKiAgIHRoaXMuYSA9IDE7XG5cdCAgICAgKiAgIHRoaXMuYiA9IDI7XG5cdCAgICAgKiB9XG5cdCAgICAgKlxuXHQgICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcblx0ICAgICAqXG5cdCAgICAgKiBfLmZvck93blJpZ2h0KG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcblx0ICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcblx0ICAgICAqIH0pO1xuXHQgICAgICogLy8gPT4gbG9ncyAnYicgYW5kICdhJyBhc3N1bWluZyBgXy5mb3JPd25gIGxvZ3MgJ2EnIGFuZCAnYidcblx0ICAgICAqL1xuXHQgICAgdmFyIGZvck93blJpZ2h0ID0gY3JlYXRlRm9yT3duKGJhc2VGb3JPd25SaWdodCk7XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGZ1bmN0aW9uIHByb3BlcnR5IG5hbWVzIGZyb20gYWxsIGVudW1lcmFibGUgcHJvcGVydGllcyxcblx0ICAgICAqIG93biBhbmQgaW5oZXJpdGVkLCBvZiBgb2JqZWN0YC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGFsaWFzIG1ldGhvZHNcblx0ICAgICAqIEBjYXRlZ29yeSBPYmplY3Rcblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuXHQgICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIF8uZnVuY3Rpb25zKF8pO1xuXHQgICAgICogLy8gPT4gWydhZnRlcicsICdhcnknLCAnYXNzaWduJywgLi4uXVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBmdW5jdGlvbnMob2JqZWN0KSB7XG5cdCAgICAgIHJldHVybiBiYXNlRnVuY3Rpb25zKG9iamVjdCwga2V5c0luKG9iamVjdCkpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogR2V0cyB0aGUgcHJvcGVydHkgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcblx0ICAgICAqIGB1bmRlZmluZWRgIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyB1c2VkIGluIGl0cyBwbGFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IE9iamVjdFxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuXHQgICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cblx0ICAgICAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGlmIHRoZSByZXNvbHZlZCB2YWx1ZSBpcyBgdW5kZWZpbmVkYC5cblx0ICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcblx0ICAgICAqXG5cdCAgICAgKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuXHQgICAgICogLy8gPT4gM1xuXHQgICAgICpcblx0ICAgICAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuXHQgICAgICogLy8gPT4gM1xuXHQgICAgICpcblx0ICAgICAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcblx0ICAgICAqIC8vID0+ICdkZWZhdWx0J1xuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcblx0ICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHRvUGF0aChwYXRoKSwgcGF0aCArICcnKTtcblx0ICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogcmVzdWx0O1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBwcm9wZXJ0eS5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IE9iamVjdFxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuXHQgICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG5cdCAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IHByb3BlcnR5LCBlbHNlIGBmYWxzZWAuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogeyAnYic6IHsgJ2MnOiAzIH0gfSB9O1xuXHQgICAgICpcblx0ICAgICAqIF8uaGFzKG9iamVjdCwgJ2EnKTtcblx0ICAgICAqIC8vID0+IHRydWVcblx0ICAgICAqXG5cdCAgICAgKiBfLmhhcyhvYmplY3QsICdhLmIuYycpO1xuXHQgICAgICogLy8gPT4gdHJ1ZVxuXHQgICAgICpcblx0ICAgICAqIF8uaGFzKG9iamVjdCwgWydhJywgJ2InLCAnYyddKTtcblx0ICAgICAqIC8vID0+IHRydWVcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gaGFzKG9iamVjdCwgcGF0aCkge1xuXHQgICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIHJlc3VsdCA9IGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwYXRoKTtcblx0ICAgICAgaWYgKCFyZXN1bHQgJiYgIWlzS2V5KHBhdGgpKSB7XG5cdCAgICAgICAgcGF0aCA9IHRvUGF0aChwYXRoKTtcblx0ICAgICAgICBvYmplY3QgPSBwYXRoLmxlbmd0aCA9PSAxID8gb2JqZWN0IDogYmFzZUdldChvYmplY3QsIGJhc2VTbGljZShwYXRoLCAwLCAtMSkpO1xuXHQgICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuXHQgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBwYXRoID0gbGFzdChwYXRoKTtcblx0ICAgICAgICByZXN1bHQgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcGF0aCk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHJlc3VsdCB8fCAoaXNMZW5ndGgob2JqZWN0Lmxlbmd0aCkgJiYgaXNJbmRleChwYXRoLCBvYmplY3QubGVuZ3RoKSAmJlxuXHQgICAgICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSkpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIGludmVydGVkIGtleXMgYW5kIHZhbHVlcyBvZiBgb2JqZWN0YC5cblx0ICAgICAqIElmIGBvYmplY3RgIGNvbnRhaW5zIGR1cGxpY2F0ZSB2YWx1ZXMsIHN1YnNlcXVlbnQgdmFsdWVzIG92ZXJ3cml0ZSBwcm9wZXJ0eVxuXHQgICAgICogYXNzaWdubWVudHMgb2YgcHJldmlvdXMgdmFsdWVzIHVubGVzcyBgbXVsdGlWYWx1ZWAgaXMgYHRydWVgLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW52ZXJ0LlxuXHQgICAgICogQHBhcmFtIHtib29sZWFufSBbbXVsdGlWYWx1ZV0gQWxsb3cgbXVsdGlwbGUgdmFsdWVzIHBlciBrZXkuXG5cdCAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cblx0ICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBpbnZlcnRlZCBvYmplY3QuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfTtcblx0ICAgICAqXG5cdCAgICAgKiBfLmludmVydChvYmplY3QpO1xuXHQgICAgICogLy8gPT4geyAnMSc6ICdjJywgJzInOiAnYicgfVxuXHQgICAgICpcblx0ICAgICAqIC8vIHdpdGggYG11bHRpVmFsdWVgXG5cdCAgICAgKiBfLmludmVydChvYmplY3QsIHRydWUpO1xuXHQgICAgICogLy8gPT4geyAnMSc6IFsnYScsICdjJ10sICcyJzogWydiJ10gfVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBpbnZlcnQob2JqZWN0LCBtdWx0aVZhbHVlLCBndWFyZCkge1xuXHQgICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwob2JqZWN0LCBtdWx0aVZhbHVlLCBndWFyZCkpIHtcblx0ICAgICAgICBtdWx0aVZhbHVlID0gdW5kZWZpbmVkO1xuXHQgICAgICB9XG5cdCAgICAgIHZhciBpbmRleCA9IC0xLFxuXHQgICAgICAgICAgcHJvcHMgPSBrZXlzKG9iamVjdCksXG5cdCAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG5cdCAgICAgICAgICByZXN1bHQgPSB7fTtcblx0XG5cdCAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdCAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XSxcblx0ICAgICAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblx0XG5cdCAgICAgICAgaWYgKG11bHRpVmFsdWUpIHtcblx0ICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwgdmFsdWUpKSB7XG5cdCAgICAgICAgICAgIHJlc3VsdFt2YWx1ZV0ucHVzaChrZXkpO1xuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgcmVzdWx0W3ZhbHVlXSA9IFtrZXldO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgIHJlc3VsdFt2YWx1ZV0gPSBrZXk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cblx0ICAgICAqXG5cdCAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuXHQgICAgICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5rZXlzKVxuXHQgICAgICogZm9yIG1vcmUgZGV0YWlscy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IE9iamVjdFxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuXHQgICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogZnVuY3Rpb24gRm9vKCkge1xuXHQgICAgICogICB0aGlzLmEgPSAxO1xuXHQgICAgICogICB0aGlzLmIgPSAyO1xuXHQgICAgICogfVxuXHQgICAgICpcblx0ICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG5cdCAgICAgKlxuXHQgICAgICogXy5rZXlzKG5ldyBGb28pO1xuXHQgICAgICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuXHQgICAgICpcblx0ICAgICAqIF8ua2V5cygnaGknKTtcblx0ICAgICAqIC8vID0+IFsnMCcsICcxJ11cblx0ICAgICAqL1xuXHQgICAgdmFyIGtleXMgPSAhbmF0aXZlS2V5cyA/IHNoaW1LZXlzIDogZnVuY3Rpb24ob2JqZWN0KSB7XG5cdCAgICAgIHZhciBDdG9yID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3QuY29uc3RydWN0b3I7XG5cdCAgICAgIGlmICgodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSA9PT0gb2JqZWN0KSB8fFxuXHQgICAgICAgICAgKHR5cGVvZiBvYmplY3QgIT0gJ2Z1bmN0aW9uJyAmJiBpc0FycmF5TGlrZShvYmplY3QpKSkge1xuXHQgICAgICAgIHJldHVybiBzaGltS2V5cyhvYmplY3QpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBpc09iamVjdChvYmplY3QpID8gbmF0aXZlS2V5cyhvYmplY3QpIDogW107XG5cdCAgICB9O1xuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cblx0ICAgICAqXG5cdCAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IE9iamVjdFxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuXHQgICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogZnVuY3Rpb24gRm9vKCkge1xuXHQgICAgICogICB0aGlzLmEgPSAxO1xuXHQgICAgICogICB0aGlzLmIgPSAyO1xuXHQgICAgICogfVxuXHQgICAgICpcblx0ICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG5cdCAgICAgKlxuXHQgICAgICogXy5rZXlzSW4obmV3IEZvbyk7XG5cdCAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuXHQgICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcblx0ICAgICAgICByZXR1cm4gW107XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG5cdCAgICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7XG5cdCAgICAgIGxlbmd0aCA9IChsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJlxuXHQgICAgICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSkgJiYgbGVuZ3RoKSB8fCAwO1xuXHRcblx0ICAgICAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG5cdCAgICAgICAgICBpbmRleCA9IC0xLFxuXHQgICAgICAgICAgaXNQcm90byA9IHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUgPT09IG9iamVjdCxcblx0ICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCksXG5cdCAgICAgICAgICBza2lwSW5kZXhlcyA9IGxlbmd0aCA+IDA7XG5cdFxuXHQgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHQgICAgICAgIHJlc3VsdFtpbmRleF0gPSAoaW5kZXggKyAnJyk7XG5cdCAgICAgIH1cblx0ICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuXHQgICAgICAgIGlmICghKHNraXBJbmRleGVzICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpKSAmJlxuXHQgICAgICAgICAgICAhKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG5cdCAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLm1hcFZhbHVlc2A7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IHdpdGggdGhlXG5cdCAgICAgKiBzYW1lIHZhbHVlcyBhcyBgb2JqZWN0YCBhbmQga2V5cyBnZW5lcmF0ZWQgYnkgcnVubmluZyBlYWNoIG93biBlbnVtZXJhYmxlXG5cdCAgICAgKiBwcm9wZXJ0eSBvZiBgb2JqZWN0YCB0aHJvdWdoIGBpdGVyYXRlZWAuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBPYmplY3Rcblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZFxuXHQgICAgICogIHBlciBpdGVyYXRpb24uXG5cdCAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cblx0ICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgb2JqZWN0LlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBfLm1hcEtleXMoeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5cdCAgICAgKiAgIHJldHVybiBrZXkgKyB2YWx1ZTtcblx0ICAgICAqIH0pO1xuXHQgICAgICogLy8gPT4geyAnYTEnOiAxLCAnYjInOiAyIH1cblx0ICAgICAqL1xuXHQgICAgdmFyIG1hcEtleXMgPSBjcmVhdGVPYmplY3RNYXBwZXIodHJ1ZSk7XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYXMgYG9iamVjdGAgYW5kIHZhbHVlcyBnZW5lcmF0ZWQgYnlcblx0ICAgICAqIHJ1bm5pbmcgZWFjaCBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBvZiBgb2JqZWN0YCB0aHJvdWdoIGBpdGVyYXRlZWAuIFRoZVxuXHQgICAgICogaXRlcmF0ZWUgZnVuY3Rpb24gaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuXHQgICAgICogKHZhbHVlLCBrZXksIG9iamVjdCkuXG5cdCAgICAgKlxuXHQgICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuXHQgICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG5cdCAgICAgKlxuXHQgICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuXHQgICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG5cdCAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuXHQgICAgICpcblx0ICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuXHQgICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cblx0ICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWRcblx0ICAgICAqICBwZXIgaXRlcmF0aW9uLlxuXHQgICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG5cdCAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIG9iamVjdC5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogXy5tYXBWYWx1ZXMoeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbihuKSB7XG5cdCAgICAgKiAgIHJldHVybiBuICogMztcblx0ICAgICAqIH0pO1xuXHQgICAgICogLy8gPT4geyAnYSc6IDMsICdiJzogNiB9XG5cdCAgICAgKlxuXHQgICAgICogdmFyIHVzZXJzID0ge1xuXHQgICAgICogICAnZnJlZCc6ICAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCB9LFxuXHQgICAgICogICAncGViYmxlcyc6IHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxIH1cblx0ICAgICAqIH07XG5cdCAgICAgKlxuXHQgICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcblx0ICAgICAqIF8ubWFwVmFsdWVzKHVzZXJzLCAnYWdlJyk7XG5cdCAgICAgKiAvLyA9PiB7ICdmcmVkJzogNDAsICdwZWJibGVzJzogMSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG5cdCAgICAgKi9cblx0ICAgIHZhciBtYXBWYWx1ZXMgPSBjcmVhdGVPYmplY3RNYXBwZXIoKTtcblx0XG5cdCAgICAvKipcblx0ICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5waWNrYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlXG5cdCAgICAgKiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYG9iamVjdGAgdGhhdCBhcmUgbm90IG9taXR0ZWQuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBPYmplY3Rcblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufC4uLihzdHJpbmd8c3RyaW5nW10pfSBbcHJlZGljYXRlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXJcblx0ICAgICAqICBpdGVyYXRpb24gb3IgcHJvcGVydHkgbmFtZXMgdG8gb21pdCwgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgcHJvcGVydHlcblx0ICAgICAqICBuYW1lcyBvciBhcnJheXMgb2YgcHJvcGVydHkgbmFtZXMuXG5cdCAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG5cdCAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH07XG5cdCAgICAgKlxuXHQgICAgICogXy5vbWl0KG9iamVjdCwgJ2FnZScpO1xuXHQgICAgICogLy8gPT4geyAndXNlcic6ICdmcmVkJyB9XG5cdCAgICAgKlxuXHQgICAgICogXy5vbWl0KG9iamVjdCwgXy5pc051bWJlcik7XG5cdCAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2ZyZWQnIH1cblx0ICAgICAqL1xuXHQgICAgdmFyIG9taXQgPSByZXN0UGFyYW0oZnVuY3Rpb24ob2JqZWN0LCBwcm9wcykge1xuXHQgICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcblx0ICAgICAgICByZXR1cm4ge307XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHR5cGVvZiBwcm9wc1swXSAhPSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgdmFyIHByb3BzID0gYXJyYXlNYXAoYmFzZUZsYXR0ZW4ocHJvcHMpLCBTdHJpbmcpO1xuXHQgICAgICAgIHJldHVybiBwaWNrQnlBcnJheShvYmplY3QsIGJhc2VEaWZmZXJlbmNlKGtleXNJbihvYmplY3QpLCBwcm9wcykpO1xuXHQgICAgICB9XG5cdCAgICAgIHZhciBwcmVkaWNhdGUgPSBiaW5kQ2FsbGJhY2socHJvcHNbMF0sIHByb3BzWzFdLCAzKTtcblx0ICAgICAgcmV0dXJuIHBpY2tCeUNhbGxiYWNrKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG5cdCAgICAgICAgcmV0dXJuICFwcmVkaWNhdGUodmFsdWUsIGtleSwgb2JqZWN0KTtcblx0ICAgICAgfSk7XG5cdCAgICB9KTtcblx0XG5cdCAgICAvKipcblx0ICAgICAqIENyZWF0ZXMgYSB0d28gZGltZW5zaW9uYWwgYXJyYXkgb2YgdGhlIGtleS12YWx1ZSBwYWlycyBmb3IgYG9iamVjdGAsXG5cdCAgICAgKiBlLmcuIGBbW2tleTEsIHZhbHVlMV0sIFtrZXkyLCB2YWx1ZTJdXWAuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBPYmplY3Rcblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cblx0ICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGtleS12YWx1ZSBwYWlycy5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogXy5wYWlycyh7ICdiYXJuZXknOiAzNiwgJ2ZyZWQnOiA0MCB9KTtcblx0ICAgICAqIC8vID0+IFtbJ2Jhcm5leScsIDM2XSwgWydmcmVkJywgNDBdXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBwYWlycyhvYmplY3QpIHtcblx0ICAgICAgb2JqZWN0ID0gdG9PYmplY3Qob2JqZWN0KTtcblx0XG5cdCAgICAgIHZhciBpbmRleCA9IC0xLFxuXHQgICAgICAgICAgcHJvcHMgPSBrZXlzKG9iamVjdCksXG5cdCAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG5cdCAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXHRcblx0ICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0ICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXHQgICAgICAgIHJlc3VsdFtpbmRleF0gPSBba2V5LCBvYmplY3Rba2V5XV07XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBwaWNrZWQgYG9iamVjdGAgcHJvcGVydGllcy4gUHJvcGVydHlcblx0ICAgICAqIG5hbWVzIG1heSBiZSBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMgb3IgYXMgYXJyYXlzIG9mIHByb3BlcnR5XG5cdCAgICAgKiBuYW1lcy4gSWYgYHByZWRpY2F0ZWAgaXMgcHJvdmlkZWQgaXQgaXMgaW52b2tlZCBmb3IgZWFjaCBwcm9wZXJ0eSBvZiBgb2JqZWN0YFxuXHQgICAgICogcGlja2luZyB0aGUgcHJvcGVydGllcyBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXNcblx0ICAgICAqIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBrZXksIG9iamVjdCkuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBPYmplY3Rcblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufC4uLihzdHJpbmd8c3RyaW5nW10pfSBbcHJlZGljYXRlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXJcblx0ICAgICAqICBpdGVyYXRpb24gb3IgcHJvcGVydHkgbmFtZXMgdG8gcGljaywgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgcHJvcGVydHlcblx0ICAgICAqICBuYW1lcyBvciBhcnJheXMgb2YgcHJvcGVydHkgbmFtZXMuXG5cdCAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYHByZWRpY2F0ZWAuXG5cdCAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH07XG5cdCAgICAgKlxuXHQgICAgICogXy5waWNrKG9iamVjdCwgJ3VzZXInKTtcblx0ICAgICAqIC8vID0+IHsgJ3VzZXInOiAnZnJlZCcgfVxuXHQgICAgICpcblx0ICAgICAqIF8ucGljayhvYmplY3QsIF8uaXNTdHJpbmcpO1xuXHQgICAgICogLy8gPT4geyAndXNlcic6ICdmcmVkJyB9XG5cdCAgICAgKi9cblx0ICAgIHZhciBwaWNrID0gcmVzdFBhcmFtKGZ1bmN0aW9uKG9iamVjdCwgcHJvcHMpIHtcblx0ICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG5cdCAgICAgICAgcmV0dXJuIHt9O1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiB0eXBlb2YgcHJvcHNbMF0gPT0gJ2Z1bmN0aW9uJ1xuXHQgICAgICAgID8gcGlja0J5Q2FsbGJhY2sob2JqZWN0LCBiaW5kQ2FsbGJhY2socHJvcHNbMF0sIHByb3BzWzFdLCAzKSlcblx0ICAgICAgICA6IHBpY2tCeUFycmF5KG9iamVjdCwgYmFzZUZsYXR0ZW4ocHJvcHMpKTtcblx0ICAgIH0pO1xuXHRcblx0ICAgIC8qKlxuXHQgICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5nZXRgIGV4Y2VwdCB0aGF0IGlmIHRoZSByZXNvbHZlZCB2YWx1ZSBpcyBhIGZ1bmN0aW9uXG5cdCAgICAgKiBpdCBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGl0cyBwYXJlbnQgb2JqZWN0IGFuZCBpdHMgcmVzdWx0XG5cdCAgICAgKiBpcyByZXR1cm5lZC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IE9iamVjdFxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuXHQgICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHJlc29sdmUuXG5cdCAgICAgKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBpZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXMgYHVuZGVmaW5lZGAuXG5cdCAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjMSc6IDMsICdjMic6IF8uY29uc3RhbnQoNCkgfSB9XSB9O1xuXHQgICAgICpcblx0ICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMScpO1xuXHQgICAgICogLy8gPT4gM1xuXHQgICAgICpcblx0ICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMicpO1xuXHQgICAgICogLy8gPT4gNFxuXHQgICAgICpcblx0ICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcblx0ICAgICAqIC8vID0+ICdkZWZhdWx0J1xuXHQgICAgICpcblx0ICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2EuYi5jJywgXy5jb25zdGFudCgnZGVmYXVsdCcpKTtcblx0ICAgICAqIC8vID0+ICdkZWZhdWx0J1xuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiByZXN1bHQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcblx0ICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W3BhdGhdO1xuXHQgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICBpZiAob2JqZWN0ICE9IG51bGwgJiYgIWlzS2V5KHBhdGgsIG9iamVjdCkpIHtcblx0ICAgICAgICAgIHBhdGggPSB0b1BhdGgocGF0aCk7XG5cdCAgICAgICAgICBvYmplY3QgPSBwYXRoLmxlbmd0aCA9PSAxID8gb2JqZWN0IDogYmFzZUdldChvYmplY3QsIGJhc2VTbGljZShwYXRoLCAwLCAtMSkpO1xuXHQgICAgICAgICAgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3RbbGFzdChwYXRoKV07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJlc3VsdCA9IHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogcmVzdWx0O1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBpc0Z1bmN0aW9uKHJlc3VsdCkgPyByZXN1bHQuY2FsbChvYmplY3QpIDogcmVzdWx0O1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogU2V0cyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgYHBhdGhgIG9uIGBvYmplY3RgLiBJZiBhIHBvcnRpb24gb2YgYHBhdGhgXG5cdCAgICAgKiBkb2VzIG5vdCBleGlzdCBpdCBpcyBjcmVhdGVkLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYXVnbWVudC5cblx0ICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG5cdCAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG5cdCAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuXHQgICAgICpcblx0ICAgICAqIF8uc2V0KG9iamVjdCwgJ2FbMF0uYi5jJywgNCk7XG5cdCAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QuYVswXS5iLmMpO1xuXHQgICAgICogLy8gPT4gNFxuXHQgICAgICpcblx0ICAgICAqIF8uc2V0KG9iamVjdCwgJ3hbMF0ueS56JywgNSk7XG5cdCAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QueFswXS55LnopO1xuXHQgICAgICogLy8gPT4gNVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBzZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSkge1xuXHQgICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcblx0ICAgICAgICByZXR1cm4gb2JqZWN0O1xuXHQgICAgICB9XG5cdCAgICAgIHZhciBwYXRoS2V5ID0gKHBhdGggKyAnJyk7XG5cdCAgICAgIHBhdGggPSAob2JqZWN0W3BhdGhLZXldICE9IG51bGwgfHwgaXNLZXkocGF0aCwgb2JqZWN0KSkgPyBbcGF0aEtleV0gOiB0b1BhdGgocGF0aCk7XG5cdFxuXHQgICAgICB2YXIgaW5kZXggPSAtMSxcblx0ICAgICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuXHQgICAgICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMSxcblx0ICAgICAgICAgIG5lc3RlZCA9IG9iamVjdDtcblx0XG5cdCAgICAgIHdoaWxlIChuZXN0ZWQgIT0gbnVsbCAmJiArK2luZGV4IDwgbGVuZ3RoKSB7XG5cdCAgICAgICAgdmFyIGtleSA9IHBhdGhbaW5kZXhdO1xuXHQgICAgICAgIGlmIChpc09iamVjdChuZXN0ZWQpKSB7XG5cdCAgICAgICAgICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG5cdCAgICAgICAgICAgIG5lc3RlZFtrZXldID0gdmFsdWU7XG5cdCAgICAgICAgICB9IGVsc2UgaWYgKG5lc3RlZFtrZXldID09IG51bGwpIHtcblx0ICAgICAgICAgICAgbmVzdGVkW2tleV0gPSBpc0luZGV4KHBhdGhbaW5kZXggKyAxXSkgPyBbXSA6IHt9O1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBuZXN0ZWQgPSBuZXN0ZWRba2V5XTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gb2JqZWN0O1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQW4gYWx0ZXJuYXRpdmUgdG8gYF8ucmVkdWNlYDsgdGhpcyBtZXRob2QgdHJhbnNmb3JtcyBgb2JqZWN0YCB0byBhIG5ld1xuXHQgICAgICogYGFjY3VtdWxhdG9yYCBvYmplY3Qgd2hpY2ggaXMgdGhlIHJlc3VsdCBvZiBydW5uaW5nIGVhY2ggb2YgaXRzIG93biBlbnVtZXJhYmxlXG5cdCAgICAgKiBwcm9wZXJ0aWVzIHRocm91Z2ggYGl0ZXJhdGVlYCwgd2l0aCBlYWNoIGludm9jYXRpb24gcG90ZW50aWFsbHkgbXV0YXRpbmdcblx0ICAgICAqIHRoZSBgYWNjdW11bGF0b3JgIG9iamVjdC4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkXG5cdCAgICAgKiB3aXRoIGZvdXIgYXJndW1lbnRzOiAoYWNjdW11bGF0b3IsIHZhbHVlLCBrZXksIG9iamVjdCkuIEl0ZXJhdGVlIGZ1bmN0aW9uc1xuXHQgICAgICogbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBPYmplY3Rcblx0ICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cblx0ICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgY3VzdG9tIGFjY3VtdWxhdG9yIHZhbHVlLlxuXHQgICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG5cdCAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIF8udHJhbnNmb3JtKFsyLCAzLCA0XSwgZnVuY3Rpb24ocmVzdWx0LCBuKSB7XG5cdCAgICAgKiAgIHJlc3VsdC5wdXNoKG4gKj0gbik7XG5cdCAgICAgKiAgIHJldHVybiBuICUgMiA9PSAwO1xuXHQgICAgICogfSk7XG5cdCAgICAgKiAvLyA9PiBbNCwgOV1cblx0ICAgICAqXG5cdCAgICAgKiBfLnRyYW5zZm9ybSh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKHJlc3VsdCwgbiwga2V5KSB7XG5cdCAgICAgKiAgIHJlc3VsdFtrZXldID0gbiAqIDM7XG5cdCAgICAgKiB9KTtcblx0ICAgICAqIC8vID0+IHsgJ2EnOiAzLCAnYic6IDYgfVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiB0cmFuc2Zvcm0ob2JqZWN0LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIHRoaXNBcmcpIHtcblx0ICAgICAgdmFyIGlzQXJyID0gaXNBcnJheShvYmplY3QpIHx8IGlzVHlwZWRBcnJheShvYmplY3QpO1xuXHQgICAgICBpdGVyYXRlZSA9IGdldENhbGxiYWNrKGl0ZXJhdGVlLCB0aGlzQXJnLCA0KTtcblx0XG5cdCAgICAgIGlmIChhY2N1bXVsYXRvciA9PSBudWxsKSB7XG5cdCAgICAgICAgaWYgKGlzQXJyIHx8IGlzT2JqZWN0KG9iamVjdCkpIHtcblx0ICAgICAgICAgIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuXHQgICAgICAgICAgaWYgKGlzQXJyKSB7XG5cdCAgICAgICAgICAgIGFjY3VtdWxhdG9yID0gaXNBcnJheShvYmplY3QpID8gbmV3IEN0b3IgOiBbXTtcblx0ICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIGFjY3VtdWxhdG9yID0gYmFzZUNyZWF0ZShpc0Z1bmN0aW9uKEN0b3IpID8gQ3Rvci5wcm90b3R5cGUgOiB1bmRlZmluZWQpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBhY2N1bXVsYXRvciA9IHt9O1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICAoaXNBcnIgPyBhcnJheUVhY2ggOiBiYXNlRm9yT3duKShvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG5cdCAgICAgICAgcmV0dXJuIGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIG9iamVjdCk7XG5cdCAgICAgIH0pO1xuXHQgICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG5cdCAgICAgKlxuXHQgICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBPYmplY3Rcblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cblx0ICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG5cdCAgICAgKiAgIHRoaXMuYSA9IDE7XG5cdCAgICAgKiAgIHRoaXMuYiA9IDI7XG5cdCAgICAgKiB9XG5cdCAgICAgKlxuXHQgICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcblx0ICAgICAqXG5cdCAgICAgKiBfLnZhbHVlcyhuZXcgRm9vKTtcblx0ICAgICAqIC8vID0+IFsxLCAyXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuXHQgICAgICpcblx0ICAgICAqIF8udmFsdWVzKCdoaScpO1xuXHQgICAgICogLy8gPT4gWydoJywgJ2knXVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7XG5cdCAgICAgIHJldHVybiBiYXNlVmFsdWVzKG9iamVjdCwga2V5cyhvYmplY3QpKTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgdmFsdWVzXG5cdCAgICAgKiBvZiBgb2JqZWN0YC5cblx0ICAgICAqXG5cdCAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IE9iamVjdFxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuXHQgICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcblx0ICAgICAqICAgdGhpcy5hID0gMTtcblx0ICAgICAqICAgdGhpcy5iID0gMjtcblx0ICAgICAqIH1cblx0ICAgICAqXG5cdCAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuXHQgICAgICpcblx0ICAgICAqIF8udmFsdWVzSW4obmV3IEZvbyk7XG5cdCAgICAgKiAvLyA9PiBbMSwgMiwgM10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gdmFsdWVzSW4ob2JqZWN0KSB7XG5cdCAgICAgIHJldHVybiBiYXNlVmFsdWVzKG9iamVjdCwga2V5c0luKG9iamVjdCkpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblx0XG5cdCAgICAvKipcblx0ICAgICAqIENoZWNrcyBpZiBgbmAgaXMgYmV0d2VlbiBgc3RhcnRgIGFuZCB1cCB0byBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuIElmXG5cdCAgICAgKiBgZW5kYCBpcyBub3Qgc3BlY2lmaWVkIGl0IGlzIHNldCB0byBgc3RhcnRgIHdpdGggYHN0YXJ0YCB0aGVuIHNldCB0byBgMGAuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBOdW1iZXJcblx0ICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgdG8gY2hlY2suXG5cdCAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG5cdCAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuXHQgICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBuYCBpcyBpbiB0aGUgcmFuZ2UsIGVsc2UgYGZhbHNlYC5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogXy5pblJhbmdlKDMsIDIsIDQpO1xuXHQgICAgICogLy8gPT4gdHJ1ZVxuXHQgICAgICpcblx0ICAgICAqIF8uaW5SYW5nZSg0LCA4KTtcblx0ICAgICAqIC8vID0+IHRydWVcblx0ICAgICAqXG5cdCAgICAgKiBfLmluUmFuZ2UoNCwgMik7XG5cdCAgICAgKiAvLyA9PiBmYWxzZVxuXHQgICAgICpcblx0ICAgICAqIF8uaW5SYW5nZSgyLCAyKTtcblx0ICAgICAqIC8vID0+IGZhbHNlXG5cdCAgICAgKlxuXHQgICAgICogXy5pblJhbmdlKDEuMiwgMik7XG5cdCAgICAgKiAvLyA9PiB0cnVlXG5cdCAgICAgKlxuXHQgICAgICogXy5pblJhbmdlKDUuMiwgNCk7XG5cdCAgICAgKiAvLyA9PiBmYWxzZVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBpblJhbmdlKHZhbHVlLCBzdGFydCwgZW5kKSB7XG5cdCAgICAgIHN0YXJ0ID0gK3N0YXJ0IHx8IDA7XG5cdCAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIGVuZCA9IHN0YXJ0O1xuXHQgICAgICAgIHN0YXJ0ID0gMDtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBlbmQgPSArZW5kIHx8IDA7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHZhbHVlID49IG5hdGl2ZU1pbihzdGFydCwgZW5kKSAmJiB2YWx1ZSA8IG5hdGl2ZU1heChzdGFydCwgZW5kKTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFByb2R1Y2VzIGEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIGBtaW5gIGFuZCBgbWF4YCAoaW5jbHVzaXZlKS4gSWYgb25seSBvbmVcblx0ICAgICAqIGFyZ3VtZW50IGlzIHByb3ZpZGVkIGEgbnVtYmVyIGJldHdlZW4gYDBgIGFuZCB0aGUgZ2l2ZW4gbnVtYmVyIGlzIHJldHVybmVkLlxuXHQgICAgICogSWYgYGZsb2F0aW5nYCBpcyBgdHJ1ZWAsIG9yIGVpdGhlciBgbWluYCBvciBgbWF4YCBhcmUgZmxvYXRzLCBhIGZsb2F0aW5nLXBvaW50XG5cdCAgICAgKiBudW1iZXIgaXMgcmV0dXJuZWQgaW5zdGVhZCBvZiBhbiBpbnRlZ2VyLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgTnVtYmVyXG5cdCAgICAgKiBAcGFyYW0ge251bWJlcn0gW21pbj0wXSBUaGUgbWluaW11bSBwb3NzaWJsZSB2YWx1ZS5cblx0ICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4PTFdIFRoZSBtYXhpbXVtIHBvc3NpYmxlIHZhbHVlLlxuXHQgICAgICogQHBhcmFtIHtib29sZWFufSBbZmxvYXRpbmddIFNwZWNpZnkgcmV0dXJuaW5nIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuXHQgICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcmFuZG9tIG51bWJlci5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogXy5yYW5kb20oMCwgNSk7XG5cdCAgICAgKiAvLyA9PiBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgNVxuXHQgICAgICpcblx0ICAgICAqIF8ucmFuZG9tKDUpO1xuXHQgICAgICogLy8gPT4gYWxzbyBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgNVxuXHQgICAgICpcblx0ICAgICAqIF8ucmFuZG9tKDUsIHRydWUpO1xuXHQgICAgICogLy8gPT4gYSBmbG9hdGluZy1wb2ludCBudW1iZXIgYmV0d2VlbiAwIGFuZCA1XG5cdCAgICAgKlxuXHQgICAgICogXy5yYW5kb20oMS4yLCA1LjIpO1xuXHQgICAgICogLy8gPT4gYSBmbG9hdGluZy1wb2ludCBudW1iZXIgYmV0d2VlbiAxLjIgYW5kIDUuMlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiByYW5kb20obWluLCBtYXgsIGZsb2F0aW5nKSB7XG5cdCAgICAgIGlmIChmbG9hdGluZyAmJiBpc0l0ZXJhdGVlQ2FsbChtaW4sIG1heCwgZmxvYXRpbmcpKSB7XG5cdCAgICAgICAgbWF4ID0gZmxvYXRpbmcgPSB1bmRlZmluZWQ7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIG5vTWluID0gbWluID09IG51bGwsXG5cdCAgICAgICAgICBub01heCA9IG1heCA9PSBudWxsO1xuXHRcblx0ICAgICAgaWYgKGZsb2F0aW5nID09IG51bGwpIHtcblx0ICAgICAgICBpZiAobm9NYXggJiYgdHlwZW9mIG1pbiA9PSAnYm9vbGVhbicpIHtcblx0ICAgICAgICAgIGZsb2F0aW5nID0gbWluO1xuXHQgICAgICAgICAgbWluID0gMTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1heCA9PSAnYm9vbGVhbicpIHtcblx0ICAgICAgICAgIGZsb2F0aW5nID0gbWF4O1xuXHQgICAgICAgICAgbm9NYXggPSB0cnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICBpZiAobm9NaW4gJiYgbm9NYXgpIHtcblx0ICAgICAgICBtYXggPSAxO1xuXHQgICAgICAgIG5vTWF4ID0gZmFsc2U7XG5cdCAgICAgIH1cblx0ICAgICAgbWluID0gK21pbiB8fCAwO1xuXHQgICAgICBpZiAobm9NYXgpIHtcblx0ICAgICAgICBtYXggPSBtaW47XG5cdCAgICAgICAgbWluID0gMDtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBtYXggPSArbWF4IHx8IDA7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKGZsb2F0aW5nIHx8IG1pbiAlIDEgfHwgbWF4ICUgMSkge1xuXHQgICAgICAgIHZhciByYW5kID0gbmF0aXZlUmFuZG9tKCk7XG5cdCAgICAgICAgcmV0dXJuIG5hdGl2ZU1pbihtaW4gKyAocmFuZCAqIChtYXggLSBtaW4gKyBwYXJzZUZsb2F0KCcxZS0nICsgKChyYW5kICsgJycpLmxlbmd0aCAtIDEpKSkpLCBtYXgpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBiYXNlUmFuZG9tKG1pbiwgbWF4KTtcblx0ICAgIH1cblx0XG5cdCAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBbY2FtZWwgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2FtZWxDYXNlKS5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IFN0cmluZ1xuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cblx0ICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNhbWVsIGNhc2VkIHN0cmluZy5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogXy5jYW1lbENhc2UoJ0ZvbyBCYXInKTtcblx0ICAgICAqIC8vID0+ICdmb29CYXInXG5cdCAgICAgKlxuXHQgICAgICogXy5jYW1lbENhc2UoJy0tZm9vLWJhcicpO1xuXHQgICAgICogLy8gPT4gJ2Zvb0Jhcidcblx0ICAgICAqXG5cdCAgICAgKiBfLmNhbWVsQ2FzZSgnX19mb29fYmFyX18nKTtcblx0ICAgICAqIC8vID0+ICdmb29CYXInXG5cdCAgICAgKi9cblx0ICAgIHZhciBjYW1lbENhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcblx0ICAgICAgd29yZCA9IHdvcmQudG9Mb3dlckNhc2UoKTtcblx0ICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICh3b3JkLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgd29yZC5zbGljZSgxKSkgOiB3b3JkKTtcblx0ICAgIH0pO1xuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ2FwaXRhbGl6ZXMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IFN0cmluZ1xuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY2FwaXRhbGl6ZS5cblx0ICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNhcGl0YWxpemVkIHN0cmluZy5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogXy5jYXBpdGFsaXplKCdmcmVkJyk7XG5cdCAgICAgKiAvLyA9PiAnRnJlZCdcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcpIHtcblx0ICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG5cdCAgICAgIHJldHVybiBzdHJpbmcgJiYgKHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKSk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBEZWJ1cnJzIGBzdHJpbmdgIGJ5IGNvbnZlcnRpbmcgW2xhdGluLTEgc3VwcGxlbWVudGFyeSBsZXR0ZXJzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbi0xX1N1cHBsZW1lbnRfKFVuaWNvZGVfYmxvY2spI0NoYXJhY3Rlcl90YWJsZSlcblx0ICAgICAqIHRvIGJhc2ljIGxhdGluIGxldHRlcnMgYW5kIHJlbW92aW5nIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcblx0ICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGRlYnVyci5cblx0ICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGRlYnVycmVkIHN0cmluZy5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogXy5kZWJ1cnIoJ2TDqWrDoCB2dScpO1xuXHQgICAgICogLy8gPT4gJ2RlamEgdnUnXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGRlYnVycihzdHJpbmcpIHtcblx0ICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG5cdCAgICAgIHJldHVybiBzdHJpbmcgJiYgc3RyaW5nLnJlcGxhY2UocmVMYXRpbjEsIGRlYnVyckxldHRlcikucmVwbGFjZShyZUNvbWJvTWFyaywgJycpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ2hlY2tzIGlmIGBzdHJpbmdgIGVuZHMgd2l0aCB0aGUgZ2l2ZW4gdGFyZ2V0IHN0cmluZy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IFN0cmluZ1xuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gc2VhcmNoLlxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IFt0YXJnZXRdIFRoZSBzdHJpbmcgdG8gc2VhcmNoIGZvci5cblx0ICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcG9zaXRpb249c3RyaW5nLmxlbmd0aF0gVGhlIHBvc2l0aW9uIHRvIHNlYXJjaCBmcm9tLlxuXHQgICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBzdHJpbmdgIGVuZHMgd2l0aCBgdGFyZ2V0YCwgZWxzZSBgZmFsc2VgLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBfLmVuZHNXaXRoKCdhYmMnLCAnYycpO1xuXHQgICAgICogLy8gPT4gdHJ1ZVxuXHQgICAgICpcblx0ICAgICAqIF8uZW5kc1dpdGgoJ2FiYycsICdiJyk7XG5cdCAgICAgKiAvLyA9PiBmYWxzZVxuXHQgICAgICpcblx0ICAgICAqIF8uZW5kc1dpdGgoJ2FiYycsICdiJywgMik7XG5cdCAgICAgKiAvLyA9PiB0cnVlXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGVuZHNXaXRoKHN0cmluZywgdGFyZ2V0LCBwb3NpdGlvbikge1xuXHQgICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcblx0ICAgICAgdGFyZ2V0ID0gKHRhcmdldCArICcnKTtcblx0XG5cdCAgICAgIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXHQgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uID09PSB1bmRlZmluZWRcblx0ICAgICAgICA/IGxlbmd0aFxuXHQgICAgICAgIDogbmF0aXZlTWluKHBvc2l0aW9uIDwgMCA/IDAgOiAoK3Bvc2l0aW9uIHx8IDApLCBsZW5ndGgpO1xuXHRcblx0ICAgICAgcG9zaXRpb24gLT0gdGFyZ2V0Lmxlbmd0aDtcblx0ICAgICAgcmV0dXJuIHBvc2l0aW9uID49IDAgJiYgc3RyaW5nLmluZGV4T2YodGFyZ2V0LCBwb3NpdGlvbikgPT0gcG9zaXRpb247XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDb252ZXJ0cyB0aGUgY2hhcmFjdGVycyBcIiZcIiwgXCI8XCIsIFwiPlwiLCAnXCInLCBcIidcIiwgYW5kIFwiXFxgXCIsIGluIGBzdHJpbmdgIHRvXG5cdCAgICAgKiB0aGVpciBjb3JyZXNwb25kaW5nIEhUTUwgZW50aXRpZXMuXG5cdCAgICAgKlxuXHQgICAgICogKipOb3RlOioqIE5vIG90aGVyIGNoYXJhY3RlcnMgYXJlIGVzY2FwZWQuIFRvIGVzY2FwZSBhZGRpdGlvbmFsIGNoYXJhY3RlcnNcblx0ICAgICAqIHVzZSBhIHRoaXJkLXBhcnR5IGxpYnJhcnkgbGlrZSBbX2hlX10oaHR0cHM6Ly9tdGhzLmJlL2hlKS5cblx0ICAgICAqXG5cdCAgICAgKiBUaG91Z2ggdGhlIFwiPlwiIGNoYXJhY3RlciBpcyBlc2NhcGVkIGZvciBzeW1tZXRyeSwgY2hhcmFjdGVycyBsaWtlXG5cdCAgICAgKiBcIj5cIiBhbmQgXCIvXCIgZG9uJ3QgbmVlZCBlc2NhcGluZyBpbiBIVE1MIGFuZCBoYXZlIG5vIHNwZWNpYWwgbWVhbmluZ1xuXHQgICAgICogdW5sZXNzIHRoZXkncmUgcGFydCBvZiBhIHRhZyBvciB1bnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUuXG5cdCAgICAgKiBTZWUgW01hdGhpYXMgQnluZW5zJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2FtYmlndW91cy1hbXBlcnNhbmRzKVxuXHQgICAgICogKHVuZGVyIFwic2VtaS1yZWxhdGVkIGZ1biBmYWN0XCIpIGZvciBtb3JlIGRldGFpbHMuXG5cdCAgICAgKlxuXHQgICAgICogQmFja3RpY2tzIGFyZSBlc2NhcGVkIGJlY2F1c2UgaW4gSW50ZXJuZXQgRXhwbG9yZXIgPCA5LCB0aGV5IGNhbiBicmVhayBvdXRcblx0ICAgICAqIG9mIGF0dHJpYnV0ZSB2YWx1ZXMgb3IgSFRNTCBjb21tZW50cy4gU2VlIFsjNTldKGh0dHBzOi8vaHRtbDVzZWMub3JnLyM1OSksXG5cdCAgICAgKiBbIzEwMl0oaHR0cHM6Ly9odG1sNXNlYy5vcmcvIzEwMiksIFsjMTA4XShodHRwczovL2h0bWw1c2VjLm9yZy8jMTA4KSwgYW5kXG5cdCAgICAgKiBbIzEzM10oaHR0cHM6Ly9odG1sNXNlYy5vcmcvIzEzMykgb2YgdGhlIFtIVE1MNSBTZWN1cml0eSBDaGVhdHNoZWV0XShodHRwczovL2h0bWw1c2VjLm9yZy8pXG5cdCAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuXHQgICAgICpcblx0ICAgICAqIFdoZW4gd29ya2luZyB3aXRoIEhUTUwgeW91IHNob3VsZCBhbHdheXMgW3F1b3RlIGF0dHJpYnV0ZSB2YWx1ZXNdKGh0dHA6Ly93b25rby5jb20vcG9zdC9odG1sLWVzY2FwaW5nKVxuXHQgICAgICogdG8gcmVkdWNlIFhTUyB2ZWN0b3JzLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBlc2NhcGUuXG5cdCAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogXy5lc2NhcGUoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG5cdCAgICAgKiAvLyA9PiAnZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzJ1xuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBlc2NhcGUoc3RyaW5nKSB7XG5cdCAgICAgIC8vIFJlc2V0IGBsYXN0SW5kZXhgIGJlY2F1c2UgaW4gSUUgPCA5IGBTdHJpbmcjcmVwbGFjZWAgZG9lcyBub3QuXG5cdCAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuXHQgICAgICByZXR1cm4gKHN0cmluZyAmJiByZUhhc1VuZXNjYXBlZEh0bWwudGVzdChzdHJpbmcpKVxuXHQgICAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVVbmVzY2FwZWRIdG1sLCBlc2NhcGVIdG1sQ2hhcilcblx0ICAgICAgICA6IHN0cmluZztcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIEVzY2FwZXMgdGhlIGBSZWdFeHBgIHNwZWNpYWwgY2hhcmFjdGVycyBcIlxcXCIsIFwiL1wiLCBcIl5cIiwgXCIkXCIsIFwiLlwiLCBcInxcIiwgXCI/XCIsXG5cdCAgICAgKiBcIipcIiwgXCIrXCIsIFwiKFwiLCBcIilcIiwgXCJbXCIsIFwiXVwiLCBcIntcIiBhbmQgXCJ9XCIgaW4gYHN0cmluZ2AuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcblx0ICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cblx0ICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBfLmVzY2FwZVJlZ0V4cCgnW2xvZGFzaF0oaHR0cHM6Ly9sb2Rhc2guY29tLyknKTtcblx0ICAgICAqIC8vID0+ICdcXFtsb2Rhc2hcXF1cXChodHRwczpcXC9cXC9sb2Rhc2hcXC5jb21cXC9cXCknXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHJpbmcpIHtcblx0ICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG5cdCAgICAgIHJldHVybiAoc3RyaW5nICYmIHJlSGFzUmVnRXhwQ2hhcnMudGVzdChzdHJpbmcpKVxuXHQgICAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVSZWdFeHBDaGFycywgZXNjYXBlUmVnRXhwQ2hhcilcblx0ICAgICAgICA6IChzdHJpbmcgfHwgJyg/OiknKTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIFtrZWJhYiBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MZXR0ZXJfY2FzZSNTcGVjaWFsX2Nhc2Vfc3R5bGVzKS5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IFN0cmluZ1xuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cblx0ICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGtlYmFiIGNhc2VkIHN0cmluZy5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogXy5rZWJhYkNhc2UoJ0ZvbyBCYXInKTtcblx0ICAgICAqIC8vID0+ICdmb28tYmFyJ1xuXHQgICAgICpcblx0ICAgICAqIF8ua2ViYWJDYXNlKCdmb29CYXInKTtcblx0ICAgICAqIC8vID0+ICdmb28tYmFyJ1xuXHQgICAgICpcblx0ICAgICAqIF8ua2ViYWJDYXNlKCdfX2Zvb19iYXJfXycpO1xuXHQgICAgICogLy8gPT4gJ2Zvby1iYXInXG5cdCAgICAgKi9cblx0ICAgIHZhciBrZWJhYkNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcblx0ICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICctJyA6ICcnKSArIHdvcmQudG9Mb3dlckNhc2UoKTtcblx0ICAgIH0pO1xuXHRcblx0ICAgIC8qKlxuXHQgICAgICogUGFkcyBgc3RyaW5nYCBvbiB0aGUgbGVmdCBhbmQgcmlnaHQgc2lkZXMgaWYgaXQncyBzaG9ydGVyIHRoYW4gYGxlbmd0aGAuXG5cdCAgICAgKiBQYWRkaW5nIGNoYXJhY3RlcnMgYXJlIHRydW5jYXRlZCBpZiB0aGV5IGNhbid0IGJlIGV2ZW5seSBkaXZpZGVkIGJ5IGBsZW5ndGhgLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBwYWQuXG5cdCAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0wXSBUaGUgcGFkZGluZyBsZW5ndGguXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG5cdCAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkZWQgc3RyaW5nLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBfLnBhZCgnYWJjJywgOCk7XG5cdCAgICAgKiAvLyA9PiAnICBhYmMgICAnXG5cdCAgICAgKlxuXHQgICAgICogXy5wYWQoJ2FiYycsIDgsICdfLScpO1xuXHQgICAgICogLy8gPT4gJ18tYWJjXy1fJ1xuXHQgICAgICpcblx0ICAgICAqIF8ucGFkKCdhYmMnLCAzKTtcblx0ICAgICAqIC8vID0+ICdhYmMnXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIHBhZChzdHJpbmcsIGxlbmd0aCwgY2hhcnMpIHtcblx0ICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG5cdCAgICAgIGxlbmd0aCA9ICtsZW5ndGg7XG5cdFxuXHQgICAgICB2YXIgc3RyTGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0ICAgICAgaWYgKHN0ckxlbmd0aCA+PSBsZW5ndGggfHwgIW5hdGl2ZUlzRmluaXRlKGxlbmd0aCkpIHtcblx0ICAgICAgICByZXR1cm4gc3RyaW5nO1xuXHQgICAgICB9XG5cdCAgICAgIHZhciBtaWQgPSAobGVuZ3RoIC0gc3RyTGVuZ3RoKSAvIDIsXG5cdCAgICAgICAgICBsZWZ0TGVuZ3RoID0gbmF0aXZlRmxvb3IobWlkKSxcblx0ICAgICAgICAgIHJpZ2h0TGVuZ3RoID0gbmF0aXZlQ2VpbChtaWQpO1xuXHRcblx0ICAgICAgY2hhcnMgPSBjcmVhdGVQYWRkaW5nKCcnLCByaWdodExlbmd0aCwgY2hhcnMpO1xuXHQgICAgICByZXR1cm4gY2hhcnMuc2xpY2UoMCwgbGVmdExlbmd0aCkgKyBzdHJpbmcgKyBjaGFycztcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFBhZHMgYHN0cmluZ2Agb24gdGhlIGxlZnQgc2lkZSBpZiBpdCdzIHNob3J0ZXIgdGhhbiBgbGVuZ3RoYC4gUGFkZGluZ1xuXHQgICAgICogY2hhcmFjdGVycyBhcmUgdHJ1bmNhdGVkIGlmIHRoZXkgZXhjZWVkIGBsZW5ndGhgLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBwYWQuXG5cdCAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0wXSBUaGUgcGFkZGluZyBsZW5ndGguXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG5cdCAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkZWQgc3RyaW5nLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBfLnBhZExlZnQoJ2FiYycsIDYpO1xuXHQgICAgICogLy8gPT4gJyAgIGFiYydcblx0ICAgICAqXG5cdCAgICAgKiBfLnBhZExlZnQoJ2FiYycsIDYsICdfLScpO1xuXHQgICAgICogLy8gPT4gJ18tX2FiYydcblx0ICAgICAqXG5cdCAgICAgKiBfLnBhZExlZnQoJ2FiYycsIDMpO1xuXHQgICAgICogLy8gPT4gJ2FiYydcblx0ICAgICAqL1xuXHQgICAgdmFyIHBhZExlZnQgPSBjcmVhdGVQYWREaXIoKTtcblx0XG5cdCAgICAvKipcblx0ICAgICAqIFBhZHMgYHN0cmluZ2Agb24gdGhlIHJpZ2h0IHNpZGUgaWYgaXQncyBzaG9ydGVyIHRoYW4gYGxlbmd0aGAuIFBhZGRpbmdcblx0ICAgICAqIGNoYXJhY3RlcnMgYXJlIHRydW5jYXRlZCBpZiB0aGV5IGV4Y2VlZCBgbGVuZ3RoYC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IFN0cmluZ1xuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxuXHQgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MF0gVGhlIHBhZGRpbmcgbGVuZ3RoLlxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuXHQgICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogXy5wYWRSaWdodCgnYWJjJywgNik7XG5cdCAgICAgKiAvLyA9PiAnYWJjICAgJ1xuXHQgICAgICpcblx0ICAgICAqIF8ucGFkUmlnaHQoJ2FiYycsIDYsICdfLScpO1xuXHQgICAgICogLy8gPT4gJ2FiY18tXydcblx0ICAgICAqXG5cdCAgICAgKiBfLnBhZFJpZ2h0KCdhYmMnLCAzKTtcblx0ICAgICAqIC8vID0+ICdhYmMnXG5cdCAgICAgKi9cblx0ICAgIHZhciBwYWRSaWdodCA9IGNyZWF0ZVBhZERpcih0cnVlKTtcblx0XG5cdCAgICAvKipcblx0ICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGFuIGludGVnZXIgb2YgdGhlIHNwZWNpZmllZCByYWRpeC4gSWYgYHJhZGl4YCBpc1xuXHQgICAgICogYHVuZGVmaW5lZGAgb3IgYDBgLCBhIGByYWRpeGAgb2YgYDEwYCBpcyB1c2VkIHVubGVzcyBgdmFsdWVgIGlzIGEgaGV4YWRlY2ltYWwsXG5cdCAgICAgKiBpbiB3aGljaCBjYXNlIGEgYHJhZGl4YCBvZiBgMTZgIGlzIHVzZWQuXG5cdCAgICAgKlxuXHQgICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGFsaWducyB3aXRoIHRoZSBbRVM1IGltcGxlbWVudGF0aW9uXShodHRwczovL2VzNS5naXRodWIuaW8vI0UpXG5cdCAgICAgKiBvZiBgcGFyc2VJbnRgLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cblx0ICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcmFkaXhdIFRoZSByYWRpeCB0byBpbnRlcnByZXQgYHZhbHVlYCBieS5cblx0ICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuXHQgICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIF8ucGFyc2VJbnQoJzA4Jyk7XG5cdCAgICAgKiAvLyA9PiA4XG5cdCAgICAgKlxuXHQgICAgICogXy5tYXAoWyc2JywgJzA4JywgJzEwJ10sIF8ucGFyc2VJbnQpO1xuXHQgICAgICogLy8gPT4gWzYsIDgsIDEwXVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBwYXJzZUludChzdHJpbmcsIHJhZGl4LCBndWFyZCkge1xuXHQgICAgICAvLyBGaXJlZm94IDwgMjEgYW5kIE9wZXJhIDwgMTUgZm9sbG93IEVTMyBmb3IgYHBhcnNlSW50YC5cblx0ICAgICAgLy8gQ2hyb21lIGZhaWxzIHRvIHRyaW0gbGVhZGluZyA8Qk9NPiB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMuXG5cdCAgICAgIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzEwOSBmb3IgbW9yZSBkZXRhaWxzLlxuXHQgICAgICBpZiAoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIHJhZGl4LCBndWFyZCkgOiByYWRpeCA9PSBudWxsKSB7XG5cdCAgICAgICAgcmFkaXggPSAwO1xuXHQgICAgICB9IGVsc2UgaWYgKHJhZGl4KSB7XG5cdCAgICAgICAgcmFkaXggPSArcmFkaXg7XG5cdCAgICAgIH1cblx0ICAgICAgc3RyaW5nID0gdHJpbShzdHJpbmcpO1xuXHQgICAgICByZXR1cm4gbmF0aXZlUGFyc2VJbnQoc3RyaW5nLCByYWRpeCB8fCAocmVIYXNIZXhQcmVmaXgudGVzdChzdHJpbmcpID8gMTYgOiAxMCkpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogUmVwZWF0cyB0aGUgZ2l2ZW4gc3RyaW5nIGBuYCB0aW1lcy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IFN0cmluZ1xuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcmVwZWF0LlxuXHQgICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTBdIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IHRoZSBzdHJpbmcuXG5cdCAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByZXBlYXRlZCBzdHJpbmcuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIF8ucmVwZWF0KCcqJywgMyk7XG5cdCAgICAgKiAvLyA9PiAnKioqJ1xuXHQgICAgICpcblx0ICAgICAqIF8ucmVwZWF0KCdhYmMnLCAyKTtcblx0ICAgICAqIC8vID0+ICdhYmNhYmMnXG5cdCAgICAgKlxuXHQgICAgICogXy5yZXBlYXQoJ2FiYycsIDApO1xuXHQgICAgICogLy8gPT4gJydcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gcmVwZWF0KHN0cmluZywgbikge1xuXHQgICAgICB2YXIgcmVzdWx0ID0gJyc7XG5cdCAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuXHQgICAgICBuID0gK247XG5cdCAgICAgIGlmIChuIDwgMSB8fCAhc3RyaW5nIHx8ICFuYXRpdmVJc0Zpbml0ZShuKSkge1xuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgIH1cblx0ICAgICAgLy8gTGV2ZXJhZ2UgdGhlIGV4cG9uZW50aWF0aW9uIGJ5IHNxdWFyaW5nIGFsZ29yaXRobSBmb3IgYSBmYXN0ZXIgcmVwZWF0LlxuXHQgICAgICAvLyBTZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXhwb25lbnRpYXRpb25fYnlfc3F1YXJpbmcgZm9yIG1vcmUgZGV0YWlscy5cblx0ICAgICAgZG8ge1xuXHQgICAgICAgIGlmIChuICUgMikge1xuXHQgICAgICAgICAgcmVzdWx0ICs9IHN0cmluZztcblx0ICAgICAgICB9XG5cdCAgICAgICAgbiA9IG5hdGl2ZUZsb29yKG4gLyAyKTtcblx0ICAgICAgICBzdHJpbmcgKz0gc3RyaW5nO1xuXHQgICAgICB9IHdoaWxlIChuKTtcblx0XG5cdCAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBbc25ha2UgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU25ha2VfY2FzZSkuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcblx0ICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG5cdCAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzbmFrZSBjYXNlZCBzdHJpbmcuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIF8uc25ha2VDYXNlKCdGb28gQmFyJyk7XG5cdCAgICAgKiAvLyA9PiAnZm9vX2Jhcidcblx0ICAgICAqXG5cdCAgICAgKiBfLnNuYWtlQ2FzZSgnZm9vQmFyJyk7XG5cdCAgICAgKiAvLyA9PiAnZm9vX2Jhcidcblx0ICAgICAqXG5cdCAgICAgKiBfLnNuYWtlQ2FzZSgnLS1mb28tYmFyJyk7XG5cdCAgICAgKiAvLyA9PiAnZm9vX2Jhcidcblx0ICAgICAqL1xuXHQgICAgdmFyIHNuYWtlQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuXHQgICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJ18nIDogJycpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xuXHQgICAgfSk7XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBbc3RhcnQgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGV0dGVyX2Nhc2UjU3R5bGlzdGljX29yX3NwZWNpYWxpc2VkX3VzYWdlKS5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IFN0cmluZ1xuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cblx0ICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0YXJ0IGNhc2VkIHN0cmluZy5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogXy5zdGFydENhc2UoJy0tZm9vLWJhcicpO1xuXHQgICAgICogLy8gPT4gJ0ZvbyBCYXInXG5cdCAgICAgKlxuXHQgICAgICogXy5zdGFydENhc2UoJ2Zvb0JhcicpO1xuXHQgICAgICogLy8gPT4gJ0ZvbyBCYXInXG5cdCAgICAgKlxuXHQgICAgICogXy5zdGFydENhc2UoJ19fZm9vX2Jhcl9fJyk7XG5cdCAgICAgKiAvLyA9PiAnRm9vIEJhcidcblx0ICAgICAqL1xuXHQgICAgdmFyIHN0YXJ0Q2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuXHQgICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJyAnIDogJycpICsgKHdvcmQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB3b3JkLnNsaWNlKDEpKTtcblx0ICAgIH0pO1xuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ2hlY2tzIGlmIGBzdHJpbmdgIHN0YXJ0cyB3aXRoIHRoZSBnaXZlbiB0YXJnZXQgc3RyaW5nLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBzZWFyY2guXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3RhcmdldF0gVGhlIHN0cmluZyB0byBzZWFyY2ggZm9yLlxuXHQgICAgICogQHBhcmFtIHtudW1iZXJ9IFtwb3NpdGlvbj0wXSBUaGUgcG9zaXRpb24gdG8gc2VhcmNoIGZyb20uXG5cdCAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHN0cmluZ2Agc3RhcnRzIHdpdGggYHRhcmdldGAsIGVsc2UgYGZhbHNlYC5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogXy5zdGFydHNXaXRoKCdhYmMnLCAnYScpO1xuXHQgICAgICogLy8gPT4gdHJ1ZVxuXHQgICAgICpcblx0ICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2InKTtcblx0ICAgICAqIC8vID0+IGZhbHNlXG5cdCAgICAgKlxuXHQgICAgICogXy5zdGFydHNXaXRoKCdhYmMnLCAnYicsIDEpO1xuXHQgICAgICogLy8gPT4gdHJ1ZVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBzdGFydHNXaXRoKHN0cmluZywgdGFyZ2V0LCBwb3NpdGlvbikge1xuXHQgICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcblx0ICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PSBudWxsXG5cdCAgICAgICAgPyAwXG5cdCAgICAgICAgOiBuYXRpdmVNaW4ocG9zaXRpb24gPCAwID8gMCA6ICgrcG9zaXRpb24gfHwgMCksIHN0cmluZy5sZW5ndGgpO1xuXHRcblx0ICAgICAgcmV0dXJuIHN0cmluZy5sYXN0SW5kZXhPZih0YXJnZXQsIHBvc2l0aW9uKSA9PSBwb3NpdGlvbjtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIENyZWF0ZXMgYSBjb21waWxlZCB0ZW1wbGF0ZSBmdW5jdGlvbiB0aGF0IGNhbiBpbnRlcnBvbGF0ZSBkYXRhIHByb3BlcnRpZXNcblx0ICAgICAqIGluIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXJzLCBIVE1MLWVzY2FwZSBpbnRlcnBvbGF0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluXG5cdCAgICAgKiBcImVzY2FwZVwiIGRlbGltaXRlcnMsIGFuZCBleGVjdXRlIEphdmFTY3JpcHQgaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnMuIERhdGFcblx0ICAgICAqIHByb3BlcnRpZXMgbWF5IGJlIGFjY2Vzc2VkIGFzIGZyZWUgdmFyaWFibGVzIGluIHRoZSB0ZW1wbGF0ZS4gSWYgYSBzZXR0aW5nXG5cdCAgICAgKiBvYmplY3QgaXMgcHJvdmlkZWQgaXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGBfLnRlbXBsYXRlU2V0dGluZ3NgIHZhbHVlcy5cblx0ICAgICAqXG5cdCAgICAgKiAqKk5vdGU6KiogSW4gdGhlIGRldmVsb3BtZW50IGJ1aWxkIGBfLnRlbXBsYXRlYCB1dGlsaXplc1xuXHQgICAgICogW3NvdXJjZVVSTHNdKGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2RldmVsb3BlcnRvb2xzL3NvdXJjZW1hcHMvI3RvYy1zb3VyY2V1cmwpXG5cdCAgICAgKiBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cblx0ICAgICAqXG5cdCAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBwcmVjb21waWxpbmcgdGVtcGxhdGVzIHNlZVxuXHQgICAgICogW2xvZGFzaCdzIGN1c3RvbSBidWlsZHMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9sb2Rhc2guY29tL2N1c3RvbS1idWlsZHMpLlxuXHQgICAgICpcblx0ICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIENocm9tZSBleHRlbnNpb24gc2FuZGJveGVzIHNlZVxuXHQgICAgICogW0Nocm9tZSdzIGV4dGVuc2lvbnMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9leHRlbnNpb25zL3NhbmRib3hpbmdFdmFsKS5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IFN0cmluZ1xuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSB0ZW1wbGF0ZSBzdHJpbmcuXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIG9iamVjdC5cblx0ICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5lc2NhcGVdIFRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyLlxuXHQgICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmV2YWx1YXRlXSBUaGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlci5cblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5pbXBvcnRzXSBBbiBvYmplY3QgdG8gaW1wb3J0IGludG8gdGhlIHRlbXBsYXRlIGFzIGZyZWUgdmFyaWFibGVzLlxuXHQgICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmludGVycG9sYXRlXSBUaGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cblx0ICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zb3VyY2VVUkxdIFRoZSBzb3VyY2VVUkwgb2YgdGhlIHRlbXBsYXRlJ3MgY29tcGlsZWQgc291cmNlLlxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnZhcmlhYmxlXSBUaGUgZGF0YSBvYmplY3QgdmFyaWFibGUgbmFtZS5cblx0ICAgICAqIEBwYXJhbS0ge09iamVjdH0gW290aGVyT3B0aW9uc10gRW5hYmxlcyB0aGUgbGVnYWN5IGBvcHRpb25zYCBwYXJhbSBzaWduYXR1cmUuXG5cdCAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAvLyB1c2luZyB0aGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlciB0byBjcmVhdGUgYSBjb21waWxlZCB0ZW1wbGF0ZVxuXHQgICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IHVzZXIgJT4hJyk7XG5cdCAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ2ZyZWQnIH0pO1xuXHQgICAgICogLy8gPT4gJ2hlbGxvIGZyZWQhJ1xuXHQgICAgICpcblx0ICAgICAqIC8vIHVzaW5nIHRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyIHRvIGVzY2FwZSBkYXRhIHByb3BlcnR5IHZhbHVlc1xuXHQgICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPGI+PCUtIHZhbHVlICU+PC9iPicpO1xuXHQgICAgICogY29tcGlsZWQoeyAndmFsdWUnOiAnPHNjcmlwdD4nIH0pO1xuXHQgICAgICogLy8gPT4gJzxiPiZsdDtzY3JpcHQmZ3Q7PC9iPidcblx0ICAgICAqXG5cdCAgICAgKiAvLyB1c2luZyB0aGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlciB0byBleGVjdXRlIEphdmFTY3JpcHQgYW5kIGdlbmVyYXRlIEhUTUxcblx0ICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIF8uZm9yRWFjaCh1c2VycywgZnVuY3Rpb24odXNlcikgeyAlPjxsaT48JS0gdXNlciAlPjwvbGk+PCUgfSk7ICU+Jyk7XG5cdCAgICAgKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcblx0ICAgICAqIC8vID0+ICc8bGk+ZnJlZDwvbGk+PGxpPmJhcm5leTwvbGk+J1xuXHQgICAgICpcblx0ICAgICAqIC8vIHVzaW5nIHRoZSBpbnRlcm5hbCBgcHJpbnRgIGZ1bmN0aW9uIGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzXG5cdCAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JSBwcmludChcImhlbGxvIFwiICsgdXNlcik7ICU+IScpO1xuXHQgICAgICogY29tcGlsZWQoeyAndXNlcic6ICdiYXJuZXknIH0pO1xuXHQgICAgICogLy8gPT4gJ2hlbGxvIGJhcm5leSEnXG5cdCAgICAgKlxuXHQgICAgICogLy8gdXNpbmcgdGhlIEVTIGRlbGltaXRlciBhcyBhbiBhbHRlcm5hdGl2ZSB0byB0aGUgZGVmYXVsdCBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyXG5cdCAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyAkeyB1c2VyIH0hJyk7XG5cdCAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ3BlYmJsZXMnIH0pO1xuXHQgICAgICogLy8gPT4gJ2hlbGxvIHBlYmJsZXMhJ1xuXHQgICAgICpcblx0ICAgICAqIC8vIHVzaW5nIGN1c3RvbSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzXG5cdCAgICAgKiBfLnRlbXBsYXRlU2V0dGluZ3MuaW50ZXJwb2xhdGUgPSAve3soW1xcc1xcU10rPyl9fS9nO1xuXHQgICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8ge3sgdXNlciB9fSEnKTtcblx0ICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnbXVzdGFjaGUnIH0pO1xuXHQgICAgICogLy8gPT4gJ2hlbGxvIG11c3RhY2hlISdcblx0ICAgICAqXG5cdCAgICAgKiAvLyB1c2luZyBiYWNrc2xhc2hlcyB0byB0cmVhdCBkZWxpbWl0ZXJzIGFzIHBsYWluIHRleHRcblx0ICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlPSBcIlxcXFw8JS0gdmFsdWUgJVxcXFw+XCIgJT4nKTtcblx0ICAgICAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJ2lnbm9yZWQnIH0pO1xuXHQgICAgICogLy8gPT4gJzwlLSB2YWx1ZSAlPidcblx0ICAgICAqXG5cdCAgICAgKiAvLyB1c2luZyB0aGUgYGltcG9ydHNgIG9wdGlvbiB0byBpbXBvcnQgYGpRdWVyeWAgYXMgYGpxYFxuXHQgICAgICogdmFyIHRleHQgPSAnPCUganEuZWFjaCh1c2VycywgZnVuY3Rpb24odXNlcikgeyAlPjxsaT48JS0gdXNlciAlPjwvbGk+PCUgfSk7ICU+Jztcblx0ICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUodGV4dCwgeyAnaW1wb3J0cyc6IHsgJ2pxJzogalF1ZXJ5IH0gfSk7XG5cdCAgICAgKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcblx0ICAgICAqIC8vID0+ICc8bGk+ZnJlZDwvbGk+PGxpPmJhcm5leTwvbGk+J1xuXHQgICAgICpcblx0ICAgICAqIC8vIHVzaW5nIHRoZSBgc291cmNlVVJMYCBvcHRpb24gdG8gc3BlY2lmeSBhIGN1c3RvbSBzb3VyY2VVUkwgZm9yIHRoZSB0ZW1wbGF0ZVxuXHQgICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IHVzZXIgJT4hJywgeyAnc291cmNlVVJMJzogJy9iYXNpYy9ncmVldGluZy5qc3QnIH0pO1xuXHQgICAgICogY29tcGlsZWQoZGF0YSk7XG5cdCAgICAgKiAvLyA9PiBmaW5kIHRoZSBzb3VyY2Ugb2YgXCJncmVldGluZy5qc3RcIiB1bmRlciB0aGUgU291cmNlcyB0YWIgb3IgUmVzb3VyY2VzIHBhbmVsIG9mIHRoZSB3ZWIgaW5zcGVjdG9yXG5cdCAgICAgKlxuXHQgICAgICogLy8gdXNpbmcgdGhlIGB2YXJpYWJsZWAgb3B0aW9uIHRvIGVuc3VyZSBhIHdpdGgtc3RhdGVtZW50IGlzbid0IHVzZWQgaW4gdGhlIGNvbXBpbGVkIHRlbXBsYXRlXG5cdCAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoaSA8JT0gZGF0YS51c2VyICU+IScsIHsgJ3ZhcmlhYmxlJzogJ2RhdGEnIH0pO1xuXHQgICAgICogY29tcGlsZWQuc291cmNlO1xuXHQgICAgICogLy8gPT4gZnVuY3Rpb24oZGF0YSkge1xuXHQgICAgICogLy8gICB2YXIgX190LCBfX3AgPSAnJztcblx0ICAgICAqIC8vICAgX19wICs9ICdoaSAnICsgKChfX3QgPSAoIGRhdGEudXNlciApKSA9PSBudWxsID8gJycgOiBfX3QpICsgJyEnO1xuXHQgICAgICogLy8gICByZXR1cm4gX19wO1xuXHQgICAgICogLy8gfVxuXHQgICAgICpcblx0ICAgICAqIC8vIHVzaW5nIHRoZSBgc291cmNlYCBwcm9wZXJ0eSB0byBpbmxpbmUgY29tcGlsZWQgdGVtcGxhdGVzIGZvciBtZWFuaW5nZnVsXG5cdCAgICAgKiAvLyBsaW5lIG51bWJlcnMgaW4gZXJyb3IgbWVzc2FnZXMgYW5kIGEgc3RhY2sgdHJhY2Vcblx0ICAgICAqIGZzLndyaXRlRmlsZVN5bmMocGF0aC5qb2luKGN3ZCwgJ2pzdC5qcycpLCAnXFxcblx0ICAgICAqICAgdmFyIEpTVCA9IHtcXFxuXHQgICAgICogICAgIFwibWFpblwiOiAnICsgXy50ZW1wbGF0ZShtYWluVGV4dCkuc291cmNlICsgJ1xcXG5cdCAgICAgKiAgIH07XFxcblx0ICAgICAqICcpO1xuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiB0ZW1wbGF0ZShzdHJpbmcsIG9wdGlvbnMsIG90aGVyT3B0aW9ucykge1xuXHQgICAgICAvLyBCYXNlZCBvbiBKb2huIFJlc2lnJ3MgYHRtcGxgIGltcGxlbWVudGF0aW9uIChodHRwOi8vZWpvaG4ub3JnL2Jsb2cvamF2YXNjcmlwdC1taWNyby10ZW1wbGF0aW5nLylcblx0ICAgICAgLy8gYW5kIExhdXJhIERva3Rvcm92YSdzIGRvVC5qcyAoaHR0cHM6Ly9naXRodWIuY29tL29sYWRvL2RvVCkuXG5cdCAgICAgIHZhciBzZXR0aW5ncyA9IGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzO1xuXHRcblx0ICAgICAgaWYgKG90aGVyT3B0aW9ucyAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIG9wdGlvbnMsIG90aGVyT3B0aW9ucykpIHtcblx0ICAgICAgICBvcHRpb25zID0gb3RoZXJPcHRpb25zID0gdW5kZWZpbmVkO1xuXHQgICAgICB9XG5cdCAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuXHQgICAgICBvcHRpb25zID0gYXNzaWduV2l0aChiYXNlQXNzaWduKHt9LCBvdGhlck9wdGlvbnMgfHwgb3B0aW9ucyksIHNldHRpbmdzLCBhc3NpZ25Pd25EZWZhdWx0cyk7XG5cdFxuXHQgICAgICB2YXIgaW1wb3J0cyA9IGFzc2lnbldpdGgoYmFzZUFzc2lnbih7fSwgb3B0aW9ucy5pbXBvcnRzKSwgc2V0dGluZ3MuaW1wb3J0cywgYXNzaWduT3duRGVmYXVsdHMpLFxuXHQgICAgICAgICAgaW1wb3J0c0tleXMgPSBrZXlzKGltcG9ydHMpLFxuXHQgICAgICAgICAgaW1wb3J0c1ZhbHVlcyA9IGJhc2VWYWx1ZXMoaW1wb3J0cywgaW1wb3J0c0tleXMpO1xuXHRcblx0ICAgICAgdmFyIGlzRXNjYXBpbmcsXG5cdCAgICAgICAgICBpc0V2YWx1YXRpbmcsXG5cdCAgICAgICAgICBpbmRleCA9IDAsXG5cdCAgICAgICAgICBpbnRlcnBvbGF0ZSA9IG9wdGlvbnMuaW50ZXJwb2xhdGUgfHwgcmVOb01hdGNoLFxuXHQgICAgICAgICAgc291cmNlID0gXCJfX3AgKz0gJ1wiO1xuXHRcblx0ICAgICAgLy8gQ29tcGlsZSB0aGUgcmVnZXhwIHRvIG1hdGNoIGVhY2ggZGVsaW1pdGVyLlxuXHQgICAgICB2YXIgcmVEZWxpbWl0ZXJzID0gUmVnRXhwKFxuXHQgICAgICAgIChvcHRpb25zLmVzY2FwZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG5cdCAgICAgICAgaW50ZXJwb2xhdGUuc291cmNlICsgJ3wnICtcblx0ICAgICAgICAoaW50ZXJwb2xhdGUgPT09IHJlSW50ZXJwb2xhdGUgPyByZUVzVGVtcGxhdGUgOiByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG5cdCAgICAgICAgKG9wdGlvbnMuZXZhbHVhdGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCQnXG5cdCAgICAgICwgJ2cnKTtcblx0XG5cdCAgICAgIC8vIFVzZSBhIHNvdXJjZVVSTCBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cblx0ICAgICAgdmFyIHNvdXJjZVVSTCA9ICcvLyMgc291cmNlVVJMPScgK1xuXHQgICAgICAgICgnc291cmNlVVJMJyBpbiBvcHRpb25zXG5cdCAgICAgICAgICA/IG9wdGlvbnMuc291cmNlVVJMXG5cdCAgICAgICAgICA6ICgnbG9kYXNoLnRlbXBsYXRlU291cmNlc1snICsgKCsrdGVtcGxhdGVDb3VudGVyKSArICddJylcblx0ICAgICAgICApICsgJ1xcbic7XG5cdFxuXHQgICAgICBzdHJpbmcucmVwbGFjZShyZURlbGltaXRlcnMsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGVWYWx1ZSwgaW50ZXJwb2xhdGVWYWx1ZSwgZXNUZW1wbGF0ZVZhbHVlLCBldmFsdWF0ZVZhbHVlLCBvZmZzZXQpIHtcblx0ICAgICAgICBpbnRlcnBvbGF0ZVZhbHVlIHx8IChpbnRlcnBvbGF0ZVZhbHVlID0gZXNUZW1wbGF0ZVZhbHVlKTtcblx0XG5cdCAgICAgICAgLy8gRXNjYXBlIGNoYXJhY3RlcnMgdGhhdCBjYW4ndCBiZSBpbmNsdWRlZCBpbiBzdHJpbmcgbGl0ZXJhbHMuXG5cdCAgICAgICAgc291cmNlICs9IHN0cmluZy5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKHJlVW5lc2NhcGVkU3RyaW5nLCBlc2NhcGVTdHJpbmdDaGFyKTtcblx0XG5cdCAgICAgICAgLy8gUmVwbGFjZSBkZWxpbWl0ZXJzIHdpdGggc25pcHBldHMuXG5cdCAgICAgICAgaWYgKGVzY2FwZVZhbHVlKSB7XG5cdCAgICAgICAgICBpc0VzY2FwaW5nID0gdHJ1ZTtcblx0ICAgICAgICAgIHNvdXJjZSArPSBcIicgK1xcbl9fZShcIiArIGVzY2FwZVZhbHVlICsgXCIpICtcXG4nXCI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChldmFsdWF0ZVZhbHVlKSB7XG5cdCAgICAgICAgICBpc0V2YWx1YXRpbmcgPSB0cnVlO1xuXHQgICAgICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlVmFsdWUgKyBcIjtcXG5fX3AgKz0gJ1wiO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoaW50ZXJwb2xhdGVWYWx1ZSkge1xuXHQgICAgICAgICAgc291cmNlICs9IFwiJyArXFxuKChfX3QgPSAoXCIgKyBpbnRlcnBvbGF0ZVZhbHVlICsgXCIpKSA9PSBudWxsID8gJycgOiBfX3QpICtcXG4nXCI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXHRcblx0ICAgICAgICAvLyBUaGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIHByb2R1Y3RzIHJlcXVpcmVzIHJldHVybmluZyB0aGUgYG1hdGNoYFxuXHQgICAgICAgIC8vIHN0cmluZyBpbiBvcmRlciB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IGBvZmZzZXRgIHZhbHVlLlxuXHQgICAgICAgIHJldHVybiBtYXRjaDtcblx0ICAgICAgfSk7XG5cdFxuXHQgICAgICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXHRcblx0ICAgICAgLy8gSWYgYHZhcmlhYmxlYCBpcyBub3Qgc3BlY2lmaWVkIHdyYXAgYSB3aXRoLXN0YXRlbWVudCBhcm91bmQgdGhlIGdlbmVyYXRlZFxuXHQgICAgICAvLyBjb2RlIHRvIGFkZCB0aGUgZGF0YSBvYmplY3QgdG8gdGhlIHRvcCBvZiB0aGUgc2NvcGUgY2hhaW4uXG5cdCAgICAgIHZhciB2YXJpYWJsZSA9IG9wdGlvbnMudmFyaWFibGU7XG5cdCAgICAgIGlmICghdmFyaWFibGUpIHtcblx0ICAgICAgICBzb3VyY2UgPSAnd2l0aCAob2JqKSB7XFxuJyArIHNvdXJjZSArICdcXG59XFxuJztcblx0ICAgICAgfVxuXHQgICAgICAvLyBDbGVhbnVwIGNvZGUgYnkgc3RyaXBwaW5nIGVtcHR5IHN0cmluZ3MuXG5cdCAgICAgIHNvdXJjZSA9IChpc0V2YWx1YXRpbmcgPyBzb3VyY2UucmVwbGFjZShyZUVtcHR5U3RyaW5nTGVhZGluZywgJycpIDogc291cmNlKVxuXHQgICAgICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdNaWRkbGUsICckMScpXG5cdCAgICAgICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ1RyYWlsaW5nLCAnJDE7Jyk7XG5cdFxuXHQgICAgICAvLyBGcmFtZSBjb2RlIGFzIHRoZSBmdW5jdGlvbiBib2R5LlxuXHQgICAgICBzb3VyY2UgPSAnZnVuY3Rpb24oJyArICh2YXJpYWJsZSB8fCAnb2JqJykgKyAnKSB7XFxuJyArXG5cdCAgICAgICAgKHZhcmlhYmxlXG5cdCAgICAgICAgICA/ICcnXG5cdCAgICAgICAgICA6ICdvYmogfHwgKG9iaiA9IHt9KTtcXG4nXG5cdCAgICAgICAgKSArXG5cdCAgICAgICAgXCJ2YXIgX190LCBfX3AgPSAnJ1wiICtcblx0ICAgICAgICAoaXNFc2NhcGluZ1xuXHQgICAgICAgICAgID8gJywgX19lID0gXy5lc2NhcGUnXG5cdCAgICAgICAgICAgOiAnJ1xuXHQgICAgICAgICkgK1xuXHQgICAgICAgIChpc0V2YWx1YXRpbmdcblx0ICAgICAgICAgID8gJywgX19qID0gQXJyYXkucHJvdG90eXBlLmpvaW47XFxuJyArXG5cdCAgICAgICAgICAgIFwiZnVuY3Rpb24gcHJpbnQoKSB7IF9fcCArPSBfX2ouY2FsbChhcmd1bWVudHMsICcnKSB9XFxuXCJcblx0ICAgICAgICAgIDogJztcXG4nXG5cdCAgICAgICAgKSArXG5cdCAgICAgICAgc291cmNlICtcblx0ICAgICAgICAncmV0dXJuIF9fcFxcbn0nO1xuXHRcblx0ICAgICAgdmFyIHJlc3VsdCA9IGF0dGVtcHQoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgcmV0dXJuIEZ1bmN0aW9uKGltcG9ydHNLZXlzLCBzb3VyY2VVUkwgKyAncmV0dXJuICcgKyBzb3VyY2UpLmFwcGx5KHVuZGVmaW5lZCwgaW1wb3J0c1ZhbHVlcyk7XG5cdCAgICAgIH0pO1xuXHRcblx0ICAgICAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgZnVuY3Rpb24ncyBzb3VyY2UgYnkgaXRzIGB0b1N0cmluZ2AgbWV0aG9kIG9yXG5cdCAgICAgIC8vIHRoZSBgc291cmNlYCBwcm9wZXJ0eSBhcyBhIGNvbnZlbmllbmNlIGZvciBpbmxpbmluZyBjb21waWxlZCB0ZW1wbGF0ZXMuXG5cdCAgICAgIHJlc3VsdC5zb3VyY2UgPSBzb3VyY2U7XG5cdCAgICAgIGlmIChpc0Vycm9yKHJlc3VsdCkpIHtcblx0ICAgICAgICB0aHJvdyByZXN1bHQ7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFJlbW92ZXMgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZSBvciBzcGVjaWZpZWQgY2hhcmFjdGVycyBmcm9tIGBzdHJpbmdgLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cmltLlxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz13aGl0ZXNwYWNlXSBUaGUgY2hhcmFjdGVycyB0byB0cmltLlxuXHQgICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG5cdCAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogXy50cmltKCcgIGFiYyAgJyk7XG5cdCAgICAgKiAvLyA9PiAnYWJjJ1xuXHQgICAgICpcblx0ICAgICAqIF8udHJpbSgnLV8tYWJjLV8tJywgJ18tJyk7XG5cdCAgICAgKiAvLyA9PiAnYWJjJ1xuXHQgICAgICpcblx0ICAgICAqIF8ubWFwKFsnICBmb28gICcsICcgIGJhciAgJ10sIF8udHJpbSk7XG5cdCAgICAgKiAvLyA9PiBbJ2ZvbycsICdiYXInXVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiB0cmltKHN0cmluZywgY2hhcnMsIGd1YXJkKSB7XG5cdCAgICAgIHZhciB2YWx1ZSA9IHN0cmluZztcblx0ICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG5cdCAgICAgIGlmICghc3RyaW5nKSB7XG5cdCAgICAgICAgcmV0dXJuIHN0cmluZztcblx0ICAgICAgfVxuXHQgICAgICBpZiAoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgY2hhcnMsIGd1YXJkKSA6IGNoYXJzID09IG51bGwpIHtcblx0ICAgICAgICByZXR1cm4gc3RyaW5nLnNsaWNlKHRyaW1tZWRMZWZ0SW5kZXgoc3RyaW5nKSwgdHJpbW1lZFJpZ2h0SW5kZXgoc3RyaW5nKSArIDEpO1xuXHQgICAgICB9XG5cdCAgICAgIGNoYXJzID0gKGNoYXJzICsgJycpO1xuXHQgICAgICByZXR1cm4gc3RyaW5nLnNsaWNlKGNoYXJzTGVmdEluZGV4KHN0cmluZywgY2hhcnMpLCBjaGFyc1JpZ2h0SW5kZXgoc3RyaW5nLCBjaGFycykgKyAxKTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFJlbW92ZXMgbGVhZGluZyB3aGl0ZXNwYWNlIG9yIHNwZWNpZmllZCBjaGFyYWN0ZXJzIGZyb20gYHN0cmluZ2AuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcblx0ICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRyaW0uXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPXdoaXRlc3BhY2VdIFRoZSBjaGFyYWN0ZXJzIHRvIHRyaW0uXG5cdCAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYSBjYWxsYmFjayBmb3IgZnVuY3Rpb25zIGxpa2UgYF8ubWFwYC5cblx0ICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBfLnRyaW1MZWZ0KCcgIGFiYyAgJyk7XG5cdCAgICAgKiAvLyA9PiAnYWJjICAnXG5cdCAgICAgKlxuXHQgICAgICogXy50cmltTGVmdCgnLV8tYWJjLV8tJywgJ18tJyk7XG5cdCAgICAgKiAvLyA9PiAnYWJjLV8tJ1xuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiB0cmltTGVmdChzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xuXHQgICAgICB2YXIgdmFsdWUgPSBzdHJpbmc7XG5cdCAgICAgIHN0cmluZyA9IGJhc2VUb1N0cmluZyhzdHJpbmcpO1xuXHQgICAgICBpZiAoIXN0cmluZykge1xuXHQgICAgICAgIHJldHVybiBzdHJpbmc7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGNoYXJzLCBndWFyZCkgOiBjaGFycyA9PSBudWxsKSB7XG5cdCAgICAgICAgcmV0dXJuIHN0cmluZy5zbGljZSh0cmltbWVkTGVmdEluZGV4KHN0cmluZykpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBzdHJpbmcuc2xpY2UoY2hhcnNMZWZ0SW5kZXgoc3RyaW5nLCAoY2hhcnMgKyAnJykpKTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFJlbW92ZXMgdHJhaWxpbmcgd2hpdGVzcGFjZSBvciBzcGVjaWZpZWQgY2hhcmFjdGVycyBmcm9tIGBzdHJpbmdgLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cmltLlxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz13aGl0ZXNwYWNlXSBUaGUgY2hhcmFjdGVycyB0byB0cmltLlxuXHQgICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG5cdCAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogXy50cmltUmlnaHQoJyAgYWJjICAnKTtcblx0ICAgICAqIC8vID0+ICcgIGFiYydcblx0ICAgICAqXG5cdCAgICAgKiBfLnRyaW1SaWdodCgnLV8tYWJjLV8tJywgJ18tJyk7XG5cdCAgICAgKiAvLyA9PiAnLV8tYWJjJ1xuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiB0cmltUmlnaHQoc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcblx0ICAgICAgdmFyIHZhbHVlID0gc3RyaW5nO1xuXHQgICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcblx0ICAgICAgaWYgKCFzdHJpbmcpIHtcblx0ICAgICAgICByZXR1cm4gc3RyaW5nO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBjaGFycywgZ3VhcmQpIDogY2hhcnMgPT0gbnVsbCkge1xuXHQgICAgICAgIHJldHVybiBzdHJpbmcuc2xpY2UoMCwgdHJpbW1lZFJpZ2h0SW5kZXgoc3RyaW5nKSArIDEpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBzdHJpbmcuc2xpY2UoMCwgY2hhcnNSaWdodEluZGV4KHN0cmluZywgKGNoYXJzICsgJycpKSArIDEpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogVHJ1bmNhdGVzIGBzdHJpbmdgIGlmIGl0J3MgbG9uZ2VyIHRoYW4gdGhlIGdpdmVuIG1heGltdW0gc3RyaW5nIGxlbmd0aC5cblx0ICAgICAqIFRoZSBsYXN0IGNoYXJhY3RlcnMgb2YgdGhlIHRydW5jYXRlZCBzdHJpbmcgYXJlIHJlcGxhY2VkIHdpdGggdGhlIG9taXNzaW9uXG5cdCAgICAgKiBzdHJpbmcgd2hpY2ggZGVmYXVsdHMgdG8gXCIuLi5cIi5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IFN0cmluZ1xuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJ1bmNhdGUuXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdHxudW1iZXJ9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3Qgb3IgbWF4aW11bSBzdHJpbmcgbGVuZ3RoLlxuXHQgICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxlbmd0aD0zMF0gVGhlIG1heGltdW0gc3RyaW5nIGxlbmd0aC5cblx0ICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5vbWlzc2lvbj0nLi4uJ10gVGhlIHN0cmluZyB0byBpbmRpY2F0ZSB0ZXh0IGlzIG9taXR0ZWQuXG5cdCAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IFtvcHRpb25zLnNlcGFyYXRvcl0gVGhlIHNlcGFyYXRvciBwYXR0ZXJuIHRvIHRydW5jYXRlIHRvLlxuXHQgICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG5cdCAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cnVuY2F0ZWQgc3RyaW5nLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBfLnRydW5jKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJyk7XG5cdCAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvLi4uJ1xuXHQgICAgICpcblx0ICAgICAqIF8udHJ1bmMoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCAyNCk7XG5cdCAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLCBuLi4uJ1xuXHQgICAgICpcblx0ICAgICAqIF8udHJ1bmMoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XG5cdCAgICAgKiAgICdsZW5ndGgnOiAyNCxcblx0ICAgICAqICAgJ3NlcGFyYXRvcic6ICcgJ1xuXHQgICAgICogfSk7XG5cdCAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLC4uLidcblx0ICAgICAqXG5cdCAgICAgKiBfLnRydW5jKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJywge1xuXHQgICAgICogICAnbGVuZ3RoJzogMjQsXG5cdCAgICAgKiAgICdzZXBhcmF0b3InOiAvLD8gKy9cblx0ICAgICAqIH0pO1xuXHQgICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZS4uLidcblx0ICAgICAqXG5cdCAgICAgKiBfLnRydW5jKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJywge1xuXHQgICAgICogICAnb21pc3Npb24nOiAnIFsuLi5dJ1xuXHQgICAgICogfSk7XG5cdCAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnIFsuLi5dJ1xuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiB0cnVuYyhzdHJpbmcsIG9wdGlvbnMsIGd1YXJkKSB7XG5cdCAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIG9wdGlvbnMsIGd1YXJkKSkge1xuXHQgICAgICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIGxlbmd0aCA9IERFRkFVTFRfVFJVTkNfTEVOR1RILFxuXHQgICAgICAgICAgb21pc3Npb24gPSBERUZBVUxUX1RSVU5DX09NSVNTSU9OO1xuXHRcblx0ICAgICAgaWYgKG9wdGlvbnMgIT0gbnVsbCkge1xuXHQgICAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuXHQgICAgICAgICAgdmFyIHNlcGFyYXRvciA9ICdzZXBhcmF0b3InIGluIG9wdGlvbnMgPyBvcHRpb25zLnNlcGFyYXRvciA6IHNlcGFyYXRvcjtcblx0ICAgICAgICAgIGxlbmd0aCA9ICdsZW5ndGgnIGluIG9wdGlvbnMgPyAoK29wdGlvbnMubGVuZ3RoIHx8IDApIDogbGVuZ3RoO1xuXHQgICAgICAgICAgb21pc3Npb24gPSAnb21pc3Npb24nIGluIG9wdGlvbnMgPyBiYXNlVG9TdHJpbmcob3B0aW9ucy5vbWlzc2lvbikgOiBvbWlzc2lvbjtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgbGVuZ3RoID0gK29wdGlvbnMgfHwgMDtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG5cdCAgICAgIGlmIChsZW5ndGggPj0gc3RyaW5nLmxlbmd0aCkge1xuXHQgICAgICAgIHJldHVybiBzdHJpbmc7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIGVuZCA9IGxlbmd0aCAtIG9taXNzaW9uLmxlbmd0aDtcblx0ICAgICAgaWYgKGVuZCA8IDEpIHtcblx0ICAgICAgICByZXR1cm4gb21pc3Npb247XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIHJlc3VsdCA9IHN0cmluZy5zbGljZSgwLCBlbmQpO1xuXHQgICAgICBpZiAoc2VwYXJhdG9yID09IG51bGwpIHtcblx0ICAgICAgICByZXR1cm4gcmVzdWx0ICsgb21pc3Npb247XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKGlzUmVnRXhwKHNlcGFyYXRvcikpIHtcblx0ICAgICAgICBpZiAoc3RyaW5nLnNsaWNlKGVuZCkuc2VhcmNoKHNlcGFyYXRvcikpIHtcblx0ICAgICAgICAgIHZhciBtYXRjaCxcblx0ICAgICAgICAgICAgICBuZXdFbmQsXG5cdCAgICAgICAgICAgICAgc3Vic3RyaW5nID0gc3RyaW5nLnNsaWNlKDAsIGVuZCk7XG5cdFxuXHQgICAgICAgICAgaWYgKCFzZXBhcmF0b3IuZ2xvYmFsKSB7XG5cdCAgICAgICAgICAgIHNlcGFyYXRvciA9IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCAocmVGbGFncy5leGVjKHNlcGFyYXRvcikgfHwgJycpICsgJ2cnKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIHNlcGFyYXRvci5sYXN0SW5kZXggPSAwO1xuXHQgICAgICAgICAgd2hpbGUgKChtYXRjaCA9IHNlcGFyYXRvci5leGVjKHN1YnN0cmluZykpKSB7XG5cdCAgICAgICAgICAgIG5ld0VuZCA9IG1hdGNoLmluZGV4O1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIG5ld0VuZCA9PSBudWxsID8gZW5kIDogbmV3RW5kKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0gZWxzZSBpZiAoc3RyaW5nLmluZGV4T2Yoc2VwYXJhdG9yLCBlbmQpICE9IGVuZCkge1xuXHQgICAgICAgIHZhciBpbmRleCA9IHJlc3VsdC5sYXN0SW5kZXhPZihzZXBhcmF0b3IpO1xuXHQgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG5cdCAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgaW5kZXgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gcmVzdWx0ICsgb21pc3Npb247XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBUaGUgaW52ZXJzZSBvZiBgXy5lc2NhcGVgOyB0aGlzIG1ldGhvZCBjb252ZXJ0cyB0aGUgSFRNTCBlbnRpdGllc1xuXHQgICAgICogYCZhbXA7YCwgYCZsdDtgLCBgJmd0O2AsIGAmcXVvdDtgLCBgJiMzOTtgLCBhbmQgYCYjOTY7YCBpbiBgc3RyaW5nYCB0byB0aGVpclxuXHQgICAgICogY29ycmVzcG9uZGluZyBjaGFyYWN0ZXJzLlxuXHQgICAgICpcblx0ICAgICAqICoqTm90ZToqKiBObyBvdGhlciBIVE1MIGVudGl0aWVzIGFyZSB1bmVzY2FwZWQuIFRvIHVuZXNjYXBlIGFkZGl0aW9uYWwgSFRNTFxuXHQgICAgICogZW50aXRpZXMgdXNlIGEgdGhpcmQtcGFydHkgbGlicmFyeSBsaWtlIFtfaGVfXShodHRwczovL210aHMuYmUvaGUpLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB1bmVzY2FwZS5cblx0ICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuZXNjYXBlZCBzdHJpbmcuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIF8udW5lc2NhcGUoJ2ZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlcycpO1xuXHQgICAgICogLy8gPT4gJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJ1xuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiB1bmVzY2FwZShzdHJpbmcpIHtcblx0ICAgICAgc3RyaW5nID0gYmFzZVRvU3RyaW5nKHN0cmluZyk7XG5cdCAgICAgIHJldHVybiAoc3RyaW5nICYmIHJlSGFzRXNjYXBlZEh0bWwudGVzdChzdHJpbmcpKVxuXHQgICAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVFc2NhcGVkSHRtbCwgdW5lc2NhcGVIdG1sQ2hhcilcblx0ICAgICAgICA6IHN0cmluZztcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFNwbGl0cyBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IFN0cmluZ1xuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cblx0ICAgICAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gW3BhdHRlcm5dIFRoZSBwYXR0ZXJuIHRvIG1hdGNoIHdvcmRzLlxuXHQgICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG5cdCAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBfLndvcmRzKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuXHQgICAgICogLy8gPT4gWydmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJ11cblx0ICAgICAqXG5cdCAgICAgKiBfLndvcmRzKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycsIC9bXiwgXSsvZyk7XG5cdCAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAnYmFybmV5JywgJyYnLCAncGViYmxlcyddXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIHdvcmRzKHN0cmluZywgcGF0dGVybiwgZ3VhcmQpIHtcblx0ICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgcGF0dGVybiwgZ3VhcmQpKSB7XG5cdCAgICAgICAgcGF0dGVybiA9IHVuZGVmaW5lZDtcblx0ICAgICAgfVxuXHQgICAgICBzdHJpbmcgPSBiYXNlVG9TdHJpbmcoc3RyaW5nKTtcblx0ICAgICAgcmV0dXJuIHN0cmluZy5tYXRjaChwYXR0ZXJuIHx8IHJlV29yZHMpIHx8IFtdO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblx0XG5cdCAgICAvKipcblx0ICAgICAqIEF0dGVtcHRzIHRvIGludm9rZSBgZnVuY2AsIHJldHVybmluZyBlaXRoZXIgdGhlIHJlc3VsdCBvciB0aGUgY2F1Z2h0IGVycm9yXG5cdCAgICAgKiBvYmplY3QuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQgaXMgaW52b2tlZC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IFV0aWxpdHlcblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGF0dGVtcHQuXG5cdCAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYGZ1bmNgIHJlc3VsdCBvciBlcnJvciBvYmplY3QuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIC8vIGF2b2lkIHRocm93aW5nIGVycm9ycyBmb3IgaW52YWxpZCBzZWxlY3RvcnNcblx0ICAgICAqIHZhciBlbGVtZW50cyA9IF8uYXR0ZW1wdChmdW5jdGlvbihzZWxlY3Rvcikge1xuXHQgICAgICogICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG5cdCAgICAgKiB9LCAnPl8+Jyk7XG5cdCAgICAgKlxuXHQgICAgICogaWYgKF8uaXNFcnJvcihlbGVtZW50cykpIHtcblx0ICAgICAqICAgZWxlbWVudHMgPSBbXTtcblx0ICAgICAqIH1cblx0ICAgICAqL1xuXHQgICAgdmFyIGF0dGVtcHQgPSByZXN0UGFyYW0oZnVuY3Rpb24oZnVuYywgYXJncykge1xuXHQgICAgICB0cnkge1xuXHQgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG5cdCAgICAgIH0gY2F0Y2goZSkge1xuXHQgICAgICAgIHJldHVybiBpc0Vycm9yKGUpID8gZSA6IG5ldyBFcnJvcihlKTtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2Bcblx0ICAgICAqIGFuZCBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uIElmIGBmdW5jYCBpcyBhIHByb3BlcnR5IG5hbWUgdGhlXG5cdCAgICAgKiBjcmVhdGVkIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIGZvciBhIGdpdmVuIGVsZW1lbnQuIElmIGBmdW5jYFxuXHQgICAgICogaXMgYW4gb2JqZWN0IHRoZSBjcmVhdGVkIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGNvbnRhaW5cblx0ICAgICAqIHRoZSBlcXVpdmFsZW50IG9iamVjdCBwcm9wZXJ0aWVzLCBvdGhlcndpc2UgaXQgcmV0dXJucyBgZmFsc2VgLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAYWxpYXMgaXRlcmF0ZWVcblx0ICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG5cdCAgICAgKiBAcGFyYW0geyp9IFtmdW5jPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGEgY2FsbGJhY2suXG5cdCAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuXHQgICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGEgY2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAuXG5cdCAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNhbGxiYWNrLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiB2YXIgdXNlcnMgPSBbXG5cdCAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG5cdCAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cblx0ICAgICAqIF07XG5cdCAgICAgKlxuXHQgICAgICogLy8gd3JhcCB0byBjcmVhdGUgY3VzdG9tIGNhbGxiYWNrIHNob3J0aGFuZHNcblx0ICAgICAqIF8uY2FsbGJhY2sgPSBfLndyYXAoXy5jYWxsYmFjaywgZnVuY3Rpb24oY2FsbGJhY2ssIGZ1bmMsIHRoaXNBcmcpIHtcblx0ICAgICAqICAgdmFyIG1hdGNoID0gL14oLis/KV9fKFtnbF10KSguKykkLy5leGVjKGZ1bmMpO1xuXHQgICAgICogICBpZiAoIW1hdGNoKSB7XG5cdCAgICAgKiAgICAgcmV0dXJuIGNhbGxiYWNrKGZ1bmMsIHRoaXNBcmcpO1xuXHQgICAgICogICB9XG5cdCAgICAgKiAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcblx0ICAgICAqICAgICByZXR1cm4gbWF0Y2hbMl0gPT0gJ2d0J1xuXHQgICAgICogICAgICAgPyBvYmplY3RbbWF0Y2hbMV1dID4gbWF0Y2hbM11cblx0ICAgICAqICAgICAgIDogb2JqZWN0W21hdGNoWzFdXSA8IG1hdGNoWzNdO1xuXHQgICAgICogICB9O1xuXHQgICAgICogfSk7XG5cdCAgICAgKlxuXHQgICAgICogXy5maWx0ZXIodXNlcnMsICdhZ2VfX2d0MzYnKTtcblx0ICAgICAqIC8vID0+IFt7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogNDAgfV1cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gY2FsbGJhY2soZnVuYywgdGhpc0FyZywgZ3VhcmQpIHtcblx0ICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGZ1bmMsIHRoaXNBcmcsIGd1YXJkKSkge1xuXHQgICAgICAgIHRoaXNBcmcgPSB1bmRlZmluZWQ7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZShmdW5jKVxuXHQgICAgICAgID8gbWF0Y2hlcyhmdW5jKVxuXHQgICAgICAgIDogYmFzZUNhbGxiYWNrKGZ1bmMsIHRoaXNBcmcpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuXHQgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20gdGhlIG5ldyBmdW5jdGlvbi5cblx0ICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJyB9O1xuXHQgICAgICogdmFyIGdldHRlciA9IF8uY29uc3RhbnQob2JqZWN0KTtcblx0ICAgICAqXG5cdCAgICAgKiBnZXR0ZXIoKSA9PT0gb2JqZWN0O1xuXHQgICAgICogLy8gPT4gdHJ1ZVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuXHQgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgICB9O1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgcHJvdmlkZWQgdG8gaXQuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG5cdCAgICAgKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cblx0ICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG5cdCAgICAgKlxuXHQgICAgICogXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3Q7XG5cdCAgICAgKiAvLyA9PiB0cnVlXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG5cdCAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gYSBnaXZlbiBvYmplY3Rcblx0ICAgICAqIGFuZCBgc291cmNlYCwgcmV0dXJuaW5nIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGhhcyBlcXVpdmFsZW50IHByb3BlcnR5XG5cdCAgICAgKiB2YWx1ZXMsIGVsc2UgYGZhbHNlYC5cblx0ICAgICAqXG5cdCAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2Qgc3VwcG9ydHMgY29tcGFyaW5nIGFycmF5cywgYm9vbGVhbnMsIGBEYXRlYCBvYmplY3RzLFxuXHQgICAgICogbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgYW5kIHN0cmluZ3MuIE9iamVjdHMgYXJlIGNvbXBhcmVkIGJ5XG5cdCAgICAgKiB0aGVpciBvd24sIG5vdCBpbmhlcml0ZWQsIGVudW1lcmFibGUgcHJvcGVydGllcy4gRm9yIGNvbXBhcmluZyBhIHNpbmdsZVxuXHQgICAgICogb3duIG9yIGluaGVyaXRlZCBwcm9wZXJ0eSB2YWx1ZSBzZWUgYF8ubWF0Y2hlc1Byb3BlcnR5YC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IFV0aWxpdHlcblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG5cdCAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogdmFyIHVzZXJzID0gW1xuXHQgICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcblx0ICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG5cdCAgICAgKiBdO1xuXHQgICAgICpcblx0ICAgICAqIF8uZmlsdGVyKHVzZXJzLCBfLm1hdGNoZXMoeyAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9KSk7XG5cdCAgICAgKiAvLyA9PiBbeyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfV1cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gbWF0Y2hlcyhzb3VyY2UpIHtcblx0ICAgICAgcmV0dXJuIGJhc2VNYXRjaGVzKGJhc2VDbG9uZShzb3VyY2UsIHRydWUpKTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGNvbXBhcmVzIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiBgcGF0aGAgb24gYSBnaXZlblxuXHQgICAgICogb2JqZWN0IHRvIGB2YWx1ZWAuXG5cdCAgICAgKlxuXHQgICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGNvbXBhcmluZyBhcnJheXMsIGJvb2xlYW5zLCBgRGF0ZWAgb2JqZWN0cyxcblx0ICAgICAqIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsIGFuZCBzdHJpbmdzLiBPYmplY3RzIGFyZSBjb21wYXJlZCBieVxuXHQgICAgICogdGhlaXIgb3duLCBub3QgaW5oZXJpdGVkLCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuXHQgICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG5cdCAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogdmFyIHVzZXJzID0gW1xuXHQgICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScgfSxcblx0ICAgICAqICAgeyAndXNlcic6ICdmcmVkJyB9XG5cdCAgICAgKiBdO1xuXHQgICAgICpcblx0ICAgICAqIF8uZmluZCh1c2VycywgXy5tYXRjaGVzUHJvcGVydHkoJ3VzZXInLCAnZnJlZCcpKTtcblx0ICAgICAqIC8vID0+IHsgJ3VzZXInOiAnZnJlZCcgfVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBtYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcblx0ICAgICAgcmV0dXJuIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgYmFzZUNsb25lKHNyY1ZhbHVlLCB0cnVlKSk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSBtZXRob2QgYXQgYHBhdGhgIG9uIGEgZ2l2ZW4gb2JqZWN0LlxuXHQgICAgICogQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byB0aGUgaW52b2tlZCBtZXRob2QuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbWV0aG9kIHRvIGludm9rZS5cblx0ICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cblx0ICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiB2YXIgb2JqZWN0cyA9IFtcblx0ICAgICAqICAgeyAnYSc6IHsgJ2InOiB7ICdjJzogXy5jb25zdGFudCgyKSB9IH0gfSxcblx0ICAgICAqICAgeyAnYSc6IHsgJ2InOiB7ICdjJzogXy5jb25zdGFudCgxKSB9IH0gfVxuXHQgICAgICogXTtcblx0ICAgICAqXG5cdCAgICAgKiBfLm1hcChvYmplY3RzLCBfLm1ldGhvZCgnYS5iLmMnKSk7XG5cdCAgICAgKiAvLyA9PiBbMiwgMV1cblx0ICAgICAqXG5cdCAgICAgKiBfLmludm9rZShfLnNvcnRCeShvYmplY3RzLCBfLm1ldGhvZChbJ2EnLCAnYicsICdjJ10pKSwgJ2EuYi5jJyk7XG5cdCAgICAgKiAvLyA9PiBbMSwgMl1cblx0ICAgICAqL1xuXHQgICAgdmFyIG1ldGhvZCA9IHJlc3RQYXJhbShmdW5jdGlvbihwYXRoLCBhcmdzKSB7XG5cdCAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcblx0ICAgICAgICByZXR1cm4gaW52b2tlUGF0aChvYmplY3QsIHBhdGgsIGFyZ3MpO1xuXHQgICAgICB9O1xuXHQgICAgfSk7XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ubWV0aG9kYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlc1xuXHQgICAgICogdGhlIG1ldGhvZCBhdCBhIGdpdmVuIHBhdGggb24gYG9iamVjdGAuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmVcblx0ICAgICAqIHByb3ZpZGVkIHRvIHRoZSBpbnZva2VkIG1ldGhvZC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IFV0aWxpdHlcblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cblx0ICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cblx0ICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiB2YXIgYXJyYXkgPSBfLnRpbWVzKDMsIF8uY29uc3RhbnQpLFxuXHQgICAgICogICAgIG9iamVjdCA9IHsgJ2EnOiBhcnJheSwgJ2InOiBhcnJheSwgJ2MnOiBhcnJheSB9O1xuXHQgICAgICpcblx0ICAgICAqIF8ubWFwKFsnYVsyXScsICdjWzBdJ10sIF8ubWV0aG9kT2Yob2JqZWN0KSk7XG5cdCAgICAgKiAvLyA9PiBbMiwgMF1cblx0ICAgICAqXG5cdCAgICAgKiBfLm1hcChbWydhJywgJzInXSwgWydjJywgJzAnXV0sIF8ubWV0aG9kT2Yob2JqZWN0KSk7XG5cdCAgICAgKiAvLyA9PiBbMiwgMF1cblx0ICAgICAqL1xuXHQgICAgdmFyIG1ldGhvZE9mID0gcmVzdFBhcmFtKGZ1bmN0aW9uKG9iamVjdCwgYXJncykge1xuXHQgICAgICByZXR1cm4gZnVuY3Rpb24ocGF0aCkge1xuXHQgICAgICAgIHJldHVybiBpbnZva2VQYXRoKG9iamVjdCwgcGF0aCwgYXJncyk7XG5cdCAgICAgIH07XG5cdCAgICB9KTtcblx0XG5cdCAgICAvKipcblx0ICAgICAqIEFkZHMgYWxsIG93biBlbnVtZXJhYmxlIGZ1bmN0aW9uIHByb3BlcnRpZXMgb2YgYSBzb3VyY2Ugb2JqZWN0IHRvIHRoZVxuXHQgICAgICogZGVzdGluYXRpb24gb2JqZWN0LiBJZiBgb2JqZWN0YCBpcyBhIGZ1bmN0aW9uIHRoZW4gbWV0aG9kcyBhcmUgYWRkZWQgdG9cblx0ICAgICAqIGl0cyBwcm90b3R5cGUgYXMgd2VsbC5cblx0ICAgICAqXG5cdCAgICAgKiAqKk5vdGU6KiogVXNlIGBfLnJ1bkluQ29udGV4dGAgdG8gY3JlYXRlIGEgcHJpc3RpbmUgYGxvZGFzaGAgZnVuY3Rpb24gdG9cblx0ICAgICAqIGF2b2lkIGNvbmZsaWN0cyBjYXVzZWQgYnkgbW9kaWZ5aW5nIHRoZSBvcmlnaW5hbC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IFV0aWxpdHlcblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSBbb2JqZWN0PWxvZGFzaF0gVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBmdW5jdGlvbnMgdG8gYWRkLlxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3QuXG5cdCAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNoYWluPXRydWVdIFNwZWNpZnkgd2hldGhlciB0aGUgZnVuY3Rpb25zIGFkZGVkXG5cdCAgICAgKiAgYXJlIGNoYWluYWJsZS5cblx0ICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIGZ1bmN0aW9uIHZvd2VscyhzdHJpbmcpIHtcblx0ICAgICAqICAgcmV0dXJuIF8uZmlsdGVyKHN0cmluZywgZnVuY3Rpb24odikge1xuXHQgICAgICogICAgIHJldHVybiAvW2FlaW91XS9pLnRlc3Qodik7XG5cdCAgICAgKiAgIH0pO1xuXHQgICAgICogfVxuXHQgICAgICpcblx0ICAgICAqIF8ubWl4aW4oeyAndm93ZWxzJzogdm93ZWxzIH0pO1xuXHQgICAgICogXy52b3dlbHMoJ2ZyZWQnKTtcblx0ICAgICAqIC8vID0+IFsnZSddXG5cdCAgICAgKlxuXHQgICAgICogXygnZnJlZCcpLnZvd2VscygpLnZhbHVlKCk7XG5cdCAgICAgKiAvLyA9PiBbJ2UnXVxuXHQgICAgICpcblx0ICAgICAqIF8ubWl4aW4oeyAndm93ZWxzJzogdm93ZWxzIH0sIHsgJ2NoYWluJzogZmFsc2UgfSk7XG5cdCAgICAgKiBfKCdmcmVkJykudm93ZWxzKCk7XG5cdCAgICAgKiAvLyA9PiBbJ2UnXVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBtaXhpbihvYmplY3QsIHNvdXJjZSwgb3B0aW9ucykge1xuXHQgICAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG5cdCAgICAgICAgdmFyIGlzT2JqID0gaXNPYmplY3Qoc291cmNlKSxcblx0ICAgICAgICAgICAgcHJvcHMgPSBpc09iaiA/IGtleXMoc291cmNlKSA6IHVuZGVmaW5lZCxcblx0ICAgICAgICAgICAgbWV0aG9kTmFtZXMgPSAocHJvcHMgJiYgcHJvcHMubGVuZ3RoKSA/IGJhc2VGdW5jdGlvbnMoc291cmNlLCBwcm9wcykgOiB1bmRlZmluZWQ7XG5cdFxuXHQgICAgICAgIGlmICghKG1ldGhvZE5hbWVzID8gbWV0aG9kTmFtZXMubGVuZ3RoIDogaXNPYmopKSB7XG5cdCAgICAgICAgICBtZXRob2ROYW1lcyA9IGZhbHNlO1xuXHQgICAgICAgICAgb3B0aW9ucyA9IHNvdXJjZTtcblx0ICAgICAgICAgIHNvdXJjZSA9IG9iamVjdDtcblx0ICAgICAgICAgIG9iamVjdCA9IHRoaXM7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIGlmICghbWV0aG9kTmFtZXMpIHtcblx0ICAgICAgICBtZXRob2ROYW1lcyA9IGJhc2VGdW5jdGlvbnMoc291cmNlLCBrZXlzKHNvdXJjZSkpO1xuXHQgICAgICB9XG5cdCAgICAgIHZhciBjaGFpbiA9IHRydWUsXG5cdCAgICAgICAgICBpbmRleCA9IC0xLFxuXHQgICAgICAgICAgaXNGdW5jID0gaXNGdW5jdGlvbihvYmplY3QpLFxuXHQgICAgICAgICAgbGVuZ3RoID0gbWV0aG9kTmFtZXMubGVuZ3RoO1xuXHRcblx0ICAgICAgaWYgKG9wdGlvbnMgPT09IGZhbHNlKSB7XG5cdCAgICAgICAgY2hhaW4gPSBmYWxzZTtcblx0ICAgICAgfSBlbHNlIGlmIChpc09iamVjdChvcHRpb25zKSAmJiAnY2hhaW4nIGluIG9wdGlvbnMpIHtcblx0ICAgICAgICBjaGFpbiA9IG9wdGlvbnMuY2hhaW47XG5cdCAgICAgIH1cblx0ICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0ICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IG1ldGhvZE5hbWVzW2luZGV4XSxcblx0ICAgICAgICAgICAgZnVuYyA9IHNvdXJjZVttZXRob2ROYW1lXTtcblx0XG5cdCAgICAgICAgb2JqZWN0W21ldGhvZE5hbWVdID0gZnVuYztcblx0ICAgICAgICBpZiAoaXNGdW5jKSB7XG5cdCAgICAgICAgICBvYmplY3QucHJvdG90eXBlW21ldGhvZE5hbWVdID0gKGZ1bmN0aW9uKGZ1bmMpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgIHZhciBjaGFpbkFsbCA9IHRoaXMuX19jaGFpbl9fO1xuXHQgICAgICAgICAgICAgIGlmIChjaGFpbiB8fCBjaGFpbkFsbCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdCh0aGlzLl9fd3JhcHBlZF9fKSxcblx0ICAgICAgICAgICAgICAgICAgICBhY3Rpb25zID0gcmVzdWx0Ll9fYWN0aW9uc19fID0gYXJyYXlDb3B5KHRoaXMuX19hY3Rpb25zX18pO1xuXHRcblx0ICAgICAgICAgICAgICAgIGFjdGlvbnMucHVzaCh7ICdmdW5jJzogZnVuYywgJ2FyZ3MnOiBhcmd1bWVudHMsICd0aGlzQXJnJzogb2JqZWN0IH0pO1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0Ll9fY2hhaW5fXyA9IGNoYWluQWxsO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkob2JqZWN0LCBhcnJheVB1c2goW3RoaXMudmFsdWUoKV0sIGFyZ3VtZW50cykpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgfShmdW5jKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBvYmplY3Q7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBSZXZlcnRzIHRoZSBgX2AgdmFyaWFibGUgdG8gaXRzIHByZXZpb3VzIHZhbHVlIGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvXG5cdCAgICAgKiB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG5cdCAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiB2YXIgbG9kYXNoID0gXy5ub0NvbmZsaWN0KCk7XG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIG5vQ29uZmxpY3QoKSB7XG5cdCAgICAgIHJvb3QuXyA9IG9sZERhc2g7XG5cdCAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQSBuby1vcGVyYXRpb24gZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB1bmRlZmluZWRgIHJlZ2FyZGxlc3Mgb2YgdGhlXG5cdCAgICAgKiBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG5cdCAgICAgKlxuXHQgICAgICogXy5ub29wKG9iamVjdCkgPT09IHVuZGVmaW5lZDtcblx0ICAgICAqIC8vID0+IHRydWVcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gbm9vcCgpIHtcblx0ICAgICAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIGF0IGBwYXRoYCBvbiBhXG5cdCAgICAgKiBnaXZlbiBvYmplY3QuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuXHQgICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIHZhciBvYmplY3RzID0gW1xuXHQgICAgICogICB7ICdhJzogeyAnYic6IHsgJ2MnOiAyIH0gfSB9LFxuXHQgICAgICogICB7ICdhJzogeyAnYic6IHsgJ2MnOiAxIH0gfSB9XG5cdCAgICAgKiBdO1xuXHQgICAgICpcblx0ICAgICAqIF8ubWFwKG9iamVjdHMsIF8ucHJvcGVydHkoJ2EuYi5jJykpO1xuXHQgICAgICogLy8gPT4gWzIsIDFdXG5cdCAgICAgKlxuXHQgICAgICogXy5wbHVjayhfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJywgJ2MnXSkpLCAnYS5iLmMnKTtcblx0ICAgICAqIC8vID0+IFsxLCAyXVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG5cdCAgICAgIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eShwYXRoKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucHJvcGVydHlgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zXG5cdCAgICAgKiB0aGUgcHJvcGVydHkgdmFsdWUgYXQgYSBnaXZlbiBwYXRoIG9uIGBvYmplY3RgLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuXHQgICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIHZhciBhcnJheSA9IFswLCAxLCAyXSxcblx0ICAgICAqICAgICBvYmplY3QgPSB7ICdhJzogYXJyYXksICdiJzogYXJyYXksICdjJzogYXJyYXkgfTtcblx0ICAgICAqXG5cdCAgICAgKiBfLm1hcChbJ2FbMl0nLCAnY1swXSddLCBfLnByb3BlcnR5T2Yob2JqZWN0KSk7XG5cdCAgICAgKiAvLyA9PiBbMiwgMF1cblx0ICAgICAqXG5cdCAgICAgKiBfLm1hcChbWydhJywgJzInXSwgWydjJywgJzAnXV0sIF8ucHJvcGVydHlPZihvYmplY3QpKTtcblx0ICAgICAqIC8vID0+IFsyLCAwXVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBwcm9wZXJ0eU9mKG9iamVjdCkge1xuXHQgICAgICByZXR1cm4gZnVuY3Rpb24ocGF0aCkge1xuXHQgICAgICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgdG9QYXRoKHBhdGgpLCBwYXRoICsgJycpO1xuXHQgICAgICB9O1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBudW1iZXJzIChwb3NpdGl2ZSBhbmQvb3IgbmVnYXRpdmUpIHByb2dyZXNzaW5nIGZyb21cblx0ICAgICAqIGBzdGFydGAgdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLCBgZW5kYC4gSWYgYGVuZGAgaXMgbm90IHNwZWNpZmllZCBpdCBpc1xuXHQgICAgICogc2V0IHRvIGBzdGFydGAgd2l0aCBgc3RhcnRgIHRoZW4gc2V0IHRvIGAwYC4gSWYgYGVuZGAgaXMgbGVzcyB0aGFuIGBzdGFydGBcblx0ICAgICAqIGEgemVyby1sZW5ndGggcmFuZ2UgaXMgY3JlYXRlZCB1bmxlc3MgYSBuZWdhdGl2ZSBgc3RlcGAgaXMgc3BlY2lmaWVkLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0eVxuXHQgICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuXHQgICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cblx0ICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RlcD0xXSBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cblx0ICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIG51bWJlcnMuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIF8ucmFuZ2UoNCk7XG5cdCAgICAgKiAvLyA9PiBbMCwgMSwgMiwgM11cblx0ICAgICAqXG5cdCAgICAgKiBfLnJhbmdlKDEsIDUpO1xuXHQgICAgICogLy8gPT4gWzEsIDIsIDMsIDRdXG5cdCAgICAgKlxuXHQgICAgICogXy5yYW5nZSgwLCAyMCwgNSk7XG5cdCAgICAgKiAvLyA9PiBbMCwgNSwgMTAsIDE1XVxuXHQgICAgICpcblx0ICAgICAqIF8ucmFuZ2UoMCwgLTQsIC0xKTtcblx0ICAgICAqIC8vID0+IFswLCAtMSwgLTIsIC0zXVxuXHQgICAgICpcblx0ICAgICAqIF8ucmFuZ2UoMSwgNCwgMCk7XG5cdCAgICAgKiAvLyA9PiBbMSwgMSwgMV1cblx0ICAgICAqXG5cdCAgICAgKiBfLnJhbmdlKDApO1xuXHQgICAgICogLy8gPT4gW11cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gcmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCkge1xuXHQgICAgICBpZiAoc3RlcCAmJiBpc0l0ZXJhdGVlQ2FsbChzdGFydCwgZW5kLCBzdGVwKSkge1xuXHQgICAgICAgIGVuZCA9IHN0ZXAgPSB1bmRlZmluZWQ7XG5cdCAgICAgIH1cblx0ICAgICAgc3RhcnQgPSArc3RhcnQgfHwgMDtcblx0ICAgICAgc3RlcCA9IHN0ZXAgPT0gbnVsbCA/IDEgOiAoK3N0ZXAgfHwgMCk7XG5cdFxuXHQgICAgICBpZiAoZW5kID09IG51bGwpIHtcblx0ICAgICAgICBlbmQgPSBzdGFydDtcblx0ICAgICAgICBzdGFydCA9IDA7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgZW5kID0gK2VuZCB8fCAwO1xuXHQgICAgICB9XG5cdCAgICAgIC8vIFVzZSBgQXJyYXkobGVuZ3RoKWAgc28gZW5naW5lcyBsaWtlIENoYWtyYSBhbmQgVjggYXZvaWQgc2xvd2VyIG1vZGVzLlxuXHQgICAgICAvLyBTZWUgaHR0cHM6Ly95b3V0dS5iZS9YQXFJcEdVOFpaayN0PTE3bTI1cyBmb3IgbW9yZSBkZXRhaWxzLlxuXHQgICAgICB2YXIgaW5kZXggPSAtMSxcblx0ICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChuYXRpdmVDZWlsKChlbmQgLSBzdGFydCkgLyAoc3RlcCB8fCAxKSksIDApLFxuXHQgICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblx0XG5cdCAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdCAgICAgICAgcmVzdWx0W2luZGV4XSA9IHN0YXJ0O1xuXHQgICAgICAgIHN0YXJ0ICs9IHN0ZXA7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIEludm9rZXMgdGhlIGl0ZXJhdGVlIGZ1bmN0aW9uIGBuYCB0aW1lcywgcmV0dXJuaW5nIGFuIGFycmF5IG9mIHRoZSByZXN1bHRzXG5cdCAgICAgKiBvZiBlYWNoIGludm9jYXRpb24uIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoXG5cdCAgICAgKiBvbmUgYXJndW1lbnQ7IChpbmRleCkuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEBjYXRlZ29yeSBVdGlsaXR5XG5cdCAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG5cdCAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGl0ZXJhdGVlYC5cblx0ICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogdmFyIGRpY2VSb2xscyA9IF8udGltZXMoMywgXy5wYXJ0aWFsKF8ucmFuZG9tLCAxLCA2LCBmYWxzZSkpO1xuXHQgICAgICogLy8gPT4gWzMsIDYsIDRdXG5cdCAgICAgKlxuXHQgICAgICogXy50aW1lcygzLCBmdW5jdGlvbihuKSB7XG5cdCAgICAgKiAgIG1hZ2UuY2FzdFNwZWxsKG4pO1xuXHQgICAgICogfSk7XG5cdCAgICAgKiAvLyA9PiBpbnZva2VzIGBtYWdlLmNhc3RTcGVsbChuKWAgdGhyZWUgdGltZXMgd2l0aCBgbmAgb2YgYDBgLCBgMWAsIGFuZCBgMmBcblx0ICAgICAqXG5cdCAgICAgKiBfLnRpbWVzKDMsIGZ1bmN0aW9uKG4pIHtcblx0ICAgICAqICAgdGhpcy5jYXN0KG4pO1xuXHQgICAgICogfSwgbWFnZSk7XG5cdCAgICAgKiAvLyA9PiBhbHNvIGludm9rZXMgYG1hZ2UuY2FzdFNwZWxsKG4pYCB0aHJlZSB0aW1lc1xuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiB0aW1lcyhuLCBpdGVyYXRlZSwgdGhpc0FyZykge1xuXHQgICAgICBuID0gbmF0aXZlRmxvb3Iobik7XG5cdFxuXHQgICAgICAvLyBFeGl0IGVhcmx5IHRvIGF2b2lkIGEgSlNDIEpJVCBidWcgaW4gU2FmYXJpIDhcblx0ICAgICAgLy8gd2hlcmUgYEFycmF5KDApYCBpcyB0cmVhdGVkIGFzIGBBcnJheSgxKWAuXG5cdCAgICAgIGlmIChuIDwgMSB8fCAhbmF0aXZlSXNGaW5pdGUobikpIHtcblx0ICAgICAgICByZXR1cm4gW107XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIGluZGV4ID0gLTEsXG5cdCAgICAgICAgICByZXN1bHQgPSBBcnJheShuYXRpdmVNaW4obiwgTUFYX0FSUkFZX0xFTkdUSCkpO1xuXHRcblx0ICAgICAgaXRlcmF0ZWUgPSBiaW5kQ2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDEpO1xuXHQgICAgICB3aGlsZSAoKytpbmRleCA8IG4pIHtcblx0ICAgICAgICBpZiAoaW5kZXggPCBNQVhfQVJSQVlfTEVOR1RIKSB7XG5cdCAgICAgICAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBpdGVyYXRlZShpbmRleCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBHZW5lcmF0ZXMgYSB1bmlxdWUgSUQuIElmIGBwcmVmaXhgIGlzIHByb3ZpZGVkIHRoZSBJRCBpcyBhcHBlbmRlZCB0byBpdC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IFV0aWxpdHlcblx0ICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcHJlZml4XSBUaGUgdmFsdWUgdG8gcHJlZml4IHRoZSBJRCB3aXRoLlxuXHQgICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5pcXVlIElELlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBfLnVuaXF1ZUlkKCdjb250YWN0XycpO1xuXHQgICAgICogLy8gPT4gJ2NvbnRhY3RfMTA0J1xuXHQgICAgICpcblx0ICAgICAqIF8udW5pcXVlSWQoKTtcblx0ICAgICAqIC8vID0+ICcxMDUnXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIHVuaXF1ZUlkKHByZWZpeCkge1xuXHQgICAgICB2YXIgaWQgPSArK2lkQ291bnRlcjtcblx0ICAgICAgcmV0dXJuIGJhc2VUb1N0cmluZyhwcmVmaXgpICsgaWQ7XG5cdCAgICB9XG5cdFxuXHQgICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQWRkcyB0d28gbnVtYmVycy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IE1hdGhcblx0ICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhdWdlbmQgVGhlIGZpcnN0IG51bWJlciB0byBhZGQuXG5cdCAgICAgKiBAcGFyYW0ge251bWJlcn0gYWRkZW5kIFRoZSBzZWNvbmQgbnVtYmVyIHRvIGFkZC5cblx0ICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN1bS5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogXy5hZGQoNiwgNCk7XG5cdCAgICAgKiAvLyA9PiAxMFxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBhZGQoYXVnZW5kLCBhZGRlbmQpIHtcblx0ICAgICAgcmV0dXJuICgrYXVnZW5kIHx8IDApICsgKCthZGRlbmQgfHwgMCk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBDYWxjdWxhdGVzIGBuYCByb3VuZGVkIHVwIHRvIGBwcmVjaXNpb25gLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuXHQgICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciB0byByb3VuZCB1cC5cblx0ICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uPTBdIFRoZSBwcmVjaXNpb24gdG8gcm91bmQgdXAgdG8uXG5cdCAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByb3VuZGVkIHVwIG51bWJlci5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogXy5jZWlsKDQuMDA2KTtcblx0ICAgICAqIC8vID0+IDVcblx0ICAgICAqXG5cdCAgICAgKiBfLmNlaWwoNi4wMDQsIDIpO1xuXHQgICAgICogLy8gPT4gNi4wMVxuXHQgICAgICpcblx0ICAgICAqIF8uY2VpbCg2MDQwLCAtMik7XG5cdCAgICAgKiAvLyA9PiA2MTAwXG5cdCAgICAgKi9cblx0ICAgIHZhciBjZWlsID0gY3JlYXRlUm91bmQoJ2NlaWwnKTtcblx0XG5cdCAgICAvKipcblx0ICAgICAqIENhbGN1bGF0ZXMgYG5gIHJvdW5kZWQgZG93biB0byBgcHJlY2lzaW9uYC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IE1hdGhcblx0ICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgdG8gcm91bmQgZG93bi5cblx0ICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uPTBdIFRoZSBwcmVjaXNpb24gdG8gcm91bmQgZG93biB0by5cblx0ICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJvdW5kZWQgZG93biBudW1iZXIuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIF8uZmxvb3IoNC4wMDYpO1xuXHQgICAgICogLy8gPT4gNFxuXHQgICAgICpcblx0ICAgICAqIF8uZmxvb3IoMC4wNDYsIDIpO1xuXHQgICAgICogLy8gPT4gMC4wNFxuXHQgICAgICpcblx0ICAgICAqIF8uZmxvb3IoNDA2MCwgLTIpO1xuXHQgICAgICogLy8gPT4gNDAwMFxuXHQgICAgICovXG5cdCAgICB2YXIgZmxvb3IgPSBjcmVhdGVSb3VuZCgnZmxvb3InKTtcblx0XG5cdCAgICAvKipcblx0ICAgICAqIEdldHMgdGhlIG1heGltdW0gdmFsdWUgb2YgYGNvbGxlY3Rpb25gLiBJZiBgY29sbGVjdGlvbmAgaXMgZW1wdHkgb3IgZmFsc2V5XG5cdCAgICAgKiBgLUluZmluaXR5YCBpcyByZXR1cm5lZC4gSWYgYW4gaXRlcmF0ZWUgZnVuY3Rpb24gaXMgcHJvdmlkZWQgaXQgaXMgaW52b2tlZFxuXHQgICAgICogZm9yIGVhY2ggdmFsdWUgaW4gYGNvbGxlY3Rpb25gIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2ggdGhlIHZhbHVlXG5cdCAgICAgKiBpcyByYW5rZWQuIFRoZSBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG5cdCAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pLlxuXHQgICAgICpcblx0ICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5wcm9wZXJ0eWBcblx0ICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuXHQgICAgICpcblx0ICAgICAqIElmIGEgdmFsdWUgaXMgYWxzbyBwcm92aWRlZCBmb3IgYHRoaXNBcmdgIHRoZSBjcmVhdGVkIGBfLm1hdGNoZXNQcm9wZXJ0eWBcblx0ICAgICAqIHN0eWxlIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgYSBtYXRjaGluZyBwcm9wZXJ0eVxuXHQgICAgICogdmFsdWUsIGVsc2UgYGZhbHNlYC5cblx0ICAgICAqXG5cdCAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBpdGVyYXRlZWAgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc2Agc3R5bGVcblx0ICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuXG5cdCAgICAgKiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IE1hdGhcblx0ICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cblx0ICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuXHQgICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1heGltdW0gdmFsdWUuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIF8ubWF4KFs0LCAyLCA4LCA2XSk7XG5cdCAgICAgKiAvLyA9PiA4XG5cdCAgICAgKlxuXHQgICAgICogXy5tYXgoW10pO1xuXHQgICAgICogLy8gPT4gLUluZmluaXR5XG5cdCAgICAgKlxuXHQgICAgICogdmFyIHVzZXJzID0gW1xuXHQgICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuXHQgICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG5cdCAgICAgKiBdO1xuXHQgICAgICpcblx0ICAgICAqIF8ubWF4KHVzZXJzLCBmdW5jdGlvbihjaHIpIHtcblx0ICAgICAqICAgcmV0dXJuIGNoci5hZ2U7XG5cdCAgICAgKiB9KTtcblx0ICAgICAqIC8vID0+IHsgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiA0MCB9XG5cdCAgICAgKlxuXHQgICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcblx0ICAgICAqIF8ubWF4KHVzZXJzLCAnYWdlJyk7XG5cdCAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogNDAgfVxuXHQgICAgICovXG5cdCAgICB2YXIgbWF4ID0gY3JlYXRlRXh0cmVtdW0oZ3QsIE5FR0FUSVZFX0lORklOSVRZKTtcblx0XG5cdCAgICAvKipcblx0ICAgICAqIEdldHMgdGhlIG1pbmltdW0gdmFsdWUgb2YgYGNvbGxlY3Rpb25gLiBJZiBgY29sbGVjdGlvbmAgaXMgZW1wdHkgb3IgZmFsc2V5XG5cdCAgICAgKiBgSW5maW5pdHlgIGlzIHJldHVybmVkLiBJZiBhbiBpdGVyYXRlZSBmdW5jdGlvbiBpcyBwcm92aWRlZCBpdCBpcyBpbnZva2VkXG5cdCAgICAgKiBmb3IgZWFjaCB2YWx1ZSBpbiBgY29sbGVjdGlvbmAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaCB0aGUgdmFsdWVcblx0ICAgICAqIGlzIHJhbmtlZC4gVGhlIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcblx0ICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikuXG5cdCAgICAgKlxuXHQgICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgaXRlcmF0ZWVgIHRoZSBjcmVhdGVkIGBfLnByb3BlcnR5YFxuXHQgICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG5cdCAgICAgKlxuXHQgICAgICogSWYgYSB2YWx1ZSBpcyBhbHNvIHByb3ZpZGVkIGZvciBgdGhpc0FyZ2AgdGhlIGNyZWF0ZWQgYF8ubWF0Y2hlc1Byb3BlcnR5YFxuXHQgICAgICogc3R5bGUgY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIHByb3BlcnR5XG5cdCAgICAgKiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuXHQgICAgICpcblx0ICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGl0ZXJhdGVlYCB0aGUgY3JlYXRlZCBgXy5tYXRjaGVzYCBzdHlsZVxuXHQgICAgICogY2FsbGJhY2sgcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW5cblx0ICAgICAqIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBtZW1iZXJPZiBfXG5cdCAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuXHQgICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2l0ZXJhdGVlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuXHQgICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBpdGVyYXRlZWAuXG5cdCAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZS5cblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogXy5taW4oWzQsIDIsIDgsIDZdKTtcblx0ICAgICAqIC8vID0+IDJcblx0ICAgICAqXG5cdCAgICAgKiBfLm1pbihbXSk7XG5cdCAgICAgKiAvLyA9PiBJbmZpbml0eVxuXHQgICAgICpcblx0ICAgICAqIHZhciB1c2VycyA9IFtcblx0ICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcblx0ICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuXHQgICAgICogXTtcblx0ICAgICAqXG5cdCAgICAgKiBfLm1pbih1c2VycywgZnVuY3Rpb24oY2hyKSB7XG5cdCAgICAgKiAgIHJldHVybiBjaHIuYWdlO1xuXHQgICAgICogfSk7XG5cdCAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG5cdCAgICAgKlxuXHQgICAgICogLy8gdXNpbmcgdGhlIGBfLnByb3BlcnR5YCBjYWxsYmFjayBzaG9ydGhhbmRcblx0ICAgICAqIF8ubWluKHVzZXJzLCAnYWdlJyk7XG5cdCAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG5cdCAgICAgKi9cblx0ICAgIHZhciBtaW4gPSBjcmVhdGVFeHRyZW11bShsdCwgUE9TSVRJVkVfSU5GSU5JVFkpO1xuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQ2FsY3VsYXRlcyBgbmAgcm91bmRlZCB0byBgcHJlY2lzaW9uYC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IE1hdGhcblx0ICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgdG8gcm91bmQuXG5cdCAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj0wXSBUaGUgcHJlY2lzaW9uIHRvIHJvdW5kIHRvLlxuXHQgICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcm91bmRlZCBudW1iZXIuXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIF8ucm91bmQoNC4wMDYpO1xuXHQgICAgICogLy8gPT4gNFxuXHQgICAgICpcblx0ICAgICAqIF8ucm91bmQoNC4wMDYsIDIpO1xuXHQgICAgICogLy8gPT4gNC4wMVxuXHQgICAgICpcblx0ICAgICAqIF8ucm91bmQoNDA2MCwgLTIpO1xuXHQgICAgICogLy8gPT4gNDEwMFxuXHQgICAgICovXG5cdCAgICB2YXIgcm91bmQgPSBjcmVhdGVSb3VuZCgncm91bmQnKTtcblx0XG5cdCAgICAvKipcblx0ICAgICAqIEdldHMgdGhlIHN1bSBvZiB0aGUgdmFsdWVzIGluIGBjb2xsZWN0aW9uYC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAbWVtYmVyT2YgX1xuXHQgICAgICogQGNhdGVnb3J5IE1hdGhcblx0ICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG5cdCAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtpdGVyYXRlZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cblx0ICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgaXRlcmF0ZWVgLlxuXHQgICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3VtLlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiBfLnN1bShbNCwgNl0pO1xuXHQgICAgICogLy8gPT4gMTBcblx0ICAgICAqXG5cdCAgICAgKiBfLnN1bSh7ICdhJzogNCwgJ2InOiA2IH0pO1xuXHQgICAgICogLy8gPT4gMTBcblx0ICAgICAqXG5cdCAgICAgKiB2YXIgb2JqZWN0cyA9IFtcblx0ICAgICAqICAgeyAnbic6IDQgfSxcblx0ICAgICAqICAgeyAnbic6IDYgfVxuXHQgICAgICogXTtcblx0ICAgICAqXG5cdCAgICAgKiBfLnN1bShvYmplY3RzLCBmdW5jdGlvbihvYmplY3QpIHtcblx0ICAgICAqICAgcmV0dXJuIG9iamVjdC5uO1xuXHQgICAgICogfSk7XG5cdCAgICAgKiAvLyA9PiAxMFxuXHQgICAgICpcblx0ICAgICAqIC8vIHVzaW5nIHRoZSBgXy5wcm9wZXJ0eWAgY2FsbGJhY2sgc2hvcnRoYW5kXG5cdCAgICAgKiBfLnN1bShvYmplY3RzLCAnbicpO1xuXHQgICAgICogLy8gPT4gMTBcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gc3VtKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG5cdCAgICAgIGlmICh0aGlzQXJnICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCB0aGlzQXJnKSkge1xuXHQgICAgICAgIGl0ZXJhdGVlID0gdW5kZWZpbmVkO1xuXHQgICAgICB9XG5cdCAgICAgIGl0ZXJhdGVlID0gZ2V0Q2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDMpO1xuXHQgICAgICByZXR1cm4gaXRlcmF0ZWUubGVuZ3RoID09IDFcblx0ICAgICAgICA/IGFycmF5U3VtKGlzQXJyYXkoY29sbGVjdGlvbikgPyBjb2xsZWN0aW9uIDogdG9JdGVyYWJsZShjb2xsZWN0aW9uKSwgaXRlcmF0ZWUpXG5cdCAgICAgICAgOiBiYXNlU3VtKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcblx0ICAgIH1cblx0XG5cdCAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cdFxuXHQgICAgLy8gRW5zdXJlIHdyYXBwZXJzIGFyZSBpbnN0YW5jZXMgb2YgYGJhc2VMb2Rhc2hgLlxuXHQgICAgbG9kYXNoLnByb3RvdHlwZSA9IGJhc2VMb2Rhc2gucHJvdG90eXBlO1xuXHRcblx0ICAgIExvZGFzaFdyYXBwZXIucHJvdG90eXBlID0gYmFzZUNyZWF0ZShiYXNlTG9kYXNoLnByb3RvdHlwZSk7XG5cdCAgICBMb2Rhc2hXcmFwcGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExvZGFzaFdyYXBwZXI7XG5cdFxuXHQgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlID0gYmFzZUNyZWF0ZShiYXNlTG9kYXNoLnByb3RvdHlwZSk7XG5cdCAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMYXp5V3JhcHBlcjtcblx0XG5cdCAgICAvLyBBZGQgZnVuY3Rpb25zIHRvIHRoZSBgTWFwYCBjYWNoZS5cblx0ICAgIE1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBEZWxldGU7XG5cdCAgICBNYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwR2V0O1xuXHQgICAgTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcEhhcztcblx0ICAgIE1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBTZXQ7XG5cdFxuXHQgICAgLy8gQWRkIGZ1bmN0aW9ucyB0byB0aGUgYFNldGAgY2FjaGUuXG5cdCAgICBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IGNhY2hlUHVzaDtcblx0XG5cdCAgICAvLyBBc3NpZ24gY2FjaGUgdG8gYF8ubWVtb2l6ZWAuXG5cdCAgICBtZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cdFxuXHQgICAgLy8gQWRkIGZ1bmN0aW9ucyB0aGF0IHJldHVybiB3cmFwcGVkIHZhbHVlcyB3aGVuIGNoYWluaW5nLlxuXHQgICAgbG9kYXNoLmFmdGVyID0gYWZ0ZXI7XG5cdCAgICBsb2Rhc2guYXJ5ID0gYXJ5O1xuXHQgICAgbG9kYXNoLmFzc2lnbiA9IGFzc2lnbjtcblx0ICAgIGxvZGFzaC5hdCA9IGF0O1xuXHQgICAgbG9kYXNoLmJlZm9yZSA9IGJlZm9yZTtcblx0ICAgIGxvZGFzaC5iaW5kID0gYmluZDtcblx0ICAgIGxvZGFzaC5iaW5kQWxsID0gYmluZEFsbDtcblx0ICAgIGxvZGFzaC5iaW5kS2V5ID0gYmluZEtleTtcblx0ICAgIGxvZGFzaC5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXHQgICAgbG9kYXNoLmNoYWluID0gY2hhaW47XG5cdCAgICBsb2Rhc2guY2h1bmsgPSBjaHVuaztcblx0ICAgIGxvZGFzaC5jb21wYWN0ID0gY29tcGFjdDtcblx0ICAgIGxvZGFzaC5jb25zdGFudCA9IGNvbnN0YW50O1xuXHQgICAgbG9kYXNoLmNvdW50QnkgPSBjb3VudEJ5O1xuXHQgICAgbG9kYXNoLmNyZWF0ZSA9IGNyZWF0ZTtcblx0ICAgIGxvZGFzaC5jdXJyeSA9IGN1cnJ5O1xuXHQgICAgbG9kYXNoLmN1cnJ5UmlnaHQgPSBjdXJyeVJpZ2h0O1xuXHQgICAgbG9kYXNoLmRlYm91bmNlID0gZGVib3VuY2U7XG5cdCAgICBsb2Rhc2guZGVmYXVsdHMgPSBkZWZhdWx0cztcblx0ICAgIGxvZGFzaC5kZWZhdWx0c0RlZXAgPSBkZWZhdWx0c0RlZXA7XG5cdCAgICBsb2Rhc2guZGVmZXIgPSBkZWZlcjtcblx0ICAgIGxvZGFzaC5kZWxheSA9IGRlbGF5O1xuXHQgICAgbG9kYXNoLmRpZmZlcmVuY2UgPSBkaWZmZXJlbmNlO1xuXHQgICAgbG9kYXNoLmRyb3AgPSBkcm9wO1xuXHQgICAgbG9kYXNoLmRyb3BSaWdodCA9IGRyb3BSaWdodDtcblx0ICAgIGxvZGFzaC5kcm9wUmlnaHRXaGlsZSA9IGRyb3BSaWdodFdoaWxlO1xuXHQgICAgbG9kYXNoLmRyb3BXaGlsZSA9IGRyb3BXaGlsZTtcblx0ICAgIGxvZGFzaC5maWxsID0gZmlsbDtcblx0ICAgIGxvZGFzaC5maWx0ZXIgPSBmaWx0ZXI7XG5cdCAgICBsb2Rhc2guZmxhdHRlbiA9IGZsYXR0ZW47XG5cdCAgICBsb2Rhc2guZmxhdHRlbkRlZXAgPSBmbGF0dGVuRGVlcDtcblx0ICAgIGxvZGFzaC5mbG93ID0gZmxvdztcblx0ICAgIGxvZGFzaC5mbG93UmlnaHQgPSBmbG93UmlnaHQ7XG5cdCAgICBsb2Rhc2guZm9yRWFjaCA9IGZvckVhY2g7XG5cdCAgICBsb2Rhc2guZm9yRWFjaFJpZ2h0ID0gZm9yRWFjaFJpZ2h0O1xuXHQgICAgbG9kYXNoLmZvckluID0gZm9ySW47XG5cdCAgICBsb2Rhc2guZm9ySW5SaWdodCA9IGZvckluUmlnaHQ7XG5cdCAgICBsb2Rhc2guZm9yT3duID0gZm9yT3duO1xuXHQgICAgbG9kYXNoLmZvck93blJpZ2h0ID0gZm9yT3duUmlnaHQ7XG5cdCAgICBsb2Rhc2guZnVuY3Rpb25zID0gZnVuY3Rpb25zO1xuXHQgICAgbG9kYXNoLmdyb3VwQnkgPSBncm91cEJ5O1xuXHQgICAgbG9kYXNoLmluZGV4QnkgPSBpbmRleEJ5O1xuXHQgICAgbG9kYXNoLmluaXRpYWwgPSBpbml0aWFsO1xuXHQgICAgbG9kYXNoLmludGVyc2VjdGlvbiA9IGludGVyc2VjdGlvbjtcblx0ICAgIGxvZGFzaC5pbnZlcnQgPSBpbnZlcnQ7XG5cdCAgICBsb2Rhc2guaW52b2tlID0gaW52b2tlO1xuXHQgICAgbG9kYXNoLmtleXMgPSBrZXlzO1xuXHQgICAgbG9kYXNoLmtleXNJbiA9IGtleXNJbjtcblx0ICAgIGxvZGFzaC5tYXAgPSBtYXA7XG5cdCAgICBsb2Rhc2gubWFwS2V5cyA9IG1hcEtleXM7XG5cdCAgICBsb2Rhc2gubWFwVmFsdWVzID0gbWFwVmFsdWVzO1xuXHQgICAgbG9kYXNoLm1hdGNoZXMgPSBtYXRjaGVzO1xuXHQgICAgbG9kYXNoLm1hdGNoZXNQcm9wZXJ0eSA9IG1hdGNoZXNQcm9wZXJ0eTtcblx0ICAgIGxvZGFzaC5tZW1vaXplID0gbWVtb2l6ZTtcblx0ICAgIGxvZGFzaC5tZXJnZSA9IG1lcmdlO1xuXHQgICAgbG9kYXNoLm1ldGhvZCA9IG1ldGhvZDtcblx0ICAgIGxvZGFzaC5tZXRob2RPZiA9IG1ldGhvZE9mO1xuXHQgICAgbG9kYXNoLm1peGluID0gbWl4aW47XG5cdCAgICBsb2Rhc2gubW9kQXJncyA9IG1vZEFyZ3M7XG5cdCAgICBsb2Rhc2gubmVnYXRlID0gbmVnYXRlO1xuXHQgICAgbG9kYXNoLm9taXQgPSBvbWl0O1xuXHQgICAgbG9kYXNoLm9uY2UgPSBvbmNlO1xuXHQgICAgbG9kYXNoLnBhaXJzID0gcGFpcnM7XG5cdCAgICBsb2Rhc2gucGFydGlhbCA9IHBhcnRpYWw7XG5cdCAgICBsb2Rhc2gucGFydGlhbFJpZ2h0ID0gcGFydGlhbFJpZ2h0O1xuXHQgICAgbG9kYXNoLnBhcnRpdGlvbiA9IHBhcnRpdGlvbjtcblx0ICAgIGxvZGFzaC5waWNrID0gcGljaztcblx0ICAgIGxvZGFzaC5wbHVjayA9IHBsdWNrO1xuXHQgICAgbG9kYXNoLnByb3BlcnR5ID0gcHJvcGVydHk7XG5cdCAgICBsb2Rhc2gucHJvcGVydHlPZiA9IHByb3BlcnR5T2Y7XG5cdCAgICBsb2Rhc2gucHVsbCA9IHB1bGw7XG5cdCAgICBsb2Rhc2gucHVsbEF0ID0gcHVsbEF0O1xuXHQgICAgbG9kYXNoLnJhbmdlID0gcmFuZ2U7XG5cdCAgICBsb2Rhc2gucmVhcmcgPSByZWFyZztcblx0ICAgIGxvZGFzaC5yZWplY3QgPSByZWplY3Q7XG5cdCAgICBsb2Rhc2gucmVtb3ZlID0gcmVtb3ZlO1xuXHQgICAgbG9kYXNoLnJlc3QgPSByZXN0O1xuXHQgICAgbG9kYXNoLnJlc3RQYXJhbSA9IHJlc3RQYXJhbTtcblx0ICAgIGxvZGFzaC5zZXQgPSBzZXQ7XG5cdCAgICBsb2Rhc2guc2h1ZmZsZSA9IHNodWZmbGU7XG5cdCAgICBsb2Rhc2guc2xpY2UgPSBzbGljZTtcblx0ICAgIGxvZGFzaC5zb3J0QnkgPSBzb3J0Qnk7XG5cdCAgICBsb2Rhc2guc29ydEJ5QWxsID0gc29ydEJ5QWxsO1xuXHQgICAgbG9kYXNoLnNvcnRCeU9yZGVyID0gc29ydEJ5T3JkZXI7XG5cdCAgICBsb2Rhc2guc3ByZWFkID0gc3ByZWFkO1xuXHQgICAgbG9kYXNoLnRha2UgPSB0YWtlO1xuXHQgICAgbG9kYXNoLnRha2VSaWdodCA9IHRha2VSaWdodDtcblx0ICAgIGxvZGFzaC50YWtlUmlnaHRXaGlsZSA9IHRha2VSaWdodFdoaWxlO1xuXHQgICAgbG9kYXNoLnRha2VXaGlsZSA9IHRha2VXaGlsZTtcblx0ICAgIGxvZGFzaC50YXAgPSB0YXA7XG5cdCAgICBsb2Rhc2gudGhyb3R0bGUgPSB0aHJvdHRsZTtcblx0ICAgIGxvZGFzaC50aHJ1ID0gdGhydTtcblx0ICAgIGxvZGFzaC50aW1lcyA9IHRpbWVzO1xuXHQgICAgbG9kYXNoLnRvQXJyYXkgPSB0b0FycmF5O1xuXHQgICAgbG9kYXNoLnRvUGxhaW5PYmplY3QgPSB0b1BsYWluT2JqZWN0O1xuXHQgICAgbG9kYXNoLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcblx0ICAgIGxvZGFzaC51bmlvbiA9IHVuaW9uO1xuXHQgICAgbG9kYXNoLnVuaXEgPSB1bmlxO1xuXHQgICAgbG9kYXNoLnVuemlwID0gdW56aXA7XG5cdCAgICBsb2Rhc2gudW56aXBXaXRoID0gdW56aXBXaXRoO1xuXHQgICAgbG9kYXNoLnZhbHVlcyA9IHZhbHVlcztcblx0ICAgIGxvZGFzaC52YWx1ZXNJbiA9IHZhbHVlc0luO1xuXHQgICAgbG9kYXNoLndoZXJlID0gd2hlcmU7XG5cdCAgICBsb2Rhc2gud2l0aG91dCA9IHdpdGhvdXQ7XG5cdCAgICBsb2Rhc2gud3JhcCA9IHdyYXA7XG5cdCAgICBsb2Rhc2gueG9yID0geG9yO1xuXHQgICAgbG9kYXNoLnppcCA9IHppcDtcblx0ICAgIGxvZGFzaC56aXBPYmplY3QgPSB6aXBPYmplY3Q7XG5cdCAgICBsb2Rhc2guemlwV2l0aCA9IHppcFdpdGg7XG5cdFxuXHQgICAgLy8gQWRkIGFsaWFzZXMuXG5cdCAgICBsb2Rhc2guYmFja2Zsb3cgPSBmbG93UmlnaHQ7XG5cdCAgICBsb2Rhc2guY29sbGVjdCA9IG1hcDtcblx0ICAgIGxvZGFzaC5jb21wb3NlID0gZmxvd1JpZ2h0O1xuXHQgICAgbG9kYXNoLmVhY2ggPSBmb3JFYWNoO1xuXHQgICAgbG9kYXNoLmVhY2hSaWdodCA9IGZvckVhY2hSaWdodDtcblx0ICAgIGxvZGFzaC5leHRlbmQgPSBhc3NpZ247XG5cdCAgICBsb2Rhc2guaXRlcmF0ZWUgPSBjYWxsYmFjaztcblx0ICAgIGxvZGFzaC5tZXRob2RzID0gZnVuY3Rpb25zO1xuXHQgICAgbG9kYXNoLm9iamVjdCA9IHppcE9iamVjdDtcblx0ICAgIGxvZGFzaC5zZWxlY3QgPSBmaWx0ZXI7XG5cdCAgICBsb2Rhc2gudGFpbCA9IHJlc3Q7XG5cdCAgICBsb2Rhc2gudW5pcXVlID0gdW5pcTtcblx0XG5cdCAgICAvLyBBZGQgZnVuY3Rpb25zIHRvIGBsb2Rhc2gucHJvdG90eXBlYC5cblx0ICAgIG1peGluKGxvZGFzaCwgbG9kYXNoKTtcblx0XG5cdCAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cdFxuXHQgICAgLy8gQWRkIGZ1bmN0aW9ucyB0aGF0IHJldHVybiB1bndyYXBwZWQgdmFsdWVzIHdoZW4gY2hhaW5pbmcuXG5cdCAgICBsb2Rhc2guYWRkID0gYWRkO1xuXHQgICAgbG9kYXNoLmF0dGVtcHQgPSBhdHRlbXB0O1xuXHQgICAgbG9kYXNoLmNhbWVsQ2FzZSA9IGNhbWVsQ2FzZTtcblx0ICAgIGxvZGFzaC5jYXBpdGFsaXplID0gY2FwaXRhbGl6ZTtcblx0ICAgIGxvZGFzaC5jZWlsID0gY2VpbDtcblx0ICAgIGxvZGFzaC5jbG9uZSA9IGNsb25lO1xuXHQgICAgbG9kYXNoLmNsb25lRGVlcCA9IGNsb25lRGVlcDtcblx0ICAgIGxvZGFzaC5kZWJ1cnIgPSBkZWJ1cnI7XG5cdCAgICBsb2Rhc2guZW5kc1dpdGggPSBlbmRzV2l0aDtcblx0ICAgIGxvZGFzaC5lc2NhcGUgPSBlc2NhcGU7XG5cdCAgICBsb2Rhc2guZXNjYXBlUmVnRXhwID0gZXNjYXBlUmVnRXhwO1xuXHQgICAgbG9kYXNoLmV2ZXJ5ID0gZXZlcnk7XG5cdCAgICBsb2Rhc2guZmluZCA9IGZpbmQ7XG5cdCAgICBsb2Rhc2guZmluZEluZGV4ID0gZmluZEluZGV4O1xuXHQgICAgbG9kYXNoLmZpbmRLZXkgPSBmaW5kS2V5O1xuXHQgICAgbG9kYXNoLmZpbmRMYXN0ID0gZmluZExhc3Q7XG5cdCAgICBsb2Rhc2guZmluZExhc3RJbmRleCA9IGZpbmRMYXN0SW5kZXg7XG5cdCAgICBsb2Rhc2guZmluZExhc3RLZXkgPSBmaW5kTGFzdEtleTtcblx0ICAgIGxvZGFzaC5maW5kV2hlcmUgPSBmaW5kV2hlcmU7XG5cdCAgICBsb2Rhc2guZmlyc3QgPSBmaXJzdDtcblx0ICAgIGxvZGFzaC5mbG9vciA9IGZsb29yO1xuXHQgICAgbG9kYXNoLmdldCA9IGdldDtcblx0ICAgIGxvZGFzaC5ndCA9IGd0O1xuXHQgICAgbG9kYXNoLmd0ZSA9IGd0ZTtcblx0ICAgIGxvZGFzaC5oYXMgPSBoYXM7XG5cdCAgICBsb2Rhc2guaWRlbnRpdHkgPSBpZGVudGl0eTtcblx0ICAgIGxvZGFzaC5pbmNsdWRlcyA9IGluY2x1ZGVzO1xuXHQgICAgbG9kYXNoLmluZGV4T2YgPSBpbmRleE9mO1xuXHQgICAgbG9kYXNoLmluUmFuZ2UgPSBpblJhbmdlO1xuXHQgICAgbG9kYXNoLmlzQXJndW1lbnRzID0gaXNBcmd1bWVudHM7XG5cdCAgICBsb2Rhc2guaXNBcnJheSA9IGlzQXJyYXk7XG5cdCAgICBsb2Rhc2guaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXHQgICAgbG9kYXNoLmlzRGF0ZSA9IGlzRGF0ZTtcblx0ICAgIGxvZGFzaC5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG5cdCAgICBsb2Rhc2guaXNFbXB0eSA9IGlzRW1wdHk7XG5cdCAgICBsb2Rhc2guaXNFcXVhbCA9IGlzRXF1YWw7XG5cdCAgICBsb2Rhc2guaXNFcnJvciA9IGlzRXJyb3I7XG5cdCAgICBsb2Rhc2guaXNGaW5pdGUgPSBpc0Zpbml0ZTtcblx0ICAgIGxvZGFzaC5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblx0ICAgIGxvZGFzaC5pc01hdGNoID0gaXNNYXRjaDtcblx0ICAgIGxvZGFzaC5pc05hTiA9IGlzTmFOO1xuXHQgICAgbG9kYXNoLmlzTmF0aXZlID0gaXNOYXRpdmU7XG5cdCAgICBsb2Rhc2guaXNOdWxsID0gaXNOdWxsO1xuXHQgICAgbG9kYXNoLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cdCAgICBsb2Rhc2guaXNPYmplY3QgPSBpc09iamVjdDtcblx0ICAgIGxvZGFzaC5pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdDtcblx0ICAgIGxvZGFzaC5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXHQgICAgbG9kYXNoLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cdCAgICBsb2Rhc2guaXNUeXBlZEFycmF5ID0gaXNUeXBlZEFycmF5O1xuXHQgICAgbG9kYXNoLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cdCAgICBsb2Rhc2gua2ViYWJDYXNlID0ga2ViYWJDYXNlO1xuXHQgICAgbG9kYXNoLmxhc3QgPSBsYXN0O1xuXHQgICAgbG9kYXNoLmxhc3RJbmRleE9mID0gbGFzdEluZGV4T2Y7XG5cdCAgICBsb2Rhc2gubHQgPSBsdDtcblx0ICAgIGxvZGFzaC5sdGUgPSBsdGU7XG5cdCAgICBsb2Rhc2gubWF4ID0gbWF4O1xuXHQgICAgbG9kYXNoLm1pbiA9IG1pbjtcblx0ICAgIGxvZGFzaC5ub0NvbmZsaWN0ID0gbm9Db25mbGljdDtcblx0ICAgIGxvZGFzaC5ub29wID0gbm9vcDtcblx0ICAgIGxvZGFzaC5ub3cgPSBub3c7XG5cdCAgICBsb2Rhc2gucGFkID0gcGFkO1xuXHQgICAgbG9kYXNoLnBhZExlZnQgPSBwYWRMZWZ0O1xuXHQgICAgbG9kYXNoLnBhZFJpZ2h0ID0gcGFkUmlnaHQ7XG5cdCAgICBsb2Rhc2gucGFyc2VJbnQgPSBwYXJzZUludDtcblx0ICAgIGxvZGFzaC5yYW5kb20gPSByYW5kb207XG5cdCAgICBsb2Rhc2gucmVkdWNlID0gcmVkdWNlO1xuXHQgICAgbG9kYXNoLnJlZHVjZVJpZ2h0ID0gcmVkdWNlUmlnaHQ7XG5cdCAgICBsb2Rhc2gucmVwZWF0ID0gcmVwZWF0O1xuXHQgICAgbG9kYXNoLnJlc3VsdCA9IHJlc3VsdDtcblx0ICAgIGxvZGFzaC5yb3VuZCA9IHJvdW5kO1xuXHQgICAgbG9kYXNoLnJ1bkluQ29udGV4dCA9IHJ1bkluQ29udGV4dDtcblx0ICAgIGxvZGFzaC5zaXplID0gc2l6ZTtcblx0ICAgIGxvZGFzaC5zbmFrZUNhc2UgPSBzbmFrZUNhc2U7XG5cdCAgICBsb2Rhc2guc29tZSA9IHNvbWU7XG5cdCAgICBsb2Rhc2guc29ydGVkSW5kZXggPSBzb3J0ZWRJbmRleDtcblx0ICAgIGxvZGFzaC5zb3J0ZWRMYXN0SW5kZXggPSBzb3J0ZWRMYXN0SW5kZXg7XG5cdCAgICBsb2Rhc2guc3RhcnRDYXNlID0gc3RhcnRDYXNlO1xuXHQgICAgbG9kYXNoLnN0YXJ0c1dpdGggPSBzdGFydHNXaXRoO1xuXHQgICAgbG9kYXNoLnN1bSA9IHN1bTtcblx0ICAgIGxvZGFzaC50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuXHQgICAgbG9kYXNoLnRyaW0gPSB0cmltO1xuXHQgICAgbG9kYXNoLnRyaW1MZWZ0ID0gdHJpbUxlZnQ7XG5cdCAgICBsb2Rhc2gudHJpbVJpZ2h0ID0gdHJpbVJpZ2h0O1xuXHQgICAgbG9kYXNoLnRydW5jID0gdHJ1bmM7XG5cdCAgICBsb2Rhc2gudW5lc2NhcGUgPSB1bmVzY2FwZTtcblx0ICAgIGxvZGFzaC51bmlxdWVJZCA9IHVuaXF1ZUlkO1xuXHQgICAgbG9kYXNoLndvcmRzID0gd29yZHM7XG5cdFxuXHQgICAgLy8gQWRkIGFsaWFzZXMuXG5cdCAgICBsb2Rhc2guYWxsID0gZXZlcnk7XG5cdCAgICBsb2Rhc2guYW55ID0gc29tZTtcblx0ICAgIGxvZGFzaC5jb250YWlucyA9IGluY2x1ZGVzO1xuXHQgICAgbG9kYXNoLmVxID0gaXNFcXVhbDtcblx0ICAgIGxvZGFzaC5kZXRlY3QgPSBmaW5kO1xuXHQgICAgbG9kYXNoLmZvbGRsID0gcmVkdWNlO1xuXHQgICAgbG9kYXNoLmZvbGRyID0gcmVkdWNlUmlnaHQ7XG5cdCAgICBsb2Rhc2guaGVhZCA9IGZpcnN0O1xuXHQgICAgbG9kYXNoLmluY2x1ZGUgPSBpbmNsdWRlcztcblx0ICAgIGxvZGFzaC5pbmplY3QgPSByZWR1Y2U7XG5cdFxuXHQgICAgbWl4aW4obG9kYXNoLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgIHZhciBzb3VyY2UgPSB7fTtcblx0ICAgICAgYmFzZUZvck93bihsb2Rhc2gsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcblx0ICAgICAgICBpZiAoIWxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0pIHtcblx0ICAgICAgICAgIHNvdXJjZVttZXRob2ROYW1lXSA9IGZ1bmM7XG5cdCAgICAgICAgfVxuXHQgICAgICB9KTtcblx0ICAgICAgcmV0dXJuIHNvdXJjZTtcblx0ICAgIH0oKSksIGZhbHNlKTtcblx0XG5cdCAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cdFxuXHQgICAgLy8gQWRkIGZ1bmN0aW9ucyBjYXBhYmxlIG9mIHJldHVybmluZyB3cmFwcGVkIGFuZCB1bndyYXBwZWQgdmFsdWVzIHdoZW4gY2hhaW5pbmcuXG5cdCAgICBsb2Rhc2guc2FtcGxlID0gc2FtcGxlO1xuXHRcblx0ICAgIGxvZGFzaC5wcm90b3R5cGUuc2FtcGxlID0gZnVuY3Rpb24obikge1xuXHQgICAgICBpZiAoIXRoaXMuX19jaGFpbl9fICYmIG4gPT0gbnVsbCkge1xuXHQgICAgICAgIHJldHVybiBzYW1wbGUodGhpcy52YWx1ZSgpKTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gdGhpcy50aHJ1KGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIHNhbXBsZSh2YWx1ZSwgbik7XG5cdCAgICAgIH0pO1xuXHQgICAgfTtcblx0XG5cdCAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBUaGUgc2VtYW50aWMgdmVyc2lvbiBudW1iZXIuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQG1lbWJlck9mIF9cblx0ICAgICAqIEB0eXBlIHN0cmluZ1xuXHQgICAgICovXG5cdCAgICBsb2Rhc2guVkVSU0lPTiA9IFZFUlNJT047XG5cdFxuXHQgICAgLy8gQXNzaWduIGRlZmF1bHQgcGxhY2Vob2xkZXJzLlxuXHQgICAgYXJyYXlFYWNoKFsnYmluZCcsICdiaW5kS2V5JywgJ2N1cnJ5JywgJ2N1cnJ5UmlnaHQnLCAncGFydGlhbCcsICdwYXJ0aWFsUmlnaHQnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuXHQgICAgICBsb2Rhc2hbbWV0aG9kTmFtZV0ucGxhY2Vob2xkZXIgPSBsb2Rhc2g7XG5cdCAgICB9KTtcblx0XG5cdCAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIGZvciBgXy5kcm9wYCBhbmQgYF8udGFrZWAgdmFyaWFudHMuXG5cdCAgICBhcnJheUVhY2goWydkcm9wJywgJ3Rha2UnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcblx0ICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24obikge1xuXHQgICAgICAgIHZhciBmaWx0ZXJlZCA9IHRoaXMuX19maWx0ZXJlZF9fO1xuXHQgICAgICAgIGlmIChmaWx0ZXJlZCAmJiAhaW5kZXgpIHtcblx0ICAgICAgICAgIHJldHVybiBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIG4gPSBuID09IG51bGwgPyAxIDogbmF0aXZlTWF4KG5hdGl2ZUZsb29yKG4pIHx8IDAsIDApO1xuXHRcblx0ICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuXHQgICAgICAgIGlmIChmaWx0ZXJlZCkge1xuXHQgICAgICAgICAgcmVzdWx0Ll9fdGFrZUNvdW50X18gPSBuYXRpdmVNaW4ocmVzdWx0Ll9fdGFrZUNvdW50X18sIG4pO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICByZXN1bHQuX192aWV3c19fLnB1c2goeyAnc2l6ZSc6IG4sICd0eXBlJzogbWV0aG9kTmFtZSArIChyZXN1bHQuX19kaXJfXyA8IDAgPyAnUmlnaHQnIDogJycpIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICB9O1xuXHRcblx0ICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWUgKyAnUmlnaHQnXSA9IGZ1bmN0aW9uKG4pIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKClbbWV0aG9kTmFtZV0obikucmV2ZXJzZSgpO1xuXHQgICAgICB9O1xuXHQgICAgfSk7XG5cdFxuXHQgICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyB0aGF0IGFjY2VwdCBhbiBgaXRlcmF0ZWVgIHZhbHVlLlxuXHQgICAgYXJyYXlFYWNoKFsnZmlsdGVyJywgJ21hcCcsICd0YWtlV2hpbGUnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcblx0ICAgICAgdmFyIHR5cGUgPSBpbmRleCArIDEsXG5cdCAgICAgICAgICBpc0ZpbHRlciA9IHR5cGUgIT0gTEFaWV9NQVBfRkxBRztcblx0XG5cdCAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKGl0ZXJhdGVlLCB0aGlzQXJnKSB7XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcblx0ICAgICAgICByZXN1bHQuX19pdGVyYXRlZXNfXy5wdXNoKHsgJ2l0ZXJhdGVlJzogZ2V0Q2FsbGJhY2soaXRlcmF0ZWUsIHRoaXNBcmcsIDEpLCAndHlwZSc6IHR5cGUgfSk7XG5cdCAgICAgICAgcmVzdWx0Ll9fZmlsdGVyZWRfXyA9IHJlc3VsdC5fX2ZpbHRlcmVkX18gfHwgaXNGaWx0ZXI7XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgfTtcblx0ICAgIH0pO1xuXHRcblx0ICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLmZpcnN0YCBhbmQgYF8ubGFzdGAuXG5cdCAgICBhcnJheUVhY2goWydmaXJzdCcsICdsYXN0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG5cdCAgICAgIHZhciB0YWtlTmFtZSA9ICd0YWtlJyArIChpbmRleCA/ICdSaWdodCcgOiAnJyk7XG5cdFxuXHQgICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICByZXR1cm4gdGhpc1t0YWtlTmFtZV0oMSkudmFsdWUoKVswXTtcblx0ICAgICAgfTtcblx0ICAgIH0pO1xuXHRcblx0ICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLmluaXRpYWxgIGFuZCBgXy5yZXN0YC5cblx0ICAgIGFycmF5RWFjaChbJ2luaXRpYWwnLCAncmVzdCddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuXHQgICAgICB2YXIgZHJvcE5hbWUgPSAnZHJvcCcgKyAoaW5kZXggPyAnJyA6ICdSaWdodCcpO1xuXHRcblx0ICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX19maWx0ZXJlZF9fID8gbmV3IExhenlXcmFwcGVyKHRoaXMpIDogdGhpc1tkcm9wTmFtZV0oMSk7XG5cdCAgICAgIH07XG5cdCAgICB9KTtcblx0XG5cdCAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIGZvciBgXy5wbHVja2AgYW5kIGBfLndoZXJlYC5cblx0ICAgIGFycmF5RWFjaChbJ3BsdWNrJywgJ3doZXJlJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG5cdCAgICAgIHZhciBvcGVyYXRpb25OYW1lID0gaW5kZXggPyAnZmlsdGVyJyA6ICdtYXAnLFxuXHQgICAgICAgICAgY3JlYXRlQ2FsbGJhY2sgPSBpbmRleCA/IGJhc2VNYXRjaGVzIDogcHJvcGVydHk7XG5cdFxuXHQgICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzW29wZXJhdGlvbk5hbWVdKGNyZWF0ZUNhbGxiYWNrKHZhbHVlKSk7XG5cdCAgICAgIH07XG5cdCAgICB9KTtcblx0XG5cdCAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuY29tcGFjdCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoaWRlbnRpdHkpO1xuXHQgICAgfTtcblx0XG5cdCAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUucmVqZWN0ID0gZnVuY3Rpb24ocHJlZGljYXRlLCB0aGlzQXJnKSB7XG5cdCAgICAgIHByZWRpY2F0ZSA9IGdldENhbGxiYWNrKHByZWRpY2F0ZSwgdGhpc0FyZywgMSk7XG5cdCAgICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiAhcHJlZGljYXRlKHZhbHVlKTtcblx0ICAgICAgfSk7XG5cdCAgICB9O1xuXHRcblx0ICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcblx0ICAgICAgc3RhcnQgPSBzdGFydCA9PSBudWxsID8gMCA6ICgrc3RhcnQgfHwgMCk7XG5cdFxuXHQgICAgICB2YXIgcmVzdWx0ID0gdGhpcztcblx0ICAgICAgaWYgKHJlc3VsdC5fX2ZpbHRlcmVkX18gJiYgKHN0YXJ0ID4gMCB8fCBlbmQgPCAwKSkge1xuXHQgICAgICAgIHJldHVybiBuZXcgTGF6eVdyYXBwZXIocmVzdWx0KTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoc3RhcnQgPCAwKSB7XG5cdCAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnRha2VSaWdodCgtc3RhcnQpO1xuXHQgICAgICB9IGVsc2UgaWYgKHN0YXJ0KSB7XG5cdCAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmRyb3Aoc3RhcnQpO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChlbmQgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIGVuZCA9ICgrZW5kIHx8IDApO1xuXHQgICAgICAgIHJlc3VsdCA9IGVuZCA8IDAgPyByZXN1bHQuZHJvcFJpZ2h0KC1lbmQpIDogcmVzdWx0LnRha2UoZW5kIC0gc3RhcnQpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9O1xuXHRcblx0ICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS50YWtlUmlnaHRXaGlsZSA9IGZ1bmN0aW9uKHByZWRpY2F0ZSwgdGhpc0FyZykge1xuXHQgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKCkudGFrZVdoaWxlKHByZWRpY2F0ZSwgdGhpc0FyZykucmV2ZXJzZSgpO1xuXHQgICAgfTtcblx0XG5cdCAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy50YWtlKFBPU0lUSVZFX0lORklOSVRZKTtcblx0ICAgIH07XG5cdFxuXHQgICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyB0byBgbG9kYXNoLnByb3RvdHlwZWAuXG5cdCAgICBiYXNlRm9yT3duKExhenlXcmFwcGVyLnByb3RvdHlwZSwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuXHQgICAgICB2YXIgY2hlY2tJdGVyYXRlZSA9IC9eKD86ZmlsdGVyfG1hcHxyZWplY3QpfFdoaWxlJC8udGVzdChtZXRob2ROYW1lKSxcblx0ICAgICAgICAgIHJldFVud3JhcHBlZCA9IC9eKD86Zmlyc3R8bGFzdCkkLy50ZXN0KG1ldGhvZE5hbWUpLFxuXHQgICAgICAgICAgbG9kYXNoRnVuYyA9IGxvZGFzaFtyZXRVbndyYXBwZWQgPyAoJ3Rha2UnICsgKG1ldGhvZE5hbWUgPT0gJ2xhc3QnID8gJ1JpZ2h0JyA6ICcnKSkgOiBtZXRob2ROYW1lXTtcblx0XG5cdCAgICAgIGlmICghbG9kYXNoRnVuYykge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHQgICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgdmFyIGFyZ3MgPSByZXRVbndyYXBwZWQgPyBbMV0gOiBhcmd1bWVudHMsXG5cdCAgICAgICAgICAgIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX18sXG5cdCAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fX3dyYXBwZWRfXyxcblx0ICAgICAgICAgICAgaXNIeWJyaWQgPSAhIXRoaXMuX19hY3Rpb25zX18ubGVuZ3RoLFxuXHQgICAgICAgICAgICBpc0xhenkgPSB2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyLFxuXHQgICAgICAgICAgICBpdGVyYXRlZSA9IGFyZ3NbMF0sXG5cdCAgICAgICAgICAgIHVzZUxhenkgPSBpc0xhenkgfHwgaXNBcnJheSh2YWx1ZSk7XG5cdFxuXHQgICAgICAgIGlmICh1c2VMYXp5ICYmIGNoZWNrSXRlcmF0ZWUgJiYgdHlwZW9mIGl0ZXJhdGVlID09ICdmdW5jdGlvbicgJiYgaXRlcmF0ZWUubGVuZ3RoICE9IDEpIHtcblx0ICAgICAgICAgIC8vIEF2b2lkIGxhenkgdXNlIGlmIHRoZSBpdGVyYXRlZSBoYXMgYSBcImxlbmd0aFwiIHZhbHVlIG90aGVyIHRoYW4gYDFgLlxuXHQgICAgICAgICAgaXNMYXp5ID0gdXNlTGF6eSA9IGZhbHNlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgaW50ZXJjZXB0b3IgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICAgICAgcmV0dXJuIChyZXRVbndyYXBwZWQgJiYgY2hhaW5BbGwpXG5cdCAgICAgICAgICAgID8gbG9kYXNoRnVuYyh2YWx1ZSwgMSlbMF1cblx0ICAgICAgICAgICAgOiBsb2Rhc2hGdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJyYXlQdXNoKFt2YWx1ZV0sIGFyZ3MpKTtcblx0ICAgICAgICB9O1xuXHRcblx0ICAgICAgICB2YXIgYWN0aW9uID0geyAnZnVuYyc6IHRocnUsICdhcmdzJzogW2ludGVyY2VwdG9yXSwgJ3RoaXNBcmcnOiB1bmRlZmluZWQgfSxcblx0ICAgICAgICAgICAgb25seUxhenkgPSBpc0xhenkgJiYgIWlzSHlicmlkO1xuXHRcblx0ICAgICAgICBpZiAocmV0VW53cmFwcGVkICYmICFjaGFpbkFsbCkge1xuXHQgICAgICAgICAgaWYgKG9ubHlMYXp5KSB7XG5cdCAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuY2xvbmUoKTtcblx0ICAgICAgICAgICAgdmFsdWUuX19hY3Rpb25zX18ucHVzaChhY3Rpb24pO1xuXHQgICAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHZhbHVlKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIHJldHVybiBsb2Rhc2hGdW5jLmNhbGwodW5kZWZpbmVkLCB0aGlzLnZhbHVlKCkpWzBdO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoIXJldFVud3JhcHBlZCAmJiB1c2VMYXp5KSB7XG5cdCAgICAgICAgICB2YWx1ZSA9IG9ubHlMYXp5ID8gdmFsdWUgOiBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG5cdCAgICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh2YWx1ZSwgYXJncyk7XG5cdCAgICAgICAgICByZXN1bHQuX19hY3Rpb25zX18ucHVzaChhY3Rpb24pO1xuXHQgICAgICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHJlc3VsdCwgY2hhaW5BbGwpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcy50aHJ1KGludGVyY2VwdG9yKTtcblx0ICAgICAgfTtcblx0ICAgIH0pO1xuXHRcblx0ICAgIC8vIEFkZCBgQXJyYXlgIGFuZCBgU3RyaW5nYCBtZXRob2RzIHRvIGBsb2Rhc2gucHJvdG90eXBlYC5cblx0ICAgIGFycmF5RWFjaChbJ2pvaW4nLCAncG9wJywgJ3B1c2gnLCAncmVwbGFjZScsICdzaGlmdCcsICdzb3J0JywgJ3NwbGljZScsICdzcGxpdCcsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcblx0ICAgICAgdmFyIGZ1bmMgPSAoL14oPzpyZXBsYWNlfHNwbGl0KSQvLnRlc3QobWV0aG9kTmFtZSkgPyBzdHJpbmdQcm90byA6IGFycmF5UHJvdG8pW21ldGhvZE5hbWVdLFxuXHQgICAgICAgICAgY2hhaW5OYW1lID0gL14oPzpwdXNofHNvcnR8dW5zaGlmdCkkLy50ZXN0KG1ldGhvZE5hbWUpID8gJ3RhcCcgOiAndGhydScsXG5cdCAgICAgICAgICByZXRVbndyYXBwZWQgPSAvXig/OmpvaW58cG9wfHJlcGxhY2V8c2hpZnQpJC8udGVzdChtZXRob2ROYW1lKTtcblx0XG5cdCAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcblx0ICAgICAgICBpZiAocmV0VW53cmFwcGVkICYmICF0aGlzLl9fY2hhaW5fXykge1xuXHQgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcy52YWx1ZSgpLCBhcmdzKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXNbY2hhaW5OYW1lXShmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodmFsdWUsIGFyZ3MpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICB9O1xuXHQgICAgfSk7XG5cdFxuXHQgICAgLy8gTWFwIG1pbmlmaWVkIGZ1bmN0aW9uIG5hbWVzIHRvIHRoZWlyIHJlYWwgbmFtZXMuXG5cdCAgICBiYXNlRm9yT3duKExhenlXcmFwcGVyLnByb3RvdHlwZSwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuXHQgICAgICB2YXIgbG9kYXNoRnVuYyA9IGxvZGFzaFttZXRob2ROYW1lXTtcblx0ICAgICAgaWYgKGxvZGFzaEZ1bmMpIHtcblx0ICAgICAgICB2YXIga2V5ID0gbG9kYXNoRnVuYy5uYW1lLFxuXHQgICAgICAgICAgICBuYW1lcyA9IHJlYWxOYW1lc1trZXldIHx8IChyZWFsTmFtZXNba2V5XSA9IFtdKTtcblx0XG5cdCAgICAgICAgbmFtZXMucHVzaCh7ICduYW1lJzogbWV0aG9kTmFtZSwgJ2Z1bmMnOiBsb2Rhc2hGdW5jIH0pO1xuXHQgICAgICB9XG5cdCAgICB9KTtcblx0XG5cdCAgICByZWFsTmFtZXNbY3JlYXRlSHlicmlkV3JhcHBlcih1bmRlZmluZWQsIEJJTkRfS0VZX0ZMQUcpLm5hbWVdID0gW3sgJ25hbWUnOiAnd3JhcHBlcicsICdmdW5jJzogdW5kZWZpbmVkIH1dO1xuXHRcblx0ICAgIC8vIEFkZCBmdW5jdGlvbnMgdG8gdGhlIGxhenkgd3JhcHBlci5cblx0ICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jbG9uZSA9IGxhenlDbG9uZTtcblx0ICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5yZXZlcnNlID0gbGF6eVJldmVyc2U7XG5cdCAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUudmFsdWUgPSBsYXp5VmFsdWU7XG5cdFxuXHQgICAgLy8gQWRkIGNoYWluaW5nIGZ1bmN0aW9ucyB0byB0aGUgYGxvZGFzaGAgd3JhcHBlci5cblx0ICAgIGxvZGFzaC5wcm90b3R5cGUuY2hhaW4gPSB3cmFwcGVyQ2hhaW47XG5cdCAgICBsb2Rhc2gucHJvdG90eXBlLmNvbW1pdCA9IHdyYXBwZXJDb21taXQ7XG5cdCAgICBsb2Rhc2gucHJvdG90eXBlLmNvbmNhdCA9IHdyYXBwZXJDb25jYXQ7XG5cdCAgICBsb2Rhc2gucHJvdG90eXBlLnBsYW50ID0gd3JhcHBlclBsYW50O1xuXHQgICAgbG9kYXNoLnByb3RvdHlwZS5yZXZlcnNlID0gd3JhcHBlclJldmVyc2U7XG5cdCAgICBsb2Rhc2gucHJvdG90eXBlLnRvU3RyaW5nID0gd3JhcHBlclRvU3RyaW5nO1xuXHQgICAgbG9kYXNoLnByb3RvdHlwZS5ydW4gPSBsb2Rhc2gucHJvdG90eXBlLnRvSlNPTiA9IGxvZGFzaC5wcm90b3R5cGUudmFsdWVPZiA9IGxvZGFzaC5wcm90b3R5cGUudmFsdWUgPSB3cmFwcGVyVmFsdWU7XG5cdFxuXHQgICAgLy8gQWRkIGZ1bmN0aW9uIGFsaWFzZXMgdG8gdGhlIGBsb2Rhc2hgIHdyYXBwZXIuXG5cdCAgICBsb2Rhc2gucHJvdG90eXBlLmNvbGxlY3QgPSBsb2Rhc2gucHJvdG90eXBlLm1hcDtcblx0ICAgIGxvZGFzaC5wcm90b3R5cGUuaGVhZCA9IGxvZGFzaC5wcm90b3R5cGUuZmlyc3Q7XG5cdCAgICBsb2Rhc2gucHJvdG90eXBlLnNlbGVjdCA9IGxvZGFzaC5wcm90b3R5cGUuZmlsdGVyO1xuXHQgICAgbG9kYXNoLnByb3RvdHlwZS50YWlsID0gbG9kYXNoLnByb3RvdHlwZS5yZXN0O1xuXHRcblx0ICAgIHJldHVybiBsb2Rhc2g7XG5cdCAgfVxuXHRcblx0ICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblx0XG5cdCAgLy8gRXhwb3J0IGxvZGFzaC5cblx0ICB2YXIgXyA9IHJ1bkluQ29udGV4dCgpO1xuXHRcblx0ICAvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzIGxpa2Ugci5qcyBjaGVjayBmb3IgY29uZGl0aW9uIHBhdHRlcm5zIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0ICBpZiAodHJ1ZSkge1xuXHQgICAgLy8gRXhwb3NlIGxvZGFzaCB0byB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGFuIEFNRCBsb2FkZXIgaXMgcHJlc2VudCB0byBhdm9pZFxuXHQgICAgLy8gZXJyb3JzIGluIGNhc2VzIHdoZXJlIGxvZGFzaCBpcyBsb2FkZWQgYnkgYSBzY3JpcHQgdGFnIGFuZCBub3QgaW50ZW5kZWRcblx0ICAgIC8vIGFzIGFuIEFNRCBtb2R1bGUuIFNlZSBodHRwOi8vcmVxdWlyZWpzLm9yZy9kb2NzL2Vycm9ycy5odG1sI21pc21hdGNoIGZvclxuXHQgICAgLy8gbW9yZSBkZXRhaWxzLlxuXHQgICAgcm9vdC5fID0gXztcblx0XG5cdCAgICAvLyBEZWZpbmUgYXMgYW4gYW5vbnltb3VzIG1vZHVsZSBzbywgdGhyb3VnaCBwYXRoIG1hcHBpbmcsIGl0IGNhbiBiZVxuXHQgICAgLy8gcmVmZXJlbmNlZCBhcyB0aGUgXCJ1bmRlcnNjb3JlXCIgbW9kdWxlLlxuXHQgICAgIShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gXztcblx0ICAgIH0uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cdCAgfVxuXHQgIC8vIENoZWNrIGZvciBgZXhwb3J0c2AgYWZ0ZXIgYGRlZmluZWAgaW4gY2FzZSBhIGJ1aWxkIG9wdGltaXplciBhZGRzIGFuIGBleHBvcnRzYCBvYmplY3QuXG5cdCAgZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuXHQgICAgLy8gRXhwb3J0IGZvciBOb2RlLmpzIG9yIFJpbmdvSlMuXG5cdCAgICBpZiAobW9kdWxlRXhwb3J0cykge1xuXHQgICAgICAoZnJlZU1vZHVsZS5leHBvcnRzID0gXykuXyA9IF87XG5cdCAgICB9XG5cdCAgICAvLyBFeHBvcnQgZm9yIFJoaW5vIHdpdGggQ29tbW9uSlMgc3VwcG9ydC5cblx0ICAgIGVsc2Uge1xuXHQgICAgICBmcmVlRXhwb3J0cy5fID0gXztcblx0ICAgIH1cblx0ICB9XG5cdCAgZWxzZSB7XG5cdCAgICAvLyBFeHBvcnQgZm9yIGEgYnJvd3NlciBvciBSaGluby5cblx0ICAgIHJvb3QuXyA9IF87XG5cdCAgfVxuXHR9LmNhbGwodGhpcykpO1xuXHRcblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oMykobW9kdWxlKSwgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0sXG4vKiAzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdFx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdFx0bW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG1vZHVsZTtcclxuXHR9XHJcblxuXG4vKioqLyB9LFxuLyogNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIE1hdHJpeCwgU2NyZWVuLCBVdGlscywgXywgX19kb21Db21wbGV0ZSwgX19kb21Db21wbGV0ZVN0YXRlLCBfX2RvbVJlYWR5LCBfdGV4dFNpemVOb2RlLFxuXHQgIGluZGV4T2YgPSBbXS5pbmRleE9mIHx8IGZ1bmN0aW9uKGl0ZW0pIHsgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykgeyBpZiAoaSBpbiB0aGlzICYmIHRoaXNbaV0gPT09IGl0ZW0pIHJldHVybiBpOyB9IHJldHVybiAtMTsgfSxcblx0ICBzbGljZSA9IFtdLnNsaWNlO1xuXHRcblx0XyA9IF9fd2VicGFja19yZXF1aXJlX18oMSkuXztcblx0XG5cdFNjcmVlbiA9IF9fd2VicGFja19yZXF1aXJlX18oNSkuU2NyZWVuO1xuXHRcblx0TWF0cml4ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KS5NYXRyaXg7XG5cdFxuXHRVdGlscyA9IHt9O1xuXHRcblx0VXRpbHMucmVzZXQgPSBmdW5jdGlvbigpIHtcblx0ICByZXR1cm4gRnJhbWVyLkN1cnJlbnRDb250ZXh0LnJlc2V0KCk7XG5cdH07XG5cdFxuXHRVdGlscy5nZXRWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgaWYgKF8uaXNGdW5jdGlvbih2YWx1ZSkpIHtcblx0ICAgIHJldHVybiB2YWx1ZSgpO1xuXHQgIH1cblx0ICByZXR1cm4gdmFsdWU7XG5cdH07XG5cdFxuXHRVdGlscy5nZXRWYWx1ZUZvcktleVBhdGggPSBmdW5jdGlvbihvYmosIGtleSkge1xuXHQgIHZhciBsZW4sIG8sIHJlZiwgcmVmMSwgcmVzdWx0O1xuXHQgIHJlc3VsdCA9IG9iajtcblx0ICBpZiAocmVmID0gIVwiLlwiLCBpbmRleE9mLmNhbGwoa2V5LCByZWYpID49IDApIHtcblx0ICAgIHJldHVybiBvYmpba2V5XTtcblx0ICB9XG5cdCAgcmVmMSA9IGtleS5zcGxpdChcIi5cIik7XG5cdCAgZm9yIChvID0gMCwgbGVuID0gcmVmMS5sZW5ndGg7IG8gPCBsZW47IG8rKykge1xuXHQgICAga2V5ID0gcmVmMVtvXTtcblx0ICAgIHJlc3VsdCA9IHJlc3VsdFtrZXldO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXHRcblx0VXRpbHMuc2V0VmFsdWVGb3JLZXlQYXRoID0gZnVuY3Rpb24ob2JqLCBwYXRoLCB2YWwpIHtcblx0ICB2YXIgZmllbGQsIGZpZWxkcywgaSwgbiwgcmVzdWx0O1xuXHQgIGZpZWxkcyA9IHBhdGguc3BsaXQoJy4nKTtcblx0ICByZXN1bHQgPSBvYmo7XG5cdCAgaSA9IDA7XG5cdCAgbiA9IGZpZWxkcy5sZW5ndGg7XG5cdCAgd2hpbGUgKGkgPCBuICYmIHJlc3VsdCAhPT0gdm9pZCAwKSB7XG5cdCAgICBmaWVsZCA9IGZpZWxkc1tpXTtcblx0ICAgIGlmIChpID09PSBuIC0gMSkge1xuXHQgICAgICByZXN1bHRbZmllbGRdID0gdmFsO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgaWYgKHR5cGVvZiByZXN1bHRbZmllbGRdID09PSAndW5kZWZpbmVkJyB8fCAhXy5pc09iamVjdChyZXN1bHRbZmllbGRdKSkge1xuXHQgICAgICAgIHJlc3VsdFtmaWVsZF0gPSB7fTtcblx0ICAgICAgfVxuXHQgICAgICByZXN1bHQgPSByZXN1bHRbZmllbGRdO1xuXHQgICAgfVxuXHQgICAgaSsrO1xuXHQgIH1cblx0fTtcblx0XG5cdFV0aWxzLnZhbHVlT3JEZWZhdWx0ID0gZnVuY3Rpb24odmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuXHQgIGlmICh2YWx1ZSA9PT0gKHZvaWQgMCkgfHwgdmFsdWUgPT09IG51bGwpIHtcblx0ICAgIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gdmFsdWU7XG5cdH07XG5cdFxuXHRVdGlscy5hcnJheU5leHQgPSBmdW5jdGlvbihhcnIsIGl0ZW0pIHtcblx0ICByZXR1cm4gYXJyW2Fyci5pbmRleE9mKGl0ZW0pICsgMV0gfHwgXy5maXJzdChhcnIpO1xuXHR9O1xuXHRcblx0VXRpbHMuYXJyYXlQcmV2ID0gZnVuY3Rpb24oYXJyLCBpdGVtKSB7XG5cdCAgcmV0dXJuIGFyclthcnIuaW5kZXhPZihpdGVtKSAtIDFdIHx8IF8ubGFzdChhcnIpO1xuXHR9O1xuXHRcblx0VXRpbHMuc3VtID0gZnVuY3Rpb24oYXJyKSB7XG5cdCAgcmV0dXJuIF8ucmVkdWNlKGFyciwgZnVuY3Rpb24oYSwgYikge1xuXHQgICAgcmV0dXJuIGEgKyBiO1xuXHQgIH0pO1xuXHR9O1xuXHRcblx0VXRpbHMuYXZlcmFnZSA9IGZ1bmN0aW9uKGFycikge1xuXHQgIHJldHVybiBVdGlscy5zdW0oYXJyKSAvIGFyci5sZW5ndGg7XG5cdH07XG5cdFxuXHRVdGlscy5tZWFuID0gVXRpbHMuYXZlcmFnZTtcblx0XG5cdFV0aWxzLm1lZGlhbiA9IGZ1bmN0aW9uKHgpIHtcblx0ICB2YXIgc29ydGVkO1xuXHQgIGlmICh4Lmxlbmd0aCA9PT0gMCkge1xuXHQgICAgcmV0dXJuIG51bGw7XG5cdCAgfVxuXHQgIHNvcnRlZCA9IHguc2xpY2UoKS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0ICAgIHJldHVybiBhIC0gYjtcblx0ICB9KTtcblx0ICBpZiAoc29ydGVkLmxlbmd0aCAlIDIgPT09IDEpIHtcblx0ICAgIHJldHVybiBzb3J0ZWRbKHNvcnRlZC5sZW5ndGggLSAxKSAvIDJdO1xuXHQgIH0gZWxzZSB7XG5cdCAgICByZXR1cm4gKHNvcnRlZFsoc29ydGVkLmxlbmd0aCAvIDIpIC0gMV0gKyBzb3J0ZWRbc29ydGVkLmxlbmd0aCAvIDJdKSAvIDI7XG5cdCAgfVxuXHR9O1xuXHRcblx0VXRpbHMubmVhcmVzdEluY3JlbWVudCA9IGZ1bmN0aW9uKHgsIGluY3JlbWVudCkge1xuXHQgIGlmICghaW5jcmVtZW50KSB7XG5cdCAgICByZXR1cm4geDtcblx0ICB9XG5cdCAgcmV0dXJuIE1hdGgucm91bmQoeCAqICgxIC8gaW5jcmVtZW50KSkgLyAoMSAvIGluY3JlbWVudCk7XG5cdH07XG5cdFxuXHRpZiAod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9PSBudWxsKSB7XG5cdCAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cdH1cblx0XG5cdGlmICh3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID09IG51bGwpIHtcblx0ICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oZikge1xuXHQgICAgcmV0dXJuIFV0aWxzLmRlbGF5KDEgLyA2MCwgZik7XG5cdCAgfTtcblx0fVxuXHRcblx0aWYgKHdpbmRvdy5wZXJmb3JtYW5jZSkge1xuXHQgIFV0aWxzLmdldFRpbWUgPSBmdW5jdGlvbigpIHtcblx0ICAgIHJldHVybiB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgLyAxMDAwO1xuXHQgIH07XG5cdH0gZWxzZSB7XG5cdCAgVXRpbHMuZ2V0VGltZSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgcmV0dXJuIERhdGUubm93KCkgLyAxMDAwO1xuXHQgIH07XG5cdH1cblx0XG5cdFV0aWxzLmRlbGF5ID0gZnVuY3Rpb24odGltZSwgZikge1xuXHQgIHZhciB0aW1lcjtcblx0ICB0aW1lciA9IHNldFRpbWVvdXQoZiwgdGltZSAqIDEwMDApO1xuXHQgIEZyYW1lci5DdXJyZW50Q29udGV4dC5hZGRUaW1lcih0aW1lcik7XG5cdCAgcmV0dXJuIHRpbWVyO1xuXHR9O1xuXHRcblx0VXRpbHMuaW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lLCBmKSB7XG5cdCAgdmFyIHRpbWVyO1xuXHQgIHRpbWVyID0gc2V0SW50ZXJ2YWwoZiwgdGltZSAqIDEwMDApO1xuXHQgIEZyYW1lci5DdXJyZW50Q29udGV4dC5hZGRJbnRlcnZhbCh0aW1lcik7XG5cdCAgcmV0dXJuIHRpbWVyO1xuXHR9O1xuXHRcblx0VXRpbHMuZGVib3VuY2UgPSBmdW5jdGlvbih0aHJlc2hvbGQsIGZuLCBpbW1lZGlhdGUpIHtcblx0ICB2YXIgdGltZW91dDtcblx0ICBpZiAodGhyZXNob2xkID09IG51bGwpIHtcblx0ICAgIHRocmVzaG9sZCA9IDAuMTtcblx0ICB9XG5cdCAgdGltZW91dCA9IG51bGw7XG5cdCAgdGhyZXNob2xkICo9IDEwMDA7XG5cdCAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIGFyZ3MsIGRlbGF5ZWQsIG9iajtcblx0ICAgIGFyZ3MgPSAxIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBzbGljZS5jYWxsKGFyZ3VtZW50cywgMCkgOiBbXTtcblx0ICAgIG9iaiA9IHRoaXM7XG5cdCAgICBkZWxheWVkID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgIGlmICghaW1tZWRpYXRlKSB7XG5cdCAgICAgICAgZm4uYXBwbHkob2JqLCBhcmdzKTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gdGltZW91dCA9IG51bGw7XG5cdCAgICB9O1xuXHQgICAgaWYgKHRpbWVvdXQpIHtcblx0ICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXHQgICAgfSBlbHNlIGlmIChpbW1lZGlhdGUpIHtcblx0ICAgICAgZm4uYXBwbHkob2JqLCBhcmdzKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0aW1lb3V0ID0gc2V0VGltZW91dChkZWxheWVkLCB0aHJlc2hvbGQpO1xuXHQgIH07XG5cdH07XG5cdFxuXHRVdGlscy50aHJvdHRsZSA9IGZ1bmN0aW9uKGRlbGF5LCBmbikge1xuXHQgIHZhciB0aW1lcjtcblx0ICBpZiAoZGVsYXkgPT09IDApIHtcblx0ICAgIHJldHVybiBmbjtcblx0ICB9XG5cdCAgZGVsYXkgKj0gMTAwMDtcblx0ICB0aW1lciA9IGZhbHNlO1xuXHQgIHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIGlmICh0aW1lcikge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICB0aW1lciA9IHRydWU7XG5cdCAgICBpZiAoZGVsYXkgIT09IC0xKSB7XG5cdCAgICAgIHNldFRpbWVvdXQoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIHJldHVybiB0aW1lciA9IGZhbHNlO1xuXHQgICAgICB9KSwgZGVsYXkpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cdCAgfTtcblx0fTtcblx0XG5cdFV0aWxzLm1lbW9pemUgPSBmdW5jdGlvbihmbikge1xuXHQgIHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIHZhciBhcmdzLCBjdXJyZW50QXJnLCBoYXNoLCBpO1xuXHQgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdCAgICBoYXNoID0gXCJcIjtcblx0ICAgIGkgPSBhcmdzLmxlbmd0aDtcblx0ICAgIGN1cnJlbnRBcmcgPSBudWxsO1xuXHQgICAgd2hpbGUgKGktLSkge1xuXHQgICAgICBjdXJyZW50QXJnID0gYXJnc1tpXTtcblx0ICAgICAgaGFzaCArPSAoY3VycmVudEFyZyA9PT0gT2JqZWN0KGN1cnJlbnRBcmcpID8gSlNPTi5zdHJpbmdpZnkoY3VycmVudEFyZykgOiBjdXJyZW50QXJnKTtcblx0ICAgICAgZm4ubWVtb2l6ZSB8fCAoZm4ubWVtb2l6ZSA9IHt9KTtcblx0ICAgIH1cblx0ICAgIGlmIChoYXNoIGluIGZuLm1lbW9pemUpIHtcblx0ICAgICAgcmV0dXJuIGZuLm1lbW9pemVbaGFzaF07XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gZm4ubWVtb2l6ZVtoYXNoXSA9IGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHQgICAgfVxuXHQgIH07XG5cdH07XG5cdFxuXHRVdGlscy5yYW5kb21Db2xvciA9IGZ1bmN0aW9uKGFscGhhKSB7XG5cdCAgaWYgKGFscGhhID09IG51bGwpIHtcblx0ICAgIGFscGhhID0gMS4wO1xuXHQgIH1cblx0ICByZXR1cm4gQ29sb3IucmFuZG9tKGFscGhhKTtcblx0fTtcblx0XG5cdFV0aWxzLnJhbmRvbUNob2ljZSA9IGZ1bmN0aW9uKGFycikge1xuXHQgIHJldHVybiBhcnJbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYXJyLmxlbmd0aCldO1xuXHR9O1xuXHRcblx0VXRpbHMucmFuZG9tTnVtYmVyID0gZnVuY3Rpb24oYSwgYikge1xuXHQgIGlmIChhID09IG51bGwpIHtcblx0ICAgIGEgPSAwO1xuXHQgIH1cblx0ICBpZiAoYiA9PSBudWxsKSB7XG5cdCAgICBiID0gMTtcblx0ICB9XG5cdCAgcmV0dXJuIFV0aWxzLm1hcFJhbmdlKE1hdGgucmFuZG9tKCksIDAsIDEsIGEsIGIpO1xuXHR9O1xuXHRcblx0VXRpbHMuZGVmaW5lRW51bSA9IGZ1bmN0aW9uKG5hbWVzLCBvZmZzZXQsIGdlb21ldHJpYykge1xuXHQgIHZhciBFbnVtLCBpLCBqLCBsZW4sIG5hbWUsIG87XG5cdCAgaWYgKG5hbWVzID09IG51bGwpIHtcblx0ICAgIG5hbWVzID0gW107XG5cdCAgfVxuXHQgIGlmIChvZmZzZXQgPT0gbnVsbCkge1xuXHQgICAgb2Zmc2V0ID0gMDtcblx0ICB9XG5cdCAgaWYgKGdlb21ldHJpYyA9PSBudWxsKSB7XG5cdCAgICBnZW9tZXRyaWMgPSAwO1xuXHQgIH1cblx0ICBFbnVtID0ge307XG5cdCAgZm9yIChpID0gbyA9IDAsIGxlbiA9IG5hbWVzLmxlbmd0aDsgbyA8IGxlbjsgaSA9ICsrbykge1xuXHQgICAgbmFtZSA9IG5hbWVzW2ldO1xuXHQgICAgaiA9IGk7XG5cdCAgICBqID0gIW9mZnNldCA/IGogOiBqICsgb2Zmc2V0O1xuXHQgICAgaiA9ICFnZW9tZXRyaWMgPyBqIDogTWF0aC5wb3coZ2VvbWV0cmljLCBqKTtcblx0ICAgIEVudW1bRW51bVtuYW1lXSA9IGpdID0gbmFtZTtcblx0ICB9XG5cdCAgcmV0dXJuIEVudW07XG5cdH07XG5cdFxuXHRVdGlscy5sYWJlbExheWVyID0gZnVuY3Rpb24obGF5ZXIsIHRleHQsIHN0eWxlKSB7XG5cdCAgaWYgKHN0eWxlID09IG51bGwpIHtcblx0ICAgIHN0eWxlID0ge307XG5cdCAgfVxuXHQgIHN0eWxlID0gXy5leHRlbmQoe1xuXHQgICAgZm9udDogXCIxMHB4LzFlbSBNZW5sb1wiLFxuXHQgICAgbGluZUhlaWdodDogbGF5ZXIuaGVpZ2h0ICsgXCJweFwiLFxuXHQgICAgdGV4dEFsaWduOiBcImNlbnRlclwiLFxuXHQgICAgY29sb3I6IFwiI2ZmZlwiXG5cdCAgfSwgc3R5bGUpO1xuXHQgIGxheWVyLnN0eWxlID0gc3R5bGU7XG5cdCAgcmV0dXJuIGxheWVyLmh0bWwgPSB0ZXh0O1xuXHR9O1xuXHRcblx0VXRpbHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24ob2JqKSB7XG5cdCAgdmFyIGVycm9yO1xuXHQgIHRyeSB7XG5cdCAgICBpZiAoXy5pc09iamVjdChvYmopKSB7XG5cdCAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmopO1xuXHQgICAgfVxuXHQgIH0gY2F0Y2ggKGVycm9yKSB7XG5cdCAgICBcIlwiO1xuXHQgIH1cblx0ICBpZiAob2JqID09PSBudWxsKSB7XG5cdCAgICByZXR1cm4gXCJudWxsXCI7XG5cdCAgfVxuXHQgIGlmIChvYmogPT09IHZvaWQgMCkge1xuXHQgICAgcmV0dXJuIFwidW5kZWZpbmVkXCI7XG5cdCAgfVxuXHQgIGlmIChvYmoudG9TdHJpbmcpIHtcblx0ICAgIHJldHVybiBvYmoudG9TdHJpbmcoKTtcblx0ICB9XG5cdCAgcmV0dXJuIG9iajtcblx0fTtcblx0XG5cdFV0aWxzLmluc3BlY3RPYmplY3RUeXBlID0gZnVuY3Rpb24oaXRlbSkge1xuXHQgIHZhciBjbGFzc05hbWUsIGV4dHJhY3QsIHJlZiwgcmVmMSwgcmVmMiwgcmVmMztcblx0ICBpZiAoKCgocmVmID0gaXRlbS5jb25zdHJ1Y3RvcikgIT0gbnVsbCA/IHJlZi5uYW1lIDogdm9pZCAwKSAhPSBudWxsKSAmJiAoKHJlZjEgPSBpdGVtLmNvbnN0cnVjdG9yKSAhPSBudWxsID8gcmVmMS5uYW1lIDogdm9pZCAwKSAhPT0gXCJPYmplY3RcIikge1xuXHQgICAgcmV0dXJuIGl0ZW0uY29uc3RydWN0b3IubmFtZTtcblx0ICB9XG5cdCAgZXh0cmFjdCA9IGZ1bmN0aW9uKHN0cikge1xuXHQgICAgdmFyIG1hdGNoLCByZWdleDtcblx0ICAgIGlmICghc3RyKSB7XG5cdCAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfVxuXHQgICAgcmVnZXggPSAvXFxbb2JqZWN0IChcXHcrKVxcXS87XG5cdCAgICBtYXRjaCA9IHJlZ2V4LmV4ZWMoc3RyKTtcblx0ICAgIGlmIChtYXRjaCkge1xuXHQgICAgICByZXR1cm4gbWF0Y2hbMV07XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbnVsbDtcblx0ICB9O1xuXHQgIGlmIChpdGVtLnRvU3RyaW5nKSB7XG5cdCAgICBjbGFzc05hbWUgPSBleHRyYWN0KGl0ZW0udG9TdHJpbmcoKSk7XG5cdCAgICBpZiAoY2xhc3NOYW1lKSB7XG5cdCAgICAgIHJldHVybiBjbGFzc05hbWU7XG5cdCAgICB9XG5cdCAgfVxuXHQgIGlmICgocmVmMiA9IGl0ZW0uY29uc3RydWN0b3IpICE9IG51bGwgPyByZWYyLnRvU3RyaW5nIDogdm9pZCAwKSB7XG5cdCAgICBjbGFzc05hbWUgPSBleHRyYWN0KChyZWYzID0gaXRlbS5jb25zdHJ1Y3RvcikgIT0gbnVsbCA/IHJlZjMudG9TdHJpbmcoKSA6IHZvaWQgMCk7XG5cdCAgICBpZiAoY2xhc3NOYW1lKSB7XG5cdCAgICAgIHJldHVybiBjbGFzc05hbWUucmVwbGFjZShcIkNvbnN0cnVjdG9yXCIsIFwiXCIpO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gXCJPYmplY3RcIjtcblx0fTtcblx0XG5cdFV0aWxzLmluc3BlY3QgPSBmdW5jdGlvbihpdGVtLCBtYXgsIGwpIHtcblx0ICB2YXIgY29kZSwgbGltaXQsIG9iamVjdEluZm8sIG9iamVjdFR5cGU7XG5cdCAgaWYgKG1heCA9PSBudWxsKSB7XG5cdCAgICBtYXggPSA1O1xuXHQgIH1cblx0ICBpZiAobCA9PSBudWxsKSB7XG5cdCAgICBsID0gMDtcblx0ICB9XG5cdCAgaWYgKGl0ZW0gPT09IG51bGwpIHtcblx0ICAgIHJldHVybiBcIm51bGxcIjtcblx0ICB9XG5cdCAgaWYgKGl0ZW0gPT09IHZvaWQgMCkge1xuXHQgICAgcmV0dXJuIFwidW5kZWZpbmVkXCI7XG5cdCAgfVxuXHQgIGlmIChfLmlzRnVuY3Rpb24oaXRlbS50b0luc3BlY3QpKSB7XG5cdCAgICByZXR1cm4gaXRlbS50b0luc3BlY3QoKTtcblx0ICB9XG5cdCAgaWYgKF8uaXNTdHJpbmcoaXRlbSkpIHtcblx0ICAgIHJldHVybiBcIlxcXCJcIiArIGl0ZW0gKyBcIlxcXCJcIjtcblx0ICB9XG5cdCAgaWYgKF8uaXNOdW1iZXIoaXRlbSkpIHtcblx0ICAgIHJldHVybiBcIlwiICsgaXRlbTtcblx0ICB9XG5cdCAgaWYgKF8uaXNGdW5jdGlvbihpdGVtKSkge1xuXHQgICAgY29kZSA9IGl0ZW0udG9TdHJpbmcoKS5zbGljZShcImZ1bmN0aW9uIFwiLmxlbmd0aCkucmVwbGFjZSgvXFxuL2csIFwiXCIpLnJlcGxhY2UoL1xccysvZywgXCIgXCIpO1xuXHQgICAgbGltaXQgPSA1MDtcblx0ICAgIGlmIChjb2RlLmxlbmd0aCA+IGxpbWl0ICYmIGwgPiAwKSB7XG5cdCAgICAgIGNvZGUgPSAoXy50cmltUmlnaHQoY29kZS5zbGljZSgwLCArbGltaXQgKyAxIHx8IDllOSkpKSArIFwi4oCmIH1cIjtcblx0ICAgIH1cblx0ICAgIHJldHVybiBcIjxGdW5jdGlvbiBcIiArIGNvZGUgKyBcIj5cIjtcblx0ICB9XG5cdCAgaWYgKF8uaXNBcnJheShpdGVtKSkge1xuXHQgICAgaWYgKGwgPiBtYXgpIHtcblx0ICAgICAgcmV0dXJuIFwiWy4uLl1cIjtcblx0ICAgIH1cblx0ICAgIHJldHVybiBcIltcIiArIF8ubWFwKGl0ZW0sIGZ1bmN0aW9uKGkpIHtcblx0ICAgICAgcmV0dXJuIFV0aWxzLmluc3BlY3QoaSwgbWF4LCBsICsgMSk7XG5cdCAgICB9KS5qb2luKFwiLCBcIikgKyBcIl1cIjtcblx0ICB9XG5cdCAgaWYgKF8uaXNPYmplY3QoaXRlbSkpIHtcblx0ICAgIG9iamVjdFR5cGUgPSBVdGlscy5pbnNwZWN0T2JqZWN0VHlwZShpdGVtKTtcblx0ICAgIGlmICgvSFRNTFxcdys/RWxlbWVudC8udGVzdChvYmplY3RUeXBlKSkge1xuXHQgICAgICByZXR1cm4gXCI8XCIgKyBvYmplY3RUeXBlICsgXCI+XCI7XG5cdCAgICB9XG5cdCAgICBpZiAobCA+IG1heCkge1xuXHQgICAgICBvYmplY3RJbmZvID0gXCJ7Li4ufVwiO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgb2JqZWN0SW5mbyA9IFwie1wiICsgXy5tYXAoaXRlbSwgZnVuY3Rpb24odiwgaykge1xuXHQgICAgICAgIHJldHVybiBrICsgXCI6XCIgKyAoVXRpbHMuaW5zcGVjdCh2LCBtYXgsIGwgKyAxKSk7XG5cdCAgICAgIH0pLmpvaW4oXCIsIFwiKSArIFwifVwiO1xuXHQgICAgfVxuXHQgICAgaWYgKG9iamVjdFR5cGUgPT09IFwiT2JqZWN0XCIpIHtcblx0ICAgICAgcmV0dXJuIG9iamVjdEluZm87XG5cdCAgICB9XG5cdCAgICByZXR1cm4gXCI8XCIgKyBvYmplY3RUeXBlICsgXCIgXCIgKyBvYmplY3RJbmZvICsgXCI+XCI7XG5cdCAgfVxuXHQgIHJldHVybiBcIlwiICsgaXRlbTtcblx0fTtcblx0XG5cdFV0aWxzLnV1aWQgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgY2hhcnMsIGRpZ2l0LCBvLCBvdXRwdXQsIHIsIHJhbmRvbTtcblx0ICBjaGFycyA9IFwiMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCIuc3BsaXQoXCJcIik7XG5cdCAgb3V0cHV0ID0gbmV3IEFycmF5KDM2KTtcblx0ICByYW5kb20gPSAwO1xuXHQgIGZvciAoZGlnaXQgPSBvID0gMTsgbyA8PSAzMjsgZGlnaXQgPSArK28pIHtcblx0ICAgIGlmIChyYW5kb20gPD0gMHgwMikge1xuXHQgICAgICByYW5kb20gPSAweDIwMDAwMDAgKyAoTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMCkgfCAwO1xuXHQgICAgfVxuXHQgICAgciA9IHJhbmRvbSAmIDB4Zjtcblx0ICAgIHJhbmRvbSA9IHJhbmRvbSA+PiA0O1xuXHQgICAgb3V0cHV0W2RpZ2l0XSA9IGNoYXJzW2RpZ2l0ID09PSAxOSA/IChyICYgMHgzKSB8IDB4OCA6IHJdO1xuXHQgIH1cblx0ICByZXR1cm4gb3V0cHV0LmpvaW4oXCJcIik7XG5cdH07XG5cdFxuXHRVdGlscy5hcnJheUZyb21Bcmd1bWVudHMgPSBmdW5jdGlvbihhcmdzKSB7XG5cdCAgaWYgKF8uaXNBcnJheShhcmdzWzBdKSkge1xuXHQgICAgcmV0dXJuIGFyZ3NbMF07XG5cdCAgfVxuXHQgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKTtcblx0fTtcblx0XG5cdFV0aWxzLmN5Y2xlID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIGFyZ3MsIGN1cnI7XG5cdCAgYXJncyA9IFV0aWxzLmFycmF5RnJvbUFyZ3VtZW50cyhhcmd1bWVudHMpO1xuXHQgIGN1cnIgPSAtMTtcblx0ICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICBjdXJyKys7XG5cdCAgICBpZiAoY3VyciA+PSBhcmdzLmxlbmd0aCkge1xuXHQgICAgICBjdXJyID0gMDtcblx0ICAgIH1cblx0ICAgIHJldHVybiBhcmdzW2N1cnJdO1xuXHQgIH07XG5cdH07XG5cdFxuXHRVdGlscy50b2dnbGUgPSBVdGlscy5jeWNsZTtcblx0XG5cdFV0aWxzLmlzV2ViS2l0ID0gZnVuY3Rpb24oKSB7XG5cdCAgcmV0dXJuIHdpbmRvdy5XZWJLaXRDU1NNYXRyaXggIT09IHZvaWQgMDtcblx0fTtcblx0XG5cdFV0aWxzLndlYmtpdFZlcnNpb24gPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgcmVnZXhwLCByZXN1bHQsIHZlcnNpb247XG5cdCAgdmVyc2lvbiA9IC0xO1xuXHQgIHJlZ2V4cCA9IC9BcHBsZVdlYktpdFxcLyhbXFxkLl0rKS87XG5cdCAgcmVzdWx0ID0gcmVnZXhwLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cdCAgaWYgKHJlc3VsdCkge1xuXHQgICAgdmVyc2lvbiA9IHBhcnNlRmxvYXQocmVzdWx0WzFdKTtcblx0ICB9XG5cdCAgcmV0dXJuIHZlcnNpb247XG5cdH07XG5cdFxuXHRVdGlscy5pc0Nocm9tZSA9IGZ1bmN0aW9uKCkge1xuXHQgIHJldHVybiAvY2hyb21lLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSk7XG5cdH07XG5cdFxuXHRVdGlscy5pc1NhZmFyaSA9IGZ1bmN0aW9uKCkge1xuXHQgIHJldHVybiAvc2FmYXJpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSk7XG5cdH07XG5cdFxuXHRVdGlscy5pc1RvdWNoID0gZnVuY3Rpb24oKSB7XG5cdCAgcmV0dXJuIHdpbmRvdy5vbnRvdWNoc3RhcnQgPT09IG51bGwgJiYgd2luZG93Lm9udG91Y2htb3ZlID09PSBudWxsICYmIHdpbmRvdy5vbnRvdWNoZW5kID09PSBudWxsO1xuXHR9O1xuXHRcblx0VXRpbHMuaXNEZXNrdG9wID0gZnVuY3Rpb24oKSB7XG5cdCAgcmV0dXJuIFV0aWxzLmRldmljZVR5cGUoKSA9PT0gXCJkZXNrdG9wXCI7XG5cdH07XG5cdFxuXHRVdGlscy5pc1Bob25lID0gZnVuY3Rpb24oKSB7XG5cdCAgcmV0dXJuIFV0aWxzLmRldmljZVR5cGUoKSA9PT0gXCJwaG9uZVwiO1xuXHR9O1xuXHRcblx0VXRpbHMuaXNUYWJsZXQgPSBmdW5jdGlvbigpIHtcblx0ICByZXR1cm4gVXRpbHMuZGV2aWNlVHlwZSgpID09PSBcInRhYmxldFwiO1xuXHR9O1xuXHRcblx0VXRpbHMuaXNNb2JpbGUgPSBmdW5jdGlvbigpIHtcblx0ICByZXR1cm4gVXRpbHMuaXNQaG9uZSgpIHx8IFV0aWxzLmlzVGFibGV0KCk7XG5cdH07XG5cdFxuXHRVdGlscy5pc0ZpbGVVcmwgPSBmdW5jdGlvbih1cmwpIHtcblx0ICByZXR1cm4gXy5zdGFydHNXaXRoKHVybCwgXCJmaWxlOi8vXCIpO1xuXHR9O1xuXHRcblx0VXRpbHMuaXNSZWxhdGl2ZVVybCA9IGZ1bmN0aW9uKHVybCkge1xuXHQgIHJldHVybiAhL14oW2EtekEtWl17MSw4fTpcXC9cXC8pLiokLy50ZXN0KHVybCk7XG5cdH07XG5cdFxuXHRVdGlscy5pc0xvY2FsU2VydmVyVXJsID0gZnVuY3Rpb24odXJsKSB7XG5cdCAgcmV0dXJuIHVybC5pbmRleE9mKFwiMTI3LjAuMC4xXCIpICE9PSAtMSB8fCB1cmwuaW5kZXhPZihcImxvY2FsaG9zdFwiKSAhPT0gLTE7XG5cdH07XG5cdFxuXHRVdGlscy5pc0xvY2FsVXJsID0gZnVuY3Rpb24odXJsKSB7XG5cdCAgaWYgKFV0aWxzLmlzRmlsZVVybCh1cmwpKSB7XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9XG5cdCAgaWYgKFV0aWxzLmlzTG9jYWxTZXJ2ZXJVcmwodXJsKSkge1xuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfVxuXHQgIHJldHVybiBmYWxzZTtcblx0fTtcblx0XG5cdFV0aWxzLmlzTG9jYWxBc3NldFVybCA9IGZ1bmN0aW9uKHVybCwgYmFzZVVybCkge1xuXHQgIGlmIChiYXNlVXJsID09IG51bGwpIHtcblx0ICAgIGJhc2VVcmwgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcblx0ICB9XG5cdCAgaWYgKFV0aWxzLmlzTG9jYWxVcmwodXJsKSkge1xuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfVxuXHQgIGlmIChVdGlscy5pc1JlbGF0aXZlVXJsKHVybCkgJiYgVXRpbHMuaXNMb2NhbFVybChiYXNlVXJsKSkge1xuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfVxuXHQgIHJldHVybiBmYWxzZTtcblx0fTtcblx0XG5cdFV0aWxzLmlzRnJhbWVyU3R1ZGlvID0gZnVuY3Rpb24oKSB7XG5cdCAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIkZyYW1lclN0dWRpb1wiKSAhPT0gLTE7XG5cdH07XG5cdFxuXHRVdGlscy5mcmFtZXJTdHVkaW9WZXJzaW9uID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIGlzQmV0YSwgaXNGdXR1cmUsIGlzTG9jYWwsIG1hdGNoZXMsIHZlcnNpb247XG5cdCAgaWYgKFV0aWxzLmlzRnJhbWVyU3R1ZGlvKCkpIHtcblx0ICAgIGlzQmV0YSA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIkZyYW1lclN0dWRpby9iZXRhXCIpID49IDA7XG5cdCAgICBpc0xvY2FsID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiRnJhbWVyU3R1ZGlvL2xvY2FsXCIpID49IDA7XG5cdCAgICBpc0Z1dHVyZSA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIkZyYW1lclN0dWRpby9mdXR1cmVcIikgPj0gMDtcblx0ICAgIGlmIChpc0JldGEgfHwgaXNMb2NhbCB8fCBpc0Z1dHVyZSkge1xuXHQgICAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcblx0ICAgIH1cblx0ICAgIG1hdGNoZXMgPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9cXGQrJC8pO1xuXHQgICAgaWYgKG1hdGNoZXMgJiYgbWF0Y2hlcy5sZW5ndGggPiAwKSB7XG5cdCAgICAgIHZlcnNpb24gPSBwYXJzZUludChtYXRjaGVzWzBdKTtcblx0ICAgIH1cblx0ICAgIGlmIChfLmlzTnVtYmVyKHZlcnNpb24pKSB7XG5cdCAgICAgIHJldHVybiB2ZXJzaW9uO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcblx0fTtcblx0XG5cdFV0aWxzLmRldmljZVBpeGVsUmF0aW8gPSBmdW5jdGlvbigpIHtcblx0ICByZXR1cm4gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG5cdH07XG5cdFxuXHRVdGlscy5pc0pQMlN1cHBvcnRlZCA9IGZ1bmN0aW9uKCkge1xuXHQgIHJldHVybiBVdGlscy5pc1dlYktpdCgpICYmICFVdGlscy5pc0Nocm9tZSgpO1xuXHR9O1xuXHRcblx0VXRpbHMuZGV2aWNlVHlwZSA9IGZ1bmN0aW9uKCkge1xuXHQgIGlmICgvKHRhYmxldCl8KGlQYWQpfChOZXh1cyA5KS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcblx0ICAgIHJldHVybiBcInRhYmxldFwiO1xuXHQgIH1cblx0ICBpZiAoLyhtb2JpKS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcblx0ICAgIHJldHVybiBcInBob25lXCI7XG5cdCAgfVxuXHQgIHJldHVybiBcImRlc2t0b3BcIjtcblx0fTtcblx0XG5cdFV0aWxzLnBhdGhKb2luID0gZnVuY3Rpb24oKSB7XG5cdCAgcmV0dXJuIFV0aWxzLmFycmF5RnJvbUFyZ3VtZW50cyhhcmd1bWVudHMpLmpvaW4oXCIvXCIpO1xuXHR9O1xuXHRcblx0VXRpbHMucm91bmQgPSBmdW5jdGlvbih2YWx1ZSwgZGVjaW1hbHMpIHtcblx0ICB2YXIgZDtcblx0ICBpZiAoZGVjaW1hbHMgPT0gbnVsbCkge1xuXHQgICAgZGVjaW1hbHMgPSAwO1xuXHQgIH1cblx0ICBkID0gTWF0aC5wb3coMTAsIGRlY2ltYWxzKTtcblx0ICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIGQpIC8gZDtcblx0fTtcblx0XG5cdFV0aWxzLmNsYW1wID0gZnVuY3Rpb24odmFsdWUsIGEsIGIpIHtcblx0ICB2YXIgbWF4LCBtaW47XG5cdCAgbWluID0gTWF0aC5taW4oYSwgYik7XG5cdCAgbWF4ID0gTWF0aC5tYXgoYSwgYik7XG5cdCAgaWYgKHZhbHVlIDwgbWluKSB7XG5cdCAgICB2YWx1ZSA9IG1pbjtcblx0ICB9XG5cdCAgaWYgKHZhbHVlID4gbWF4KSB7XG5cdCAgICB2YWx1ZSA9IG1heDtcblx0ICB9XG5cdCAgcmV0dXJuIHZhbHVlO1xuXHR9O1xuXHRcblx0VXRpbHMubWFwUmFuZ2UgPSBmdW5jdGlvbih2YWx1ZSwgZnJvbUxvdywgZnJvbUhpZ2gsIHRvTG93LCB0b0hpZ2gpIHtcblx0ICByZXR1cm4gdG9Mb3cgKyAoKCh2YWx1ZSAtIGZyb21Mb3cpIC8gKGZyb21IaWdoIC0gZnJvbUxvdykpICogKHRvSGlnaCAtIHRvTG93KSk7XG5cdH07XG5cdFxuXHRVdGlscy5tb2R1bGF0ZSA9IGZ1bmN0aW9uKHZhbHVlLCByYW5nZUEsIHJhbmdlQiwgbGltaXQpIHtcblx0ICB2YXIgZnJvbUhpZ2gsIGZyb21Mb3csIHJlc3VsdCwgdG9IaWdoLCB0b0xvdztcblx0ICBpZiAobGltaXQgPT0gbnVsbCkge1xuXHQgICAgbGltaXQgPSBmYWxzZTtcblx0ICB9XG5cdCAgZnJvbUxvdyA9IHJhbmdlQVswXSwgZnJvbUhpZ2ggPSByYW5nZUFbMV07XG5cdCAgdG9Mb3cgPSByYW5nZUJbMF0sIHRvSGlnaCA9IHJhbmdlQlsxXTtcblx0ICByZXN1bHQgPSB0b0xvdyArICgoKHZhbHVlIC0gZnJvbUxvdykgLyAoZnJvbUhpZ2ggLSBmcm9tTG93KSkgKiAodG9IaWdoIC0gdG9Mb3cpKTtcblx0ICBpZiAobGltaXQgPT09IHRydWUpIHtcblx0ICAgIGlmICh0b0xvdyA8IHRvSGlnaCkge1xuXHQgICAgICBpZiAocmVzdWx0IDwgdG9Mb3cpIHtcblx0ICAgICAgICByZXR1cm4gdG9Mb3c7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHJlc3VsdCA+IHRvSGlnaCkge1xuXHQgICAgICAgIHJldHVybiB0b0hpZ2g7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlmIChyZXN1bHQgPiB0b0xvdykge1xuXHQgICAgICAgIHJldHVybiB0b0xvdztcblx0ICAgICAgfVxuXHQgICAgICBpZiAocmVzdWx0IDwgdG9IaWdoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRvSGlnaDtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXHRcblx0VXRpbHMucGFyc2VGdW5jdGlvbiA9IGZ1bmN0aW9uKHN0cikge1xuXHQgIHZhciByZXN1bHQ7XG5cdCAgcmVzdWx0ID0ge1xuXHQgICAgbmFtZTogXCJcIixcblx0ICAgIGFyZ3M6IFtdXG5cdCAgfTtcblx0ICBpZiAoXy5lbmRzV2l0aChzdHIsIFwiKVwiKSkge1xuXHQgICAgcmVzdWx0Lm5hbWUgPSBzdHIuc3BsaXQoXCIoXCIpWzBdO1xuXHQgICAgcmVzdWx0LmFyZ3MgPSBzdHIuc3BsaXQoXCIoXCIpWzFdLnNwbGl0KFwiLFwiKS5tYXAoZnVuY3Rpb24oYSkge1xuXHQgICAgICByZXR1cm4gXy50cmltKF8udHJpbVJpZ2h0KGEsIFwiKVwiKSk7XG5cdCAgICB9KTtcblx0ICB9IGVsc2Uge1xuXHQgICAgcmVzdWx0Lm5hbWUgPSBzdHI7XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cdFxuXHRfX2RvbUNvbXBsZXRlU3RhdGUgPSBcImludGVyYWN0aXZlXCI7XG5cdFxuXHRfX2RvbUNvbXBsZXRlID0gW107XG5cdFxuXHRfX2RvbVJlYWR5ID0gZmFsc2U7XG5cdFxuXHRpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50ICE9PSBudWxsKSB7XG5cdCAgZG9jdW1lbnQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0ICAgIHZhciBmLCByZXN1bHRzO1xuXHQgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IF9fZG9tQ29tcGxldGVTdGF0ZSkge1xuXHQgICAgICBfX2RvbVJlYWR5ID0gdHJ1ZTtcblx0ICAgICAgcmVzdWx0cyA9IFtdO1xuXHQgICAgICB3aGlsZSAoX19kb21Db21wbGV0ZS5sZW5ndGgpIHtcblx0ICAgICAgICByZXN1bHRzLnB1c2goZiA9IF9fZG9tQ29tcGxldGUuc2hpZnQoKSgpKTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gcmVzdWx0cztcblx0ICAgIH1cblx0ICB9O1xuXHR9XG5cdFxuXHRVdGlscy5kb21Db21wbGV0ZSA9IGZ1bmN0aW9uKGYpIHtcblx0ICBpZiAoX19kb21SZWFkeSkge1xuXHQgICAgcmV0dXJuIGYoKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgcmV0dXJuIF9fZG9tQ29tcGxldGUucHVzaChmKTtcblx0ICB9XG5cdH07XG5cdFxuXHRVdGlscy5kb21Db21wbGV0ZUNhbmNlbCA9IGZ1bmN0aW9uKGYpIHtcblx0ICByZXR1cm4gX19kb21Db21wbGV0ZSA9IF8ud2l0aG91dChfX2RvbUNvbXBsZXRlLCBmKTtcblx0fTtcblx0XG5cdFV0aWxzLmRvbVZhbGlkRXZlbnQgPSBmdW5jdGlvbihlbGVtZW50LCBldmVudE5hbWUpIHtcblx0ICBpZiAoIWV2ZW50TmFtZSkge1xuXHQgICAgcmV0dXJuO1xuXHQgIH1cblx0ICBpZiAoZXZlbnROYW1lID09PSBcInRvdWNoc3RhcnRcIiB8fCBldmVudE5hbWUgPT09IFwidG91Y2htb3ZlXCIgfHwgZXZlbnROYW1lID09PSBcInRvdWNoZW5kXCIpIHtcblx0ICAgIHJldHVybiB0cnVlO1xuXHQgIH1cblx0ICByZXR1cm4gdHlwZW9mIGVsZW1lbnRbXCJvblwiICsgKGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpKV0gIT09IFwidW5kZWZpbmVkXCI7XG5cdH07XG5cdFxuXHRVdGlscy5kb21Mb2FkU2NyaXB0ID0gZnVuY3Rpb24odXJsLCBjYWxsYmFjaykge1xuXHQgIHZhciBoZWFkLCBzY3JpcHQ7XG5cdCAgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcblx0ICBzY3JpcHQudHlwZSA9IFwidGV4dC9qYXZhc2NyaXB0XCI7XG5cdCAgc2NyaXB0LnNyYyA9IHVybDtcblx0ICBzY3JpcHQub25sb2FkID0gY2FsbGJhY2s7XG5cdCAgaGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcblx0ICBoZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG5cdCAgcmV0dXJuIHNjcmlwdDtcblx0fTtcblx0XG5cdFV0aWxzLmRvbUxvYWREYXRhID0gZnVuY3Rpb24ocGF0aCwgY2FsbGJhY2spIHtcblx0ICB2YXIgcmVxdWVzdDtcblx0ICByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdCAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBmdW5jdGlvbigpIHtcblx0ICAgIHJldHVybiBjYWxsYmFjayhudWxsLCByZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG5cdCAgfSwgZmFsc2UpO1xuXHQgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGZ1bmN0aW9uKCkge1xuXHQgICAgcmV0dXJuIGNhbGxiYWNrKHRydWUsIG51bGwpO1xuXHQgIH0sIGZhbHNlKTtcblx0ICByZXF1ZXN0Lm9wZW4oXCJHRVRcIiwgcGF0aCwgdHJ1ZSk7XG5cdCAgcmV0dXJuIHJlcXVlc3Quc2VuZChudWxsKTtcblx0fTtcblx0XG5cdFV0aWxzLmRvbUxvYWRKU09OID0gZnVuY3Rpb24ocGF0aCwgY2FsbGJhY2spIHtcblx0ICByZXR1cm4gVXRpbHMuZG9tTG9hZERhdGEocGF0aCwgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG5cdCAgICByZXR1cm4gY2FsbGJhY2soZXJyLCBKU09OLnBhcnNlKGRhdGEpKTtcblx0ICB9KTtcblx0fTtcblx0XG5cdFV0aWxzLmRvbUxvYWREYXRhU3luYyA9IGZ1bmN0aW9uKHBhdGgpIHtcblx0ICB2YXIgZSwgZXJyb3IsIGhhbmRsZUVycm9yLCByZWYsIHJlcXVlc3Q7XG5cdCAgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXHQgIHJlcXVlc3Qub3BlbihcIkdFVFwiLCBwYXRoLCBmYWxzZSk7XG5cdCAgdHJ5IHtcblx0ICAgIHJlcXVlc3Quc2VuZChudWxsKTtcblx0ICB9IGNhdGNoIChlcnJvcikge1xuXHQgICAgZSA9IGVycm9yO1xuXHQgICAgY29uc29sZS5kZWJ1ZyhcIlhNTEh0dHBSZXF1ZXN0LmVycm9yXCIsIGUpO1xuXHQgIH1cblx0ICBoYW5kbGVFcnJvciA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdGhyb3cgRXJyb3IoXCJVdGlscy5kb21Mb2FkRGF0YVN5bmM6IFwiICsgcGF0aCArIFwiIC0+IFtcIiArIHJlcXVlc3Quc3RhdHVzICsgXCIgXCIgKyByZXF1ZXN0LnN0YXR1c1RleHQgKyBcIl1cIik7XG5cdCAgfTtcblx0ICByZXF1ZXN0Lm9uZXJyb3IgPSBoYW5kbGVFcnJvcjtcblx0ICBpZiAoKHJlZiA9IHJlcXVlc3Quc3RhdHVzKSAhPT0gMjAwICYmIHJlZiAhPT0gMCkge1xuXHQgICAgaGFuZGxlRXJyb3IoKTtcblx0ICB9XG5cdCAgaWYgKCFyZXF1ZXN0LnJlc3BvbnNlVGV4dCkge1xuXHQgICAgaGFuZGxlRXJyb3IoKTtcblx0ICB9XG5cdCAgcmV0dXJuIHJlcXVlc3QucmVzcG9uc2VUZXh0O1xuXHR9O1xuXHRcblx0VXRpbHMuZG9tTG9hZEpTT05TeW5jID0gZnVuY3Rpb24ocGF0aCkge1xuXHQgIHJldHVybiBKU09OLnBhcnNlKFV0aWxzLmRvbUxvYWREYXRhU3luYyhwYXRoKSk7XG5cdH07XG5cdFxuXHRVdGlscy5kb21Mb2FkU2NyaXB0U3luYyA9IGZ1bmN0aW9uKHBhdGgpIHtcblx0ICB2YXIgc2NyaXB0RGF0YTtcblx0ICBzY3JpcHREYXRhID0gVXRpbHMuZG9tTG9hZERhdGFTeW5jKHBhdGgpO1xuXHQgIGV2YWwoc2NyaXB0RGF0YSk7XG5cdCAgcmV0dXJuIHNjcmlwdERhdGE7XG5cdH07XG5cdFxuXHRVdGlscy5pbnNlcnRDU1MgPSBmdW5jdGlvbihjc3MpIHtcblx0ICB2YXIgc3R5bGVFbGVtZW50O1xuXHQgIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcblx0ICBzdHlsZUVsZW1lbnQudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0ICBzdHlsZUVsZW1lbnQuaW5uZXJIVE1MID0gY3NzO1xuXHQgIHJldHVybiBVdGlscy5kb21Db21wbGV0ZShmdW5jdGlvbigpIHtcblx0ICAgIHJldHVybiBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XG5cdCAgfSk7XG5cdH07XG5cdFxuXHRVdGlscy5sb2FkSW1hZ2UgPSBmdW5jdGlvbih1cmwsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG5cdCAgdmFyIGVsZW1lbnQ7XG5cdCAgZWxlbWVudCA9IG5ldyBJbWFnZTtcblx0ICBpZiAoY29udGV4dCA9PSBudWxsKSB7XG5cdCAgICBjb250ZXh0ID0gRnJhbWVyLkN1cnJlbnRDb250ZXh0O1xuXHQgIH1cblx0ICBjb250ZXh0LmRvbUV2ZW50TWFuYWdlci53cmFwKGVsZW1lbnQpLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdCAgICByZXR1cm4gY2FsbGJhY2soKTtcblx0ICB9KTtcblx0ICBjb250ZXh0LmRvbUV2ZW50TWFuYWdlci53cmFwKGVsZW1lbnQpLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBmdW5jdGlvbihldmVudCkge1xuXHQgICAgcmV0dXJuIGNhbGxiYWNrKHRydWUpO1xuXHQgIH0pO1xuXHQgIHJldHVybiBlbGVtZW50LnNyYyA9IHVybDtcblx0fTtcblx0XG5cdFV0aWxzLnBvaW50RGl2aWRlID0gZnVuY3Rpb24ocG9pbnQsIGZyYWN0aW9uKSB7XG5cdCAgcmV0dXJuIHBvaW50ID0ge1xuXHQgICAgeDogcG9pbnQueCAvIGZyYWN0aW9uLFxuXHQgICAgeTogcG9pbnQueSAvIGZyYWN0aW9uXG5cdCAgfTtcblx0fTtcblx0XG5cdFV0aWxzLnBvaW50QWRkID0gZnVuY3Rpb24ocG9pbnRBLCBwb2ludEIpIHtcblx0ICB2YXIgcG9pbnQ7XG5cdCAgcmV0dXJuIHBvaW50ID0ge1xuXHQgICAgeDogcG9pbnRBLnggKyBwb2ludEIueCxcblx0ICAgIHk6IHBvaW50QS55ICsgcG9pbnRCLnlcblx0ICB9O1xuXHR9O1xuXHRcblx0VXRpbHMucG9pbnRTdWJ0cmFjdCA9IGZ1bmN0aW9uKHBvaW50QSwgcG9pbnRCKSB7XG5cdCAgdmFyIHBvaW50O1xuXHQgIHJldHVybiBwb2ludCA9IHtcblx0ICAgIHg6IHBvaW50QS54IC0gcG9pbnRCLngsXG5cdCAgICB5OiBwb2ludEEueSAtIHBvaW50Qi55XG5cdCAgfTtcblx0fTtcblx0XG5cdFV0aWxzLnBvaW50WmVybyA9IGZ1bmN0aW9uKGFyZ3MpIHtcblx0ICBpZiAoYXJncyA9PSBudWxsKSB7XG5cdCAgICBhcmdzID0ge307XG5cdCAgfVxuXHQgIHJldHVybiBfLmRlZmF1bHRzKGFyZ3MsIHtcblx0ICAgIHg6IDAsXG5cdCAgICB5OiAwXG5cdCAgfSk7XG5cdH07XG5cdFxuXHRVdGlscy5wb2ludE1pbiA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciBwb2ludCwgcG9pbnRzO1xuXHQgIHBvaW50cyA9IFV0aWxzLmFycmF5RnJvbUFyZ3VtZW50cyhhcmd1bWVudHMpO1xuXHQgIHJldHVybiBwb2ludCA9IHtcblx0ICAgIHg6IF8ubWluKHBvaW50cy5tYXAoZnVuY3Rpb24oc2l6ZSkge1xuXHQgICAgICByZXR1cm4gc2l6ZS54O1xuXHQgICAgfSkpLFxuXHQgICAgeTogXy5taW4ocG9pbnRzLm1hcChmdW5jdGlvbihzaXplKSB7XG5cdCAgICAgIHJldHVybiBzaXplLnk7XG5cdCAgICB9KSlcblx0ICB9O1xuXHR9O1xuXHRcblx0VXRpbHMucG9pbnRNYXggPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgcG9pbnQsIHBvaW50cztcblx0ICBwb2ludHMgPSBVdGlscy5hcnJheUZyb21Bcmd1bWVudHMoYXJndW1lbnRzKTtcblx0ICByZXR1cm4gcG9pbnQgPSB7XG5cdCAgICB4OiBfLm1heChwb2ludHMubWFwKGZ1bmN0aW9uKHNpemUpIHtcblx0ICAgICAgcmV0dXJuIHNpemUueDtcblx0ICAgIH0pKSxcblx0ICAgIHk6IF8ubWF4KHBvaW50cy5tYXAoZnVuY3Rpb24oc2l6ZSkge1xuXHQgICAgICByZXR1cm4gc2l6ZS55O1xuXHQgICAgfSkpXG5cdCAgfTtcblx0fTtcblx0XG5cdFV0aWxzLnBvaW50RGVsdGEgPSBmdW5jdGlvbihwb2ludEEsIHBvaW50Qikge1xuXHQgIHZhciBkZWx0YTtcblx0ICByZXR1cm4gZGVsdGEgPSB7XG5cdCAgICB4OiBwb2ludEIueCAtIHBvaW50QS54LFxuXHQgICAgeTogcG9pbnRCLnkgLSBwb2ludEEueVxuXHQgIH07XG5cdH07XG5cdFxuXHRVdGlscy5wb2ludERpc3RhbmNlID0gZnVuY3Rpb24ocG9pbnRBLCBwb2ludEIpIHtcblx0ICB2YXIgYSwgYjtcblx0ICBhID0gcG9pbnRBLnggLSBwb2ludEIueDtcblx0ICBiID0gcG9pbnRBLnkgLSBwb2ludEIueTtcblx0ICByZXR1cm4gTWF0aC5zcXJ0KChhICogYSkgKyAoYiAqIGIpKTtcblx0fTtcblx0XG5cdFV0aWxzLnBvaW50SW52ZXJ0ID0gZnVuY3Rpb24ocG9pbnQpIHtcblx0ICByZXR1cm4gcG9pbnQgPSB7XG5cdCAgICB4OiAwIC0gcG9pbnQueCxcblx0ICAgIHk6IDAgLSBwb2ludC55XG5cdCAgfTtcblx0fTtcblx0XG5cdFV0aWxzLnBvaW50VG90YWwgPSBmdW5jdGlvbihwb2ludCkge1xuXHQgIHJldHVybiBwb2ludC54ICsgcG9pbnQueTtcblx0fTtcblx0XG5cdFV0aWxzLnBvaW50QWJzID0gZnVuY3Rpb24ocG9pbnQpIHtcblx0ICByZXR1cm4gcG9pbnQgPSB7XG5cdCAgICB4OiBNYXRoLmFicyhwb2ludC54KSxcblx0ICAgIHk6IE1hdGguYWJzKHBvaW50LnkpXG5cdCAgfTtcblx0fTtcblx0XG5cdFV0aWxzLnBvaW50SW5GcmFtZSA9IGZ1bmN0aW9uKHBvaW50LCBmcmFtZSkge1xuXHQgIGlmIChwb2ludC54IDwgVXRpbHMuZnJhbWVHZXRNaW5YKGZyYW1lKSB8fCBwb2ludC54ID4gVXRpbHMuZnJhbWVHZXRNYXhYKGZyYW1lKSkge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0ICBpZiAocG9pbnQueSA8IFV0aWxzLmZyYW1lR2V0TWluWShmcmFtZSkgfHwgcG9pbnQueSA+IFV0aWxzLmZyYW1lR2V0TWF4WShmcmFtZSkpIHtcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cdCAgcmV0dXJuIHRydWU7XG5cdH07XG5cdFxuXHRVdGlscy5wb2ludENlbnRlciA9IGZ1bmN0aW9uKHBvaW50QSwgcG9pbnRCKSB7XG5cdCAgdmFyIHBvaW50O1xuXHQgIHJldHVybiBwb2ludCA9IHtcblx0ICAgIHg6IChwb2ludEEueCArIHBvaW50Qi54KSAvIDIsXG5cdCAgICB5OiAocG9pbnRBLnkgKyBwb2ludEIueSkgLyAyXG5cdCAgfTtcblx0fTtcblx0XG5cdFV0aWxzLnBvaW50QW5nbGUgPSBmdW5jdGlvbihwb2ludEEsIHBvaW50Qikge1xuXHQgIHJldHVybiBNYXRoLmF0YW4yKHBvaW50Qi55IC0gcG9pbnRBLnksIHBvaW50Qi54IC0gcG9pbnRBLngpICogMTgwIC8gTWF0aC5QSTtcblx0fTtcblx0XG5cdFV0aWxzLnNpemVaZXJvID0gZnVuY3Rpb24oYXJncykge1xuXHQgIGlmIChhcmdzID09IG51bGwpIHtcblx0ICAgIGFyZ3MgPSB7fTtcblx0ICB9XG5cdCAgcmV0dXJuIF8uZGVmYXVsdHMoYXJncywge1xuXHQgICAgd2lkdGg6IDAsXG5cdCAgICBoZWlnaHQ6IDBcblx0ICB9KTtcblx0fTtcblx0XG5cdFV0aWxzLnNpemVNaW4gPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgc2l6ZSwgc2l6ZXM7XG5cdCAgc2l6ZXMgPSBVdGlscy5hcnJheUZyb21Bcmd1bWVudHMoYXJndW1lbnRzKTtcblx0ICByZXR1cm4gc2l6ZSA9IHtcblx0ICAgIHdpZHRoOiBfLm1pbihzaXplcy5tYXAoZnVuY3Rpb24oc2l6ZSkge1xuXHQgICAgICByZXR1cm4gc2l6ZS53aWR0aDtcblx0ICAgIH0pKSxcblx0ICAgIGhlaWdodDogXy5taW4oc2l6ZXMubWFwKGZ1bmN0aW9uKHNpemUpIHtcblx0ICAgICAgcmV0dXJuIHNpemUuaGVpZ2h0O1xuXHQgICAgfSkpXG5cdCAgfTtcblx0fTtcblx0XG5cdFV0aWxzLnNpemVNYXggPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgc2l6ZSwgc2l6ZXM7XG5cdCAgc2l6ZXMgPSBVdGlscy5hcnJheUZyb21Bcmd1bWVudHMoYXJndW1lbnRzKTtcblx0ICByZXR1cm4gc2l6ZSA9IHtcblx0ICAgIHdpZHRoOiBfLm1heChzaXplcy5tYXAoZnVuY3Rpb24oc2l6ZSkge1xuXHQgICAgICByZXR1cm4gc2l6ZS53aWR0aDtcblx0ICAgIH0pKSxcblx0ICAgIGhlaWdodDogXy5tYXgoc2l6ZXMubWFwKGZ1bmN0aW9uKHNpemUpIHtcblx0ICAgICAgcmV0dXJuIHNpemUuaGVpZ2h0O1xuXHQgICAgfSkpXG5cdCAgfTtcblx0fTtcblx0XG5cdFV0aWxzLnJlY3RaZXJvID0gZnVuY3Rpb24oYXJncykge1xuXHQgIGlmIChhcmdzID09IG51bGwpIHtcblx0ICAgIGFyZ3MgPSB7fTtcblx0ICB9XG5cdCAgcmV0dXJuIF8uZGVmYXVsdHMoYXJncywge1xuXHQgICAgdG9wOiAwLFxuXHQgICAgcmlnaHQ6IDAsXG5cdCAgICBib3R0b206IDAsXG5cdCAgICBsZWZ0OiAwXG5cdCAgfSk7XG5cdH07XG5cdFxuXHRVdGlscy5wYXJzZVJlY3QgPSBmdW5jdGlvbihhcmdzKSB7XG5cdCAgaWYgKF8uaXNBcnJheShhcmdzKSAmJiBfLmlzTnVtYmVyKGFyZ3NbMF0pKSB7XG5cdCAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcblx0ICAgICAgcmV0dXJuIFV0aWxzLnBhcnNlUmVjdCh7XG5cdCAgICAgICAgdG9wOiBhcmdzWzBdXG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG5cdCAgICAgIHJldHVybiBVdGlscy5wYXJzZVJlY3Qoe1xuXHQgICAgICAgIHRvcDogYXJnc1swXSxcblx0ICAgICAgICByaWdodDogYXJnc1sxXVxuXHQgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMykge1xuXHQgICAgICByZXR1cm4gVXRpbHMucGFyc2VSZWN0KHtcblx0ICAgICAgICB0b3A6IGFyZ3NbMF0sXG5cdCAgICAgICAgcmlnaHQ6IGFyZ3NbMV0sXG5cdCAgICAgICAgYm90dG9tOiBhcmdzWzJdXG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgaWYgKGFyZ3MubGVuZ3RoID09PSA0KSB7XG5cdCAgICAgIHJldHVybiBVdGlscy5wYXJzZVJlY3Qoe1xuXHQgICAgICAgIHRvcDogYXJnc1swXSxcblx0ICAgICAgICByaWdodDogYXJnc1sxXSxcblx0ICAgICAgICBib3R0b206IGFyZ3NbMl0sXG5cdCAgICAgICAgbGVmdDogYXJnc1szXVxuXHQgICAgICB9KTtcblx0ICAgIH1cblx0ICB9XG5cdCAgaWYgKF8uaXNBcnJheShhcmdzKSAmJiBfLmlzT2JqZWN0KGFyZ3NbMF0pKSB7XG5cdCAgICByZXR1cm4gYXJnc1swXTtcblx0ICB9XG5cdCAgaWYgKF8uaXNPYmplY3QoYXJncykpIHtcblx0ICAgIHJldHVybiBhcmdzO1xuXHQgIH1cblx0ICByZXR1cm4ge307XG5cdH07XG5cdFxuXHRVdGlscy5mcmFtZUdldE1pblggPSBmdW5jdGlvbihmcmFtZSkge1xuXHQgIHJldHVybiBmcmFtZS54O1xuXHR9O1xuXHRcblx0VXRpbHMuZnJhbWVTZXRNaW5YID0gZnVuY3Rpb24oZnJhbWUsIHZhbHVlKSB7XG5cdCAgcmV0dXJuIGZyYW1lLnggPSB2YWx1ZTtcblx0fTtcblx0XG5cdFV0aWxzLmZyYW1lR2V0TWlkWCA9IGZ1bmN0aW9uKGZyYW1lKSB7XG5cdCAgaWYgKGZyYW1lLndpZHRoID09PSAwKSB7XG5cdCAgICByZXR1cm4gMDtcblx0ICB9IGVsc2Uge1xuXHQgICAgcmV0dXJuIGZyYW1lLnggKyAoZnJhbWUud2lkdGggLyAyLjApO1xuXHQgIH1cblx0fTtcblx0XG5cdFV0aWxzLmZyYW1lU2V0TWlkWCA9IGZ1bmN0aW9uKGZyYW1lLCB2YWx1ZSkge1xuXHQgIHJldHVybiBmcmFtZS54ID0gZnJhbWUud2lkdGggPT09IDAgPyAwIDogdmFsdWUgLSAoZnJhbWUud2lkdGggLyAyLjApO1xuXHR9O1xuXHRcblx0VXRpbHMuZnJhbWVHZXRNYXhYID0gZnVuY3Rpb24oZnJhbWUpIHtcblx0ICBpZiAoZnJhbWUud2lkdGggPT09IDApIHtcblx0ICAgIHJldHVybiAwO1xuXHQgIH0gZWxzZSB7XG5cdCAgICByZXR1cm4gZnJhbWUueCArIGZyYW1lLndpZHRoO1xuXHQgIH1cblx0fTtcblx0XG5cdFV0aWxzLmZyYW1lU2V0TWF4WCA9IGZ1bmN0aW9uKGZyYW1lLCB2YWx1ZSkge1xuXHQgIHJldHVybiBmcmFtZS54ID0gZnJhbWUud2lkdGggPT09IDAgPyAwIDogdmFsdWUgLSBmcmFtZS53aWR0aDtcblx0fTtcblx0XG5cdFV0aWxzLmZyYW1lR2V0TWluWSA9IGZ1bmN0aW9uKGZyYW1lKSB7XG5cdCAgcmV0dXJuIGZyYW1lLnk7XG5cdH07XG5cdFxuXHRVdGlscy5mcmFtZVNldE1pblkgPSBmdW5jdGlvbihmcmFtZSwgdmFsdWUpIHtcblx0ICByZXR1cm4gZnJhbWUueSA9IHZhbHVlO1xuXHR9O1xuXHRcblx0VXRpbHMuZnJhbWVHZXRNaWRZID0gZnVuY3Rpb24oZnJhbWUpIHtcblx0ICBpZiAoZnJhbWUuaGVpZ2h0ID09PSAwKSB7XG5cdCAgICByZXR1cm4gMDtcblx0ICB9IGVsc2Uge1xuXHQgICAgcmV0dXJuIGZyYW1lLnkgKyAoZnJhbWUuaGVpZ2h0IC8gMi4wKTtcblx0ICB9XG5cdH07XG5cdFxuXHRVdGlscy5mcmFtZVNldE1pZFkgPSBmdW5jdGlvbihmcmFtZSwgdmFsdWUpIHtcblx0ICByZXR1cm4gZnJhbWUueSA9IGZyYW1lLmhlaWdodCA9PT0gMCA/IDAgOiB2YWx1ZSAtIChmcmFtZS5oZWlnaHQgLyAyLjApO1xuXHR9O1xuXHRcblx0VXRpbHMuZnJhbWVHZXRNYXhZID0gZnVuY3Rpb24oZnJhbWUpIHtcblx0ICBpZiAoZnJhbWUuaGVpZ2h0ID09PSAwKSB7XG5cdCAgICByZXR1cm4gMDtcblx0ICB9IGVsc2Uge1xuXHQgICAgcmV0dXJuIGZyYW1lLnkgKyBmcmFtZS5oZWlnaHQ7XG5cdCAgfVxuXHR9O1xuXHRcblx0VXRpbHMuZnJhbWVTZXRNYXhZID0gZnVuY3Rpb24oZnJhbWUsIHZhbHVlKSB7XG5cdCAgcmV0dXJuIGZyYW1lLnkgPSBmcmFtZS5oZWlnaHQgPT09IDAgPyAwIDogdmFsdWUgLSBmcmFtZS5oZWlnaHQ7XG5cdH07XG5cdFxuXHRVdGlscy5mcmFtZVplcm8gPSBmdW5jdGlvbihhcmdzKSB7XG5cdCAgaWYgKGFyZ3MgPT0gbnVsbCkge1xuXHQgICAgYXJncyA9IHt9O1xuXHQgIH1cblx0ICByZXR1cm4gXy5kZWZhdWx0cyhhcmdzLCB7XG5cdCAgICB0b3A6IDAsXG5cdCAgICByaWdodDogMCxcblx0ICAgIGJvdHRvbTogMCxcblx0ICAgIGxlZnQ6IDBcblx0ICB9KTtcblx0fTtcblx0XG5cdFV0aWxzLmZyYW1lU2l6ZSA9IGZ1bmN0aW9uKGZyYW1lKSB7XG5cdCAgdmFyIHNpemU7XG5cdCAgcmV0dXJuIHNpemUgPSB7XG5cdCAgICB3aWR0aDogZnJhbWUud2lkdGgsXG5cdCAgICBoZWlnaHQ6IGZyYW1lLmhlaWdodFxuXHQgIH07XG5cdH07XG5cdFxuXHRVdGlscy5mcmFtZVBvaW50ID0gZnVuY3Rpb24oZnJhbWUpIHtcblx0ICB2YXIgcG9pbnQ7XG5cdCAgcmV0dXJuIHBvaW50ID0ge1xuXHQgICAgeDogZnJhbWUueCxcblx0ICAgIHk6IGZyYW1lLnlcblx0ICB9O1xuXHR9O1xuXHRcblx0VXRpbHMucG9pbnRzRnJvbUZyYW1lID0gZnVuY3Rpb24oZnJhbWUpIHtcblx0ICB2YXIgY29ybmVyMSwgY29ybmVyMiwgY29ybmVyMywgY29ybmVyNCwgbWF4WCwgbWF4WSwgbWluWCwgbWluWTtcblx0ICBtaW5YID0gVXRpbHMuZnJhbWVHZXRNaW5YKGZyYW1lKTtcblx0ICBtYXhYID0gVXRpbHMuZnJhbWVHZXRNYXhYKGZyYW1lKTtcblx0ICBtaW5ZID0gVXRpbHMuZnJhbWVHZXRNaW5ZKGZyYW1lKTtcblx0ICBtYXhZID0gVXRpbHMuZnJhbWVHZXRNYXhZKGZyYW1lKTtcblx0ICBjb3JuZXIxID0ge1xuXHQgICAgeDogbWluWCxcblx0ICAgIHk6IG1pbllcblx0ICB9O1xuXHQgIGNvcm5lcjIgPSB7XG5cdCAgICB4OiBtaW5YLFxuXHQgICAgeTogbWF4WVxuXHQgIH07XG5cdCAgY29ybmVyMyA9IHtcblx0ICAgIHg6IG1heFgsXG5cdCAgICB5OiBtYXhZXG5cdCAgfTtcblx0ICBjb3JuZXI0ID0ge1xuXHQgICAgeDogbWF4WCxcblx0ICAgIHk6IG1pbllcblx0ICB9O1xuXHQgIHJldHVybiBbY29ybmVyMSwgY29ybmVyMiwgY29ybmVyMywgY29ybmVyNF07XG5cdH07XG5cdFxuXHRVdGlscy5mcmFtZUZyb21Qb2ludHMgPSBmdW5jdGlvbihwb2ludHMpIHtcblx0ICB2YXIgZnJhbWUsIG1heFgsIG1heFksIG1pblgsIG1pblksIHhWYWx1ZXMsIHlWYWx1ZXM7XG5cdCAgeFZhbHVlcyA9IF8ucGx1Y2socG9pbnRzLCBcInhcIik7XG5cdCAgeVZhbHVlcyA9IF8ucGx1Y2socG9pbnRzLCBcInlcIik7XG5cdCAgbWluWCA9IF8ubWluKHhWYWx1ZXMpO1xuXHQgIG1heFggPSBfLm1heCh4VmFsdWVzKTtcblx0ICBtaW5ZID0gXy5taW4oeVZhbHVlcyk7XG5cdCAgbWF4WSA9IF8ubWF4KHlWYWx1ZXMpO1xuXHQgIHJldHVybiBmcmFtZSA9IHtcblx0ICAgIHg6IG1pblgsXG5cdCAgICB5OiBtaW5ZLFxuXHQgICAgd2lkdGg6IG1heFggLSBtaW5YLFxuXHQgICAgaGVpZ2h0OiBtYXhZIC0gbWluWVxuXHQgIH07XG5cdH07XG5cdFxuXHRVdGlscy5waXhlbEFsaWduZWRGcmFtZSA9IGZ1bmN0aW9uKGZyYW1lKSB7XG5cdCAgdmFyIHJlc3VsdDtcblx0ICByZXR1cm4gcmVzdWx0ID0ge1xuXHQgICAgd2lkdGg6IE1hdGgucm91bmQoZnJhbWUud2lkdGggKyAoZnJhbWUueCAlIDEpKSxcblx0ICAgIGhlaWdodDogTWF0aC5yb3VuZChmcmFtZS5oZWlnaHQgKyAoZnJhbWUueSAlIDEpKSxcblx0ICAgIHg6IE1hdGgucm91bmQoZnJhbWUueCksXG5cdCAgICB5OiBNYXRoLnJvdW5kKGZyYW1lLnkpXG5cdCAgfTtcblx0fTtcblx0XG5cdFV0aWxzLmZyYW1lTWVyZ2UgPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgZnJhbWUsIGZyYW1lcztcblx0ICBmcmFtZXMgPSBVdGlscy5hcnJheUZyb21Bcmd1bWVudHMoYXJndW1lbnRzKTtcblx0ICBmcmFtZSA9IHtcblx0ICAgIHg6IF8ubWluKGZyYW1lcy5tYXAoVXRpbHMuZnJhbWVHZXRNaW5YKSksXG5cdCAgICB5OiBfLm1pbihmcmFtZXMubWFwKFV0aWxzLmZyYW1lR2V0TWluWSkpXG5cdCAgfTtcblx0ICBmcmFtZS53aWR0aCA9IF8ubWF4KGZyYW1lcy5tYXAoVXRpbHMuZnJhbWVHZXRNYXhYKSkgLSBmcmFtZS54O1xuXHQgIGZyYW1lLmhlaWdodCA9IF8ubWF4KGZyYW1lcy5tYXAoVXRpbHMuZnJhbWVHZXRNYXhZKSkgLSBmcmFtZS55O1xuXHQgIHJldHVybiBmcmFtZTtcblx0fTtcblx0XG5cdFV0aWxzLmZyYW1lUG9pbnRGb3JPcmlnaW4gPSBmdW5jdGlvbihmcmFtZSwgb3JpZ2luWCwgb3JpZ2luWSkge1xuXHQgIHJldHVybiBmcmFtZSA9IHtcblx0ICAgIHg6IGZyYW1lLnggKyAob3JpZ2luWCAqIGZyYW1lLndpZHRoKSxcblx0ICAgIHk6IGZyYW1lLnkgKyAob3JpZ2luWSAqIGZyYW1lLmhlaWdodCksXG5cdCAgICB3aWR0aDogZnJhbWUud2lkdGgsXG5cdCAgICBoZWlnaHQ6IGZyYW1lLmhlaWdodFxuXHQgIH07XG5cdH07XG5cdFxuXHRVdGlscy5mcmFtZUluc2V0ID0gZnVuY3Rpb24oZnJhbWUsIGluc2V0KSB7XG5cdCAgaWYgKF8uaXNOdW1iZXIoaW5zZXQpKSB7XG5cdCAgICBpbnNldCA9IHtcblx0ICAgICAgdG9wOiBpbnNldCxcblx0ICAgICAgcmlnaHQ6IGluc2V0LFxuXHQgICAgICBib3R0b206IGluc2V0LFxuXHQgICAgICBsZWZ0OiBpbnNldFxuXHQgICAgfTtcblx0ICB9XG5cdCAgcmV0dXJuIGZyYW1lID0ge1xuXHQgICAgeDogZnJhbWUueCArIGluc2V0LmxlZnQsXG5cdCAgICB5OiBmcmFtZS55ICsgaW5zZXQudG9wLFxuXHQgICAgd2lkdGg6IGZyYW1lLndpZHRoIC0gaW5zZXQubGVmdCAtIGluc2V0LnJpZ2h0LFxuXHQgICAgaGVpZ2h0OiBmcmFtZS5oZWlnaHQgLSBpbnNldC50b3AgLSBpbnNldC5ib3R0b21cblx0ICB9O1xuXHR9O1xuXHRcblx0VXRpbHMuZnJhbWVTb3J0QnlBYnNvbHV0ZURpc3RhbmNlID0gZnVuY3Rpb24ocG9pbnQsIGZyYW1lcywgb3JpZ2luWCwgb3JpZ2luWSkge1xuXHQgIHZhciBkaXN0YW5jZTtcblx0ICBpZiAob3JpZ2luWCA9PSBudWxsKSB7XG5cdCAgICBvcmlnaW5YID0gMDtcblx0ICB9XG5cdCAgaWYgKG9yaWdpblkgPT0gbnVsbCkge1xuXHQgICAgb3JpZ2luWSA9IDA7XG5cdCAgfVxuXHQgIGRpc3RhbmNlID0gZnVuY3Rpb24oZnJhbWUpIHtcblx0ICAgIHZhciByZXN1bHQ7XG5cdCAgICByZXN1bHQgPSBVdGlscy5wb2ludERlbHRhKHBvaW50LCBVdGlscy5mcmFtZVBvaW50Rm9yT3JpZ2luKGZyYW1lLCBvcmlnaW5YLCBvcmlnaW5ZKSk7XG5cdCAgICByZXN1bHQgPSBVdGlscy5wb2ludEFicyhyZXN1bHQpO1xuXHQgICAgcmVzdWx0ID0gVXRpbHMucG9pbnRUb3RhbChyZXN1bHQpO1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9O1xuXHQgIHJldHVybiBmcmFtZXMuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdCAgICByZXR1cm4gZGlzdGFuY2UoYSkgLSBkaXN0YW5jZShiKTtcblx0ICB9KTtcblx0fTtcblx0XG5cdFV0aWxzLnBvaW50SW5Qb2x5Z29uID0gZnVuY3Rpb24ocG9pbnQsIHZzKSB7XG5cdCAgdmFyIGksIGluc2lkZSwgaW50ZXJzZWN0LCBqLCB4LCB4aSwgeGosIHksIHlpLCB5ajtcblx0ICB4ID0gcG9pbnRbMF07XG5cdCAgeSA9IHBvaW50WzFdO1xuXHQgIGluc2lkZSA9IGZhbHNlO1xuXHQgIGkgPSAwO1xuXHQgIGogPSB2cy5sZW5ndGggLSAxO1xuXHQgIHdoaWxlIChpIDwgdnMubGVuZ3RoKSB7XG5cdCAgICB4aSA9IHZzW2ldWzBdO1xuXHQgICAgeWkgPSB2c1tpXVsxXTtcblx0ICAgIHhqID0gdnNbal1bMF07XG5cdCAgICB5aiA9IHZzW2pdWzFdO1xuXHQgICAgaW50ZXJzZWN0ID0gKCh5aSA+IHkgJiYgeSAhPT0geWopICYmIHlqID4geSkgJiYgeCA8ICh4aiAtIHhpKSAqICh5IC0geWkpIC8gKHlqIC0geWkpICsgeGk7XG5cdCAgICBpZiAoaW50ZXJzZWN0KSB7XG5cdCAgICAgIGluc2lkZSA9ICFpbnNpZGU7XG5cdCAgICB9XG5cdCAgICBqID0gaSsrO1xuXHQgIH1cblx0ICByZXR1cm4gaW5zaWRlO1xuXHR9O1xuXHRcblx0VXRpbHMuZnJhbWVDZW50ZXJQb2ludCA9IGZ1bmN0aW9uKGZyYW1lKSB7XG5cdCAgdmFyIHBvaW50O1xuXHQgIHJldHVybiBwb2ludCA9IHtcblx0ICAgIHg6IFV0aWxzLmZyYW1lR2V0TWlkWChmcmFtZSksXG5cdCAgICB5OiBVdGlscy5mcmFtZUdldE1pZFkoZnJhbWUpXG5cdCAgfTtcblx0fTtcblx0XG5cdFV0aWxzLnJvdGF0aW9uTm9ybWFsaXplciA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciBsYXN0VmFsdWU7XG5cdCAgbGFzdFZhbHVlID0gbnVsbDtcblx0ICByZXR1cm4gKGZ1bmN0aW9uKF90aGlzKSB7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgdmFyIGRpZmYsIG1heERpZmYsIG5UaW1lcztcblx0ICAgICAgaWYgKGxhc3RWYWx1ZSA9PSBudWxsKSB7XG5cdCAgICAgICAgbGFzdFZhbHVlID0gdmFsdWU7XG5cdCAgICAgIH1cblx0ICAgICAgZGlmZiA9IGxhc3RWYWx1ZSAtIHZhbHVlO1xuXHQgICAgICBtYXhEaWZmID0gTWF0aC5hYnMoZGlmZikgKyAxODA7XG5cdCAgICAgIG5UaW1lcyA9IE1hdGguZmxvb3IobWF4RGlmZiAvIDM2MCk7XG5cdCAgICAgIGlmIChkaWZmIDwgMTgwKSB7XG5cdCAgICAgICAgdmFsdWUgLT0gblRpbWVzICogMzYwO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChkaWZmID4gMTgwKSB7XG5cdCAgICAgICAgdmFsdWUgKz0gblRpbWVzICogMzYwO1xuXHQgICAgICB9XG5cdCAgICAgIGxhc3RWYWx1ZSA9IHZhbHVlO1xuXHQgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICB9O1xuXHQgIH0pKHRoaXMpO1xuXHR9O1xuXHRcblx0VXRpbHMuY29udmVydFBvaW50VG9Db250ZXh0ID0gZnVuY3Rpb24ocG9pbnQsIGxheWVyLCByb290Q29udGV4dCwgaW5jbHVkZUxheWVyKSB7XG5cdCAgdmFyIGFuY2VzdG9yLCBhbmNlc3RvcnMsIGxlbiwgbztcblx0ICBpZiAocG9pbnQgPT0gbnVsbCkge1xuXHQgICAgcG9pbnQgPSB7fTtcblx0ICB9XG5cdCAgaWYgKHJvb3RDb250ZXh0ID09IG51bGwpIHtcblx0ICAgIHJvb3RDb250ZXh0ID0gZmFsc2U7XG5cdCAgfVxuXHQgIGlmIChpbmNsdWRlTGF5ZXIgPT0gbnVsbCkge1xuXHQgICAgaW5jbHVkZUxheWVyID0gdHJ1ZTtcblx0ICB9XG5cdCAgcG9pbnQgPSBfLmRlZmF1bHRzKHBvaW50LCB7XG5cdCAgICB4OiAwLFxuXHQgICAgeTogMCxcblx0ICAgIHo6IDBcblx0ICB9KTtcblx0ICBhbmNlc3RvcnMgPSBsYXllci5hbmNlc3RvcnMocm9vdENvbnRleHQpO1xuXHQgIGlmIChpbmNsdWRlTGF5ZXIpIHtcblx0ICAgIGFuY2VzdG9ycy51bnNoaWZ0KGxheWVyKTtcblx0ICB9XG5cdCAgZm9yIChvID0gMCwgbGVuID0gYW5jZXN0b3JzLmxlbmd0aDsgbyA8IGxlbjsgbysrKSB7XG5cdCAgICBhbmNlc3RvciA9IGFuY2VzdG9yc1tvXTtcblx0ICAgIGlmIChhbmNlc3Rvci5mbGF0IHx8IGFuY2VzdG9yLmNsaXApIHtcblx0ICAgICAgcG9pbnQueiA9IDA7XG5cdCAgICB9XG5cdCAgICBwb2ludCA9IGFuY2VzdG9yLm1hdHJpeDNkLnBvaW50KHBvaW50KTtcblx0ICAgIGlmICghYW5jZXN0b3IucGFyZW50KSB7XG5cdCAgICAgIHBvaW50LnogPSAwO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gcG9pbnQ7XG5cdH07XG5cdFxuXHRVdGlscy5jb252ZXJ0RnJhbWVUb0NvbnRleHQgPSBmdW5jdGlvbihmcmFtZSwgbGF5ZXIsIHJvb3RDb250ZXh0LCBpbmNsdWRlTGF5ZXIpIHtcblx0ICB2YXIgY29udmVydGVkQ29ybmVycywgY29ybmVycztcblx0ICBpZiAoZnJhbWUgPT0gbnVsbCkge1xuXHQgICAgZnJhbWUgPSB7fTtcblx0ICB9XG5cdCAgaWYgKHJvb3RDb250ZXh0ID09IG51bGwpIHtcblx0ICAgIHJvb3RDb250ZXh0ID0gZmFsc2U7XG5cdCAgfVxuXHQgIGlmIChpbmNsdWRlTGF5ZXIgPT0gbnVsbCkge1xuXHQgICAgaW5jbHVkZUxheWVyID0gdHJ1ZTtcblx0ICB9XG5cdCAgZnJhbWUgPSBfLmRlZmF1bHRzKGZyYW1lLCB7XG5cdCAgICB4OiAwLFxuXHQgICAgeTogMCxcblx0ICAgIHdpZHRoOiAxMDAsXG5cdCAgICBoZWlnaHQ6IDEwMFxuXHQgIH0pO1xuXHQgIGNvcm5lcnMgPSBVdGlscy5wb2ludHNGcm9tRnJhbWUoZnJhbWUpO1xuXHQgIGNvbnZlcnRlZENvcm5lcnMgPSBjb3JuZXJzLm1hcCgoZnVuY3Rpb24oX3RoaXMpIHtcblx0ICAgIHJldHVybiBmdW5jdGlvbihwb2ludCkge1xuXHQgICAgICByZXR1cm4gVXRpbHMuY29udmVydFBvaW50VG9Db250ZXh0KHBvaW50LCBsYXllciwgcm9vdENvbnRleHQsIGluY2x1ZGVMYXllcik7XG5cdCAgICB9O1xuXHQgIH0pKHRoaXMpKTtcblx0ICByZXR1cm4gVXRpbHMuZnJhbWVGcm9tUG9pbnRzKGNvbnZlcnRlZENvcm5lcnMpO1xuXHR9O1xuXHRcblx0VXRpbHMuY29udmVydFBvaW50RnJvbUNvbnRleHQgPSBmdW5jdGlvbihwb2ludCwgbGF5ZXIsIHJvb3RDb250ZXh0LCBpbmNsdWRlTGF5ZXIpIHtcblx0ICB2YXIgYW5jZXN0b3IsIGFuY2VzdG9ycywgbGVuLCBub2RlLCBvLCBwYXJlbnQ7XG5cdCAgaWYgKHBvaW50ID09IG51bGwpIHtcblx0ICAgIHBvaW50ID0ge307XG5cdCAgfVxuXHQgIGlmIChyb290Q29udGV4dCA9PSBudWxsKSB7XG5cdCAgICByb290Q29udGV4dCA9IGZhbHNlO1xuXHQgIH1cblx0ICBpZiAoaW5jbHVkZUxheWVyID09IG51bGwpIHtcblx0ICAgIGluY2x1ZGVMYXllciA9IHRydWU7XG5cdCAgfVxuXHQgIHBvaW50ID0gXy5kZWZhdWx0cyhwb2ludCwge1xuXHQgICAgeDogMCxcblx0ICAgIHk6IDAsXG5cdCAgICB6OiAwXG5cdCAgfSk7XG5cdCAgaWYgKHJvb3RDb250ZXh0ICYmICh0eXBlb2Ygd2Via2l0Q29udmVydFBvaW50RnJvbVBhZ2VUb05vZGUgIT09IFwidW5kZWZpbmVkXCIgJiYgd2Via2l0Q29udmVydFBvaW50RnJvbVBhZ2VUb05vZGUgIT09IG51bGwpKSB7XG5cdCAgICBpZiAoaW5jbHVkZUxheWVyKSB7XG5cdCAgICAgIG5vZGUgPSBsYXllci5fZWxlbWVudDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHBhcmVudCA9IGxheWVyLnBhcmVudCB8fCBsYXllci5jb250ZXh0O1xuXHQgICAgICBub2RlID0gcGFyZW50Ll9lbGVtZW50O1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHdlYmtpdENvbnZlcnRQb2ludEZyb21QYWdlVG9Ob2RlKG5vZGUsIG5ldyBXZWJLaXRQb2ludChwb2ludC54LCBwb2ludC55KSk7XG5cdCAgfVxuXHQgIGFuY2VzdG9ycyA9IGxheWVyLmFuY2VzdG9ycyhyb290Q29udGV4dCk7XG5cdCAgYW5jZXN0b3JzLnJldmVyc2UoKTtcblx0ICBpZiAoaW5jbHVkZUxheWVyKSB7XG5cdCAgICBhbmNlc3RvcnMucHVzaChsYXllcik7XG5cdCAgfVxuXHQgIGZvciAobyA9IDAsIGxlbiA9IGFuY2VzdG9ycy5sZW5ndGg7IG8gPCBsZW47IG8rKykge1xuXHQgICAgYW5jZXN0b3IgPSBhbmNlc3RvcnNbb107XG5cdCAgICBwb2ludCA9IGFuY2VzdG9yLm1hdHJpeDNkLmludmVyc2UoKS5wb2ludChwb2ludCk7XG5cdCAgfVxuXHQgIHJldHVybiBwb2ludDtcblx0fTtcblx0XG5cdFV0aWxzLmNvbnZlcnRGcmFtZUZyb21Db250ZXh0ID0gZnVuY3Rpb24oZnJhbWUsIGxheWVyLCByb290Q29udGV4dCwgaW5jbHVkZUxheWVyKSB7XG5cdCAgdmFyIGNvbnZlcnRlZENvcm5lcnMsIGNvcm5lcnM7XG5cdCAgaWYgKGZyYW1lID09IG51bGwpIHtcblx0ICAgIGZyYW1lID0ge307XG5cdCAgfVxuXHQgIGlmIChyb290Q29udGV4dCA9PSBudWxsKSB7XG5cdCAgICByb290Q29udGV4dCA9IGZhbHNlO1xuXHQgIH1cblx0ICBpZiAoaW5jbHVkZUxheWVyID09IG51bGwpIHtcblx0ICAgIGluY2x1ZGVMYXllciA9IHRydWU7XG5cdCAgfVxuXHQgIGZyYW1lID0gXy5kZWZhdWx0cyhmcmFtZSwge1xuXHQgICAgeDogMCxcblx0ICAgIHk6IDAsXG5cdCAgICB3aWR0aDogMTAwLFxuXHQgICAgaGVpZ2h0OiAxMDBcblx0ICB9KTtcblx0ICBjb3JuZXJzID0gVXRpbHMucG9pbnRzRnJvbUZyYW1lKGZyYW1lKTtcblx0ICBjb252ZXJ0ZWRDb3JuZXJzID0gY29ybmVycy5tYXAoKGZ1bmN0aW9uKF90aGlzKSB7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24ocG9pbnQpIHtcblx0ICAgICAgcmV0dXJuIFV0aWxzLmNvbnZlcnRQb2ludEZyb21Db250ZXh0KHBvaW50LCBsYXllciwgcm9vdENvbnRleHQsIGluY2x1ZGVMYXllcik7XG5cdCAgICB9O1xuXHQgIH0pKHRoaXMpKTtcblx0ICByZXR1cm4gVXRpbHMuZnJhbWVGcm9tUG9pbnRzKGNvbnZlcnRlZENvcm5lcnMpO1xuXHR9O1xuXHRcblx0VXRpbHMuY29udmVydFBvaW50ID0gZnVuY3Rpb24oaW5wdXQsIGxheWVyQSwgbGF5ZXJCLCByb290Q29udGV4dCkge1xuXHQgIHZhciBub2RlLCBwb2ludDtcblx0ICBpZiAocm9vdENvbnRleHQgPT0gbnVsbCkge1xuXHQgICAgcm9vdENvbnRleHQgPSBmYWxzZTtcblx0ICB9XG5cdCAgcG9pbnQgPSBfLmRlZmF1bHRzKGlucHV0LCB7XG5cdCAgICB4OiAwLFxuXHQgICAgeTogMCxcblx0ICAgIHo6IDBcblx0ICB9KTtcblx0ICBpZiAobGF5ZXJBKSB7XG5cdCAgICBwb2ludCA9IFV0aWxzLmNvbnZlcnRQb2ludFRvQ29udGV4dChwb2ludCwgbGF5ZXJBLCByb290Q29udGV4dCk7XG5cdCAgfVxuXHQgIGlmIChsYXllckIgIT0gbnVsbCkge1xuXHQgICAgcmV0dXJuIFV0aWxzLmNvbnZlcnRQb2ludEZyb21Db250ZXh0KHBvaW50LCBsYXllckIsIHJvb3RDb250ZXh0KTtcblx0ICB9IGVsc2UgaWYgKChsYXllckEgIT0gbnVsbCkgJiYgcm9vdENvbnRleHQgJiYgKHR5cGVvZiB3ZWJraXRDb252ZXJ0UG9pbnRGcm9tUGFnZVRvTm9kZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3ZWJraXRDb252ZXJ0UG9pbnRGcm9tUGFnZVRvTm9kZSAhPT0gbnVsbCkpIHtcblx0ICAgIG5vZGUgPSBsYXllckEuY29udGV4dC5fZWxlbWVudDtcblx0ICAgIHJldHVybiB3ZWJraXRDb252ZXJ0UG9pbnRGcm9tUGFnZVRvTm9kZShub2RlLCBuZXcgV2ViS2l0UG9pbnQocG9pbnQueCwgcG9pbnQueSkpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICByZXR1cm4gcG9pbnQ7XG5cdCAgfVxuXHR9O1xuXHRcblx0VXRpbHMuYm91bmRpbmdGcmFtZSA9IGZ1bmN0aW9uKGxheWVyLCByb290Q29udGV4dCkge1xuXHQgIHZhciBib3VuZGluZ0ZyYW1lLCBjb250ZXh0Q29ybmVyUG9pbnRzLCBjb3JuZXJQb2ludHMsIGZyYW1lO1xuXHQgIGlmIChyb290Q29udGV4dCA9PSBudWxsKSB7XG5cdCAgICByb290Q29udGV4dCA9IHRydWU7XG5cdCAgfVxuXHQgIGZyYW1lID0ge1xuXHQgICAgeDogMCxcblx0ICAgIHk6IDAsXG5cdCAgICB3aWR0aDogbGF5ZXIud2lkdGgsXG5cdCAgICBoZWlnaHQ6IGxheWVyLmhlaWdodFxuXHQgIH07XG5cdCAgY29ybmVyUG9pbnRzID0gVXRpbHMucG9pbnRzRnJvbUZyYW1lKGZyYW1lKTtcblx0ICBjb250ZXh0Q29ybmVyUG9pbnRzID0gY29ybmVyUG9pbnRzLm1hcChmdW5jdGlvbihwb2ludCkge1xuXHQgICAgcmV0dXJuIFV0aWxzLmNvbnZlcnRQb2ludFRvQ29udGV4dChwb2ludCwgbGF5ZXIsIHJvb3RDb250ZXh0KTtcblx0ICB9KTtcblx0ICBib3VuZGluZ0ZyYW1lID0gVXRpbHMuZnJhbWVGcm9tUG9pbnRzKGNvbnRleHRDb3JuZXJQb2ludHMpO1xuXHQgIHJldHVybiBVdGlscy5waXhlbEFsaWduZWRGcmFtZShib3VuZGluZ0ZyYW1lKTtcblx0fTtcblx0XG5cdFV0aWxzLnBlcnNwZWN0aXZlUHJvamVjdGlvbk1hdHJpeCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0ICB2YXIgbSwgcDtcblx0ICBwID0gZWxlbWVudC5wZXJzcGVjdGl2ZTtcblx0ICBtID0gbmV3IE1hdHJpeCgpO1xuXHQgIGlmICgocCAhPSBudWxsKSAmJiBwICE9PSAwKSB7XG5cdCAgICBtLm0zNCA9IC0xIC8gcDtcblx0ICB9XG5cdCAgcmV0dXJuIG07XG5cdH07XG5cdFxuXHRVdGlscy5wZXJzcGVjdGl2ZU1hdHJpeCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0ICB2YXIgb3gsIG95LCBwcG07XG5cdCAgb3ggPSBlbGVtZW50LnBlcnNwZWN0aXZlT3JpZ2luWCAqIGVsZW1lbnQud2lkdGg7XG5cdCAgb3kgPSBlbGVtZW50LnBlcnNwZWN0aXZlT3JpZ2luWSAqIGVsZW1lbnQuaGVpZ2h0O1xuXHQgIHBwbSA9IFV0aWxzLnBlcnNwZWN0aXZlUHJvamVjdGlvbk1hdHJpeChlbGVtZW50KTtcblx0ICByZXR1cm4gbmV3IE1hdHJpeCgpLnRyYW5zbGF0ZShveCwgb3kpLm11bHRpcGx5KHBwbSkudHJhbnNsYXRlKC1veCwgLW95KTtcblx0fTtcblx0XG5cdFV0aWxzLmdsb2JhbExheWVycyA9IGZ1bmN0aW9uKGltcG9ydGVkTGF5ZXJzKSB7XG5cdCAgdmFyIGxheWVyLCBsYXllck5hbWU7XG5cdCAgZm9yIChsYXllck5hbWUgaW4gaW1wb3J0ZWRMYXllcnMpIHtcblx0ICAgIGxheWVyID0gaW1wb3J0ZWRMYXllcnNbbGF5ZXJOYW1lXTtcblx0ICAgIGxheWVyTmFtZSA9IGxheWVyTmFtZS5yZXBsYWNlKC9cXHMvZywgXCJcIik7XG5cdCAgICBpZiAod2luZG93Lmhhc093blByb3BlcnR5KGxheWVyTmFtZSkgJiYgIXdpbmRvdy5GcmFtZXIuX2dsb2JhbFdhcm5pbmdHaXZlbikge1xuXHQgICAgICBwcmludChcIldhcm5pbmc6IENhbm5vdCBtYWtlIGxheWVyICdcIiArIGxheWVyTmFtZSArIFwiJyBhIGdsb2JhbCwgYSB2YXJpYWJsZSB3aXRoIHRoYXQgbmFtZSBhbHJlYWR5IGV4aXN0c1wiKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHdpbmRvd1tsYXllck5hbWVdID0gbGF5ZXI7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiB3aW5kb3cuRnJhbWVyLl9nbG9iYWxXYXJuaW5nR2l2ZW4gPSB0cnVlO1xuXHR9O1xuXHRcblx0X3RleHRTaXplTm9kZSA9IG51bGw7XG5cdFxuXHRVdGlscy50ZXh0U2l6ZSA9IGZ1bmN0aW9uKHRleHQsIHN0eWxlLCBjb25zdHJhaW50cykge1xuXHQgIHZhciBmcmFtZSwgcmVjdCwgc2hvdWxkQ3JlYXRlTm9kZTtcblx0ICBpZiAoc3R5bGUgPT0gbnVsbCkge1xuXHQgICAgc3R5bGUgPSB7fTtcblx0ICB9XG5cdCAgaWYgKGNvbnN0cmFpbnRzID09IG51bGwpIHtcblx0ICAgIGNvbnN0cmFpbnRzID0ge307XG5cdCAgfVxuXHQgIHNob3VsZENyZWF0ZU5vZGUgPSAhX3RleHRTaXplTm9kZTtcblx0ICBpZiAoc2hvdWxkQ3JlYXRlTm9kZSkge1xuXHQgICAgX3RleHRTaXplTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cdCAgICBfdGV4dFNpemVOb2RlLmlkID0gXCJfdGV4dFNpemVOb2RlXCI7XG5cdCAgfVxuXHQgIF90ZXh0U2l6ZU5vZGUucmVtb3ZlQXR0cmlidXRlKFwic3R5bGVcIik7XG5cdCAgX3RleHRTaXplTm9kZS5pbm5lckhUTUwgPSB0ZXh0O1xuXHQgIHN0eWxlID0gXy5leHRlbmQoXy5jbG9uZShzdHlsZSksIHtcblx0ICAgIHBvc2l0aW9uOiBcImZpeGVkXCIsXG5cdCAgICBkaXNwbGF5OiBcImlubGluZVwiLFxuXHQgICAgdmlzaWJpbGl0eTogXCJoaWRkZW5cIixcblx0ICAgIHRvcDogXCItMTAwMDBweFwiLFxuXHQgICAgbGVmdDogXCItMTAwMDBweFwiXG5cdCAgfSk7XG5cdCAgZGVsZXRlIHN0eWxlLndpZHRoO1xuXHQgIGRlbGV0ZSBzdHlsZS5oZWlnaHQ7XG5cdCAgZGVsZXRlIHN0eWxlLmJvdHRvbTtcblx0ICBkZWxldGUgc3R5bGUucmlnaHQ7XG5cdCAgaWYgKGNvbnN0cmFpbnRzLndpZHRoKSB7XG5cdCAgICBzdHlsZS53aWR0aCA9IGNvbnN0cmFpbnRzLndpZHRoICsgXCJweFwiO1xuXHQgIH1cblx0ICBpZiAoY29uc3RyYWludHMuaGVpZ2h0KSB7XG5cdCAgICBzdHlsZS5oZWlnaHQgPSBjb25zdHJhaW50cy5oZWlnaHQgKyBcInB4XCI7XG5cdCAgfVxuXHQgIF8uZXh0ZW5kKF90ZXh0U2l6ZU5vZGUuc3R5bGUsIHN0eWxlKTtcblx0ICBpZiAoc2hvdWxkQ3JlYXRlTm9kZSkge1xuXHQgICAgaWYgKCF3aW5kb3cuZG9jdW1lbnQuYm9keSkge1xuXHQgICAgICBkb2N1bWVudC53cml0ZShfdGV4dFNpemVOb2RlLm91dGVySFRNTCk7XG5cdCAgICAgIF90ZXh0U2l6ZU5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIl90ZXh0U2l6ZU5vZGVcIik7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB3aW5kb3cuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChfdGV4dFNpemVOb2RlKTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmVjdCA9IF90ZXh0U2l6ZU5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdCAgcmV0dXJuIGZyYW1lID0ge1xuXHQgICAgd2lkdGg6IHJlY3QucmlnaHQgLSByZWN0LmxlZnQsXG5cdCAgICBoZWlnaHQ6IHJlY3QuYm90dG9tIC0gcmVjdC50b3Bcblx0ICB9O1xuXHR9O1xuXHRcblx0Xy5leHRlbmQoZXhwb3J0cywgVXRpbHMpO1xuXG5cbi8qKiovIH0sXG4vKiA1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgQmFzZUNsYXNzLCBTY3JlZW5DbGFzcyxcblx0ICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG5cdCAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXHRcblx0QmFzZUNsYXNzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KS5CYXNlQ2xhc3M7XG5cdFxuXHRTY3JlZW5DbGFzcyA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG5cdCAgZXh0ZW5kKFNjcmVlbkNsYXNzLCBzdXBlckNsYXNzKTtcblx0XG5cdCAgZnVuY3Rpb24gU2NyZWVuQ2xhc3MoKSB7XG5cdCAgICByZXR1cm4gU2NyZWVuQ2xhc3MuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgfVxuXHRcblx0ICBTY3JlZW5DbGFzcy5kZWZpbmUoXCJ3aWR0aFwiLCB7XG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gRnJhbWVyLkN1cnJlbnRDb250ZXh0LndpZHRoO1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBTY3JlZW5DbGFzcy5kZWZpbmUoXCJoZWlnaHRcIiwge1xuXHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIEZyYW1lci5DdXJyZW50Q29udGV4dC5oZWlnaHQ7XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIFNjcmVlbkNsYXNzLmRlZmluZShcInNpemVcIiwge1xuXHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIEZyYW1lci5DdXJyZW50Q29udGV4dC5zaXplO1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBTY3JlZW5DbGFzcy5kZWZpbmUoXCJmcmFtZVwiLCB7XG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gRnJhbWVyLkN1cnJlbnRDb250ZXh0LmZyYW1lO1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBTY3JlZW5DbGFzcy5kZWZpbmUoXCJjYW52YXNGcmFtZVwiLCB7XG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gRnJhbWVyLkN1cnJlbnRDb250ZXh0LmNhbnZhc0ZyYW1lO1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBTY3JlZW5DbGFzcy5kZWZpbmUoXCJiYWNrZ3JvdW5kQ29sb3JcIiwge1xuXHQgICAgaW1wb3J0YWJsZTogZmFsc2UsXG5cdCAgICBleHBvcnRhYmxlOiBmYWxzZSxcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiBGcmFtZXIuRGV2aWNlLnNjcmVlbi5iYWNrZ3JvdW5kQ29sb3I7XG5cdCAgICB9LFxuXHQgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICByZXR1cm4gRnJhbWVyLkRldmljZS5zY3JlZW4uYmFja2dyb3VuZENvbG9yID0gdmFsdWU7XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIFNjcmVlbkNsYXNzLmRlZmluZShcInBlcnNwZWN0aXZlXCIsIHtcblx0ICAgIGltcG9ydGFibGU6IGZhbHNlLFxuXHQgICAgZXhwb3J0YWJsZTogZmFsc2UsXG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gRnJhbWVyLkN1cnJlbnRDb250ZXh0LnBlcnNwZWN0aXZlO1xuXHQgICAgfSxcblx0ICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgcmV0dXJuIEZyYW1lci5DdXJyZW50Q29udGV4dC5wZXJzcGVjdGl2ZSA9IHZhbHVlO1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBTY3JlZW5DbGFzcy5kZWZpbmUoXCJwZXJzcGVjdGl2ZU9yaWdpblhcIiwge1xuXHQgICAgaW1wb3J0YWJsZTogZmFsc2UsXG5cdCAgICBleHBvcnRhYmxlOiBmYWxzZSxcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiBGcmFtZXIuQ3VycmVudENvbnRleHQucGVyc3BlY3RpdmVPcmlnaW5YO1xuXHQgICAgfSxcblx0ICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgcmV0dXJuIEZyYW1lci5DdXJyZW50Q29udGV4dC5wZXJzcGVjdGl2ZU9yaWdpblggPSB2YWx1ZTtcblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgU2NyZWVuQ2xhc3MuZGVmaW5lKFwicGVyc3BlY3RpdmVPcmlnaW5ZXCIsIHtcblx0ICAgIGltcG9ydGFibGU6IGZhbHNlLFxuXHQgICAgZXhwb3J0YWJsZTogZmFsc2UsXG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gRnJhbWVyLkN1cnJlbnRDb250ZXh0LnBlcnNwZWN0aXZlT3JpZ2luWTtcblx0ICAgIH0sXG5cdCAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgIHJldHVybiBGcmFtZXIuQ3VycmVudENvbnRleHQucGVyc3BlY3RpdmVPcmlnaW5ZID0gdmFsdWU7XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIFNjcmVlbkNsYXNzLnByb3RvdHlwZS50b0luc3BlY3QgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciByb3VuZDtcblx0ICAgIHJvdW5kID0gZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgaWYgKHBhcnNlSW50KHZhbHVlKSA9PT0gdmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBVdGlscy5yb3VuZCh2YWx1ZSwgMSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFwiPFNjcmVlbiBcIiArIChyb3VuZCh0aGlzLndpZHRoKSkgKyBcInhcIiArIChyb3VuZCh0aGlzLmhlaWdodCkpICsgXCI+XCI7XG5cdCAgfTtcblx0XG5cdCAgU2NyZWVuQ2xhc3MucHJvdG90eXBlLm9uRWRnZVN3aXBlID0gZnVuY3Rpb24oY2IpIHtcblx0ICAgIHJldHVybiB0aGlzLm9uKEV2ZW50cy5FZGdlU3dpcGUsIGNiKTtcblx0ICB9O1xuXHRcblx0ICBTY3JlZW5DbGFzcy5wcm90b3R5cGUub25FZGdlU3dpcGVTdGFydCA9IGZ1bmN0aW9uKGNiKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vbihFdmVudHMuRWRnZVN3aXBlU3RhcnQsIGNiKTtcblx0ICB9O1xuXHRcblx0ICBTY3JlZW5DbGFzcy5wcm90b3R5cGUub25FZGdlU3dpcGVFbmQgPSBmdW5jdGlvbihjYikge1xuXHQgICAgcmV0dXJuIHRoaXMub24oRXZlbnRzLkVkZ2VTd2lwZUVuZCwgY2IpO1xuXHQgIH07XG5cdFxuXHQgIFNjcmVlbkNsYXNzLnByb3RvdHlwZS5vbkVkZ2VTd2lwZVRvcCA9IGZ1bmN0aW9uKGNiKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vbihFdmVudHMuRWRnZVN3aXBlVG9wLCBjYik7XG5cdCAgfTtcblx0XG5cdCAgU2NyZWVuQ2xhc3MucHJvdG90eXBlLm9uRWRnZVN3aXBlVG9wU3RhcnQgPSBmdW5jdGlvbihjYikge1xuXHQgICAgcmV0dXJuIHRoaXMub24oRXZlbnRzLkVkZ2VTd2lwZVRvcFN0YXJ0LCBjYik7XG5cdCAgfTtcblx0XG5cdCAgU2NyZWVuQ2xhc3MucHJvdG90eXBlLm9uRWRnZVN3aXBlVG9wRW5kID0gZnVuY3Rpb24oY2IpIHtcblx0ICAgIHJldHVybiB0aGlzLm9uKEV2ZW50cy5FZGdlU3dpcGVUb3BFbmQsIGNiKTtcblx0ICB9O1xuXHRcblx0ICBTY3JlZW5DbGFzcy5wcm90b3R5cGUub25FZGdlU3dpcGVSaWdodCA9IGZ1bmN0aW9uKGNiKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vbihFdmVudHMuRWRnZVN3aXBlUmlnaHQsIGNiKTtcblx0ICB9O1xuXHRcblx0ICBTY3JlZW5DbGFzcy5wcm90b3R5cGUub25FZGdlU3dpcGVSaWdodFN0YXJ0ID0gZnVuY3Rpb24oY2IpIHtcblx0ICAgIHJldHVybiB0aGlzLm9uKEV2ZW50cy5FZGdlU3dpcGVSaWdodFN0YXJ0LCBjYik7XG5cdCAgfTtcblx0XG5cdCAgU2NyZWVuQ2xhc3MucHJvdG90eXBlLm9uRWRnZVN3aXBlUmlnaHRFbmQgPSBmdW5jdGlvbihjYikge1xuXHQgICAgcmV0dXJuIHRoaXMub24oRXZlbnRzLkVkZ2VTd2lwZVJpZ2h0RW5kLCBjYik7XG5cdCAgfTtcblx0XG5cdCAgU2NyZWVuQ2xhc3MucHJvdG90eXBlLm9uRWRnZVN3aXBlQm90dG9tID0gZnVuY3Rpb24oY2IpIHtcblx0ICAgIHJldHVybiB0aGlzLm9uKEV2ZW50cy5FZGdlU3dpcGVCb3R0b20sIGNiKTtcblx0ICB9O1xuXHRcblx0ICBTY3JlZW5DbGFzcy5wcm90b3R5cGUub25FZGdlU3dpcGVCb3R0b21TdGFydCA9IGZ1bmN0aW9uKGNiKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vbihFdmVudHMuRWRnZVN3aXBlQm90dG9tU3RhcnQsIGNiKTtcblx0ICB9O1xuXHRcblx0ICBTY3JlZW5DbGFzcy5wcm90b3R5cGUub25FZGdlU3dpcGVCb3R0b21FbmQgPSBmdW5jdGlvbihjYikge1xuXHQgICAgcmV0dXJuIHRoaXMub24oRXZlbnRzLkVkZ2VTd2lwZUJvdHRvbUVuZCwgY2IpO1xuXHQgIH07XG5cdFxuXHQgIFNjcmVlbkNsYXNzLnByb3RvdHlwZS5vbkVkZ2VTd2lwZUxlZnQgPSBmdW5jdGlvbihjYikge1xuXHQgICAgcmV0dXJuIHRoaXMub24oRXZlbnRzLkVkZ2VTd2lwZUxlZnQsIGNiKTtcblx0ICB9O1xuXHRcblx0ICBTY3JlZW5DbGFzcy5wcm90b3R5cGUub25FZGdlU3dpcGVMZWZ0U3RhcnQgPSBmdW5jdGlvbihjYikge1xuXHQgICAgcmV0dXJuIHRoaXMub24oRXZlbnRzLkVkZ2VTd2lwZUxlZnRTdGFydCwgY2IpO1xuXHQgIH07XG5cdFxuXHQgIFNjcmVlbkNsYXNzLnByb3RvdHlwZS5vbkVkZ2VTd2lwZUxlZnRFbmQgPSBmdW5jdGlvbihjYikge1xuXHQgICAgcmV0dXJuIHRoaXMub24oRXZlbnRzLkVkZ2VTd2lwZUxlZnRFbmQsIGNiKTtcblx0ICB9O1xuXHRcblx0ICByZXR1cm4gU2NyZWVuQ2xhc3M7XG5cdFxuXHR9KShCYXNlQ2xhc3MpO1xuXHRcblx0ZXhwb3J0cy5TY3JlZW4gPSBuZXcgU2NyZWVuQ2xhc3M7XG5cblxuLyoqKi8gfSxcbi8qIDYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBDb3VudGVyS2V5LCBEZWZpbmVkUHJvcGVydGllc0tleSwgRGVmaW5lZFByb3BlcnRpZXNWYWx1ZXNLZXksIEV2ZW50RW1pdHRlciwgVXRpbHMsIF8sIGNhcGl0YWxpemVGaXJzdExldHRlcixcblx0ICBiaW5kID0gZnVuY3Rpb24oZm4sIG1lKXsgcmV0dXJuIGZ1bmN0aW9uKCl7IHJldHVybiBmbi5hcHBseShtZSwgYXJndW1lbnRzKTsgfTsgfSxcblx0ICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG5cdCAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXHRcblx0XyA9IF9fd2VicGFja19yZXF1aXJlX18oMSkuXztcblx0XG5cdFV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0XG5cdEV2ZW50RW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oNykuRXZlbnRFbWl0dGVyO1xuXHRcblx0Q291bnRlcktleSA9IFwiX09iamVjdENvdW50ZXJcIjtcblx0XG5cdERlZmluZWRQcm9wZXJ0aWVzS2V5ID0gXCJfRGVmaW5lZFByb3BlcnRpZXNLZXlcIjtcblx0XG5cdERlZmluZWRQcm9wZXJ0aWVzVmFsdWVzS2V5ID0gXCJfRGVmaW5lZFByb3BlcnRpZXNWYWx1ZXNLZXlcIjtcblx0XG5cdGNhcGl0YWxpemVGaXJzdExldHRlciA9IGZ1bmN0aW9uKHN0cmluZykge1xuXHQgIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSk7XG5cdH07XG5cdFxuXHRleHBvcnRzLkJhc2VDbGFzcyA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG5cdCAgZXh0ZW5kKEJhc2VDbGFzcywgc3VwZXJDbGFzcyk7XG5cdFxuXHQgIEJhc2VDbGFzcy5kZWZpbmUgPSBmdW5jdGlvbihwcm9wZXJ0eU5hbWUsIGRlc2NyaXB0b3IpIHtcblx0ICAgIHZhciBnZXROYW1lLCBpLCBqLCBsZW4sIHJlZiwgc2V0TmFtZTtcblx0ICAgIHJlZiA9IFtcImVudW1lcmFibGVcIiwgXCJleHBvcnRhYmxlXCIsIFwiaW1wb3J0YWJsZVwiXTtcblx0ICAgIGZvciAoaiA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGogPCBsZW47IGorKykge1xuXHQgICAgICBpID0gcmVmW2pdO1xuXHQgICAgICBpZiAoZGVzY3JpcHRvci5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHQgICAgICAgIGlmICghXy5pc0Jvb2xlYW4oZGVzY3JpcHRvcltpXSkpIHtcblx0ICAgICAgICAgIHRocm93IEVycm9yKFwid29vcHMgXCIgKyBwcm9wZXJ0eU5hbWUgKyBcIiBcIiArIGRlc2NyaXB0b3JbaV0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKHRoaXMgIT09IEJhc2VDbGFzcykge1xuXHQgICAgICBkZXNjcmlwdG9yLnByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZTtcblx0ICAgICAgaWYgKGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9PSBudWxsKSB7XG5cdCAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gdHJ1ZTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoZGVzY3JpcHRvci5leHBvcnRhYmxlID09IG51bGwpIHtcblx0ICAgICAgICBkZXNjcmlwdG9yLmV4cG9ydGFibGUgPSB0cnVlO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChkZXNjcmlwdG9yLmltcG9ydGFibGUgPT0gbnVsbCkge1xuXHQgICAgICAgIGRlc2NyaXB0b3IuaW1wb3J0YWJsZSA9IHRydWU7XG5cdCAgICAgIH1cblx0ICAgICAgZGVzY3JpcHRvci5pbXBvcnRhYmxlID0gZGVzY3JpcHRvci5pbXBvcnRhYmxlICYmIGRlc2NyaXB0b3Iuc2V0O1xuXHQgICAgICBpZiAoZGVzY3JpcHRvci5leHBvcnRhYmxlIHx8IGRlc2NyaXB0b3IuaW1wb3J0YWJsZSkge1xuXHQgICAgICAgIGlmICh0aGlzW0RlZmluZWRQcm9wZXJ0aWVzS2V5XSA9PSBudWxsKSB7XG5cdCAgICAgICAgICB0aGlzW0RlZmluZWRQcm9wZXJ0aWVzS2V5XSA9IHt9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzW0RlZmluZWRQcm9wZXJ0aWVzS2V5XVtwcm9wZXJ0eU5hbWVdID0gZGVzY3JpcHRvcjtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgZ2V0TmFtZSA9IFwiZ2V0XCIgKyAoY2FwaXRhbGl6ZUZpcnN0TGV0dGVyKHByb3BlcnR5TmFtZSkpO1xuXHQgICAgdGhpcy5wcm90b3R5cGVbZ2V0TmFtZV0gPSBkZXNjcmlwdG9yLmdldDtcblx0ICAgIGRlc2NyaXB0b3IuZ2V0ID0gdGhpcy5wcm90b3R5cGVbZ2V0TmFtZV07XG5cdCAgICBpZiAoZGVzY3JpcHRvci5zZXQpIHtcblx0ICAgICAgc2V0TmFtZSA9IFwic2V0XCIgKyAoY2FwaXRhbGl6ZUZpcnN0TGV0dGVyKHByb3BlcnR5TmFtZSkpO1xuXHQgICAgICB0aGlzLnByb3RvdHlwZVtzZXROYW1lXSA9IGRlc2NyaXB0b3Iuc2V0O1xuXHQgICAgICBkZXNjcmlwdG9yLnNldCA9IHRoaXMucHJvdG90eXBlW3NldE5hbWVdO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLnByb3RvdHlwZSwgcHJvcGVydHlOYW1lLCBkZXNjcmlwdG9yKTtcblx0ICB9O1xuXHRcblx0ICBCYXNlQ2xhc3Muc2ltcGxlUHJvcGVydHkgPSBmdW5jdGlvbihuYW1lLCBmYWxsYmFjaywgb3B0aW9ucykge1xuXHQgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuXHQgICAgICBvcHRpb25zID0ge307XG5cdCAgICB9XG5cdCAgICByZXR1cm4gXy5leHRlbmQob3B0aW9ucywge1xuXHQgICAgICBcImRlZmF1bHRcIjogZmFsbGJhY2ssXG5cdCAgICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2dldFByb3BlcnR5VmFsdWUobmFtZSk7XG5cdCAgICAgIH0sXG5cdCAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fc2V0UHJvcGVydHlWYWx1ZShuYW1lLCB2YWx1ZSk7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgIH07XG5cdFxuXHQgIEJhc2VDbGFzcy5wcm94eVByb3BlcnR5ID0gZnVuY3Rpb24oa2V5UGF0aCwgb3B0aW9ucykge1xuXHQgICAgdmFyIG9iamVjdEtleTtcblx0ICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcblx0ICAgICAgb3B0aW9ucyA9IHt9O1xuXHQgICAgfVxuXHQgICAgb2JqZWN0S2V5ID0ga2V5UGF0aC5zcGxpdChcIi5cIilbMF07XG5cdCAgICByZXR1cm4gXy5leHRlbmQob3B0aW9ucywge1xuXHQgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIGlmICghXy5pc09iamVjdCh0aGlzW29iamVjdEtleV0pKSB7XG5cdCAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBVdGlscy5nZXRWYWx1ZUZvcktleVBhdGgodGhpcywga2V5UGF0aCk7XG5cdCAgICAgIH0sXG5cdCAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgICBpZiAoIV8uaXNPYmplY3QodGhpc1tvYmplY3RLZXldKSkge1xuXHQgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gVXRpbHMuc2V0VmFsdWVGb3JLZXlQYXRoKHRoaXMsIGtleVBhdGgsIHZhbHVlKTtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgfTtcblx0XG5cdCAgQmFzZUNsYXNzLnByb3RvdHlwZS5fc2V0UHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uKGssIHYpIHtcblx0ICAgIHJldHVybiB0aGlzW0RlZmluZWRQcm9wZXJ0aWVzVmFsdWVzS2V5XVtrXSA9IHY7XG5cdCAgfTtcblx0XG5cdCAgQmFzZUNsYXNzLnByb3RvdHlwZS5fZ2V0UHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uKGspIHtcblx0ICAgIHJldHVybiBVdGlscy52YWx1ZU9yRGVmYXVsdCh0aGlzW0RlZmluZWRQcm9wZXJ0aWVzVmFsdWVzS2V5XVtrXSwgdGhpcy5fZ2V0UHJvcGVydHlEZWZhdWx0VmFsdWUoaykpO1xuXHQgIH07XG5cdFxuXHQgIEJhc2VDbGFzcy5wcm90b3R5cGUuX2dldFByb3BlcnR5RGVmYXVsdFZhbHVlID0gZnVuY3Rpb24oaykge1xuXHQgICAgcmV0dXJuIHRoaXMuX3Byb3BlcnR5TGlzdCgpW2tdW1wiZGVmYXVsdFwiXTtcblx0ICB9O1xuXHRcblx0ICBCYXNlQ2xhc3MucHJvdG90eXBlLl9wcm9wZXJ0eUxpc3QgPSBmdW5jdGlvbigpIHtcblx0ICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yW0RlZmluZWRQcm9wZXJ0aWVzS2V5XTtcblx0ICB9O1xuXHRcblx0ICBCYXNlQ2xhc3MucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbigpIHtcblx0ICAgIHJldHVybiBfLmtleXModGhpcy5wcm9wcyk7XG5cdCAgfTtcblx0XG5cdCAgQmFzZUNsYXNzLmRlZmluZShcInByb3BzXCIsIHtcblx0ICAgIGltcG9ydGFibGU6IGZhbHNlLFxuXHQgICAgZXhwb3J0YWJsZTogZmFsc2UsXG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICB2YXIgZGVzY3JpcHRvciwga2V5LCBrZXlzLCBwcm9wZXJ0eUxpc3Q7XG5cdCAgICAgIGtleXMgPSBbXTtcblx0ICAgICAgcHJvcGVydHlMaXN0ID0gdGhpcy5fcHJvcGVydHlMaXN0KCk7XG5cdCAgICAgIGZvciAoa2V5IGluIHByb3BlcnR5TGlzdCkge1xuXHQgICAgICAgIGRlc2NyaXB0b3IgPSBwcm9wZXJ0eUxpc3Rba2V5XTtcblx0ICAgICAgICBpZiAoZGVzY3JpcHRvci5leHBvcnRhYmxlKSB7XG5cdCAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIF8ucGljayh0aGlzLCBrZXlzKTtcblx0ICAgIH0sXG5cdCAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgIHZhciBrLCBwcm9wZXJ0eUxpc3QsIHJlZiwgcmVzdWx0cywgdjtcblx0ICAgICAgcHJvcGVydHlMaXN0ID0gdGhpcy5fcHJvcGVydHlMaXN0KCk7XG5cdCAgICAgIHJlc3VsdHMgPSBbXTtcblx0ICAgICAgZm9yIChrIGluIHZhbHVlKSB7XG5cdCAgICAgICAgdiA9IHZhbHVlW2tdO1xuXHQgICAgICAgIGlmICgocmVmID0gcHJvcGVydHlMaXN0W2tdKSAhPSBudWxsID8gcmVmLmltcG9ydGFibGUgOiB2b2lkIDApIHtcblx0ICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzW2tdID0gdik7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHJlc3VsdHMucHVzaCh2b2lkIDApO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gcmVzdWx0cztcblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgQmFzZUNsYXNzLmRlZmluZShcImlkXCIsIHtcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9pZDtcblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgQmFzZUNsYXNzLnByb3RvdHlwZS50b0luc3BlY3QgPSBmdW5jdGlvbigpIHtcblx0ICAgIHJldHVybiBcIjxcIiArIHRoaXMuY29uc3RydWN0b3IubmFtZSArIFwiIGlkOlwiICsgKHRoaXMuaWQgfHwgbnVsbCkgKyBcIj5cIjtcblx0ICB9O1xuXHRcblx0ICBCYXNlQ2xhc3MucHJvdG90eXBlLm9uQ2hhbmdlID0gZnVuY3Rpb24obmFtZSwgY2IpIHtcblx0ICAgIHJldHVybiB0aGlzLm9uKFwiY2hhbmdlOlwiICsgbmFtZSwgY2IpO1xuXHQgIH07XG5cdFxuXHQgIGZ1bmN0aW9uIEJhc2VDbGFzcyhvcHRpb25zKSB7XG5cdCAgICB0aGlzLnRvSW5zcGVjdCA9IGJpbmQodGhpcy50b0luc3BlY3QsIHRoaXMpO1xuXHQgICAgdGhpcy5fZ2V0UHJvcGVydHlWYWx1ZSA9IGJpbmQodGhpcy5fZ2V0UHJvcGVydHlWYWx1ZSwgdGhpcyk7XG5cdCAgICB0aGlzLl9zZXRQcm9wZXJ0eVZhbHVlID0gYmluZCh0aGlzLl9zZXRQcm9wZXJ0eVZhbHVlLCB0aGlzKTtcblx0ICAgIHZhciBiYXNlO1xuXHQgICAgQmFzZUNsYXNzLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgdGhpcy5fY29udGV4dCA9IHR5cGVvZiBGcmFtZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRnJhbWVyICE9PSBudWxsID8gRnJhbWVyLkN1cnJlbnRDb250ZXh0IDogdm9pZCAwO1xuXHQgICAgdGhpc1tEZWZpbmVkUHJvcGVydGllc1ZhbHVlc0tleV0gPSB7fTtcblx0ICAgIGlmICgoYmFzZSA9IHRoaXMuY29uc3RydWN0b3IpW0NvdW50ZXJLZXldID09IG51bGwpIHtcblx0ICAgICAgYmFzZVtDb3VudGVyS2V5XSA9IDA7XG5cdCAgICB9XG5cdCAgICB0aGlzLmNvbnN0cnVjdG9yW0NvdW50ZXJLZXldICs9IDE7XG5cdCAgICB0aGlzLl9pZCA9IHRoaXMuY29uc3RydWN0b3JbQ291bnRlcktleV07XG5cdCAgICB0aGlzLl9hcHBseU9wdGlvbnNBbmREZWZhdWx0cyhvcHRpb25zKTtcblx0ICB9XG5cdFxuXHQgIEJhc2VDbGFzcy5wcm90b3R5cGUuX2FwcGx5T3B0aW9uc0FuZERlZmF1bHRzID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHQgICAgdmFyIGRlc2NyaXB0b3IsIGtleSwgcmVmLCByZXN1bHRzLCB2YWx1ZTtcblx0ICAgIHJlZiA9IHRoaXMuX3Byb3BlcnR5TGlzdCgpO1xuXHQgICAgcmVzdWx0cyA9IFtdO1xuXHQgICAgZm9yIChrZXkgaW4gcmVmKSB7XG5cdCAgICAgIGRlc2NyaXB0b3IgPSByZWZba2V5XTtcblx0ICAgICAgaWYgKGRlc2NyaXB0b3Iuc2V0KSB7XG5cdCAgICAgICAgdmFsdWUgPSBVdGlscy52YWx1ZU9yRGVmYXVsdCgoZGVzY3JpcHRvci5pbXBvcnRhYmxlID8gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9uc1trZXldIDogdm9pZCAwIDogdm9pZCAwKSwgdGhpcy5fZ2V0UHJvcGVydHlEZWZhdWx0VmFsdWUoa2V5KSk7XG5cdCAgICAgICAgaWYgKCEodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09ICh2b2lkIDApKSkge1xuXHQgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXNba2V5XSA9IHZhbHVlKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJlc3VsdHMucHVzaCh2b2lkIDApO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzdWx0cztcblx0ICB9O1xuXHRcblx0ICByZXR1cm4gQmFzZUNsYXNzO1xuXHRcblx0fSkoRXZlbnRFbWl0dGVyKTtcblxuXG4vKioqLyB9LFxuLyogNyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIEV2ZW50RW1pdHRlcjMsIEV2ZW50S2V5LCBfLFxuXHQgIGV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcblx0ICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cdFxuXHRfID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKS5fO1xuXHRcblx0RXZlbnRFbWl0dGVyMyA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cdFxuXHRFdmVudEtleSA9IFwiX2V2ZW50c1wiO1xuXHRcblx0ZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuXHQgIGV4dGVuZChFdmVudEVtaXR0ZXIsIHN1cGVyQ2xhc3MpO1xuXHRcblx0ICBmdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG5cdCAgICByZXR1cm4gRXZlbnRFbWl0dGVyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgIH1cblx0XG5cdCAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgcmV0dXJuIF8ua2V5cyh0aGlzW0V2ZW50S2V5XSk7XG5cdCAgfTtcblx0XG5cdCAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudE5hbWUpIHtcblx0ICAgIHZhciBldmVudE5hbWVzLCBpLCBsZW4sIGxpc3RlbmVyLCByZXN1bHRzO1xuXHQgICAgaWYgKGV2ZW50TmFtZSkge1xuXHQgICAgICBldmVudE5hbWVzID0gW2V2ZW50TmFtZV07XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBldmVudE5hbWVzID0gdGhpcy5saXN0ZW5lckV2ZW50cygpO1xuXHQgICAgfVxuXHQgICAgcmVzdWx0cyA9IFtdO1xuXHQgICAgZm9yIChpID0gMCwgbGVuID0gZXZlbnROYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHQgICAgICBldmVudE5hbWUgPSBldmVudE5hbWVzW2ldO1xuXHQgICAgICByZXN1bHRzLnB1c2goKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIHZhciBqLCBsZW4xLCByZWYsIHJlc3VsdHMxO1xuXHQgICAgICAgIHJlZiA9IHRoaXMubGlzdGVuZXJzKGV2ZW50TmFtZSk7XG5cdCAgICAgICAgcmVzdWx0czEgPSBbXTtcblx0ICAgICAgICBmb3IgKGogPSAwLCBsZW4xID0gcmVmLmxlbmd0aDsgaiA8IGxlbjE7IGorKykge1xuXHQgICAgICAgICAgbGlzdGVuZXIgPSByZWZbal07XG5cdCAgICAgICAgICByZXN1bHRzMS5wdXNoKHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVzdWx0czE7XG5cdCAgICAgIH0pLmNhbGwodGhpcykpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdHM7XG5cdCAgfTtcblx0XG5cdCAgcmV0dXJuIEV2ZW50RW1pdHRlcjtcblx0XG5cdH0pKEV2ZW50RW1pdHRlcjMpO1xuXG5cbi8qKiovIH0sXG4vKiA4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHQvL1xuXHQvLyBXZSBzdG9yZSBvdXIgRUUgb2JqZWN0cyBpbiBhIHBsYWluIG9iamVjdCB3aG9zZSBwcm9wZXJ0aWVzIGFyZSBldmVudCBuYW1lcy5cblx0Ly8gSWYgYE9iamVjdC5jcmVhdGUobnVsbClgIGlzIG5vdCBzdXBwb3J0ZWQgd2UgcHJlZml4IHRoZSBldmVudCBuYW1lcyB3aXRoIGFcblx0Ly8gYH5gIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBidWlsdC1pbiBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90IG92ZXJyaWRkZW4gb3Jcblx0Ly8gdXNlZCBhcyBhbiBhdHRhY2sgdmVjdG9yLlxuXHQvLyBXZSBhbHNvIGFzc3VtZSB0aGF0IGBPYmplY3QuY3JlYXRlKG51bGwpYCBpcyBhdmFpbGFibGUgd2hlbiB0aGUgZXZlbnQgbmFtZVxuXHQvLyBpcyBhbiBFUzYgU3ltYm9sLlxuXHQvL1xuXHR2YXIgcHJlZml4ID0gdHlwZW9mIE9iamVjdC5jcmVhdGUgIT09ICdmdW5jdGlvbicgPyAnficgOiBmYWxzZTtcblx0XG5cdC8qKlxuXHQgKiBSZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSBFdmVudEVtaXR0ZXIgZnVuY3Rpb24uXG5cdCAqXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEV2ZW50IGhhbmRsZXIgdG8gYmUgY2FsbGVkLlxuXHQgKiBAcGFyYW0ge01peGVkfSBjb250ZXh0IENvbnRleHQgZm9yIGZ1bmN0aW9uIGV4ZWN1dGlvbi5cblx0ICogQHBhcmFtIHtCb29sZWFufSBvbmNlIE9ubHkgZW1pdCBvbmNlXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gRUUoZm4sIGNvbnRleHQsIG9uY2UpIHtcblx0ICB0aGlzLmZuID0gZm47XG5cdCAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcblx0ICB0aGlzLm9uY2UgPSBvbmNlIHx8IGZhbHNlO1xuXHR9XG5cdFxuXHQvKipcblx0ICogTWluaW1hbCBFdmVudEVtaXR0ZXIgaW50ZXJmYWNlIHRoYXQgaXMgbW9sZGVkIGFnYWluc3QgdGhlIE5vZGUuanNcblx0ICogRXZlbnRFbWl0dGVyIGludGVyZmFjZS5cblx0ICpcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRmdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7IC8qIE5vdGhpbmcgdG8gc2V0ICovIH1cblx0XG5cdC8qKlxuXHQgKiBIb2xkcyB0aGUgYXNzaWduZWQgRXZlbnRFbWl0dGVycyBieSBuYW1lLlxuXHQgKlxuXHQgKiBAdHlwZSB7T2JqZWN0fVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuXHRcblx0LyoqXG5cdCAqIFJldHVybiBhIGxpc3Qgb2YgYXNzaWduZWQgZXZlbnQgbGlzdGVuZXJzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgVGhlIGV2ZW50cyB0aGF0IHNob3VsZCBiZSBsaXN0ZWQuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gZXhpc3RzIFdlIG9ubHkgbmVlZCB0byBrbm93IGlmIHRoZXJlIGFyZSBsaXN0ZW5lcnMuXG5cdCAqIEByZXR1cm5zIHtBcnJheXxCb29sZWFufVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnMoZXZlbnQsIGV4aXN0cykge1xuXHQgIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG5cdCAgICAsIGF2YWlsYWJsZSA9IHRoaXMuX2V2ZW50cyAmJiB0aGlzLl9ldmVudHNbZXZ0XTtcblx0XG5cdCAgaWYgKGV4aXN0cykgcmV0dXJuICEhYXZhaWxhYmxlO1xuXHQgIGlmICghYXZhaWxhYmxlKSByZXR1cm4gW107XG5cdCAgaWYgKGF2YWlsYWJsZS5mbikgcmV0dXJuIFthdmFpbGFibGUuZm5dO1xuXHRcblx0ICBmb3IgKHZhciBpID0gMCwgbCA9IGF2YWlsYWJsZS5sZW5ndGgsIGVlID0gbmV3IEFycmF5KGwpOyBpIDwgbDsgaSsrKSB7XG5cdCAgICBlZVtpXSA9IGF2YWlsYWJsZVtpXS5mbjtcblx0ICB9XG5cdFxuXHQgIHJldHVybiBlZTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBFbWl0IGFuIGV2ZW50IHRvIGFsbCByZWdpc3RlcmVkIGV2ZW50IGxpc3RlbmVycy5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IFRoZSBuYW1lIG9mIHRoZSBldmVudC5cblx0ICogQHJldHVybnMge0Jvb2xlYW59IEluZGljYXRpb24gaWYgd2UndmUgZW1pdHRlZCBhbiBldmVudC5cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cdEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnQsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuXHQgIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXHRcblx0ICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiBmYWxzZTtcblx0XG5cdCAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdXG5cdCAgICAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcblx0ICAgICwgYXJnc1xuXHQgICAgLCBpO1xuXHRcblx0ICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGxpc3RlbmVycy5mbikge1xuXHQgICAgaWYgKGxpc3RlbmVycy5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnMuZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cdFxuXHQgICAgc3dpdGNoIChsZW4pIHtcblx0ICAgICAgY2FzZSAxOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQpLCB0cnVlO1xuXHQgICAgICBjYXNlIDI6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEpLCB0cnVlO1xuXHQgICAgICBjYXNlIDM6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyKSwgdHJ1ZTtcblx0ICAgICAgY2FzZSA0OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMpLCB0cnVlO1xuXHQgICAgICBjYXNlIDU6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQpLCB0cnVlO1xuXHQgICAgICBjYXNlIDY6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQsIGE1KSwgdHJ1ZTtcblx0ICAgIH1cblx0XG5cdCAgICBmb3IgKGkgPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGkgPCBsZW47IGkrKykge1xuXHQgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblx0ICAgIH1cblx0XG5cdCAgICBsaXN0ZW5lcnMuZm4uYXBwbHkobGlzdGVuZXJzLmNvbnRleHQsIGFyZ3MpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB2YXIgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aFxuXHQgICAgICAsIGo7XG5cdFxuXHQgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGlmIChsaXN0ZW5lcnNbaV0ub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzW2ldLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXHRcblx0ICAgICAgc3dpdGNoIChsZW4pIHtcblx0ICAgICAgICBjYXNlIDE6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0KTsgYnJlYWs7XG5cdCAgICAgICAgY2FzZSAyOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEpOyBicmVhaztcblx0ICAgICAgICBjYXNlIDM6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIpOyBicmVhaztcblx0ICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgaWYgKCFhcmdzKSBmb3IgKGogPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGogPCBsZW47IGorKykge1xuXHQgICAgICAgICAgICBhcmdzW2ogLSAxXSA9IGFyZ3VtZW50c1tqXTtcblx0ICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uYXBwbHkobGlzdGVuZXJzW2ldLmNvbnRleHQsIGFyZ3MpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHRcblx0ICByZXR1cm4gdHJ1ZTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZWdpc3RlciBhIG5ldyBFdmVudExpc3RlbmVyIGZvciB0aGUgZ2l2ZW4gZXZlbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBOYW1lIG9mIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtGdW5jdG9ufSBmbiBDYWxsYmFjayBmdW5jdGlvbi5cblx0ICogQHBhcmFtIHtNaXhlZH0gY29udGV4dCBUaGUgY29udGV4dCBvZiB0aGUgZnVuY3Rpb24uXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZlbnQsIGZuLCBjb250ZXh0KSB7XG5cdCAgdmFyIGxpc3RlbmVyID0gbmV3IEVFKGZuLCBjb250ZXh0IHx8IHRoaXMpXG5cdCAgICAsIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cdFxuXHQgIGlmICghdGhpcy5fZXZlbnRzKSB0aGlzLl9ldmVudHMgPSBwcmVmaXggPyB7fSA6IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdCAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgdGhpcy5fZXZlbnRzW2V2dF0gPSBsaXN0ZW5lcjtcblx0ICBlbHNlIHtcblx0ICAgIGlmICghdGhpcy5fZXZlbnRzW2V2dF0uZm4pIHRoaXMuX2V2ZW50c1tldnRdLnB1c2gobGlzdGVuZXIpO1xuXHQgICAgZWxzZSB0aGlzLl9ldmVudHNbZXZ0XSA9IFtcblx0ICAgICAgdGhpcy5fZXZlbnRzW2V2dF0sIGxpc3RlbmVyXG5cdCAgICBdO1xuXHQgIH1cblx0XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQWRkIGFuIEV2ZW50TGlzdGVuZXIgdGhhdCdzIG9ubHkgY2FsbGVkIG9uY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBOYW1lIG9mIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gQ2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqIEBwYXJhbSB7TWl4ZWR9IGNvbnRleHQgVGhlIGNvbnRleHQgb2YgdGhlIGZ1bmN0aW9uLlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZShldmVudCwgZm4sIGNvbnRleHQpIHtcblx0ICB2YXIgbGlzdGVuZXIgPSBuZXcgRUUoZm4sIGNvbnRleHQgfHwgdGhpcywgdHJ1ZSlcblx0ICAgICwgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblx0XG5cdCAgaWYgKCF0aGlzLl9ldmVudHMpIHRoaXMuX2V2ZW50cyA9IHByZWZpeCA/IHt9IDogT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0ICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSB0aGlzLl9ldmVudHNbZXZ0XSA9IGxpc3RlbmVyO1xuXHQgIGVsc2Uge1xuXHQgICAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XS5mbikgdGhpcy5fZXZlbnRzW2V2dF0ucHVzaChsaXN0ZW5lcik7XG5cdCAgICBlbHNlIHRoaXMuX2V2ZW50c1tldnRdID0gW1xuXHQgICAgICB0aGlzLl9ldmVudHNbZXZ0XSwgbGlzdGVuZXJcblx0ICAgIF07XG5cdCAgfVxuXHRcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgVGhlIGV2ZW50IHdlIHdhbnQgdG8gcmVtb3ZlLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgdGhhdCB3ZSBuZWVkIHRvIGZpbmQuXG5cdCAqIEBwYXJhbSB7TWl4ZWR9IGNvbnRleHQgT25seSByZW1vdmUgbGlzdGVuZXJzIG1hdGNoaW5nIHRoaXMgY29udGV4dC5cblx0ICogQHBhcmFtIHtCb29sZWFufSBvbmNlIE9ubHkgcmVtb3ZlIG9uY2UgbGlzdGVuZXJzLlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuXHQgIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXHRcblx0ICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiB0aGlzO1xuXHRcblx0ICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF1cblx0ICAgICwgZXZlbnRzID0gW107XG5cdFxuXHQgIGlmIChmbikge1xuXHQgICAgaWYgKGxpc3RlbmVycy5mbikge1xuXHQgICAgICBpZiAoXG5cdCAgICAgICAgICAgbGlzdGVuZXJzLmZuICE9PSBmblxuXHQgICAgICAgIHx8IChvbmNlICYmICFsaXN0ZW5lcnMub25jZSlcblx0ICAgICAgICB8fCAoY29udGV4dCAmJiBsaXN0ZW5lcnMuY29udGV4dCAhPT0gY29udGV4dClcblx0ICAgICAgKSB7XG5cdCAgICAgICAgZXZlbnRzLnB1c2gobGlzdGVuZXJzKTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuXHQgICAgICAgIGlmIChcblx0ICAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbiAhPT0gZm5cblx0ICAgICAgICAgIHx8IChvbmNlICYmICFsaXN0ZW5lcnNbaV0ub25jZSlcblx0ICAgICAgICAgIHx8IChjb250ZXh0ICYmIGxpc3RlbmVyc1tpXS5jb250ZXh0ICE9PSBjb250ZXh0KVxuXHQgICAgICAgICkge1xuXHQgICAgICAgICAgZXZlbnRzLnB1c2gobGlzdGVuZXJzW2ldKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdFxuXHQgIC8vXG5cdCAgLy8gUmVzZXQgdGhlIGFycmF5LCBvciByZW1vdmUgaXQgY29tcGxldGVseSBpZiB3ZSBoYXZlIG5vIG1vcmUgbGlzdGVuZXJzLlxuXHQgIC8vXG5cdCAgaWYgKGV2ZW50cy5sZW5ndGgpIHtcblx0ICAgIHRoaXMuX2V2ZW50c1tldnRdID0gZXZlbnRzLmxlbmd0aCA9PT0gMSA/IGV2ZW50c1swXSA6IGV2ZW50cztcblx0ICB9IGVsc2Uge1xuXHQgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1tldnRdO1xuXHQgIH1cblx0XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgb3Igb25seSB0aGUgbGlzdGVuZXJzIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgVGhlIGV2ZW50IHdhbnQgdG8gcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yLlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcblx0ICBpZiAoIXRoaXMuX2V2ZW50cykgcmV0dXJuIHRoaXM7XG5cdFxuXHQgIGlmIChldmVudCkgZGVsZXRlIHRoaXMuX2V2ZW50c1twcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XTtcblx0ICBlbHNlIHRoaXMuX2V2ZW50cyA9IHByZWZpeCA/IHt9IDogT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvL1xuXHQvLyBBbGlhcyBtZXRob2RzIG5hbWVzIGJlY2F1c2UgcGVvcGxlIHJvbGwgbGlrZSB0aGF0LlxuXHQvL1xuXHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cdEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xuXHRcblx0Ly9cblx0Ly8gVGhpcyBmdW5jdGlvbiBkb2Vzbid0IGFwcGx5IGFueW1vcmUuXG5cdC8vXG5cdEV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKCkge1xuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0Ly9cblx0Ly8gRXhwb3NlIHRoZSBwcmVmaXguXG5cdC8vXG5cdEV2ZW50RW1pdHRlci5wcmVmaXhlZCA9IHByZWZpeDtcblx0XG5cdC8vXG5cdC8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuXHQvL1xuXHRpZiAodHJ1ZSkge1xuXHQgIG1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXHR9XG5cblxuLyoqKi8gfSxcbi8qIDkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFdlYktpdENTU01hdHJpeC5wcm90b3R5cGUuc2tldyA9IGZ1bmN0aW9uKHNrZXcpIHtcblx0ICB2YXIgbSwgcmFkLCB2YWx1ZTtcblx0ICBpZiAoIXNrZXcpIHtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH1cblx0ICByYWQgPSBza2V3ICogTWF0aC5QSSAvIDE4MDtcblx0ICB2YWx1ZSA9IE1hdGgudGFuKHJhZCk7XG5cdCAgbSA9IG5ldyBXZWJLaXRDU1NNYXRyaXgoKTtcblx0ICBtLm0xMiA9IHZhbHVlO1xuXHQgIG0ubTIxID0gdmFsdWU7XG5cdCAgcmV0dXJuIHRoaXMubXVsdGlwbHkobSk7XG5cdH07XG5cdFxuXHRXZWJLaXRDU1NNYXRyaXgucHJvdG90eXBlLnBvaW50ID0gZnVuY3Rpb24ocG9pbnQpIHtcblx0ICB2YXIgcmVmLCB3LCB4LCB5LCB6O1xuXHQgIGlmIChwb2ludCA9PSBudWxsKSB7XG5cdCAgICBwb2ludCA9IHt9O1xuXHQgIH1cblx0ICByZWYgPSBfLmRlZmF1bHRzKHBvaW50LCB7XG5cdCAgICB4OiAwLFxuXHQgICAgeTogMCxcblx0ICAgIHo6IDBcblx0ICB9KSwgeCA9IHJlZi54LCB5ID0gcmVmLnksIHogPSByZWYuejtcblx0ICB3ID0gdGhpcy5tMTQgKiB4ICsgdGhpcy5tMjQgKiB5ICsgdGhpcy5tMzQgKiB6ICsgdGhpcy5tNDQ7XG5cdCAgdyA9IHcgfHwgMTtcblx0ICByZXR1cm4gcG9pbnQgPSB7XG5cdCAgICB4OiAodGhpcy5tMTEgKiB4ICsgdGhpcy5tMjEgKiB5ICsgdGhpcy5tMzEgKiB6ICsgdGhpcy5tNDEpIC8gdyxcblx0ICAgIHk6ICh0aGlzLm0xMiAqIHggKyB0aGlzLm0yMiAqIHkgKyB0aGlzLm0zMiAqIHogKyB0aGlzLm00MikgLyB3LFxuXHQgICAgejogKHRoaXMubTEzICogeCArIHRoaXMubTIzICogeSArIHRoaXMubTMzICogeiArIHRoaXMubTQzKSAvIHdcblx0ICB9O1xuXHR9O1xuXHRcblx0ZXhwb3J0cy5NYXRyaXggPSBXZWJLaXRDU1NNYXRyaXg7XG5cblxuLyoqKi8gfSxcbi8qIDEwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgQmFzZUNsYXNzLCBDb2xvck1vZGVsLCBDb2xvclR5cGUsIF8sIGJvdW5kMDEsIGNvbnZlcnRUb1BlcmNlbnRhZ2UsIGNvcnJlY3RBbHBoYSwgY3NzTmFtZXMsIGhzbFRvUmdiLCBpbnB1dERhdGEsIGlzTnVtZXJpYywgaXNPbmVQb2ludFplcm8sIGlzUGVyY2VudGFnZSwgbGliaHVzbCwgbWF0Y2hlcnMsIG51bWJlckZyb21TdHJpbmcsIHBhZDIsIHBlcmNlbnRUb0ZyYWN0aW9uLCByZ2JUb0hleCwgcmdiVG9Ic2wsIHJnYlRvUmdiLCByZ2JhRnJvbUh1c2wsIHN0cmluZ1RvT2JqZWN0LFxuXHQgIGJpbmQgPSBmdW5jdGlvbihmbiwgbWUpeyByZXR1cm4gZnVuY3Rpb24oKXsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9OyB9LFxuXHQgIGV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcblx0ICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cdFxuXHRfID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKS5fO1xuXHRcblx0QmFzZUNsYXNzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KS5CYXNlQ2xhc3M7XG5cdFxuXHRsaWJodXNsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cdFxuXHRDb2xvclR5cGUgPSB7XG5cdCAgUkdCOiBcInJnYlwiLFxuXHQgIEhTTDogXCJoc2xcIixcblx0ICBIRVg6IFwiaGV4XCIsXG5cdCAgTkFNRTogXCJuYW1lXCJcblx0fTtcblx0XG5cdGV4cG9ydHMuQ29sb3IgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuXHQgIGV4dGVuZChDb2xvciwgc3VwZXJDbGFzcyk7XG5cdFxuXHQgIGZ1bmN0aW9uIENvbG9yKGNvbG9yMSwgciwgZywgYikge1xuXHQgICAgdmFyIGNvbG9yLCBpbnB1dDtcblx0ICAgIHRoaXMuY29sb3IgPSBjb2xvcjE7XG5cdCAgICB0aGlzLnRvSW5zcGVjdCA9IGJpbmQodGhpcy50b0luc3BlY3QsIHRoaXMpO1xuXHQgICAgaWYgKHRoaXMuY29sb3IgPT09IFwiXCIpIHtcblx0ICAgICAgdGhpcy5jb2xvciA9IG51bGw7XG5cdCAgICB9XG5cdCAgICBjb2xvciA9IHRoaXMuY29sb3I7XG5cdCAgICBpZiAoQ29sb3IuaXNDb2xvck9iamVjdChjb2xvcikpIHtcblx0ICAgICAgcmV0dXJuIGNvbG9yO1xuXHQgICAgfVxuXHQgICAgaW5wdXQgPSBpbnB1dERhdGEoY29sb3IsIHIsIGcsIGIpO1xuXHQgICAgdGhpcy5fdHlwZSA9IGlucHV0LnR5cGU7XG5cdCAgICB0aGlzLl9yID0gaW5wdXQucjtcblx0ICAgIHRoaXMuX2cgPSBpbnB1dC5nO1xuXHQgICAgdGhpcy5fYiA9IGlucHV0LmI7XG5cdCAgICB0aGlzLl9hID0gaW5wdXQuYTtcblx0ICAgIHRoaXMuX2ggPSBpbnB1dC5oO1xuXHQgICAgdGhpcy5fcyA9IGlucHV0LnM7XG5cdCAgICB0aGlzLl9sID0gaW5wdXQubDtcblx0ICAgIHRoaXMuX3JvdW5kQSA9IE1hdGgucm91bmQoMTAwICogdGhpcy5fYSkgLyAxMDA7XG5cdCAgfVxuXHRcblx0ICBDb2xvci5kZWZpbmUoXCJyXCIsIHtcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9yO1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBDb2xvci5kZWZpbmUoXCJnXCIsIHtcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9nO1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBDb2xvci5kZWZpbmUoXCJiXCIsIHtcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9iO1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBDb2xvci5kZWZpbmUoXCJhXCIsIHtcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9hO1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBDb2xvci5kZWZpbmUoXCJoXCIsIHtcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9oO1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBDb2xvci5kZWZpbmUoXCJzXCIsIHtcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9zO1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBDb2xvci5kZWZpbmUoXCJsXCIsIHtcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9sO1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBDb2xvci5wcm90b3R5cGUudG9IZXggPSBmdW5jdGlvbihhbGxvdzNDaGFyKSB7XG5cdCAgICByZXR1cm4gcmdiVG9IZXgodGhpcy5fciwgdGhpcy5fZywgdGhpcy5fYiwgYWxsb3czQ2hhcik7XG5cdCAgfTtcblx0XG5cdCAgQ29sb3IucHJvdG90eXBlLnRvSGV4U3RyaW5nID0gZnVuY3Rpb24oYWxsb3czQ2hhcikge1xuXHQgICAgcmV0dXJuIFwiI1wiICsgdGhpcy50b0hleChhbGxvdzNDaGFyKTtcblx0ICB9O1xuXHRcblx0ICBDb2xvci5wcm90b3R5cGUudG9SZ2IgPSBmdW5jdGlvbigpIHtcblx0ICAgIGlmICh0aGlzLl9yZ2IgPT09IHZvaWQgMCkge1xuXHQgICAgICB0aGlzLl9yZ2IgPSB7XG5cdCAgICAgICAgcjogTWF0aC5yb3VuZCh0aGlzLl9yKSxcblx0ICAgICAgICBnOiBNYXRoLnJvdW5kKHRoaXMuX2cpLFxuXHQgICAgICAgIGI6IE1hdGgucm91bmQodGhpcy5fYiksXG5cdCAgICAgICAgYTogdGhpcy5fYVxuXHQgICAgICB9O1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIF8uY2xvbmUodGhpcy5fcmdiKTtcblx0ICB9O1xuXHRcblx0ICBDb2xvci5wcm90b3R5cGUudG9SZ2JTdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0ICAgIGlmICh0aGlzLl9hID09PSAxKSB7XG5cdCAgICAgIHJldHVybiBcInJnYihcIiArIChVdGlscy5yb3VuZCh0aGlzLl9yLCAwKSkgKyBcIiwgXCIgKyAoVXRpbHMucm91bmQodGhpcy5fZywgMCkpICsgXCIsIFwiICsgKFV0aWxzLnJvdW5kKHRoaXMuX2IsIDApKSArIFwiKVwiO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIFwicmdiYShcIiArIChVdGlscy5yb3VuZCh0aGlzLl9yLCAwKSkgKyBcIiwgXCIgKyAoVXRpbHMucm91bmQodGhpcy5fZywgMCkpICsgXCIsIFwiICsgKFV0aWxzLnJvdW5kKHRoaXMuX2IsIDApKSArIFwiLCBcIiArIHRoaXMuX3JvdW5kQSArIFwiKVwiO1xuXHQgICAgfVxuXHQgIH07XG5cdFxuXHQgIENvbG9yLnByb3RvdHlwZS50b0hzbCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgaWYgKHRoaXMuX2hzbCA9PT0gdm9pZCAwKSB7XG5cdCAgICAgIHRoaXMuX2hzbCA9IHtcblx0ICAgICAgICBoOiB0aGlzLmgsXG5cdCAgICAgICAgczogdGhpcy5zLFxuXHQgICAgICAgIGw6IHRoaXMubCxcblx0ICAgICAgICBhOiB0aGlzLmFcblx0ICAgICAgfTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBfLmNsb25lKHRoaXMuX2hzbCk7XG5cdCAgfTtcblx0XG5cdCAgQ29sb3IucHJvdG90eXBlLnRvSHVzbCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIGMsIGh1c2w7XG5cdCAgICBpZiAodGhpcy5faHVzbCA9PT0gdm9pZCAwKSB7XG5cdCAgICAgIGMgPSBsaWJodXNsLl9jb252O1xuXHQgICAgICBodXNsID0gYy5sY2guaHVzbChjLmx1di5sY2goYy54eXoubHV2KGMucmdiLnh5eihbdGhpcy5yIC8gMjU1LCB0aGlzLmcgLyAyNTUsIHRoaXMuYiAvIDI1NV0pKSkpO1xuXHQgICAgICB0aGlzLl9odXNsID0ge1xuXHQgICAgICAgIGg6IGh1c2xbMF0sXG5cdCAgICAgICAgczogaHVzbFsxXSxcblx0ICAgICAgICBsOiBodXNsWzJdXG5cdCAgICAgIH07XG5cdCAgICB9XG5cdCAgICByZXR1cm4gXy5jbG9uZSh0aGlzLl9odXNsKTtcblx0ICB9O1xuXHRcblx0ICBDb2xvci5wcm90b3R5cGUudG9Ic2xTdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciBoLCBoc2wsIGwsIHM7XG5cdCAgICBpZiAodGhpcy5faHNsU3RyaW5nID09PSB2b2lkIDApIHtcblx0ICAgICAgaHNsID0gdGhpcy50b0hzbCgpO1xuXHQgICAgICBoID0gTWF0aC5yb3VuZChoc2wuaCk7XG5cdCAgICAgIHMgPSBNYXRoLnJvdW5kKGhzbC5zICogMTAwKTtcblx0ICAgICAgbCA9IE1hdGgucm91bmQoaHNsLmwgKiAxMDApO1xuXHQgICAgICBpZiAodGhpcy5fYSA9PT0gMSkge1xuXHQgICAgICAgIHRoaXMuX2hzbFN0cmluZyA9IFwiaHNsKFwiICsgaCArIFwiLCBcIiArIHMgKyBcIiUsIFwiICsgbCArIFwiJSlcIjtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB0aGlzLl9oc2xTdHJpbmcgPSBcImhzbGEoXCIgKyBoICsgXCIsIFwiICsgcyArIFwiJSwgXCIgKyBsICsgXCIlLCBcIiArIHRoaXMuX3JvdW5kQSArIFwiKVwiO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcy5faHNsU3RyaW5nO1xuXHQgIH07XG5cdFxuXHQgIENvbG9yLnByb3RvdHlwZS50b05hbWUgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciBoZXgsIGksIGtleSwgbGVuLCByZWYsIHZhbHVlO1xuXHQgICAgaWYgKHRoaXMuX2EgPT09IDApIHtcblx0ICAgICAgcmV0dXJuIFwidHJhbnNwYXJlbnRcIjtcblx0ICAgIH1cblx0ICAgIGlmICh0aGlzLl9hIDwgMSkge1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgICBoZXggPSByZ2JUb0hleCh0aGlzLl9yLCB0aGlzLl9nLCB0aGlzLl9iLCB0cnVlKTtcblx0ICAgIHJlZiA9IF8ua2V5cyhjc3NOYW1lcyk7XG5cdCAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0ICAgICAga2V5ID0gcmVmW2ldO1xuXHQgICAgICB2YWx1ZSA9IGNzc05hbWVzW2tleV07XG5cdCAgICAgIGlmICh2YWx1ZSA9PT0gaGV4KSB7XG5cdCAgICAgICAgcmV0dXJuIGtleTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH07XG5cdFxuXHQgIENvbG9yLnByb3RvdHlwZS5saWdodGVuID0gZnVuY3Rpb24oYW1vdW50KSB7XG5cdCAgICB2YXIgaHNsO1xuXHQgICAgaWYgKGFtb3VudCA9PSBudWxsKSB7XG5cdCAgICAgIGFtb3VudCA9IDEwO1xuXHQgICAgfVxuXHQgICAgaHNsID0gdGhpcy50b0hzbCgpO1xuXHQgICAgaHNsLmwgKz0gYW1vdW50IC8gMTAwO1xuXHQgICAgaHNsLmwgPSBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBoc2wubCkpO1xuXHQgICAgcmV0dXJuIG5ldyBDb2xvcihoc2wpO1xuXHQgIH07XG5cdFxuXHQgIENvbG9yLnByb3RvdHlwZS5icmlnaHRlbiA9IGZ1bmN0aW9uKGFtb3VudCkge1xuXHQgICAgdmFyIHJnYjtcblx0ICAgIGlmIChhbW91bnQgPT0gbnVsbCkge1xuXHQgICAgICBhbW91bnQgPSAxMDtcblx0ICAgIH1cblx0ICAgIHJnYiA9IHRoaXMudG9SZ2IoKTtcblx0ICAgIHJnYi5yID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCByZ2IuciAtIE1hdGgucm91bmQoMjU1ICogLShhbW91bnQgLyAxMDApKSkpO1xuXHQgICAgcmdiLmcgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIHJnYi5nIC0gTWF0aC5yb3VuZCgyNTUgKiAtKGFtb3VudCAvIDEwMCkpKSk7XG5cdCAgICByZ2IuYiA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgcmdiLmIgLSBNYXRoLnJvdW5kKDI1NSAqIC0oYW1vdW50IC8gMTAwKSkpKTtcblx0ICAgIHJldHVybiBuZXcgQ29sb3IocmdiKTtcblx0ICB9O1xuXHRcblx0ICBDb2xvci5wcm90b3R5cGUuZGFya2VuID0gZnVuY3Rpb24oYW1vdW50KSB7XG5cdCAgICB2YXIgaHNsO1xuXHQgICAgaWYgKGFtb3VudCA9PSBudWxsKSB7XG5cdCAgICAgIGFtb3VudCA9IDEwO1xuXHQgICAgfVxuXHQgICAgaHNsID0gdGhpcy50b0hzbCgpO1xuXHQgICAgaHNsLmwgLT0gYW1vdW50IC8gMTAwO1xuXHQgICAgaHNsLmwgPSBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBoc2wubCkpO1xuXHQgICAgcmV0dXJuIG5ldyBDb2xvcihoc2wpO1xuXHQgIH07XG5cdFxuXHQgIENvbG9yLnByb3RvdHlwZS5kZXNhdHVyYXRlID0gZnVuY3Rpb24oYW1vdW50KSB7XG5cdCAgICB2YXIgaHNsO1xuXHQgICAgaWYgKGFtb3VudCA9PSBudWxsKSB7XG5cdCAgICAgIGFtb3VudCA9IDEwO1xuXHQgICAgfVxuXHQgICAgaHNsID0gdGhpcy50b0hzbCgpO1xuXHQgICAgaHNsLnMgLT0gYW1vdW50IC8gMTAwO1xuXHQgICAgaHNsLnMgPSBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBoc2wucykpO1xuXHQgICAgcmV0dXJuIG5ldyBDb2xvcihoc2wpO1xuXHQgIH07XG5cdFxuXHQgIENvbG9yLnByb3RvdHlwZS5zYXR1cmF0ZSA9IGZ1bmN0aW9uKGFtb3VudCkge1xuXHQgICAgdmFyIGhzbDtcblx0ICAgIGlmIChhbW91bnQgPT0gbnVsbCkge1xuXHQgICAgICBhbW91bnQgPSAxMDtcblx0ICAgIH1cblx0ICAgIGhzbCA9IHRoaXMudG9Ic2woKTtcblx0ICAgIGhzbC5zICs9IGFtb3VudCAvIDEwMDtcblx0ICAgIGhzbC5zID0gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgaHNsLnMpKTtcblx0ICAgIHJldHVybiBuZXcgQ29sb3IoaHNsKTtcblx0ICB9O1xuXHRcblx0ICBDb2xvci5wcm90b3R5cGUuZ3JheXNjYWxlID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgaHNsO1xuXHQgICAgaHNsID0gdGhpcy50b0hzbCgpO1xuXHQgICAgcmV0dXJuIG5ldyBDb2xvcihoc2wpLmRlc2F0dXJhdGUoMTAwKTtcblx0ICB9O1xuXHRcblx0ICBDb2xvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0ICAgIHJldHVybiB0aGlzLnRvUmdiU3RyaW5nKCk7XG5cdCAgfTtcblx0XG5cdCAgQ29sb3IucHJvdG90eXBlLnRyYW5zcGFyZW50ID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgcmVzdWx0O1xuXHQgICAgcmV0dXJuIHJlc3VsdCA9IG5ldyBDb2xvcih7XG5cdCAgICAgIHI6IHRoaXMucixcblx0ICAgICAgZzogdGhpcy5nLFxuXHQgICAgICBiOiB0aGlzLmIsXG5cdCAgICAgIGE6IDBcblx0ICAgIH0pO1xuXHQgIH07XG5cdFxuXHQgIENvbG9yLnByb3RvdHlwZS5taXggPSBmdW5jdGlvbihjb2xvckIsIGZyYWN0aW9uLCBsaW1pdCwgbW9kZWwpIHtcblx0ICAgIGlmIChsaW1pdCA9PSBudWxsKSB7XG5cdCAgICAgIGxpbWl0ID0gZmFsc2U7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gQ29sb3IubWl4KHRoaXMsIGNvbG9yQiwgZnJhY3Rpb24sIGxpbWl0LCBtb2RlbCk7XG5cdCAgfTtcblx0XG5cdCAgQ29sb3IucHJvdG90eXBlLmlzRXF1YWwgPSBmdW5jdGlvbihjb2xvckIpIHtcblx0ICAgIHJldHVybiBDb2xvci5lcXVhbCh0aGlzLCBjb2xvckIpO1xuXHQgIH07XG5cdFxuXHQgIENvbG9yLnByb3RvdHlwZS50b0luc3BlY3QgPSBmdW5jdGlvbigpIHtcblx0ICAgIGlmICh0aGlzLl90eXBlID09PSBDb2xvclR5cGUuSFNMKSB7XG5cdCAgICAgIHJldHVybiBcIjxcIiArIHRoaXMuY29uc3RydWN0b3IubmFtZSArIFwiIGg6XCIgKyB0aGlzLmggKyBcIiBzOlwiICsgdGhpcy5zICsgXCIgbDpcIiArIHRoaXMubCArIFwiIGE6XCIgKyB0aGlzLmEgKyBcIj5cIjtcblx0ICAgIH0gZWxzZSBpZiAodGhpcy5fdHlwZSA9PT0gQ29sb3JUeXBlLkhFWCB8fCB0aGlzLl90eXBlID09PSBDb2xvclR5cGUuTkFNRSkge1xuXHQgICAgICByZXR1cm4gXCI8XCIgKyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyBcIiBcXFwiXCIgKyB0aGlzLmNvbG9yICsgXCJcXFwiPlwiO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIFwiPFwiICsgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lICsgXCIgcjpcIiArIHRoaXMuciArIFwiIGc6XCIgKyB0aGlzLmcgKyBcIiBiOlwiICsgdGhpcy5iICsgXCIgYTpcIiArIHRoaXMuYSArIFwiPlwiO1xuXHQgICAgfVxuXHQgIH07XG5cdFxuXHQgIENvbG9yLm1peCA9IGZ1bmN0aW9uKGNvbG9yQSwgY29sb3JCLCBmcmFjdGlvbiwgbGltaXQsIG1vZGVsKSB7XG5cdCAgICB2YXIgZGVsdGFILCBmcm9tSCwgaHNsQSwgaHNsQiwgcmVzdWx0LCB0b0gsIHR3ZWVuO1xuXHQgICAgaWYgKGZyYWN0aW9uID09IG51bGwpIHtcblx0ICAgICAgZnJhY3Rpb24gPSAuNTtcblx0ICAgIH1cblx0ICAgIGlmIChsaW1pdCA9PSBudWxsKSB7XG5cdCAgICAgIGxpbWl0ID0gZmFsc2U7XG5cdCAgICB9XG5cdCAgICByZXN1bHQgPSBudWxsO1xuXHQgICAgaWYgKHR5cGVvZiBjb2xvckEgPT09IFwic3RyaW5nXCIgJiYgdGhpcy5pc0NvbG9yU3RyaW5nKGNvbG9yQSkpIHtcblx0ICAgICAgY29sb3JBID0gbmV3IENvbG9yKGNvbG9yQSk7XG5cdCAgICB9XG5cdCAgICBpZiAodHlwZW9mIGNvbG9yQiA9PT0gXCJzdHJpbmdcIiAmJiB0aGlzLmlzQ29sb3JTdHJpbmcoY29sb3JCKSkge1xuXHQgICAgICBjb2xvckIgPSBuZXcgQ29sb3IoY29sb3JCKTtcblx0ICAgIH1cblx0ICAgIGlmICghKGNvbG9yQSBpbnN0YW5jZW9mIENvbG9yKSAmJiBjb2xvckIgaW5zdGFuY2VvZiBDb2xvcikge1xuXHQgICAgICBjb2xvckEgPSBjb2xvckIudHJhbnNwYXJlbnQoKTtcblx0ICAgIH0gZWxzZSBpZiAoY29sb3JBIGluc3RhbmNlb2YgQ29sb3IgJiYgY29sb3JBLl9hID09PSAwICYmIGNvbG9yQiBpbnN0YW5jZW9mIENvbG9yICYmIGNvbG9yQi5fYSAhPT0gMCkge1xuXHQgICAgICBjb2xvckEgPSBjb2xvckIudHJhbnNwYXJlbnQoKTtcblx0ICAgIH0gZWxzZSBpZiAoIShjb2xvckIgaW5zdGFuY2VvZiBDb2xvcikgJiYgY29sb3JBIGluc3RhbmNlb2YgQ29sb3IpIHtcblx0ICAgICAgY29sb3JCID0gY29sb3JBLnRyYW5zcGFyZW50KCk7XG5cdCAgICB9IGVsc2UgaWYgKGNvbG9yQiBpbnN0YW5jZW9mIENvbG9yICYmIGNvbG9yQi5fYSA9PT0gMCAmJiBjb2xvckEgaW5zdGFuY2VvZiBDb2xvciAmJiBjb2xvckEuX2EgIT09IDApIHtcblx0ICAgICAgY29sb3JCID0gY29sb3JBLnRyYW5zcGFyZW50KCk7XG5cdCAgICB9XG5cdCAgICBpZiAoY29sb3JCIGluc3RhbmNlb2YgQ29sb3IpIHtcblx0ICAgICAgaWYgKENvbG9yTW9kZWwuaXNSR0IobW9kZWwpKSB7XG5cdCAgICAgICAgcmVzdWx0ID0gbmV3IENvbG9yKHtcblx0ICAgICAgICAgIHI6IFV0aWxzLm1vZHVsYXRlKGZyYWN0aW9uLCBbMCwgMV0sIFtjb2xvckEuX3IsIGNvbG9yQi5fcl0sIGxpbWl0KSxcblx0ICAgICAgICAgIGc6IFV0aWxzLm1vZHVsYXRlKGZyYWN0aW9uLCBbMCwgMV0sIFtjb2xvckEuX2csIGNvbG9yQi5fZ10sIGxpbWl0KSxcblx0ICAgICAgICAgIGI6IFV0aWxzLm1vZHVsYXRlKGZyYWN0aW9uLCBbMCwgMV0sIFtjb2xvckEuX2IsIGNvbG9yQi5fYl0sIGxpbWl0KSxcblx0ICAgICAgICAgIGE6IFV0aWxzLm1vZHVsYXRlKGZyYWN0aW9uLCBbMCwgMV0sIFtjb2xvckEuX2EsIGNvbG9yQi5fYV0sIGxpbWl0KVxuXHQgICAgICAgIH0pO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGhzbEE7XG5cdCAgICAgICAgaHNsQjtcblx0ICAgICAgICBpZiAoQ29sb3JNb2RlbC5pc0hTTChtb2RlbCkpIHtcblx0ICAgICAgICAgIGhzbEEgPSBjb2xvckEudG9Ic2woKTtcblx0ICAgICAgICAgIGhzbEIgPSBjb2xvckIudG9Ic2woKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgaHNsQSA9IGNvbG9yQS50b0h1c2woKTtcblx0ICAgICAgICAgIGhzbEIgPSBjb2xvckIudG9IdXNsKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChoc2xBLnMgPT09IDApIHtcblx0ICAgICAgICAgIGhzbEEuaCA9IGhzbEIuaDtcblx0ICAgICAgICB9IGVsc2UgaWYgKGhzbEIucyA9PT0gMCkge1xuXHQgICAgICAgICAgaHNsQi5oID0gaHNsQS5oO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmcm9tSCA9IGhzbEEuaDtcblx0ICAgICAgICB0b0ggPSBoc2xCLmg7XG5cdCAgICAgICAgZGVsdGFIID0gdG9IIC0gZnJvbUg7XG5cdCAgICAgICAgaWYgKGRlbHRhSCA+IDE4MCkge1xuXHQgICAgICAgICAgZGVsdGFIID0gKHRvSCAtIDM2MCkgLSBmcm9tSDtcblx0ICAgICAgICB9IGVsc2UgaWYgKGRlbHRhSCA8IC0xODApIHtcblx0ICAgICAgICAgIGRlbHRhSCA9ICh0b0ggKyAzNjApIC0gZnJvbUg7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHR3ZWVuID0ge1xuXHQgICAgICAgICAgaDogVXRpbHMubW9kdWxhdGUoZnJhY3Rpb24sIFswLCAxXSwgW2Zyb21ILCBmcm9tSCArIGRlbHRhSF0sIGxpbWl0KSxcblx0ICAgICAgICAgIHM6IFV0aWxzLm1vZHVsYXRlKGZyYWN0aW9uLCBbMCwgMV0sIFtoc2xBLnMsIGhzbEIuc10sIGxpbWl0KSxcblx0ICAgICAgICAgIGw6IFV0aWxzLm1vZHVsYXRlKGZyYWN0aW9uLCBbMCwgMV0sIFtoc2xBLmwsIGhzbEIubF0sIGxpbWl0KSxcblx0ICAgICAgICAgIGE6IFV0aWxzLm1vZHVsYXRlKGZyYWN0aW9uLCBbMCwgMV0sIFtjb2xvckEuYSwgY29sb3JCLmFdLCBsaW1pdClcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGlmIChDb2xvck1vZGVsLmlzSFNMKG1vZGVsKSkge1xuXHQgICAgICAgICAgcmVzdWx0ID0gbmV3IENvbG9yKHR3ZWVuKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgcmVzdWx0ID0gbmV3IENvbG9yKHJnYmFGcm9tSHVzbCh0d2VlbikpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9O1xuXHRcblx0ICBDb2xvci5yYW5kb20gPSBmdW5jdGlvbihhbHBoYSkge1xuXHQgICAgdmFyIGM7XG5cdCAgICBpZiAoYWxwaGEgPT0gbnVsbCkge1xuXHQgICAgICBhbHBoYSA9IDEuMDtcblx0ICAgIH1cblx0ICAgIGMgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIHBhcnNlSW50KE1hdGgucmFuZG9tKCkgKiAyNTUpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBuZXcgQ29sb3IoXCJyZ2JhKFwiICsgKGMoKSkgKyBcIiwgXCIgKyAoYygpKSArIFwiLCBcIiArIChjKCkpICsgXCIsIFwiICsgYWxwaGEgKyBcIilcIik7XG5cdCAgfTtcblx0XG5cdCAgQ29sb3IudG9Db2xvciA9IGZ1bmN0aW9uKGNvbG9yKSB7XG5cdCAgICByZXR1cm4gbmV3IENvbG9yKGNvbG9yKTtcblx0ICB9O1xuXHRcblx0ICBDb2xvci52YWxpZENvbG9yVmFsdWUgPSBmdW5jdGlvbihjb2xvcikge1xuXHQgICAgcmV0dXJuIGNvbG9yIGluc3RhbmNlb2YgQ29sb3IgfHwgY29sb3IgPT09IG51bGw7XG5cdCAgfTtcblx0XG5cdCAgQ29sb3IuaXNDb2xvciA9IGZ1bmN0aW9uKGNvbG9yKSB7XG5cdCAgICBpZiAoXy5pc1N0cmluZyhjb2xvcikpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuaXNDb2xvclN0cmluZyhjb2xvcik7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gdGhpcy5pc0NvbG9yT2JqZWN0KGNvbG9yKTtcblx0ICAgIH1cblx0ICB9O1xuXHRcblx0ICBDb2xvci5pc0NvbG9yT2JqZWN0ID0gZnVuY3Rpb24oY29sb3IpIHtcblx0ICAgIHJldHVybiBjb2xvciBpbnN0YW5jZW9mIENvbG9yO1xuXHQgIH07XG5cdFxuXHQgIENvbG9yLmlzQ29sb3JTdHJpbmcgPSBmdW5jdGlvbihjb2xvclN0cmluZykge1xuXHQgICAgaWYgKF8uaXNTdHJpbmcoY29sb3JTdHJpbmcpKSB7XG5cdCAgICAgIHJldHVybiBzdHJpbmdUb09iamVjdChjb2xvclN0cmluZykgIT09IGZhbHNlO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH07XG5cdFxuXHQgIENvbG9yLmVxdWFsID0gZnVuY3Rpb24oY29sb3JBLCBjb2xvckIpIHtcblx0ICAgIGlmICghdGhpcy52YWxpZENvbG9yVmFsdWUoY29sb3JBKSkge1xuXHQgICAgICBpZiAoIUNvbG9yLmlzQ29sb3JTdHJpbmcoY29sb3JBKSkge1xuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKCF0aGlzLnZhbGlkQ29sb3JWYWx1ZShjb2xvckIpKSB7XG5cdCAgICAgIGlmICghQ29sb3IuaXNDb2xvclN0cmluZyhjb2xvckIpKSB7XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICBjb2xvckEgPSBuZXcgQ29sb3IoY29sb3JBKTtcblx0ICAgIGNvbG9yQiA9IG5ldyBDb2xvcihjb2xvckIpO1xuXHQgICAgaWYgKGNvbG9yQS5yICE9PSBjb2xvckIucikge1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgICBpZiAoY29sb3JBLmcgIT09IGNvbG9yQi5nKSB7XG5cdCAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblx0ICAgIGlmIChjb2xvckEuYiAhPT0gY29sb3JCLmIpIHtcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgICAgaWYgKGNvbG9yQS5hICE9PSBjb2xvckIuYSkge1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9O1xuXHRcblx0ICBDb2xvci5yZ2JUb0hzbCA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcblx0ICAgIHJldHVybiByZ2JUb0hzbChhLCBiLCBjKTtcblx0ICB9O1xuXHRcblx0ICByZXR1cm4gQ29sb3I7XG5cdFxuXHR9KShCYXNlQ2xhc3MpO1xuXHRcblx0Q29sb3JNb2RlbCA9IHtcblx0ICBSR0I6IFwicmdiXCIsXG5cdCAgUkdCQTogXCJyZ2JhXCIsXG5cdCAgSFNMOiBcImhzbFwiLFxuXHQgIEhTTEE6IFwiaHNsYVwiXG5cdH07XG5cdFxuXHRDb2xvck1vZGVsLmlzUkdCID0gZnVuY3Rpb24oY29sb3JNb2RlbCkge1xuXHQgIHZhciByZWY7XG5cdCAgaWYgKF8uaXNTdHJpbmcoY29sb3JNb2RlbCkpIHtcblx0ICAgIHJldHVybiAocmVmID0gY29sb3JNb2RlbC50b0xvd2VyQ2FzZSgpKSA9PT0gQ29sb3JNb2RlbC5SR0IgfHwgcmVmID09PSBDb2xvck1vZGVsLlJHQkE7XG5cdCAgfVxuXHQgIHJldHVybiBmYWxzZTtcblx0fTtcblx0XG5cdENvbG9yTW9kZWwuaXNIU0wgPSBmdW5jdGlvbihjb2xvck1vZGVsKSB7XG5cdCAgdmFyIHJlZjtcblx0ICBpZiAoXy5pc1N0cmluZyhjb2xvck1vZGVsKSkge1xuXHQgICAgcmV0dXJuIChyZWYgPSBjb2xvck1vZGVsLnRvTG93ZXJDYXNlKCkpID09PSBDb2xvck1vZGVsLkhTTCB8fCByZWYgPT09IENvbG9yTW9kZWwuSFNMQTtcblx0ICB9XG5cdCAgcmV0dXJuIGZhbHNlO1xuXHR9O1xuXHRcblx0cmdiYUZyb21IdXNsID0gZnVuY3Rpb24oaHVzbCkge1xuXHQgIHZhciBjLCByZ2IsIHJnYmE7XG5cdCAgYyA9IGxpYmh1c2wuX2NvbnY7XG5cdCAgcmdiID0gYy54eXoucmdiKGMubHV2Lnh5eihjLmxjaC5sdXYoYy5odXNsLmxjaChbaHVzbC5oLCBodXNsLnMsIGh1c2wubF0pKSkpO1xuXHQgIHJnYmEgPSB7XG5cdCAgICByOiByZ2JbMF0gKiAyNTUsXG5cdCAgICBnOiByZ2JbMV0gKiAyNTUsXG5cdCAgICBiOiByZ2JbMl0gKiAyNTUsXG5cdCAgICBhOiBodXNsLmFcblx0ICB9O1xuXHQgIHJldHVybiByZ2JhO1xuXHR9O1xuXHRcblx0aW5wdXREYXRhID0gZnVuY3Rpb24oY29sb3IsIGcsIGIsIGFscGhhKSB7XG5cdCAgdmFyIGEsIGgsIGhzbCwgbCwgb2ssIHJnYiwgcywgdHlwZTtcblx0ICByZ2IgPSB7XG5cdCAgICByOiAwLFxuXHQgICAgZzogMCxcblx0ICAgIGI6IDBcblx0ICB9O1xuXHQgIGhzbCA9IHtcblx0ICAgIGg6IDAsXG5cdCAgICBzOiAwLFxuXHQgICAgbDogMFxuXHQgIH07XG5cdCAgYSA9IDE7XG5cdCAgb2sgPSBmYWxzZTtcblx0ICB0eXBlID0gQ29sb3JUeXBlLlJHQjtcblx0ICBpZiAoY29sb3IgPT09IG51bGwpIHtcblx0ICAgIGEgPSAwO1xuXHQgIH0gZWxzZSBpZiAoXy5pc051bWJlcihjb2xvcikpIHtcblx0ICAgIHJnYi5yID0gY29sb3I7XG5cdCAgICBpZiAoXy5pc051bWJlcihnKSkge1xuXHQgICAgICByZ2IuZyA9IGc7XG5cdCAgICB9XG5cdCAgICBpZiAoXy5pc051bWJlcihiKSkge1xuXHQgICAgICByZ2IuYiA9IGI7XG5cdCAgICB9XG5cdCAgICBpZiAoXy5pc051bWJlcihhbHBoYSkpIHtcblx0ICAgICAgYSA9IGFscGhhO1xuXHQgICAgfVxuXHQgIH0gZWxzZSB7XG5cdCAgICBpZiAodHlwZW9mIGNvbG9yID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgIGNvbG9yID0gc3RyaW5nVG9PYmplY3QoY29sb3IpO1xuXHQgICAgICBpZiAoIWNvbG9yKSB7XG5cdCAgICAgICAgY29sb3IgPSB7XG5cdCAgICAgICAgICByOiAwLFxuXHQgICAgICAgICAgZzogMCxcblx0ICAgICAgICAgIGI6IDAsXG5cdCAgICAgICAgICBhOiAwXG5cdCAgICAgICAgfTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoY29sb3IuaGFzT3duUHJvcGVydHkoXCJ0eXBlXCIpKSB7XG5cdCAgICAgICAgdHlwZSA9IGNvbG9yLnR5cGU7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIGlmICh0eXBlb2YgY29sb3IgPT09IFwib2JqZWN0XCIpIHtcblx0ICAgICAgaWYgKGNvbG9yLmhhc093blByb3BlcnR5KFwiclwiKSB8fCBjb2xvci5oYXNPd25Qcm9wZXJ0eShcImdcIikgfHwgY29sb3IuaGFzT3duUHJvcGVydHkoXCJiXCIpKSB7XG5cdCAgICAgICAgcmdiID0gcmdiVG9SZ2IoY29sb3IuciwgY29sb3IuZywgY29sb3IuYik7XG5cdCAgICAgIH0gZWxzZSBpZiAoY29sb3IuaGFzT3duUHJvcGVydHkoXCJoXCIpIHx8IGNvbG9yLmhhc093blByb3BlcnR5KFwic1wiKSB8fCBjb2xvci5oYXNPd25Qcm9wZXJ0eShcImxcIikpIHtcblx0ICAgICAgICBoID0gaXNOdW1lcmljKGNvbG9yLmgpID8gcGFyc2VGbG9hdChjb2xvci5oKSA6IDA7XG5cdCAgICAgICAgaCA9IChoICsgMzYwKSAlIDM2MDtcblx0ICAgICAgICBzID0gaXNOdW1lcmljKGNvbG9yLnMpID8gY29sb3IucyA6IDE7XG5cdCAgICAgICAgaWYgKF8uaXNTdHJpbmcoY29sb3IucykpIHtcblx0ICAgICAgICAgIHMgPSBudW1iZXJGcm9tU3RyaW5nKGNvbG9yLnMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBsID0gaXNOdW1lcmljKGNvbG9yLmwpID8gY29sb3IubCA6IDAuNTtcblx0ICAgICAgICBpZiAoXy5pc1N0cmluZyhjb2xvci5sKSkge1xuXHQgICAgICAgICAgbCA9IG51bWJlckZyb21TdHJpbmcoY29sb3IubCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJnYiA9IGhzbFRvUmdiKGgsIHMsIGwpO1xuXHQgICAgICAgIHR5cGUgPSBDb2xvclR5cGUuSFNMO1xuXHQgICAgICAgIGhzbCA9IHtcblx0ICAgICAgICAgIGg6IGgsXG5cdCAgICAgICAgICBzOiBzLFxuXHQgICAgICAgICAgbDogbFxuXHQgICAgICAgIH07XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKGNvbG9yLmhhc093blByb3BlcnR5KFwiYVwiKSkge1xuXHQgICAgICAgIGEgPSBjb2xvci5hO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHQgIGEgPSBjb3JyZWN0QWxwaGEoYSk7XG5cdCAgaWYgKHR5cGUgIT09IENvbG9yVHlwZS5IU0wpIHtcblx0ICAgIGhzbCA9IHJnYlRvSHNsKHJnYi5yLCByZ2IuZywgcmdiLmIpO1xuXHQgIH1cblx0ICByZXR1cm4ge1xuXHQgICAgdHlwZTogdHlwZSxcblx0ICAgIHI6IE1hdGgubWluKDI1NSwgTWF0aC5tYXgocmdiLnIsIDApKSxcblx0ICAgIGc6IE1hdGgubWluKDI1NSwgTWF0aC5tYXgocmdiLmcsIDApKSxcblx0ICAgIGI6IE1hdGgubWluKDI1NSwgTWF0aC5tYXgocmdiLmIsIDApKSxcblx0ICAgIGg6IFV0aWxzLmNsYW1wKGhzbC5oLCAwLCAzNjApLFxuXHQgICAgczogVXRpbHMuY2xhbXAoaHNsLnMsIDAsIDEpLFxuXHQgICAgbDogVXRpbHMuY2xhbXAoaHNsLmwsIDAsIDEpLFxuXHQgICAgYTogYVxuXHQgIH07XG5cdH07XG5cdFxuXHRudW1iZXJGcm9tU3RyaW5nID0gZnVuY3Rpb24oc3RyaW5nKSB7XG5cdCAgcmV0dXJuIHN0cmluZy5tYXRjaCgvXFxkKy8pWzBdO1xuXHR9O1xuXHRcblx0cmdiVG9SZ2IgPSBmdW5jdGlvbihyLCBnLCBiKSB7XG5cdCAgcmV0dXJuIHtcblx0ICAgIHI6IGlzTnVtZXJpYyhyKSA/IGJvdW5kMDEociwgMjU1KSAqIDI1NSA6IDAsXG5cdCAgICBnOiBpc051bWVyaWMoZykgPyBib3VuZDAxKGcsIDI1NSkgKiAyNTUgOiAwLFxuXHQgICAgYjogaXNOdW1lcmljKGIpID8gYm91bmQwMShiLCAyNTUpICogMjU1IDogMFxuXHQgIH07XG5cdH07XG5cdFxuXHRyZ2JUb0hleCA9IGZ1bmN0aW9uKHIsIGcsIGIsIGFsbG93M0NoYXIpIHtcblx0ICB2YXIgaGV4O1xuXHQgIGhleCA9IFtwYWQyKE1hdGgucm91bmQocikudG9TdHJpbmcoMTYpKSwgcGFkMihNYXRoLnJvdW5kKGcpLnRvU3RyaW5nKDE2KSksIHBhZDIoTWF0aC5yb3VuZChiKS50b1N0cmluZygxNikpXTtcblx0ICBpZiAoYWxsb3czQ2hhciAmJiBoZXhbMF0uY2hhckF0KDApID09PSBoZXhbMF0uY2hhckF0KDEpICYmIGhleFsxXS5jaGFyQXQoMCkgPT09IGhleFsxXS5jaGFyQXQoMSkgJiYgaGV4WzJdLmNoYXJBdCgwKSA9PT0gaGV4WzJdLmNoYXJBdCgxKSkge1xuXHQgICAgcmV0dXJuIGhleFswXS5jaGFyQXQoMCkgKyBoZXhbMV0uY2hhckF0KDApICsgaGV4WzJdLmNoYXJBdCgwKTtcblx0ICB9XG5cdCAgcmV0dXJuIGhleC5qb2luKFwiXCIpO1xuXHR9O1xuXHRcblx0cmdiVG9Ic2wgPSBmdW5jdGlvbihyLCBnLCBiKSB7XG5cdCAgdmFyIGQsIGgsIGwsIG1heCwgbWluLCBzO1xuXHQgIHIgPSBib3VuZDAxKHIsIDI1NSk7XG5cdCAgZyA9IGJvdW5kMDEoZywgMjU1KTtcblx0ICBiID0gYm91bmQwMShiLCAyNTUpO1xuXHQgIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuXHQgIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuXHQgIGggPSBzID0gbCA9IChtYXggKyBtaW4pIC8gMjtcblx0ICBpZiAobWF4ID09PSBtaW4pIHtcblx0ICAgIGggPSBzID0gMDtcblx0ICB9IGVsc2Uge1xuXHQgICAgZCA9IG1heCAtIG1pbjtcblx0ICAgIHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKTtcblx0ICAgIHN3aXRjaCAobWF4KSB7XG5cdCAgICAgIGNhc2Ugcjpcblx0ICAgICAgICBoID0gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCk7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIGNhc2UgZzpcblx0ICAgICAgICBoID0gKGIgLSByKSAvIGQgKyAyO1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICBjYXNlIGI6XG5cdCAgICAgICAgaCA9IChyIC0gZykgLyBkICsgNDtcblx0ICAgIH1cblx0ICAgIGggLz0gNjtcblx0ICB9XG5cdCAgcmV0dXJuIHtcblx0ICAgIGg6IGggKiAzNjAsXG5cdCAgICBzOiBzLFxuXHQgICAgbDogbFxuXHQgIH07XG5cdH07XG5cdFxuXHRoc2xUb1JnYiA9IGZ1bmN0aW9uKGgsIHMsIGwpIHtcblx0ICB2YXIgYiwgZywgaHVlMnJnYiwgcCwgcSwgcjtcblx0ICByID0gdm9pZCAwO1xuXHQgIGcgPSB2b2lkIDA7XG5cdCAgYiA9IHZvaWQgMDtcblx0ICBoID0gYm91bmQwMShoLCAzNjApO1xuXHQgIHMgPSBib3VuZDAxKHMgKiAxMDAsIDEwMCk7XG5cdCAgbCA9IGJvdW5kMDEobCAqIDEwMCwgMTAwKTtcblx0ICBodWUycmdiID0gZnVuY3Rpb24ocCwgcSwgdCkge1xuXHQgICAgaWYgKHQgPCAwKSB7XG5cdCAgICAgIHQgKz0gMTtcblx0ICAgIH1cblx0ICAgIGlmICh0ID4gMSkge1xuXHQgICAgICB0IC09IDE7XG5cdCAgICB9XG5cdCAgICBpZiAodCA8IDEgLyA2KSB7XG5cdCAgICAgIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0O1xuXHQgICAgfVxuXHQgICAgaWYgKHQgPCAxIC8gMikge1xuXHQgICAgICByZXR1cm4gcTtcblx0ICAgIH1cblx0ICAgIGlmICh0IDwgMiAvIDMpIHtcblx0ICAgICAgcmV0dXJuIHAgKyAocSAtIHApICogKDIgLyAzIC0gdCkgKiA2O1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHA7XG5cdCAgfTtcblx0ICBpZiAocyA9PT0gMCkge1xuXHQgICAgciA9IGcgPSBiID0gbDtcblx0ICB9IGVsc2Uge1xuXHQgICAgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XG5cdCAgICBwID0gMiAqIGwgLSBxO1xuXHQgICAgciA9IGh1ZTJyZ2IocCwgcSwgaCArIDEgLyAzKTtcblx0ICAgIGcgPSBodWUycmdiKHAsIHEsIGgpO1xuXHQgICAgYiA9IGh1ZTJyZ2IocCwgcSwgaCAtICgxIC8gMykpO1xuXHQgIH1cblx0ICByZXR1cm4ge1xuXHQgICAgcjogciAqIDI1NSxcblx0ICAgIGc6IGcgKiAyNTUsXG5cdCAgICBiOiBiICogMjU1XG5cdCAgfTtcblx0fTtcblx0XG5cdGNvbnZlcnRUb1BlcmNlbnRhZ2UgPSBmdW5jdGlvbihuKSB7XG5cdCAgaWYgKG4gPD0gMSkge1xuXHQgICAgbiA9IG4gKiAxMDAgKyBcIiVcIjtcblx0ICB9XG5cdCAgcmV0dXJuIG47XG5cdH07XG5cdFxuXHRjb3JyZWN0QWxwaGEgPSBmdW5jdGlvbihhKSB7XG5cdCAgYSA9IHBhcnNlRmxvYXQoYSk7XG5cdCAgaWYgKGEgPCAwKSB7XG5cdCAgICBhID0gMDtcblx0ICB9XG5cdCAgaWYgKGlzTmFOKGEpIHx8IGEgPiAxKSB7XG5cdCAgICBhID0gMTtcblx0ICB9XG5cdCAgcmV0dXJuIGE7XG5cdH07XG5cdFxuXHRib3VuZDAxID0gZnVuY3Rpb24obiwgbWF4KSB7XG5cdCAgdmFyIHByb2Nlc3NQZXJjZW50O1xuXHQgIGlmIChpc09uZVBvaW50WmVybyhuKSkge1xuXHQgICAgbiA9IFwiMTAwJVwiO1xuXHQgIH1cblx0ICBwcm9jZXNzUGVyY2VudCA9IGlzUGVyY2VudGFnZShuKTtcblx0ICBuID0gTWF0aC5taW4obWF4LCBNYXRoLm1heCgwLCBwYXJzZUZsb2F0KG4pKSk7XG5cdCAgaWYgKHByb2Nlc3NQZXJjZW50KSB7XG5cdCAgICBuID0gcGFyc2VJbnQobiAqIG1heCwgMTApIC8gMTAwO1xuXHQgIH1cblx0ICBpZiAoTWF0aC5hYnMobiAtIG1heCkgPCAwLjAwMDAwMSkge1xuXHQgICAgcmV0dXJuIDE7XG5cdCAgfVxuXHQgIHJldHVybiBuICUgbWF4IC8gcGFyc2VGbG9hdChtYXgpO1xuXHR9O1xuXHRcblx0aXNPbmVQb2ludFplcm8gPSBmdW5jdGlvbihuKSB7XG5cdCAgcmV0dXJuIHR5cGVvZiBuID09PSBcInN0cmluZ1wiICYmIG4uaW5kZXhPZihcIi5cIikgIT09IC0xICYmIHBhcnNlRmxvYXQobikgPT09IDE7XG5cdH07XG5cdFxuXHRpc1BlcmNlbnRhZ2UgPSBmdW5jdGlvbihuKSB7XG5cdCAgcmV0dXJuIHR5cGVvZiBuID09PSBcInN0cmluZ1wiICYmIG4uaW5kZXhPZihcIiVcIikgIT09IC0xO1xuXHR9O1xuXHRcblx0cGFkMiA9IGZ1bmN0aW9uKGNoYXIpIHtcblx0ICBpZiAoY2hhci5sZW5ndGggPT09IDEpIHtcblx0ICAgIHJldHVybiBcIjBcIiArIGNoYXI7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHJldHVybiBcIlwiICsgY2hhcjtcblx0ICB9XG5cdH07XG5cdFxuXHRtYXRjaGVycyA9IChmdW5jdGlvbigpIHtcblx0ICB2YXIgY3NzX2ludGVnZXIsIGNzc19udW1iZXIsIGNzc191bml0LCBwZXJtaXNzaXZlX21hdGNoMywgcGVybWlzc2l2ZV9tYXRjaDQ7XG5cdCAgY3NzX2ludGVnZXIgPSAnWy1cXFxcK10/XFxcXGQrJT8nO1xuXHQgIGNzc19udW1iZXIgPSBcIlstXFxcXCtdP1xcXFxkKlxcXFwuXFxcXGQrJT9cIjtcblx0ICBjc3NfdW5pdCA9IFwiKD86XCIgKyBjc3NfbnVtYmVyICsgXCIpfCg/OlwiICsgY3NzX2ludGVnZXIgKyBcIilcIjtcblx0ICBwZXJtaXNzaXZlX21hdGNoMyA9ICdbXFxcXHN8XFxcXChdKygnICsgY3NzX3VuaXQgKyAnKVssfFxcXFxzXSsoJyArIGNzc191bml0ICsgJylbLHxcXFxcc10rKCcgKyBjc3NfdW5pdCArICcpXFxcXHMqXFxcXCk/Jztcblx0ICBwZXJtaXNzaXZlX21hdGNoNCA9ICdbXFxcXHN8XFxcXChdKygnICsgY3NzX3VuaXQgKyAnKVssfFxcXFxzXSsoJyArIGNzc191bml0ICsgJylbLHxcXFxcc10rKCcgKyBjc3NfdW5pdCArICcpWyx8XFxcXHNdKygnICsgY3NzX3VuaXQgKyAnKVxcXFxzKlxcXFwpPyc7XG5cdCAgcmV0dXJuIHtcblx0ICAgIHJnYjogbmV3IFJlZ0V4cCgncmdiJyArIHBlcm1pc3NpdmVfbWF0Y2gzKSxcblx0ICAgIHJnYmE6IG5ldyBSZWdFeHAoJ3JnYmEnICsgcGVybWlzc2l2ZV9tYXRjaDQpLFxuXHQgICAgaHNsOiBuZXcgUmVnRXhwKCdoc2wnICsgcGVybWlzc2l2ZV9tYXRjaDMpLFxuXHQgICAgaHNsYTogbmV3IFJlZ0V4cCgnaHNsYScgKyBwZXJtaXNzaXZlX21hdGNoNCksXG5cdCAgICBoZXgzOiAvXihbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KSQvLFxuXHQgICAgaGV4NjogL14oWzAtOWEtZkEtRl17Mn0pKFswLTlhLWZBLUZdezJ9KShbMC05YS1mQS1GXXsyfSkkL1xuXHQgIH07XG5cdH0pKCk7XG5cdFxuXHRpc051bWVyaWMgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHQgIHJldHVybiAhaXNOYU4odmFsdWUpICYmIGlzRmluaXRlKHZhbHVlKTtcblx0fTtcblx0XG5cdHBlcmNlbnRUb0ZyYWN0aW9uID0gZnVuY3Rpb24ocGVyY2VudGFnZSkge1xuXHQgIHJldHVybiBudW1iZXJGcm9tU3RyaW5nKHBlcmNlbnRhZ2UpIC8gMTAwO1xuXHR9O1xuXHRcblx0c3RyaW5nVG9PYmplY3QgPSBmdW5jdGlvbihjb2xvcikge1xuXHQgIHZhciBtYXRjaCwgbmFtZWQsIHRyaW1MZWZ0LCB0cmltUmlnaHQ7XG5cdCAgdHJpbUxlZnQgPSAvXltcXHMsI10rLztcblx0ICB0cmltUmlnaHQgPSAvXFxzKyQvO1xuXHQgIGNvbG9yID0gY29sb3IucmVwbGFjZSh0cmltTGVmdCwgXCJcIikucmVwbGFjZSh0cmltUmlnaHQsIFwiXCIpLnRvTG93ZXJDYXNlKCk7XG5cdCAgbmFtZWQgPSBmYWxzZTtcblx0ICBpZiAoY3NzTmFtZXNbY29sb3JdKSB7XG5cdCAgICBjb2xvciA9IGNzc05hbWVzW2NvbG9yXTtcblx0ICAgIG5hbWVkID0gdHJ1ZTtcblx0ICAgICh7XG5cdCAgICAgIHR5cGU6IENvbG9yVHlwZS5OQU1FXG5cdCAgICB9KTtcblx0ICB9IGVsc2UgaWYgKGNvbG9yID09PSBcInRyYW5zcGFyZW50XCIpIHtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgIHI6IDAsXG5cdCAgICAgIGc6IDAsXG5cdCAgICAgIGI6IDAsXG5cdCAgICAgIGE6IDAsXG5cdCAgICAgIHR5cGU6IENvbG9yVHlwZS5OQU1FXG5cdCAgICB9O1xuXHQgIH1cblx0ICBtYXRjaCA9IHZvaWQgMDtcblx0ICBpZiAobWF0Y2ggPSBtYXRjaGVycy5yZ2IuZXhlYyhjb2xvcikpIHtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgIHI6IG1hdGNoWzFdLFxuXHQgICAgICBnOiBtYXRjaFsyXSxcblx0ICAgICAgYjogbWF0Y2hbM11cblx0ICAgIH07XG5cdCAgfVxuXHQgIGlmIChtYXRjaCA9IG1hdGNoZXJzLnJnYmEuZXhlYyhjb2xvcikpIHtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgIHI6IG1hdGNoWzFdLFxuXHQgICAgICBnOiBtYXRjaFsyXSxcblx0ICAgICAgYjogbWF0Y2hbM10sXG5cdCAgICAgIGE6IG1hdGNoWzRdXG5cdCAgICB9O1xuXHQgIH1cblx0ICBpZiAobWF0Y2ggPSBtYXRjaGVycy5oc2wuZXhlYyhjb2xvcikpIHtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgIGg6IG1hdGNoWzFdLFxuXHQgICAgICBzOiBwZXJjZW50VG9GcmFjdGlvbihtYXRjaFsyXSksXG5cdCAgICAgIGw6IHBlcmNlbnRUb0ZyYWN0aW9uKG1hdGNoWzNdKVxuXHQgICAgfTtcblx0ICB9XG5cdCAgaWYgKG1hdGNoID0gbWF0Y2hlcnMuaHNsYS5leGVjKGNvbG9yKSkge1xuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgaDogbWF0Y2hbMV0sXG5cdCAgICAgIHM6IHBlcmNlbnRUb0ZyYWN0aW9uKG1hdGNoWzJdKSxcblx0ICAgICAgbDogcGVyY2VudFRvRnJhY3Rpb24obWF0Y2hbM10pLFxuXHQgICAgICBhOiBtYXRjaFs0XVxuXHQgICAgfTtcblx0ICB9XG5cdCAgaWYgKG1hdGNoID0gbWF0Y2hlcnMuaGV4Ni5leGVjKGNvbG9yKSB8fCAobWF0Y2ggPSBtYXRjaGVycy5oZXg2LmV4ZWMoY3NzTmFtZXNbY29sb3JdKSkpIHtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgIHI6IHBhcnNlSW50KG1hdGNoWzFdLCAxNiksXG5cdCAgICAgIGc6IHBhcnNlSW50KG1hdGNoWzJdLCAxNiksXG5cdCAgICAgIGI6IHBhcnNlSW50KG1hdGNoWzNdLCAxNiksXG5cdCAgICAgIGE6IDEsXG5cdCAgICAgIHR5cGU6IENvbG9yVHlwZS5IRVhcblx0ICAgIH07XG5cdCAgfVxuXHQgIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhleDMuZXhlYyhjb2xvcikgfHwgKG1hdGNoID0gbWF0Y2hlcnMuaGV4My5leGVjKGNzc05hbWVzW2NvbG9yXSkpKSB7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICByOiBwYXJzZUludChtYXRjaFsxXSArIFwiXCIgKyBtYXRjaFsxXSwgMTYpLFxuXHQgICAgICBnOiBwYXJzZUludChtYXRjaFsyXSArIFwiXCIgKyBtYXRjaFsyXSwgMTYpLFxuXHQgICAgICBiOiBwYXJzZUludChtYXRjaFszXSArIFwiXCIgKyBtYXRjaFszXSwgMTYpLFxuXHQgICAgICB0eXBlOiBDb2xvclR5cGUuSEVYXG5cdCAgICB9O1xuXHQgIH0gZWxzZSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXHR9O1xuXHRcblx0Y3NzTmFtZXMgPSB7XG5cdCAgYWxpY2VibHVlOiBcImYwZjhmZlwiLFxuXHQgIGFudGlxdWV3aGl0ZTogXCJmYWViZDdcIixcblx0ICBhcXVhOiBcIjBmZlwiLFxuXHQgIGFxdWFtYXJpbmU6IFwiN2ZmZmQ0XCIsXG5cdCAgYXp1cmU6IFwiZjBmZmZmXCIsXG5cdCAgYmVpZ2U6IFwiZjVmNWRjXCIsXG5cdCAgYmlzcXVlOiBcImZmZTRjNFwiLFxuXHQgIGJsYWNrOiBcIjAwMFwiLFxuXHQgIGJsYW5jaGVkYWxtb25kOiBcImZmZWJjZFwiLFxuXHQgIGJsdWU6IFwiMDBmXCIsXG5cdCAgYmx1ZXZpb2xldDogXCI4YTJiZTJcIixcblx0ICBicm93bjogXCJhNTJhMmFcIixcblx0ICBidXJseXdvb2Q6IFwiZGViODg3XCIsXG5cdCAgYnVybnRzaWVubmE6IFwiZWE3ZTVkXCIsXG5cdCAgY2FkZXRibHVlOiBcIjVmOWVhMFwiLFxuXHQgIGNoYXJ0cmV1c2U6IFwiN2ZmZjAwXCIsXG5cdCAgY2hvY29sYXRlOiBcImQyNjkxZVwiLFxuXHQgIGNvcmFsOiBcImZmN2Y1MFwiLFxuXHQgIGNvcm5mbG93ZXJibHVlOiBcIjY0OTVlZFwiLFxuXHQgIGNvcm5zaWxrOiBcImZmZjhkY1wiLFxuXHQgIGNyaW1zb246IFwiZGMxNDNjXCIsXG5cdCAgY3lhbjogXCIwZmZcIixcblx0ICBkYXJrYmx1ZTogXCIwMDAwOGJcIixcblx0ICBkYXJrY3lhbjogXCIwMDhiOGJcIixcblx0ICBkYXJrZ29sZGVucm9kOiBcImI4ODYwYlwiLFxuXHQgIGRhcmtncmF5OiBcImE5YTlhOVwiLFxuXHQgIGRhcmtncmVlbjogXCIwMDY0MDBcIixcblx0ICBkYXJrZ3JleTogXCJhOWE5YTlcIixcblx0ICBkYXJra2hha2k6IFwiYmRiNzZiXCIsXG5cdCAgZGFya21hZ2VudGE6IFwiOGIwMDhiXCIsXG5cdCAgZGFya29saXZlZ3JlZW46IFwiNTU2YjJmXCIsXG5cdCAgZGFya29yYW5nZTogXCJmZjhjMDBcIixcblx0ICBkYXJrb3JjaGlkOiBcIjk5MzJjY1wiLFxuXHQgIGRhcmtyZWQ6IFwiOGIwMDAwXCIsXG5cdCAgZGFya3NhbG1vbjogXCJlOTk2N2FcIixcblx0ICBkYXJrc2VhZ3JlZW46IFwiOGZiYzhmXCIsXG5cdCAgZGFya3NsYXRlYmx1ZTogXCI0ODNkOGJcIixcblx0ICBkYXJrc2xhdGVncmF5OiBcIjJmNGY0ZlwiLFxuXHQgIGRhcmtzbGF0ZWdyZXk6IFwiMmY0ZjRmXCIsXG5cdCAgZGFya3R1cnF1b2lzZTogXCIwMGNlZDFcIixcblx0ICBkYXJrdmlvbGV0OiBcIjk0MDBkM1wiLFxuXHQgIGRlZXBwaW5rOiBcImZmMTQ5M1wiLFxuXHQgIGRlZXBza3libHVlOiBcIjAwYmZmZlwiLFxuXHQgIGRpbWdyYXk6IFwiNjk2OTY5XCIsXG5cdCAgZGltZ3JleTogXCI2OTY5NjlcIixcblx0ICBkb2RnZXJibHVlOiBcIjFlOTBmZlwiLFxuXHQgIGZpcmVicmljazogXCJiMjIyMjJcIixcblx0ICBmbG9yYWx3aGl0ZTogXCJmZmZhZjBcIixcblx0ICBmb3Jlc3RncmVlbjogXCIyMjhiMjJcIixcblx0ICBmdWNoc2lhOiBcImYwZlwiLFxuXHQgIGdhaW5zYm9ybzogXCJkY2RjZGNcIixcblx0ICBnaG9zdHdoaXRlOiBcImY4ZjhmZlwiLFxuXHQgIGdvbGQ6IFwiZmZkNzAwXCIsXG5cdCAgZ29sZGVucm9kOiBcImRhYTUyMFwiLFxuXHQgIGdyYXk6IFwiODA4MDgwXCIsXG5cdCAgZ3JlZW46IFwiMDA4MDAwXCIsXG5cdCAgZ3JlZW55ZWxsb3c6IFwiYWRmZjJmXCIsXG5cdCAgZ3JleTogXCI4MDgwODBcIixcblx0ICBob25leWRldzogXCJmMGZmZjBcIixcblx0ICBob3RwaW5rOiBcImZmNjliNFwiLFxuXHQgIGluZGlhbnJlZDogXCJjZDVjNWNcIixcblx0ICBpbmRpZ286IFwiNGIwMDgyXCIsXG5cdCAgaXZvcnk6IFwiZmZmZmYwXCIsXG5cdCAga2hha2k6IFwiZjBlNjhjXCIsXG5cdCAgbGF2ZW5kZXI6IFwiZTZlNmZhXCIsXG5cdCAgbGF2ZW5kZXJibHVzaDogXCJmZmYwZjVcIixcblx0ICBsYXduZ3JlZW46IFwiN2NmYzAwXCIsXG5cdCAgbGVtb25jaGlmZm9uOiBcImZmZmFjZFwiLFxuXHQgIGxpZ2h0Ymx1ZTogXCJhZGQ4ZTZcIixcblx0ICBsaWdodGNvcmFsOiBcImYwODA4MFwiLFxuXHQgIGxpZ2h0Y3lhbjogXCJlMGZmZmZcIixcblx0ICBsaWdodGdvbGRlbnJvZHllbGxvdzogXCJmYWZhZDJcIixcblx0ICBsaWdodGdyYXk6IFwiZDNkM2QzXCIsXG5cdCAgbGlnaHRncmVlbjogXCI5MGVlOTBcIixcblx0ICBsaWdodGdyZXk6IFwiZDNkM2QzXCIsXG5cdCAgbGlnaHRwaW5rOiBcImZmYjZjMVwiLFxuXHQgIGxpZ2h0c2FsbW9uOiBcImZmYTA3YVwiLFxuXHQgIGxpZ2h0c2VhZ3JlZW46IFwiMjBiMmFhXCIsXG5cdCAgbGlnaHRza3libHVlOiBcIjg3Y2VmYVwiLFxuXHQgIGxpZ2h0c2xhdGVncmF5OiBcIjc4OVwiLFxuXHQgIGxpZ2h0c2xhdGVncmV5OiBcIjc4OVwiLFxuXHQgIGxpZ2h0c3RlZWxibHVlOiBcImIwYzRkZVwiLFxuXHQgIGxpZ2h0eWVsbG93OiBcImZmZmZlMFwiLFxuXHQgIGxpbWU6IFwiMGYwXCIsXG5cdCAgbGltZWdyZWVuOiBcIjMyY2QzMlwiLFxuXHQgIGxpbmVuOiBcImZhZjBlNlwiLFxuXHQgIG1hZ2VudGE6IFwiZjBmXCIsXG5cdCAgbWFyb29uOiBcIjgwMDAwMFwiLFxuXHQgIG1lZGl1bWFxdWFtYXJpbmU6IFwiNjZjZGFhXCIsXG5cdCAgbWVkaXVtYmx1ZTogXCIwMDAwY2RcIixcblx0ICBtZWRpdW1vcmNoaWQ6IFwiYmE1NWQzXCIsXG5cdCAgbWVkaXVtcHVycGxlOiBcIjkzNzBkYlwiLFxuXHQgIG1lZGl1bXNlYWdyZWVuOiBcIjNjYjM3MVwiLFxuXHQgIG1lZGl1bXNsYXRlYmx1ZTogXCI3YjY4ZWVcIixcblx0ICBtZWRpdW1zcHJpbmdncmVlbjogXCIwMGZhOWFcIixcblx0ICBtZWRpdW10dXJxdW9pc2U6IFwiNDhkMWNjXCIsXG5cdCAgbWVkaXVtdmlvbGV0cmVkOiBcImM3MTU4NVwiLFxuXHQgIG1pZG5pZ2h0Ymx1ZTogXCIxOTE5NzBcIixcblx0ICBtaW50Y3JlYW06IFwiZjVmZmZhXCIsXG5cdCAgbWlzdHlyb3NlOiBcImZmZTRlMVwiLFxuXHQgIG1vY2Nhc2luOiBcImZmZTRiNVwiLFxuXHQgIG5hdmFqb3doaXRlOiBcImZmZGVhZFwiLFxuXHQgIG5hdnk6IFwiMDAwMDgwXCIsXG5cdCAgb2xkbGFjZTogXCJmZGY1ZTZcIixcblx0ICBvbGl2ZTogXCI4MDgwMDBcIixcblx0ICBvbGl2ZWRyYWI6IFwiNmI4ZTIzXCIsXG5cdCAgb3JhbmdlOiBcImZmYTUwMFwiLFxuXHQgIG9yYW5nZXJlZDogXCJmZjQ1MDBcIixcblx0ICBvcmNoaWQ6IFwiZGE3MGQ2XCIsXG5cdCAgcGFsZWdvbGRlbnJvZDogXCJlZWU4YWFcIixcblx0ICBwYWxlZ3JlZW46IFwiOThmYjk4XCIsXG5cdCAgcGFsZXR1cnF1b2lzZTogXCJhZmVlZWVcIixcblx0ICBwYWxldmlvbGV0cmVkOiBcImRiNzA5M1wiLFxuXHQgIHBhcGF5YXdoaXA6IFwiZmZlZmQ1XCIsXG5cdCAgcGVhY2hwdWZmOiBcImZmZGFiOVwiLFxuXHQgIHBlcnU6IFwiY2Q4NTNmXCIsXG5cdCAgcGluazogXCJmZmMwY2JcIixcblx0ICBwbHVtOiBcImRkYTBkZFwiLFxuXHQgIHBvd2RlcmJsdWU6IFwiYjBlMGU2XCIsXG5cdCAgcHVycGxlOiBcIjgwMDA4MFwiLFxuXHQgIHJlYmVjY2FwdXJwbGU6IFwiNjYzMzk5XCIsXG5cdCAgcmVkOiBcImYwMFwiLFxuXHQgIHJvc3licm93bjogXCJiYzhmOGZcIixcblx0ICByb3lhbGJsdWU6IFwiNDE2OWUxXCIsXG5cdCAgc2FkZGxlYnJvd246IFwiOGI0NTEzXCIsXG5cdCAgc2FsbW9uOiBcImZhODA3MlwiLFxuXHQgIHNhbmR5YnJvd246IFwiZjRhNDYwXCIsXG5cdCAgc2VhZ3JlZW46IFwiMmU4YjU3XCIsXG5cdCAgc2Vhc2hlbGw6IFwiZmZmNWVlXCIsXG5cdCAgc2llbm5hOiBcImEwNTIyZFwiLFxuXHQgIHNpbHZlcjogXCJjMGMwYzBcIixcblx0ICBza3libHVlOiBcIjg3Y2VlYlwiLFxuXHQgIHNsYXRlYmx1ZTogXCI2YTVhY2RcIixcblx0ICBzbGF0ZWdyYXk6IFwiNzA4MDkwXCIsXG5cdCAgc2xhdGVncmV5OiBcIjcwODA5MFwiLFxuXHQgIHNub3c6IFwiZmZmYWZhXCIsXG5cdCAgc3ByaW5nZ3JlZW46IFwiMDBmZjdmXCIsXG5cdCAgc3RlZWxibHVlOiBcIjQ2ODJiNFwiLFxuXHQgIHRhbjogXCJkMmI0OGNcIixcblx0ICB0ZWFsOiBcIjAwODA4MFwiLFxuXHQgIHRoaXN0bGU6IFwiZDhiZmQ4XCIsXG5cdCAgdG9tYXRvOiBcImZmNjM0N1wiLFxuXHQgIHR1cnF1b2lzZTogXCI0MGUwZDBcIixcblx0ICB2aW9sZXQ6IFwiZWU4MmVlXCIsXG5cdCAgd2hlYXQ6IFwiZjVkZWIzXCIsXG5cdCAgd2hpdGU6IFwiZmZmXCIsXG5cdCAgd2hpdGVzbW9rZTogXCJmNWY1ZjVcIixcblx0ICB5ZWxsb3c6IFwiZmYwXCIsXG5cdCAgeWVsbG93Z3JlZW46IFwiOWFjZDMyXCJcblx0fTtcblxuXG4vKioqLyB9LFxuLyogMTEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihtb2R1bGUpIHsvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuOS4zXG5cdChmdW5jdGlvbigpIHtcblx0ICB2YXIgTF90b19ZLCBZX3RvX0wsIGNvbnYsIGRpc3RhbmNlRnJvbVBvbGUsIGRvdFByb2R1Y3QsIGVwc2lsb24sIGZyb21MaW5lYXIsIGdldEJvdW5kcywgaW50ZXJzZWN0TGluZUxpbmUsIGthcHBhLCBsZW5ndGhPZlJheVVudGlsSW50ZXJzZWN0LCBtLCBtX2ludiwgbWF4Q2hyb21hRm9yTEgsIG1heFNhZmVDaHJvbWFGb3JMLCByZWZVLCByZWZWLCByb290LCB0b0xpbmVhcjtcblx0XG5cdCAgbSA9IHtcblx0ICAgIFI6IFszLjI0MDk2OTk0MTkwNDUyMTQsIC0xLjUzNzM4MzE3NzU3MDA5MzUsIC0wLjQ5ODYxMDc2MDI5MzAwMzI4XSxcblx0ICAgIEc6IFstMC45NjkyNDM2MzYyODA4Nzk4MywgMS44NzU5Njc1MDE1MDc3MjA3LCAwLjA0MTU1NTA1NzQwNzE3NTYxM10sXG5cdCAgICBCOiBbMC4wNTU2MzAwNzk2OTY5OTM2MDksIC0wLjIwMzk3Njk1ODg4ODk3NjU3LCAxLjA1Njk3MTUxNDI0Mjg3ODZdXG5cdCAgfTtcblx0XG5cdCAgbV9pbnYgPSB7XG5cdCAgICBYOiBbMC40MTIzOTA3OTkyNjU5NTk0OCwgMC4zNTc1ODQzMzkzODM4Nzc5NiwgMC4xODA0ODA3ODg0MDE4MzQyOV0sXG5cdCAgICBZOiBbMC4yMTI2MzkwMDU4NzE1MTAzNiwgMC43MTUxNjg2Nzg3Njc3NTU5MywgMC4wNzIxOTIzMTUzNjA3MzM3MTVdLFxuXHQgICAgWjogWzAuMDE5MzMwODE4NzE1NTkxODUxLCAwLjExOTE5NDc3OTc5NDYyNTk5LCAwLjk1MDUzMjE1MjI0OTY2MDU4XVxuXHQgIH07XG5cdFxuXHQgIHJlZlUgPSAwLjE5NzgzMDAwNjY0MjgzNjgxO1xuXHRcblx0ICByZWZWID0gMC40NjgzMTk5OTQ5Mzg3OTE7XG5cdFxuXHQgIGthcHBhID0gOTAzLjI5NjI5NjI5NjI5NjM7XG5cdFxuXHQgIGVwc2lsb24gPSAwLjAwODg1NjQ1MTY3OTAzNTYzMDg7XG5cdFxuXHQgIGdldEJvdW5kcyA9IGZ1bmN0aW9uKEwpIHtcblx0ICAgIHZhciBib3R0b20sIGNoYW5uZWwsIGosIGssIGxlbjEsIGxlbjIsIG0xLCBtMiwgbTMsIHJlZiwgcmVmMSwgcmVmMiwgcmV0LCBzdWIxLCBzdWIyLCB0LCB0b3AxLCB0b3AyO1xuXHQgICAgc3ViMSA9IE1hdGgucG93KEwgKyAxNiwgMykgLyAxNTYwODk2O1xuXHQgICAgc3ViMiA9IHN1YjEgPiBlcHNpbG9uID8gc3ViMSA6IEwgLyBrYXBwYTtcblx0ICAgIHJldCA9IFtdO1xuXHQgICAgcmVmID0gWydSJywgJ0cnLCAnQiddO1xuXHQgICAgZm9yIChqID0gMCwgbGVuMSA9IHJlZi5sZW5ndGg7IGogPCBsZW4xOyBqKyspIHtcblx0ICAgICAgY2hhbm5lbCA9IHJlZltqXTtcblx0ICAgICAgcmVmMSA9IG1bY2hhbm5lbF0sIG0xID0gcmVmMVswXSwgbTIgPSByZWYxWzFdLCBtMyA9IHJlZjFbMl07XG5cdCAgICAgIHJlZjIgPSBbMCwgMV07XG5cdCAgICAgIGZvciAoayA9IDAsIGxlbjIgPSByZWYyLmxlbmd0aDsgayA8IGxlbjI7IGsrKykge1xuXHQgICAgICAgIHQgPSByZWYyW2tdO1xuXHQgICAgICAgIHRvcDEgPSAoMjg0NTE3ICogbTEgLSA5NDgzOSAqIG0zKSAqIHN1YjI7XG5cdCAgICAgICAgdG9wMiA9ICg4Mzg0MjIgKiBtMyArIDc2OTg2MCAqIG0yICsgNzMxNzE4ICogbTEpICogTCAqIHN1YjIgLSA3Njk4NjAgKiB0ICogTDtcblx0ICAgICAgICBib3R0b20gPSAoNjMyMjYwICogbTMgLSAxMjY0NTIgKiBtMikgKiBzdWIyICsgMTI2NDUyICogdDtcblx0ICAgICAgICByZXQucHVzaChbdG9wMSAvIGJvdHRvbSwgdG9wMiAvIGJvdHRvbV0pO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmV0O1xuXHQgIH07XG5cdFxuXHQgIGludGVyc2VjdExpbmVMaW5lID0gZnVuY3Rpb24obGluZTEsIGxpbmUyKSB7XG5cdCAgICByZXR1cm4gKGxpbmUxWzFdIC0gbGluZTJbMV0pIC8gKGxpbmUyWzBdIC0gbGluZTFbMF0pO1xuXHQgIH07XG5cdFxuXHQgIGRpc3RhbmNlRnJvbVBvbGUgPSBmdW5jdGlvbihwb2ludCkge1xuXHQgICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwb2ludFswXSwgMikgKyBNYXRoLnBvdyhwb2ludFsxXSwgMikpO1xuXHQgIH07XG5cdFxuXHQgIGxlbmd0aE9mUmF5VW50aWxJbnRlcnNlY3QgPSBmdW5jdGlvbih0aGV0YSwgbGluZSkge1xuXHQgICAgdmFyIGIxLCBsZW4sIG0xO1xuXHQgICAgbTEgPSBsaW5lWzBdLCBiMSA9IGxpbmVbMV07XG5cdCAgICBsZW4gPSBiMSAvIChNYXRoLnNpbih0aGV0YSkgLSBtMSAqIE1hdGguY29zKHRoZXRhKSk7XG5cdCAgICBpZiAobGVuIDwgMCkge1xuXHQgICAgICByZXR1cm4gbnVsbDtcblx0ICAgIH1cblx0ICAgIHJldHVybiBsZW47XG5cdCAgfTtcblx0XG5cdCAgbWF4U2FmZUNocm9tYUZvckwgPSBmdW5jdGlvbihMKSB7XG5cdCAgICB2YXIgYjEsIGosIGxlbjEsIGxlbmd0aHMsIG0xLCByZWYsIHJlZjEsIHg7XG5cdCAgICBsZW5ndGhzID0gW107XG5cdCAgICByZWYgPSBnZXRCb3VuZHMoTCk7XG5cdCAgICBmb3IgKGogPSAwLCBsZW4xID0gcmVmLmxlbmd0aDsgaiA8IGxlbjE7IGorKykge1xuXHQgICAgICByZWYxID0gcmVmW2pdLCBtMSA9IHJlZjFbMF0sIGIxID0gcmVmMVsxXTtcblx0ICAgICAgeCA9IGludGVyc2VjdExpbmVMaW5lKFttMSwgYjFdLCBbLTEgLyBtMSwgMF0pO1xuXHQgICAgICBsZW5ndGhzLnB1c2goZGlzdGFuY2VGcm9tUG9sZShbeCwgYjEgKyB4ICogbTFdKSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gTWF0aC5taW4uYXBwbHkoTWF0aCwgbGVuZ3Rocyk7XG5cdCAgfTtcblx0XG5cdCAgbWF4Q2hyb21hRm9yTEggPSBmdW5jdGlvbihMLCBIKSB7XG5cdCAgICB2YXIgaHJhZCwgaiwgbCwgbGVuMSwgbGVuZ3RocywgbGluZSwgcmVmO1xuXHQgICAgaHJhZCA9IEggLyAzNjAgKiBNYXRoLlBJICogMjtcblx0ICAgIGxlbmd0aHMgPSBbXTtcblx0ICAgIHJlZiA9IGdldEJvdW5kcyhMKTtcblx0ICAgIGZvciAoaiA9IDAsIGxlbjEgPSByZWYubGVuZ3RoOyBqIDwgbGVuMTsgaisrKSB7XG5cdCAgICAgIGxpbmUgPSByZWZbal07XG5cdCAgICAgIGwgPSBsZW5ndGhPZlJheVVudGlsSW50ZXJzZWN0KGhyYWQsIGxpbmUpO1xuXHQgICAgICBpZiAobCAhPT0gbnVsbCkge1xuXHQgICAgICAgIGxlbmd0aHMucHVzaChsKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIE1hdGgubWluLmFwcGx5KE1hdGgsIGxlbmd0aHMpO1xuXHQgIH07XG5cdFxuXHQgIGRvdFByb2R1Y3QgPSBmdW5jdGlvbihhLCBiKSB7XG5cdCAgICB2YXIgaSwgaiwgcmVmLCByZXQ7XG5cdCAgICByZXQgPSAwO1xuXHQgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IGEubGVuZ3RoIC0gMTsgMCA8PSByZWYgPyBqIDw9IHJlZiA6IGogPj0gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcblx0ICAgICAgcmV0ICs9IGFbaV0gKiBiW2ldO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJldDtcblx0ICB9O1xuXHRcblx0ICBmcm9tTGluZWFyID0gZnVuY3Rpb24oYykge1xuXHQgICAgaWYgKGMgPD0gMC4wMDMxMzA4KSB7XG5cdCAgICAgIHJldHVybiAxMi45MiAqIGM7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gMS4wNTUgKiBNYXRoLnBvdyhjLCAxIC8gMi40KSAtIDAuMDU1O1xuXHQgICAgfVxuXHQgIH07XG5cdFxuXHQgIHRvTGluZWFyID0gZnVuY3Rpb24oYykge1xuXHQgICAgdmFyIGE7XG5cdCAgICBhID0gMC4wNTU7XG5cdCAgICBpZiAoYyA+IDAuMDQwNDUpIHtcblx0ICAgICAgcmV0dXJuIE1hdGgucG93KChjICsgYSkgLyAoMSArIGEpLCAyLjQpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIGMgLyAxMi45Mjtcblx0ICAgIH1cblx0ICB9O1xuXHRcblx0ICBjb252ID0ge1xuXHQgICAgJ3h5eic6IHt9LFxuXHQgICAgJ2x1dic6IHt9LFxuXHQgICAgJ2xjaCc6IHt9LFxuXHQgICAgJ2h1c2wnOiB7fSxcblx0ICAgICdodXNscCc6IHt9LFxuXHQgICAgJ3JnYic6IHt9LFxuXHQgICAgJ2hleCc6IHt9XG5cdCAgfTtcblx0XG5cdCAgY29udi54eXoucmdiID0gZnVuY3Rpb24odHVwbGUpIHtcblx0ICAgIHZhciBCLCBHLCBSO1xuXHQgICAgUiA9IGZyb21MaW5lYXIoZG90UHJvZHVjdChtLlIsIHR1cGxlKSk7XG5cdCAgICBHID0gZnJvbUxpbmVhcihkb3RQcm9kdWN0KG0uRywgdHVwbGUpKTtcblx0ICAgIEIgPSBmcm9tTGluZWFyKGRvdFByb2R1Y3QobS5CLCB0dXBsZSkpO1xuXHQgICAgcmV0dXJuIFtSLCBHLCBCXTtcblx0ICB9O1xuXHRcblx0ICBjb252LnJnYi54eXogPSBmdW5jdGlvbih0dXBsZSkge1xuXHQgICAgdmFyIEIsIEcsIFIsIFgsIFksIFosIHJnYmw7XG5cdCAgICBSID0gdHVwbGVbMF0sIEcgPSB0dXBsZVsxXSwgQiA9IHR1cGxlWzJdO1xuXHQgICAgcmdibCA9IFt0b0xpbmVhcihSKSwgdG9MaW5lYXIoRyksIHRvTGluZWFyKEIpXTtcblx0ICAgIFggPSBkb3RQcm9kdWN0KG1faW52LlgsIHJnYmwpO1xuXHQgICAgWSA9IGRvdFByb2R1Y3QobV9pbnYuWSwgcmdibCk7XG5cdCAgICBaID0gZG90UHJvZHVjdChtX2ludi5aLCByZ2JsKTtcblx0ICAgIHJldHVybiBbWCwgWSwgWl07XG5cdCAgfTtcblx0XG5cdCAgWV90b19MID0gZnVuY3Rpb24oWSkge1xuXHQgICAgaWYgKFkgPD0gZXBzaWxvbikge1xuXHQgICAgICByZXR1cm4gWSAqIGthcHBhO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIDExNiAqIE1hdGgucG93KFksIDEgLyAzKSAtIDE2O1xuXHQgICAgfVxuXHQgIH07XG5cdFxuXHQgIExfdG9fWSA9IGZ1bmN0aW9uKEwpIHtcblx0ICAgIGlmIChMIDw9IDgpIHtcblx0ICAgICAgcmV0dXJuIEwgLyBrYXBwYTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiBNYXRoLnBvdygoTCArIDE2KSAvIDExNiwgMyk7XG5cdCAgICB9XG5cdCAgfTtcblx0XG5cdCAgY29udi54eXoubHV2ID0gZnVuY3Rpb24odHVwbGUpIHtcblx0ICAgIHZhciBMLCBVLCBWLCBYLCBZLCBaLCB2YXJVLCB2YXJWO1xuXHQgICAgWCA9IHR1cGxlWzBdLCBZID0gdHVwbGVbMV0sIFogPSB0dXBsZVsyXTtcblx0ICAgIGlmIChZID09PSAwKSB7XG5cdCAgICAgIHJldHVybiBbMCwgMCwgMF07XG5cdCAgICB9XG5cdCAgICBMID0gWV90b19MKFkpO1xuXHQgICAgdmFyVSA9ICg0ICogWCkgLyAoWCArICgxNSAqIFkpICsgKDMgKiBaKSk7XG5cdCAgICB2YXJWID0gKDkgKiBZKSAvIChYICsgKDE1ICogWSkgKyAoMyAqIFopKTtcblx0ICAgIFUgPSAxMyAqIEwgKiAodmFyVSAtIHJlZlUpO1xuXHQgICAgViA9IDEzICogTCAqICh2YXJWIC0gcmVmVik7XG5cdCAgICByZXR1cm4gW0wsIFUsIFZdO1xuXHQgIH07XG5cdFxuXHQgIGNvbnYubHV2Lnh5eiA9IGZ1bmN0aW9uKHR1cGxlKSB7XG5cdCAgICB2YXIgTCwgVSwgViwgWCwgWSwgWiwgdmFyVSwgdmFyVjtcblx0ICAgIEwgPSB0dXBsZVswXSwgVSA9IHR1cGxlWzFdLCBWID0gdHVwbGVbMl07XG5cdCAgICBpZiAoTCA9PT0gMCkge1xuXHQgICAgICByZXR1cm4gWzAsIDAsIDBdO1xuXHQgICAgfVxuXHQgICAgdmFyVSA9IFUgLyAoMTMgKiBMKSArIHJlZlU7XG5cdCAgICB2YXJWID0gViAvICgxMyAqIEwpICsgcmVmVjtcblx0ICAgIFkgPSBMX3RvX1koTCk7XG5cdCAgICBYID0gMCAtICg5ICogWSAqIHZhclUpIC8gKCh2YXJVIC0gNCkgKiB2YXJWIC0gdmFyVSAqIHZhclYpO1xuXHQgICAgWiA9ICg5ICogWSAtICgxNSAqIHZhclYgKiBZKSAtICh2YXJWICogWCkpIC8gKDMgKiB2YXJWKTtcblx0ICAgIHJldHVybiBbWCwgWSwgWl07XG5cdCAgfTtcblx0XG5cdCAgY29udi5sdXYubGNoID0gZnVuY3Rpb24odHVwbGUpIHtcblx0ICAgIHZhciBDLCBILCBIcmFkLCBMLCBVLCBWO1xuXHQgICAgTCA9IHR1cGxlWzBdLCBVID0gdHVwbGVbMV0sIFYgPSB0dXBsZVsyXTtcblx0ICAgIEMgPSBNYXRoLnNxcnQoTWF0aC5wb3coVSwgMikgKyBNYXRoLnBvdyhWLCAyKSk7XG5cdCAgICBpZiAoQyA8IDAuMDAwMDAwMDEpIHtcblx0ICAgICAgSCA9IDA7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBIcmFkID0gTWF0aC5hdGFuMihWLCBVKTtcblx0ICAgICAgSCA9IEhyYWQgKiAzNjAgLyAyIC8gTWF0aC5QSTtcblx0ICAgICAgaWYgKEggPCAwKSB7XG5cdCAgICAgICAgSCA9IDM2MCArIEg7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBbTCwgQywgSF07XG5cdCAgfTtcblx0XG5cdCAgY29udi5sY2gubHV2ID0gZnVuY3Rpb24odHVwbGUpIHtcblx0ICAgIHZhciBDLCBILCBIcmFkLCBMLCBVLCBWO1xuXHQgICAgTCA9IHR1cGxlWzBdLCBDID0gdHVwbGVbMV0sIEggPSB0dXBsZVsyXTtcblx0ICAgIEhyYWQgPSBIIC8gMzYwICogMiAqIE1hdGguUEk7XG5cdCAgICBVID0gTWF0aC5jb3MoSHJhZCkgKiBDO1xuXHQgICAgViA9IE1hdGguc2luKEhyYWQpICogQztcblx0ICAgIHJldHVybiBbTCwgVSwgVl07XG5cdCAgfTtcblx0XG5cdCAgY29udi5odXNsLmxjaCA9IGZ1bmN0aW9uKHR1cGxlKSB7XG5cdCAgICB2YXIgQywgSCwgTCwgUywgbWF4O1xuXHQgICAgSCA9IHR1cGxlWzBdLCBTID0gdHVwbGVbMV0sIEwgPSB0dXBsZVsyXTtcblx0ICAgIGlmIChMID4gOTkuOTk5OTk5OSB8fCBMIDwgMC4wMDAwMDAwMSkge1xuXHQgICAgICBDID0gMDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIG1heCA9IG1heENocm9tYUZvckxIKEwsIEgpO1xuXHQgICAgICBDID0gbWF4IC8gMTAwICogUztcblx0ICAgIH1cblx0ICAgIHJldHVybiBbTCwgQywgSF07XG5cdCAgfTtcblx0XG5cdCAgY29udi5sY2guaHVzbCA9IGZ1bmN0aW9uKHR1cGxlKSB7XG5cdCAgICB2YXIgQywgSCwgTCwgUywgbWF4O1xuXHQgICAgTCA9IHR1cGxlWzBdLCBDID0gdHVwbGVbMV0sIEggPSB0dXBsZVsyXTtcblx0ICAgIGlmIChMID4gOTkuOTk5OTk5OSB8fCBMIDwgMC4wMDAwMDAwMSkge1xuXHQgICAgICBTID0gMDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIG1heCA9IG1heENocm9tYUZvckxIKEwsIEgpO1xuXHQgICAgICBTID0gQyAvIG1heCAqIDEwMDtcblx0ICAgIH1cblx0ICAgIHJldHVybiBbSCwgUywgTF07XG5cdCAgfTtcblx0XG5cdCAgY29udi5odXNscC5sY2ggPSBmdW5jdGlvbih0dXBsZSkge1xuXHQgICAgdmFyIEMsIEgsIEwsIFMsIG1heDtcblx0ICAgIEggPSB0dXBsZVswXSwgUyA9IHR1cGxlWzFdLCBMID0gdHVwbGVbMl07XG5cdCAgICBpZiAoTCA+IDk5Ljk5OTk5OTkgfHwgTCA8IDAuMDAwMDAwMDEpIHtcblx0ICAgICAgQyA9IDA7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBtYXggPSBtYXhTYWZlQ2hyb21hRm9yTChMKTtcblx0ICAgICAgQyA9IG1heCAvIDEwMCAqIFM7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gW0wsIEMsIEhdO1xuXHQgIH07XG5cdFxuXHQgIGNvbnYubGNoLmh1c2xwID0gZnVuY3Rpb24odHVwbGUpIHtcblx0ICAgIHZhciBDLCBILCBMLCBTLCBtYXg7XG5cdCAgICBMID0gdHVwbGVbMF0sIEMgPSB0dXBsZVsxXSwgSCA9IHR1cGxlWzJdO1xuXHQgICAgaWYgKEwgPiA5OS45OTk5OTk5IHx8IEwgPCAwLjAwMDAwMDAxKSB7XG5cdCAgICAgIFMgPSAwO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgbWF4ID0gbWF4U2FmZUNocm9tYUZvckwoTCk7XG5cdCAgICAgIFMgPSBDIC8gbWF4ICogMTAwO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIFtILCBTLCBMXTtcblx0ICB9O1xuXHRcblx0ICBjb252LnJnYi5oZXggPSBmdW5jdGlvbih0dXBsZSkge1xuXHQgICAgdmFyIGNoLCBoZXgsIGosIGxlbjE7XG5cdCAgICBoZXggPSBcIiNcIjtcblx0ICAgIGZvciAoaiA9IDAsIGxlbjEgPSB0dXBsZS5sZW5ndGg7IGogPCBsZW4xOyBqKyspIHtcblx0ICAgICAgY2ggPSB0dXBsZVtqXTtcblx0ICAgICAgY2ggPSBNYXRoLnJvdW5kKGNoICogMWU2KSAvIDFlNjtcblx0ICAgICAgaWYgKGNoIDwgMCB8fCBjaCA+IDEpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIHJnYiB2YWx1ZTogXCIgKyBjaCk7XG5cdCAgICAgIH1cblx0ICAgICAgY2ggPSBNYXRoLnJvdW5kKGNoICogMjU1KS50b1N0cmluZygxNik7XG5cdCAgICAgIGlmIChjaC5sZW5ndGggPT09IDEpIHtcblx0ICAgICAgICBjaCA9IFwiMFwiICsgY2g7XG5cdCAgICAgIH1cblx0ICAgICAgaGV4ICs9IGNoO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGhleDtcblx0ICB9O1xuXHRcblx0ICBjb252LmhleC5yZ2IgPSBmdW5jdGlvbihoZXgpIHtcblx0ICAgIHZhciBiLCBnLCBqLCBsZW4xLCBuLCByLCByZWYsIHJlc3VsdHM7XG5cdCAgICBpZiAoaGV4LmNoYXJBdCgwKSA9PT0gXCIjXCIpIHtcblx0ICAgICAgaGV4ID0gaGV4LnN1YnN0cmluZygxLCA3KTtcblx0ICAgIH1cblx0ICAgIHIgPSBoZXguc3Vic3RyaW5nKDAsIDIpO1xuXHQgICAgZyA9IGhleC5zdWJzdHJpbmcoMiwgNCk7XG5cdCAgICBiID0gaGV4LnN1YnN0cmluZyg0LCA2KTtcblx0ICAgIHJlZiA9IFtyLCBnLCBiXTtcblx0ICAgIHJlc3VsdHMgPSBbXTtcblx0ICAgIGZvciAoaiA9IDAsIGxlbjEgPSByZWYubGVuZ3RoOyBqIDwgbGVuMTsgaisrKSB7XG5cdCAgICAgIG4gPSByZWZbal07XG5cdCAgICAgIHJlc3VsdHMucHVzaChwYXJzZUludChuLCAxNikgLyAyNTUpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdHM7XG5cdCAgfTtcblx0XG5cdCAgY29udi5sY2gucmdiID0gZnVuY3Rpb24odHVwbGUpIHtcblx0ICAgIHJldHVybiBjb252Lnh5ei5yZ2IoY29udi5sdXYueHl6KGNvbnYubGNoLmx1dih0dXBsZSkpKTtcblx0ICB9O1xuXHRcblx0ICBjb252LnJnYi5sY2ggPSBmdW5jdGlvbih0dXBsZSkge1xuXHQgICAgcmV0dXJuIGNvbnYubHV2LmxjaChjb252Lnh5ei5sdXYoY29udi5yZ2IueHl6KHR1cGxlKSkpO1xuXHQgIH07XG5cdFxuXHQgIGNvbnYuaHVzbC5yZ2IgPSBmdW5jdGlvbih0dXBsZSkge1xuXHQgICAgcmV0dXJuIGNvbnYubGNoLnJnYihjb252Lmh1c2wubGNoKHR1cGxlKSk7XG5cdCAgfTtcblx0XG5cdCAgY29udi5yZ2IuaHVzbCA9IGZ1bmN0aW9uKHR1cGxlKSB7XG5cdCAgICByZXR1cm4gY29udi5sY2guaHVzbChjb252LnJnYi5sY2godHVwbGUpKTtcblx0ICB9O1xuXHRcblx0ICBjb252Lmh1c2xwLnJnYiA9IGZ1bmN0aW9uKHR1cGxlKSB7XG5cdCAgICByZXR1cm4gY29udi5sY2gucmdiKGNvbnYuaHVzbHAubGNoKHR1cGxlKSk7XG5cdCAgfTtcblx0XG5cdCAgY29udi5yZ2IuaHVzbHAgPSBmdW5jdGlvbih0dXBsZSkge1xuXHQgICAgcmV0dXJuIGNvbnYubGNoLmh1c2xwKGNvbnYucmdiLmxjaCh0dXBsZSkpO1xuXHQgIH07XG5cdFxuXHQgIHJvb3QgPSB7fTtcblx0XG5cdCAgcm9vdC5mcm9tUkdCID0gZnVuY3Rpb24oUiwgRywgQikge1xuXHQgICAgcmV0dXJuIGNvbnYucmdiLmh1c2woW1IsIEcsIEJdKTtcblx0ICB9O1xuXHRcblx0ICByb290LmZyb21IZXggPSBmdW5jdGlvbihoZXgpIHtcblx0ICAgIHJldHVybiBjb252LnJnYi5odXNsKGNvbnYuaGV4LnJnYihoZXgpKTtcblx0ICB9O1xuXHRcblx0ICByb290LnRvUkdCID0gZnVuY3Rpb24oSCwgUywgTCkge1xuXHQgICAgcmV0dXJuIGNvbnYuaHVzbC5yZ2IoW0gsIFMsIExdKTtcblx0ICB9O1xuXHRcblx0ICByb290LnRvSGV4ID0gZnVuY3Rpb24oSCwgUywgTCkge1xuXHQgICAgcmV0dXJuIGNvbnYucmdiLmhleChjb252Lmh1c2wucmdiKFtILCBTLCBMXSkpO1xuXHQgIH07XG5cdFxuXHQgIHJvb3QucCA9IHt9O1xuXHRcblx0ICByb290LnAudG9SR0IgPSBmdW5jdGlvbihILCBTLCBMKSB7XG5cdCAgICByZXR1cm4gY29udi54eXoucmdiKGNvbnYubHV2Lnh5eihjb252LmxjaC5sdXYoY29udi5odXNscC5sY2goW0gsIFMsIExdKSkpKTtcblx0ICB9O1xuXHRcblx0ICByb290LnAudG9IZXggPSBmdW5jdGlvbihILCBTLCBMKSB7XG5cdCAgICByZXR1cm4gY29udi5yZ2IuaGV4KGNvbnYueHl6LnJnYihjb252Lmx1di54eXooY29udi5sY2gubHV2KGNvbnYuaHVzbHAubGNoKFtILCBTLCBMXSkpKSkpO1xuXHQgIH07XG5cdFxuXHQgIHJvb3QucC5mcm9tUkdCID0gZnVuY3Rpb24oUiwgRywgQikge1xuXHQgICAgcmV0dXJuIGNvbnYubGNoLmh1c2xwKGNvbnYubHV2LmxjaChjb252Lnh5ei5sdXYoY29udi5yZ2IueHl6KFtSLCBHLCBCXSkpKSk7XG5cdCAgfTtcblx0XG5cdCAgcm9vdC5wLmZyb21IZXggPSBmdW5jdGlvbihoZXgpIHtcblx0ICAgIHJldHVybiBjb252LmxjaC5odXNscChjb252Lmx1di5sY2goY29udi54eXoubHV2KGNvbnYucmdiLnh5eihjb252LmhleC5yZ2IoaGV4KSkpKSk7XG5cdCAgfTtcblx0XG5cdCAgcm9vdC5fY29udiA9IGNvbnY7XG5cdFxuXHQgIHJvb3QuX2dldEJvdW5kcyA9IGdldEJvdW5kcztcblx0XG5cdCAgcm9vdC5fbWF4Q2hyb21hRm9yTEggPSBtYXhDaHJvbWFGb3JMSDtcblx0XG5cdCAgcm9vdC5fbWF4U2FmZUNocm9tYUZvckwgPSBtYXhTYWZlQ2hyb21hRm9yTDtcblx0XG5cdCAgaWYgKCEoKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlICE9PSBudWxsKSB8fCAodHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBqUXVlcnkgIT09IG51bGwpIHx8ICh0eXBlb2YgcmVxdWlyZWpzICE9PSBcInVuZGVmaW5lZFwiICYmIHJlcXVpcmVqcyAhPT0gbnVsbCkpKSB7XG5cdCAgICB0aGlzLkhVU0wgPSByb290O1xuXHQgIH1cblx0XG5cdCAgaWYgKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlICE9PSBudWxsKSB7XG5cdCAgICBtb2R1bGUuZXhwb3J0cyA9IHJvb3Q7XG5cdCAgfVxuXHRcblx0ICBpZiAodHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBqUXVlcnkgIT09IG51bGwpIHtcblx0ICAgIGpRdWVyeS5odXNsID0gcm9vdDtcblx0ICB9XG5cdFxuXHQgIGlmICgodHlwZW9mIHJlcXVpcmVqcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiByZXF1aXJlanMgIT09IG51bGwpICYmIChcImZ1bmN0aW9uXCIgIT09IFwidW5kZWZpbmVkXCIgJiYgX193ZWJwYWNrX3JlcXVpcmVfXygxMikgIT09IG51bGwpKSB7XG5cdCAgICAhKF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9IChyb290KSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/IChfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpKSA6IF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblx0ICB9XG5cdFxuXHR9KS5jYWxsKHRoaXMpO1xuXHRcblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oMykobW9kdWxlKSkpXG5cbi8qKiovIH0sXG4vKiAxMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHsgdGhyb3cgbmV3IEVycm9yKFwiZGVmaW5lIGNhbm5vdCBiZSB1c2VkIGluZGlyZWN0XCIpOyB9O1xyXG5cblxuLyoqKi8gfSxcbi8qIDEzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgQW5pbWF0aW9uLCBCYXNlQ2xhc3MsIENvbG9yLCBDb25maWcsIERlZmF1bHRzLCBFdmVudEVtaXR0ZXIsIEV2ZW50cywgR2VzdHVyZXMsIExheWVyRHJhZ2dhYmxlLCBMYXllclBpbmNoYWJsZSwgTGF5ZXJTdGF0ZXMsIExheWVyU3R5bGUsIE1hdHJpeCwgTm9DYWNoZURhdGVLZXksIFV0aWxzLCBfLCBsYXllclByb3BlcnR5LCBsYXllclByb3BlcnR5UG9pbnRUcmFuc2Zvcm1lciwgbGF5ZXJWYWx1ZVR5cGVFcnJvcixcblx0ICBiaW5kID0gZnVuY3Rpb24oZm4sIG1lKXsgcmV0dXJuIGZ1bmN0aW9uKCl7IHJldHVybiBmbi5hcHBseShtZSwgYXJndW1lbnRzKTsgfTsgfSxcblx0ICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG5cdCAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxuXHQgIGluZGV4T2YgPSBbXS5pbmRleE9mIHx8IGZ1bmN0aW9uKGl0ZW0pIHsgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykgeyBpZiAoaSBpbiB0aGlzICYmIHRoaXNbaV0gPT09IGl0ZW0pIHJldHVybiBpOyB9IHJldHVybiAtMTsgfSxcblx0ICBzbGljZSA9IFtdLnNsaWNlO1xuXHRcblx0XyA9IF9fd2VicGFja19yZXF1aXJlX18oMSkuXztcblx0XG5cdFV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0XG5cdENvbmZpZyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpLkNvbmZpZztcblx0XG5cdEV2ZW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpLkV2ZW50cztcblx0XG5cdERlZmF1bHRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNykuRGVmYXVsdHM7XG5cdFxuXHRCYXNlQ2xhc3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpLkJhc2VDbGFzcztcblx0XG5cdEV2ZW50RW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oNykuRXZlbnRFbWl0dGVyO1xuXHRcblx0Q29sb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKS5Db2xvcjtcblx0XG5cdE1hdHJpeCA9IF9fd2VicGFja19yZXF1aXJlX18oOSkuTWF0cml4O1xuXHRcblx0QW5pbWF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCkuQW5pbWF0aW9uO1xuXHRcblx0TGF5ZXJTdHlsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpLkxheWVyU3R5bGU7XG5cdFxuXHRMYXllclN0YXRlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpLkxheWVyU3RhdGVzO1xuXHRcblx0TGF5ZXJEcmFnZ2FibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KS5MYXllckRyYWdnYWJsZTtcblx0XG5cdExheWVyUGluY2hhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCkuTGF5ZXJQaW5jaGFibGU7XG5cdFxuXHRHZXN0dXJlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpLkdlc3R1cmVzO1xuXHRcblx0Tm9DYWNoZURhdGVLZXkgPSBEYXRlLm5vdygpO1xuXHRcblx0bGF5ZXJWYWx1ZVR5cGVFcnJvciA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG5cdCAgdGhyb3cgbmV3IEVycm9yKFwiTGF5ZXIuXCIgKyBuYW1lICsgXCI6IHZhbHVlICdcIiArIHZhbHVlICsgXCInIG9mIHR5cGUgJ1wiICsgKHR5cGVvZiB2YWx1ZSkgKyBcIicnIGlzIG5vdCB2YWxpZFwiKTtcblx0fTtcblx0XG5cdGxheWVyUHJvcGVydHkgPSBmdW5jdGlvbihvYmosIG5hbWUsIGNzc1Byb3BlcnR5LCBmYWxsYmFjaywgdmFsaWRhdG9yLCB0cmFuc2Zvcm1lciwgb3B0aW9ucywgc2V0KSB7XG5cdCAgdmFyIHJlc3VsdDtcblx0ICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG5cdCAgICBvcHRpb25zID0ge307XG5cdCAgfVxuXHQgIHJlc3VsdCA9IHtcblx0ICAgIFwiZGVmYXVsdFwiOiBmYWxsYmFjayxcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIGlmICh0aGlzLl9wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BlcnRpZXNbbmFtZV07XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuXHQgICAgfSxcblx0ICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgaWYgKHRyYW5zZm9ybWVyKSB7XG5cdCAgICAgICAgdmFsdWUgPSB0cmFuc2Zvcm1lcih2YWx1ZSwgdGhpcywgbmFtZSk7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHZhbHVlID09PSB0aGlzLl9wcm9wZXJ0aWVzW25hbWVdKSB7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cdCAgICAgIGlmICh2YWx1ZSAmJiB2YWxpZGF0b3IgJiYgIXZhbGlkYXRvcih2YWx1ZSkpIHtcblx0ICAgICAgICBsYXllclZhbHVlVHlwZUVycm9yKG5hbWUsIHZhbHVlKTtcblx0ICAgICAgfVxuXHQgICAgICB0aGlzLl9wcm9wZXJ0aWVzW25hbWVdID0gdmFsdWU7XG5cdCAgICAgIGlmIChjc3NQcm9wZXJ0eSAhPT0gbnVsbCkge1xuXHQgICAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbY3NzUHJvcGVydHldID0gTGF5ZXJTdHlsZVtjc3NQcm9wZXJ0eV0odGhpcyk7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHR5cGVvZiBzZXQgPT09IFwiZnVuY3Rpb25cIikge1xuXHQgICAgICAgIHNldCh0aGlzLCB2YWx1ZSk7XG5cdCAgICAgIH1cblx0ICAgICAgdGhpcy5lbWl0KFwiY2hhbmdlOlwiICsgbmFtZSwgdmFsdWUpO1xuXHQgICAgICBpZiAobmFtZSA9PT0gXCJ4XCIgfHwgbmFtZSA9PT0gXCJ5XCIpIHtcblx0ICAgICAgICB0aGlzLmVtaXQoXCJjaGFuZ2U6cG9pbnRcIiwgdmFsdWUpO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChuYW1lID09PSBcIndpZHRoXCIgfHwgbmFtZSA9PT0gXCJoZWlnaHRcIikge1xuXHQgICAgICAgIHRoaXMuZW1pdChcImNoYW5nZTpzaXplXCIsIHZhbHVlKTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAobmFtZSA9PT0gXCJ4XCIgfHwgbmFtZSA9PT0gXCJ5XCIgfHwgbmFtZSA9PT0gXCJ3aWR0aFwiIHx8IG5hbWUgPT09IFwiaGVpZ2h0XCIpIHtcblx0ICAgICAgICB0aGlzLmVtaXQoXCJjaGFuZ2U6ZnJhbWVcIiwgdmFsdWUpO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChuYW1lID09PSBcInJvdGF0aW9uWlwiKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChcImNoYW5nZTpyb3RhdGlvblwiLCB2YWx1ZSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXHQgIHJldHVybiByZXN1bHQgPSBfLmV4dGVuZChyZXN1bHQsIG9wdGlvbnMpO1xuXHR9O1xuXHRcblx0bGF5ZXJQcm9wZXJ0eVBvaW50VHJhbnNmb3JtZXIgPSBmdW5jdGlvbih2YWx1ZSwgbGF5ZXIsIHByb3BlcnR5KSB7XG5cdCAgaWYgKF8uaXNGdW5jdGlvbih2YWx1ZSkpIHtcblx0ICAgIHZhbHVlID0gdmFsdWUobGF5ZXIsIHByb3BlcnR5KTtcblx0ICB9XG5cdCAgcmV0dXJuIHZhbHVlO1xuXHR9O1xuXHRcblx0ZXhwb3J0cy5MYXllciA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG5cdCAgZXh0ZW5kKExheWVyLCBzdXBlckNsYXNzKTtcblx0XG5cdCAgZnVuY3Rpb24gTGF5ZXIob3B0aW9ucykge1xuXHQgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuXHQgICAgICBvcHRpb25zID0ge307XG5cdCAgICB9XG5cdCAgICB0aGlzLmFkZExpc3RlbmVyID0gYmluZCh0aGlzLmFkZExpc3RlbmVyLCB0aGlzKTtcblx0ICAgIHRoaXMub25jZSA9IGJpbmQodGhpcy5vbmNlLCB0aGlzKTtcblx0ICAgIHRoaXMuX3Byb3BlcnRpZXMgPSB7fTtcblx0ICAgIHRoaXMuX3N0eWxlID0ge307XG5cdCAgICB0aGlzLl9jaGlsZHJlbiA9IFtdO1xuXHQgICAgdGhpcy5fcHJlZmVyMmQgPSBmYWxzZTtcblx0ICAgIHRoaXMuX2Fsd2F5c1VzZUltYWdlQ2FjaGUgPSBmYWxzZTtcblx0ICAgIHRoaXMuX2NhbmNlbENsaWNrRXZlbnRJbkRyYWdTZXNzaW9uID0gdHJ1ZTtcblx0ICAgIHRoaXMuX2NhbmNlbENsaWNrRXZlbnRJbkRyYWdTZXNzaW9uVmVsb2NpdHkgPSAwLjE7XG5cdCAgICB0aGlzLl9jcmVhdGVFbGVtZW50KCk7XG5cdCAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShcImZyYW1lXCIpKSB7XG5cdCAgICAgIG9wdGlvbnMgPSBfLmV4dGVuZChvcHRpb25zLCBvcHRpb25zLmZyYW1lKTtcblx0ICAgIH1cblx0ICAgIG9wdGlvbnMgPSBEZWZhdWx0cy5nZXREZWZhdWx0cyhcIkxheWVyXCIsIG9wdGlvbnMpO1xuXHQgICAgTGF5ZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICB0aGlzLl9jb250ZXh0LmFkZExheWVyKHRoaXMpO1xuXHQgICAgdGhpcy5faWQgPSB0aGlzLl9jb250ZXh0LmxheWVyQ291bnRlcjtcblx0ICAgIGlmICghb3B0aW9ucy5wYXJlbnQgJiYgb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShcInN1cGVyTGF5ZXJcIikpIHtcblx0ICAgICAgb3B0aW9ucy5wYXJlbnQgPSBvcHRpb25zLnN1cGVyTGF5ZXI7XG5cdCAgICB9XG5cdCAgICBpZiAoIW9wdGlvbnMucGFyZW50KSB7XG5cdCAgICAgIGlmICghb3B0aW9ucy5zaGFkb3cpIHtcblx0ICAgICAgICB0aGlzLl9pbnNlcnRFbGVtZW50KCk7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRoaXMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG5cdCAgICB9XG5cdCAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShcImluZGV4XCIpKSB7XG5cdCAgICAgIHRoaXMuaW5kZXggPSBvcHRpb25zLmluZGV4O1xuXHQgICAgfVxuXHQgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoXCJ4XCIpKSB7XG5cdCAgICAgIHRoaXMueCA9IG9wdGlvbnMueDtcblx0ICAgIH1cblx0ICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KFwieVwiKSkge1xuXHQgICAgICB0aGlzLnkgPSBvcHRpb25zLnk7XG5cdCAgICB9XG5cdCAgICB0aGlzLl9jb250ZXh0LmVtaXQoXCJsYXllcjpjcmVhdGVcIiwgdGhpcyk7XG5cdCAgfVxuXHRcblx0ICBMYXllci5kZWZpbmUoXCJjb250ZXh0XCIsIHtcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0O1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBMYXllci5kZWZpbmUoXCJjdXN0b21cIiwgTGF5ZXIuc2ltcGxlUHJvcGVydHkoXCJjdXN0b21cIiwgdm9pZCAwKSk7XG5cdFxuXHQgIExheWVyLmRlZmluZShcIndpZHRoXCIsIGxheWVyUHJvcGVydHkoTGF5ZXIsIFwid2lkdGhcIiwgXCJ3aWR0aFwiLCAxMDAsIF8uaXNOdW1iZXIpKTtcblx0XG5cdCAgTGF5ZXIuZGVmaW5lKFwiaGVpZ2h0XCIsIGxheWVyUHJvcGVydHkoTGF5ZXIsIFwiaGVpZ2h0XCIsIFwiaGVpZ2h0XCIsIDEwMCwgXy5pc051bWJlcikpO1xuXHRcblx0ICBMYXllci5kZWZpbmUoXCJ2aXNpYmxlXCIsIGxheWVyUHJvcGVydHkoTGF5ZXIsIFwidmlzaWJsZVwiLCBcImRpc3BsYXlcIiwgdHJ1ZSwgXy5pc0Jvb2xlYW4pKTtcblx0XG5cdCAgTGF5ZXIuZGVmaW5lKFwib3BhY2l0eVwiLCBsYXllclByb3BlcnR5KExheWVyLCBcIm9wYWNpdHlcIiwgXCJvcGFjaXR5XCIsIDEsIF8uaXNOdW1iZXIpKTtcblx0XG5cdCAgTGF5ZXIuZGVmaW5lKFwiaW5kZXhcIiwgbGF5ZXJQcm9wZXJ0eShMYXllciwgXCJpbmRleFwiLCBcInpJbmRleFwiLCAwLCBfLmlzTnVtYmVyLCBudWxsLCB7XG5cdCAgICBpbXBvcnRhYmxlOiBmYWxzZSxcblx0ICAgIGV4cG9ydGFibGU6IGZhbHNlXG5cdCAgfSkpO1xuXHRcblx0ICBMYXllci5kZWZpbmUoXCJjbGlwXCIsIGxheWVyUHJvcGVydHkoTGF5ZXIsIFwiY2xpcFwiLCBcIm92ZXJmbG93XCIsIGZhbHNlLCBfLmlzQm9vbGVhbikpO1xuXHRcblx0ICBMYXllci5kZWZpbmUoXCJzY3JvbGxIb3Jpem9udGFsXCIsIGxheWVyUHJvcGVydHkoTGF5ZXIsIFwic2Nyb2xsSG9yaXpvbnRhbFwiLCBcIm92ZXJmbG93WFwiLCBmYWxzZSwgXy5pc0Jvb2xlYW4sIG51bGwsIHt9LCBmdW5jdGlvbihsYXllciwgdmFsdWUpIHtcblx0ICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuXHQgICAgICByZXR1cm4gbGF5ZXIuaWdub3JlRXZlbnRzID0gZmFsc2U7XG5cdCAgICB9XG5cdCAgfSkpO1xuXHRcblx0ICBMYXllci5kZWZpbmUoXCJzY3JvbGxWZXJ0aWNhbFwiLCBsYXllclByb3BlcnR5KExheWVyLCBcInNjcm9sbFZlcnRpY2FsXCIsIFwib3ZlcmZsb3dZXCIsIGZhbHNlLCBfLmlzQm9vbGVhbiwgbnVsbCwge30sIGZ1bmN0aW9uKGxheWVyLCB2YWx1ZSkge1xuXHQgICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG5cdCAgICAgIHJldHVybiBsYXllci5pZ25vcmVFdmVudHMgPSBmYWxzZTtcblx0ICAgIH1cblx0ICB9KSk7XG5cdFxuXHQgIExheWVyLmRlZmluZShcInNjcm9sbFwiLCB7XG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5zY3JvbGxIb3Jpem9udGFsID09PSB0cnVlIHx8IHRoaXMuc2Nyb2xsVmVydGljYWwgPT09IHRydWU7XG5cdCAgICB9LFxuXHQgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5zY3JvbGxIb3Jpem9udGFsID0gdGhpcy5zY3JvbGxWZXJ0aWNhbCA9IHZhbHVlO1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBMYXllci5kZWZpbmUoXCJpZ25vcmVFdmVudHNcIiwgbGF5ZXJQcm9wZXJ0eShMYXllciwgXCJpZ25vcmVFdmVudHNcIiwgXCJwb2ludGVyRXZlbnRzXCIsIHRydWUsIF8uaXNCb29sZWFuKSk7XG5cdFxuXHQgIExheWVyLmRlZmluZShcInhcIiwgbGF5ZXJQcm9wZXJ0eShMYXllciwgXCJ4XCIsIFwid2Via2l0VHJhbnNmb3JtXCIsIDAsIF8uaXNOdW1iZXIsIGxheWVyUHJvcGVydHlQb2ludFRyYW5zZm9ybWVyKSk7XG5cdFxuXHQgIExheWVyLmRlZmluZShcInlcIiwgbGF5ZXJQcm9wZXJ0eShMYXllciwgXCJ5XCIsIFwid2Via2l0VHJhbnNmb3JtXCIsIDAsIF8uaXNOdW1iZXIsIGxheWVyUHJvcGVydHlQb2ludFRyYW5zZm9ybWVyKSk7XG5cdFxuXHQgIExheWVyLmRlZmluZShcInpcIiwgbGF5ZXJQcm9wZXJ0eShMYXllciwgXCJ6XCIsIFwid2Via2l0VHJhbnNmb3JtXCIsIDAsIF8uaXNOdW1iZXIpKTtcblx0XG5cdCAgTGF5ZXIuZGVmaW5lKFwic2NhbGVYXCIsIGxheWVyUHJvcGVydHkoTGF5ZXIsIFwic2NhbGVYXCIsIFwid2Via2l0VHJhbnNmb3JtXCIsIDEsIF8uaXNOdW1iZXIpKTtcblx0XG5cdCAgTGF5ZXIuZGVmaW5lKFwic2NhbGVZXCIsIGxheWVyUHJvcGVydHkoTGF5ZXIsIFwic2NhbGVZXCIsIFwid2Via2l0VHJhbnNmb3JtXCIsIDEsIF8uaXNOdW1iZXIpKTtcblx0XG5cdCAgTGF5ZXIuZGVmaW5lKFwic2NhbGVaXCIsIGxheWVyUHJvcGVydHkoTGF5ZXIsIFwic2NhbGVaXCIsIFwid2Via2l0VHJhbnNmb3JtXCIsIDEsIF8uaXNOdW1iZXIpKTtcblx0XG5cdCAgTGF5ZXIuZGVmaW5lKFwic2NhbGVcIiwgbGF5ZXJQcm9wZXJ0eShMYXllciwgXCJzY2FsZVwiLCBcIndlYmtpdFRyYW5zZm9ybVwiLCAxLCBfLmlzTnVtYmVyKSk7XG5cdFxuXHQgIExheWVyLmRlZmluZShcInNrZXdYXCIsIGxheWVyUHJvcGVydHkoTGF5ZXIsIFwic2tld1hcIiwgXCJ3ZWJraXRUcmFuc2Zvcm1cIiwgMCwgXy5pc051bWJlcikpO1xuXHRcblx0ICBMYXllci5kZWZpbmUoXCJza2V3WVwiLCBsYXllclByb3BlcnR5KExheWVyLCBcInNrZXdZXCIsIFwid2Via2l0VHJhbnNmb3JtXCIsIDAsIF8uaXNOdW1iZXIpKTtcblx0XG5cdCAgTGF5ZXIuZGVmaW5lKFwic2tld1wiLCBsYXllclByb3BlcnR5KExheWVyLCBcInNrZXdcIiwgXCJ3ZWJraXRUcmFuc2Zvcm1cIiwgMCwgXy5pc051bWJlcikpO1xuXHRcblx0ICBMYXllci5kZWZpbmUoXCJvcmlnaW5YXCIsIGxheWVyUHJvcGVydHkoTGF5ZXIsIFwib3JpZ2luWFwiLCBcIndlYmtpdFRyYW5zZm9ybU9yaWdpblwiLCAwLjUsIF8uaXNOdW1iZXIpKTtcblx0XG5cdCAgTGF5ZXIuZGVmaW5lKFwib3JpZ2luWVwiLCBsYXllclByb3BlcnR5KExheWVyLCBcIm9yaWdpbllcIiwgXCJ3ZWJraXRUcmFuc2Zvcm1PcmlnaW5cIiwgMC41LCBfLmlzTnVtYmVyKSk7XG5cdFxuXHQgIExheWVyLmRlZmluZShcIm9yaWdpblpcIiwgbGF5ZXJQcm9wZXJ0eShMYXllciwgXCJvcmlnaW5aXCIsIG51bGwsIDAsIF8uaXNOdW1iZXIpKTtcblx0XG5cdCAgTGF5ZXIuZGVmaW5lKFwicGVyc3BlY3RpdmVcIiwgbGF5ZXJQcm9wZXJ0eShMYXllciwgXCJwZXJzcGVjdGl2ZVwiLCBcIndlYmtpdFBlcnNwZWN0aXZlXCIsIDAsIF8uaXNOdW1iZXIpKTtcblx0XG5cdCAgTGF5ZXIuZGVmaW5lKFwicGVyc3BlY3RpdmVPcmlnaW5YXCIsIGxheWVyUHJvcGVydHkoTGF5ZXIsIFwicGVyc3BlY3RpdmVPcmlnaW5YXCIsIFwid2Via2l0UGVyc3BlY3RpdmVPcmlnaW5cIiwgMC41LCBfLmlzTnVtYmVyKSk7XG5cdFxuXHQgIExheWVyLmRlZmluZShcInBlcnNwZWN0aXZlT3JpZ2luWVwiLCBsYXllclByb3BlcnR5KExheWVyLCBcInBlcnNwZWN0aXZlT3JpZ2luWVwiLCBcIndlYmtpdFBlcnNwZWN0aXZlT3JpZ2luXCIsIDAuNSwgXy5pc051bWJlcikpO1xuXHRcblx0ICBMYXllci5kZWZpbmUoXCJyb3RhdGlvblhcIiwgbGF5ZXJQcm9wZXJ0eShMYXllciwgXCJyb3RhdGlvblhcIiwgXCJ3ZWJraXRUcmFuc2Zvcm1cIiwgMCwgXy5pc051bWJlcikpO1xuXHRcblx0ICBMYXllci5kZWZpbmUoXCJyb3RhdGlvbllcIiwgbGF5ZXJQcm9wZXJ0eShMYXllciwgXCJyb3RhdGlvbllcIiwgXCJ3ZWJraXRUcmFuc2Zvcm1cIiwgMCwgXy5pc051bWJlcikpO1xuXHRcblx0ICBMYXllci5kZWZpbmUoXCJyb3RhdGlvblpcIiwgbGF5ZXJQcm9wZXJ0eShMYXllciwgXCJyb3RhdGlvblpcIiwgXCJ3ZWJraXRUcmFuc2Zvcm1cIiwgMCwgXy5pc051bWJlcikpO1xuXHRcblx0ICBMYXllci5kZWZpbmUoXCJyb3RhdGlvblwiLCB7XG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5yb3RhdGlvblo7XG5cdCAgICB9LFxuXHQgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5yb3RhdGlvblogPSB2YWx1ZTtcblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgTGF5ZXIuZGVmaW5lKFwiYmx1clwiLCBsYXllclByb3BlcnR5KExheWVyLCBcImJsdXJcIiwgXCJ3ZWJraXRGaWx0ZXJcIiwgMCwgXy5pc051bWJlcikpO1xuXHRcblx0ICBMYXllci5kZWZpbmUoXCJicmlnaHRuZXNzXCIsIGxheWVyUHJvcGVydHkoTGF5ZXIsIFwiYnJpZ2h0bmVzc1wiLCBcIndlYmtpdEZpbHRlclwiLCAxMDAsIF8uaXNOdW1iZXIpKTtcblx0XG5cdCAgTGF5ZXIuZGVmaW5lKFwic2F0dXJhdGVcIiwgbGF5ZXJQcm9wZXJ0eShMYXllciwgXCJzYXR1cmF0ZVwiLCBcIndlYmtpdEZpbHRlclwiLCAxMDAsIF8uaXNOdW1iZXIpKTtcblx0XG5cdCAgTGF5ZXIuZGVmaW5lKFwiaHVlUm90YXRlXCIsIGxheWVyUHJvcGVydHkoTGF5ZXIsIFwiaHVlUm90YXRlXCIsIFwid2Via2l0RmlsdGVyXCIsIDAsIF8uaXNOdW1iZXIpKTtcblx0XG5cdCAgTGF5ZXIuZGVmaW5lKFwiY29udHJhc3RcIiwgbGF5ZXJQcm9wZXJ0eShMYXllciwgXCJjb250cmFzdFwiLCBcIndlYmtpdEZpbHRlclwiLCAxMDAsIF8uaXNOdW1iZXIpKTtcblx0XG5cdCAgTGF5ZXIuZGVmaW5lKFwiaW52ZXJ0XCIsIGxheWVyUHJvcGVydHkoTGF5ZXIsIFwiaW52ZXJ0XCIsIFwid2Via2l0RmlsdGVyXCIsIDAsIF8uaXNOdW1iZXIpKTtcblx0XG5cdCAgTGF5ZXIuZGVmaW5lKFwiZ3JheXNjYWxlXCIsIGxheWVyUHJvcGVydHkoTGF5ZXIsIFwiZ3JheXNjYWxlXCIsIFwid2Via2l0RmlsdGVyXCIsIDAsIF8uaXNOdW1iZXIpKTtcblx0XG5cdCAgTGF5ZXIuZGVmaW5lKFwic2VwaWFcIiwgbGF5ZXJQcm9wZXJ0eShMYXllciwgXCJzZXBpYVwiLCBcIndlYmtpdEZpbHRlclwiLCAwLCBfLmlzTnVtYmVyKSk7XG5cdFxuXHQgIExheWVyLmRlZmluZShcInNoYWRvd1hcIiwgbGF5ZXJQcm9wZXJ0eShMYXllciwgXCJzaGFkb3dYXCIsIFwiYm94U2hhZG93XCIsIDAsIF8uaXNOdW1iZXIpKTtcblx0XG5cdCAgTGF5ZXIuZGVmaW5lKFwic2hhZG93WVwiLCBsYXllclByb3BlcnR5KExheWVyLCBcInNoYWRvd1lcIiwgXCJib3hTaGFkb3dcIiwgMCwgXy5pc051bWJlcikpO1xuXHRcblx0ICBMYXllci5kZWZpbmUoXCJzaGFkb3dCbHVyXCIsIGxheWVyUHJvcGVydHkoTGF5ZXIsIFwic2hhZG93Qmx1clwiLCBcImJveFNoYWRvd1wiLCAwLCBfLmlzTnVtYmVyKSk7XG5cdFxuXHQgIExheWVyLmRlZmluZShcInNoYWRvd1NwcmVhZFwiLCBsYXllclByb3BlcnR5KExheWVyLCBcInNoYWRvd1NwcmVhZFwiLCBcImJveFNoYWRvd1wiLCAwLCBfLmlzTnVtYmVyKSk7XG5cdFxuXHQgIExheWVyLmRlZmluZShcInNoYWRvd0NvbG9yXCIsIGxheWVyUHJvcGVydHkoTGF5ZXIsIFwic2hhZG93Q29sb3JcIiwgXCJib3hTaGFkb3dcIiwgXCJcIiwgQ29sb3IudmFsaWRDb2xvclZhbHVlLCBDb2xvci50b0NvbG9yKSk7XG5cdFxuXHQgIExheWVyLmRlZmluZShcImJhY2tncm91bmRDb2xvclwiLCBsYXllclByb3BlcnR5KExheWVyLCBcImJhY2tncm91bmRDb2xvclwiLCBcImJhY2tncm91bmRDb2xvclwiLCBudWxsLCBDb2xvci52YWxpZENvbG9yVmFsdWUsIENvbG9yLnRvQ29sb3IpKTtcblx0XG5cdCAgTGF5ZXIuZGVmaW5lKFwiY29sb3JcIiwgbGF5ZXJQcm9wZXJ0eShMYXllciwgXCJjb2xvclwiLCBcImNvbG9yXCIsIG51bGwsIENvbG9yLnZhbGlkQ29sb3JWYWx1ZSwgQ29sb3IudG9Db2xvcikpO1xuXHRcblx0ICBMYXllci5kZWZpbmUoXCJib3JkZXJDb2xvclwiLCBsYXllclByb3BlcnR5KExheWVyLCBcImJvcmRlckNvbG9yXCIsIFwiYm9yZGVyXCIsIG51bGwsIENvbG9yLnZhbGlkQ29sb3JWYWx1ZSwgQ29sb3IudG9Db2xvcikpO1xuXHRcblx0ICBMYXllci5kZWZpbmUoXCJib3JkZXJXaWR0aFwiLCBsYXllclByb3BlcnR5KExheWVyLCBcImJvcmRlcldpZHRoXCIsIFwiYm9yZGVyXCIsIDAsIF8uaXNOdW1iZXIpKTtcblx0XG5cdCAgTGF5ZXIuZGVmaW5lKFwiZm9yY2UyZFwiLCBsYXllclByb3BlcnR5KExheWVyLCBcImZvcmNlMmRcIiwgXCJ3ZWJraXRUcmFuc2Zvcm1cIiwgZmFsc2UsIF8uaXNCb29sZWFuKSk7XG5cdFxuXHQgIExheWVyLmRlZmluZShcImZsYXRcIiwgbGF5ZXJQcm9wZXJ0eShMYXllciwgXCJmbGF0XCIsIFwid2Via2l0VHJhbnNmb3JtU3R5bGVcIiwgZmFsc2UsIF8uaXNCb29sZWFuKSk7XG5cdFxuXHQgIExheWVyLmRlZmluZShcImJhY2tmYWNlVmlzaWJsZVwiLCBsYXllclByb3BlcnR5KExheWVyLCBcImJhY2tmYWNlVmlzaWJsZVwiLCBcIndlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eVwiLCB0cnVlLCBfLmlzQm9vbGVhbikpO1xuXHRcblx0ICBMYXllci5kZWZpbmUoXCJuYW1lXCIsIHtcblx0ICAgIFwiZGVmYXVsdFwiOiBcIlwiLFxuXHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX2dldFByb3BlcnR5VmFsdWUoXCJuYW1lXCIpO1xuXHQgICAgfSxcblx0ICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgdGhpcy5fc2V0UHJvcGVydHlWYWx1ZShcIm5hbWVcIiwgdmFsdWUpO1xuXHQgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsIHZhbHVlKTtcblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgTGF5ZXIuZGVmaW5lKFwibWF0cml4XCIsIHtcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIGlmICh0aGlzLmZvcmNlMmQpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fbWF0cml4MmQ7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIG5ldyBNYXRyaXgoKS50cmFuc2xhdGUodGhpcy54LCB0aGlzLnksIHRoaXMueikuc2NhbGUodGhpcy5zY2FsZSkuc2NhbGUodGhpcy5zY2FsZVgsIHRoaXMuc2NhbGVZLCB0aGlzLnNjYWxlWikuc2tldyh0aGlzLnNrZXcpLnNrZXdYKHRoaXMuc2tld1gpLnNrZXdZKHRoaXMuc2tld1kpLnRyYW5zbGF0ZSgwLCAwLCB0aGlzLm9yaWdpblopLnJvdGF0ZSh0aGlzLnJvdGF0aW9uWCwgMCwgMCkucm90YXRlKDAsIHRoaXMucm90YXRpb25ZLCAwKS5yb3RhdGUoMCwgMCwgdGhpcy5yb3RhdGlvblopLnRyYW5zbGF0ZSgwLCAwLCAtdGhpcy5vcmlnaW5aKTtcblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgTGF5ZXIuZGVmaW5lKFwiX21hdHJpeDJkXCIsIHtcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiBuZXcgTWF0cml4KCkudHJhbnNsYXRlKHRoaXMueCwgdGhpcy55KS5zY2FsZSh0aGlzLnNjYWxlKS5za2V3WCh0aGlzLnNrZXcpLnNrZXdZKHRoaXMuc2tldykucm90YXRlKDAsIDAsIHRoaXMucm90YXRpb25aKTtcblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgTGF5ZXIuZGVmaW5lKFwidHJhbnNmb3JtTWF0cml4XCIsIHtcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiBuZXcgTWF0cml4KCkudHJhbnNsYXRlKHRoaXMub3JpZ2luWCAqIHRoaXMud2lkdGgsIHRoaXMub3JpZ2luWSAqIHRoaXMuaGVpZ2h0KS5tdWx0aXBseSh0aGlzLm1hdHJpeCkudHJhbnNsYXRlKC10aGlzLm9yaWdpblggKiB0aGlzLndpZHRoLCAtdGhpcy5vcmlnaW5ZICogdGhpcy5oZWlnaHQpO1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBMYXllci5kZWZpbmUoXCJtYXRyaXgzZFwiLCB7XG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICB2YXIgcGFyZW50LCBwcG07XG5cdCAgICAgIHBhcmVudCA9IHRoaXMuc3VwZXJMYXllciB8fCB0aGlzLmNvbnRleHQ7XG5cdCAgICAgIHBwbSA9IFV0aWxzLnBlcnNwZWN0aXZlTWF0cml4KHBhcmVudCk7XG5cdCAgICAgIHJldHVybiBuZXcgTWF0cml4KCkubXVsdGlwbHkocHBtKS5tdWx0aXBseSh0aGlzLnRyYW5zZm9ybU1hdHJpeCk7XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIExheWVyLmRlZmluZShcImJvcmRlclJhZGl1c1wiLCB7XG5cdCAgICBpbXBvcnRhYmxlOiB0cnVlLFxuXHQgICAgZXhwb3J0YWJsZTogdHJ1ZSxcblx0ICAgIFwiZGVmYXVsdFwiOiAwLFxuXHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX3Byb3BlcnRpZXNbXCJib3JkZXJSYWRpdXNcIl07XG5cdCAgICB9LFxuXHQgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICBpZiAodmFsdWUgJiYgIV8uaXNOdW1iZXIodmFsdWUpKSB7XG5cdCAgICAgICAgY29uc29sZS53YXJuKFwiTGF5ZXIuYm9yZGVyUmFkaXVzIHNob3VsZCBiZSBhIG51bWVyaWMgcHJvcGVydHksIG5vdCB0eXBlIFwiICsgKHR5cGVvZiB2YWx1ZSkpO1xuXHQgICAgICB9XG5cdCAgICAgIHRoaXMuX3Byb3BlcnRpZXNbXCJib3JkZXJSYWRpdXNcIl0gPSB2YWx1ZTtcblx0ICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtcImJvcmRlclJhZGl1c1wiXSA9IExheWVyU3R5bGVbXCJib3JkZXJSYWRpdXNcIl0odGhpcyk7XG5cdCAgICAgIHJldHVybiB0aGlzLmVtaXQoXCJjaGFuZ2U6Ym9yZGVyUmFkaXVzXCIsIHZhbHVlKTtcblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgTGF5ZXIuZGVmaW5lKFwiY29ybmVyUmFkaXVzXCIsIHtcblx0ICAgIGltcG9ydGFibGU6IGZhbHNlLFxuXHQgICAgZXhwb3J0YWJsZTogZmFsc2UsXG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5ib3JkZXJSYWRpdXM7XG5cdCAgICB9LFxuXHQgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5ib3JkZXJSYWRpdXMgPSB2YWx1ZTtcblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgTGF5ZXIuZGVmaW5lKFwicG9pbnRcIiwge1xuXHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIF8ucGljayh0aGlzLCBbXCJ4XCIsIFwieVwiXSk7XG5cdCAgICB9LFxuXHQgICAgc2V0OiBmdW5jdGlvbihwb2ludCkge1xuXHQgICAgICB2YXIgaSwgaywgbGVuLCByZWYsIHJlc3VsdHM7XG5cdCAgICAgIGlmICghcG9pbnQpIHtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKF8uaXNOdW1iZXIocG9pbnQpKSB7XG5cdCAgICAgICAgcG9pbnQgPSB7XG5cdCAgICAgICAgICB4OiBwb2ludCxcblx0ICAgICAgICAgIHk6IHBvaW50XG5cdCAgICAgICAgfTtcblx0ICAgICAgfVxuXHQgICAgICByZWYgPSBbXCJ4XCIsIFwieVwiXTtcblx0ICAgICAgcmVzdWx0cyA9IFtdO1xuXHQgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0ICAgICAgICBrID0gcmVmW2ldO1xuXHQgICAgICAgIGlmIChwb2ludC5oYXNPd25Qcm9wZXJ0eShrKSkge1xuXHQgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXNba10gPSBwb2ludFtrXSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHJlc3VsdHMucHVzaCh2b2lkIDApO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gcmVzdWx0cztcblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgTGF5ZXIuZGVmaW5lKFwic2l6ZVwiLCB7XG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gXy5waWNrKHRoaXMsIFtcIndpZHRoXCIsIFwiaGVpZ2h0XCJdKTtcblx0ICAgIH0sXG5cdCAgICBzZXQ6IGZ1bmN0aW9uKHNpemUpIHtcblx0ICAgICAgdmFyIGksIGssIGxlbiwgcmVmLCByZXN1bHRzO1xuXHQgICAgICBpZiAoIXNpemUpIHtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKF8uaXNOdW1iZXIoc2l6ZSkpIHtcblx0ICAgICAgICBzaXplID0ge1xuXHQgICAgICAgICAgd2lkdGg6IHNpemUsXG5cdCAgICAgICAgICBoZWlnaHQ6IHNpemVcblx0ICAgICAgICB9O1xuXHQgICAgICB9XG5cdCAgICAgIHJlZiA9IFtcIndpZHRoXCIsIFwiaGVpZ2h0XCJdO1xuXHQgICAgICByZXN1bHRzID0gW107XG5cdCAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHQgICAgICAgIGsgPSByZWZbaV07XG5cdCAgICAgICAgaWYgKHNpemUuaGFzT3duUHJvcGVydHkoaykpIHtcblx0ICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzW2tdID0gc2l6ZVtrXSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHJlc3VsdHMucHVzaCh2b2lkIDApO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gcmVzdWx0cztcblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgTGF5ZXIuZGVmaW5lKFwiZnJhbWVcIiwge1xuXHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIF8ucGljayh0aGlzLCBbXCJ4XCIsIFwieVwiLCBcIndpZHRoXCIsIFwiaGVpZ2h0XCJdKTtcblx0ICAgIH0sXG5cdCAgICBzZXQ6IGZ1bmN0aW9uKGZyYW1lKSB7XG5cdCAgICAgIHZhciBpLCBrLCBsZW4sIHJlZiwgcmVzdWx0cztcblx0ICAgICAgaWYgKCFmcmFtZSkge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHQgICAgICByZWYgPSBbXCJ4XCIsIFwieVwiLCBcIndpZHRoXCIsIFwiaGVpZ2h0XCJdO1xuXHQgICAgICByZXN1bHRzID0gW107XG5cdCAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHQgICAgICAgIGsgPSByZWZbaV07XG5cdCAgICAgICAgaWYgKGZyYW1lLmhhc093blByb3BlcnR5KGspKSB7XG5cdCAgICAgICAgICByZXN1bHRzLnB1c2godGhpc1trXSA9IGZyYW1lW2tdKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiByZXN1bHRzO1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBMYXllci5kZWZpbmUoXCJtaW5YXCIsIHtcblx0ICAgIGltcG9ydGFibGU6IHRydWUsXG5cdCAgICBleHBvcnRhYmxlOiBmYWxzZSxcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLng7XG5cdCAgICB9LFxuXHQgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICByZXR1cm4gdGhpcy54ID0gdmFsdWU7XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIExheWVyLmRlZmluZShcIm1pZFhcIiwge1xuXHQgICAgaW1wb3J0YWJsZTogdHJ1ZSxcblx0ICAgIGV4cG9ydGFibGU6IGZhbHNlLFxuXHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIFV0aWxzLmZyYW1lR2V0TWlkWCh0aGlzKTtcblx0ICAgIH0sXG5cdCAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgIHJldHVybiBVdGlscy5mcmFtZVNldE1pZFgodGhpcywgdmFsdWUpO1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBMYXllci5kZWZpbmUoXCJtYXhYXCIsIHtcblx0ICAgIGltcG9ydGFibGU6IHRydWUsXG5cdCAgICBleHBvcnRhYmxlOiBmYWxzZSxcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiBVdGlscy5mcmFtZUdldE1heFgodGhpcyk7XG5cdCAgICB9LFxuXHQgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICByZXR1cm4gVXRpbHMuZnJhbWVTZXRNYXhYKHRoaXMsIHZhbHVlKTtcblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgTGF5ZXIuZGVmaW5lKFwibWluWVwiLCB7XG5cdCAgICBpbXBvcnRhYmxlOiB0cnVlLFxuXHQgICAgZXhwb3J0YWJsZTogZmFsc2UsXG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy55O1xuXHQgICAgfSxcblx0ICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMueSA9IHZhbHVlO1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBMYXllci5kZWZpbmUoXCJtaWRZXCIsIHtcblx0ICAgIGltcG9ydGFibGU6IHRydWUsXG5cdCAgICBleHBvcnRhYmxlOiBmYWxzZSxcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiBVdGlscy5mcmFtZUdldE1pZFkodGhpcyk7XG5cdCAgICB9LFxuXHQgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICByZXR1cm4gVXRpbHMuZnJhbWVTZXRNaWRZKHRoaXMsIHZhbHVlKTtcblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgTGF5ZXIuZGVmaW5lKFwibWF4WVwiLCB7XG5cdCAgICBpbXBvcnRhYmxlOiB0cnVlLFxuXHQgICAgZXhwb3J0YWJsZTogZmFsc2UsXG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gVXRpbHMuZnJhbWVHZXRNYXhZKHRoaXMpO1xuXHQgICAgfSxcblx0ICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgcmV0dXJuIFV0aWxzLmZyYW1lU2V0TWF4WSh0aGlzLCB2YWx1ZSk7XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5jb252ZXJ0UG9pbnRGcm9tU2NyZWVuID0gZnVuY3Rpb24ocG9pbnQpIHtcblx0ICAgIHJldHVybiBVdGlscy5jb252ZXJ0UG9pbnRGcm9tQ29udGV4dChwb2ludCwgdGhpcywgZmFsc2UpO1xuXHQgIH07XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5jb252ZXJ0UG9pbnRGcm9tQ2FudmFzID0gZnVuY3Rpb24ocG9pbnQpIHtcblx0ICAgIHJldHVybiBVdGlscy5jb252ZXJ0UG9pbnRGcm9tQ29udGV4dChwb2ludCwgdGhpcywgdHJ1ZSk7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLmNvbnZlcnRQb2ludFRvU2NyZWVuID0gZnVuY3Rpb24ocG9pbnQpIHtcblx0ICAgIHJldHVybiBVdGlscy5jb252ZXJ0UG9pbnRUb0NvbnRleHQocG9pbnQsIHRoaXMsIGZhbHNlKTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUuY29udmVydFBvaW50VG9DYW52YXMgPSBmdW5jdGlvbihwb2ludCkge1xuXHQgICAgcmV0dXJuIFV0aWxzLmNvbnZlcnRQb2ludFRvQ29udGV4dChwb2ludCwgdGhpcywgdHJ1ZSk7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIuZGVmaW5lKFwiY2FudmFzRnJhbWVcIiwge1xuXHQgICAgaW1wb3J0YWJsZTogdHJ1ZSxcblx0ICAgIGV4cG9ydGFibGU6IGZhbHNlLFxuXHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIFV0aWxzLmJvdW5kaW5nRnJhbWUodGhpcyk7XG5cdCAgICB9LFxuXHQgICAgc2V0OiBmdW5jdGlvbihmcmFtZSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5mcmFtZSA9IFV0aWxzLmNvbnZlcnRGcmFtZUZyb21Db250ZXh0KGZyYW1lLCB0aGlzLCB0cnVlLCBmYWxzZSk7XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIExheWVyLmRlZmluZShcInNjcmVlbkZyYW1lXCIsIHtcblx0ICAgIGltcG9ydGFibGU6IHRydWUsXG5cdCAgICBleHBvcnRhYmxlOiBmYWxzZSxcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiBVdGlscy5ib3VuZGluZ0ZyYW1lKHRoaXMsIGZhbHNlKTtcblx0ICAgIH0sXG5cdCAgICBzZXQ6IGZ1bmN0aW9uKGZyYW1lKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmZyYW1lID0gVXRpbHMuY29udmVydEZyYW1lRnJvbUNvbnRleHQoZnJhbWUsIHRoaXMsIGZhbHNlLCBmYWxzZSk7XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5jb250ZW50RnJhbWUgPSBmdW5jdGlvbigpIHtcblx0ICAgIGlmICghdGhpcy5jaGlsZHJlbi5sZW5ndGgpIHtcblx0ICAgICAgcmV0dXJuIHtcblx0ICAgICAgICB4OiAwLFxuXHQgICAgICAgIHk6IDAsXG5cdCAgICAgICAgd2lkdGg6IDAsXG5cdCAgICAgICAgaGVpZ2h0OiAwXG5cdCAgICAgIH07XG5cdCAgICB9XG5cdCAgICByZXR1cm4gVXRpbHMuZnJhbWVNZXJnZShfLnBsdWNrKHRoaXMuY2hpbGRyZW4sIFwiZnJhbWVcIikpO1xuXHQgIH07XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5jZW50ZXJGcmFtZSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIGZyYW1lO1xuXHQgICAgaWYgKHRoaXMucGFyZW50KSB7XG5cdCAgICAgIGZyYW1lID0gdGhpcy5mcmFtZTtcblx0ICAgICAgVXRpbHMuZnJhbWVTZXRNaWRYKGZyYW1lLCBwYXJzZUludCgodGhpcy5wYXJlbnQud2lkdGggLyAyLjApIC0gdGhpcy5zdXBlckxheWVyLmJvcmRlcldpZHRoKSk7XG5cdCAgICAgIFV0aWxzLmZyYW1lU2V0TWlkWShmcmFtZSwgcGFyc2VJbnQoKHRoaXMucGFyZW50LmhlaWdodCAvIDIuMCkgLSB0aGlzLnN1cGVyTGF5ZXIuYm9yZGVyV2lkdGgpKTtcblx0ICAgICAgcmV0dXJuIGZyYW1lO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZnJhbWUgPSB0aGlzLmZyYW1lO1xuXHQgICAgICBVdGlscy5mcmFtZVNldE1pZFgoZnJhbWUsIHBhcnNlSW50KHRoaXMuX2NvbnRleHQud2lkdGggLyAyLjApKTtcblx0ICAgICAgVXRpbHMuZnJhbWVTZXRNaWRZKGZyYW1lLCBwYXJzZUludCh0aGlzLl9jb250ZXh0LmhlaWdodCAvIDIuMCkpO1xuXHQgICAgICByZXR1cm4gZnJhbWU7XG5cdCAgICB9XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLmNlbnRlciA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdGhpcy5mcmFtZSA9IHRoaXMuY2VudGVyRnJhbWUoKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5jZW50ZXJYID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG5cdCAgICBpZiAob2Zmc2V0ID09IG51bGwpIHtcblx0ICAgICAgb2Zmc2V0ID0gMDtcblx0ICAgIH1cblx0ICAgIHRoaXMueCA9IHRoaXMuY2VudGVyRnJhbWUoKS54ICsgb2Zmc2V0O1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLmNlbnRlclkgPSBmdW5jdGlvbihvZmZzZXQpIHtcblx0ICAgIGlmIChvZmZzZXQgPT0gbnVsbCkge1xuXHQgICAgICBvZmZzZXQgPSAwO1xuXHQgICAgfVxuXHQgICAgdGhpcy55ID0gdGhpcy5jZW50ZXJGcmFtZSgpLnkgKyBvZmZzZXQ7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUucGl4ZWxBbGlnbiA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdGhpcy54ID0gcGFyc2VJbnQodGhpcy54KTtcblx0ICAgIHJldHVybiB0aGlzLnkgPSBwYXJzZUludCh0aGlzLnkpO1xuXHQgIH07XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5jYW52YXNTY2FsZVggPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciBjb250ZXh0LCBpLCBsZW4sIHBhcmVudCwgcmVmLCBzY2FsZTtcblx0ICAgIHNjYWxlID0gdGhpcy5zY2FsZSAqIHRoaXMuc2NhbGVYO1xuXHQgICAgcmVmID0gdGhpcy5hbmNlc3RvcnMoY29udGV4dCA9IHRydWUpO1xuXHQgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICAgIHBhcmVudCA9IHJlZltpXTtcblx0ICAgICAgc2NhbGUgPSBzY2FsZSAqIHBhcmVudC5zY2FsZSAqIHBhcmVudC5zY2FsZVg7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gc2NhbGU7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLmNhbnZhc1NjYWxlWSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIGNvbnRleHQsIGksIGxlbiwgcGFyZW50LCByZWYsIHNjYWxlO1xuXHQgICAgc2NhbGUgPSB0aGlzLnNjYWxlICogdGhpcy5zY2FsZVk7XG5cdCAgICByZWYgPSB0aGlzLmFuY2VzdG9ycyhjb250ZXh0ID0gdHJ1ZSk7XG5cdCAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0ICAgICAgcGFyZW50ID0gcmVmW2ldO1xuXHQgICAgICBzY2FsZSA9IHNjYWxlICogcGFyZW50LnNjYWxlICogcGFyZW50LnNjYWxlWTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBzY2FsZTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUuc2NyZWVuU2NhbGVYID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgY29udGV4dCwgaSwgbGVuLCBwYXJlbnQsIHJlZiwgc2NhbGU7XG5cdCAgICBzY2FsZSA9IHRoaXMuc2NhbGUgKiB0aGlzLnNjYWxlWDtcblx0ICAgIHJlZiA9IHRoaXMuYW5jZXN0b3JzKGNvbnRleHQgPSBmYWxzZSk7XG5cdCAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0ICAgICAgcGFyZW50ID0gcmVmW2ldO1xuXHQgICAgICBzY2FsZSA9IHNjYWxlICogcGFyZW50LnNjYWxlICogcGFyZW50LnNjYWxlWDtcblx0ICAgIH1cblx0ICAgIHJldHVybiBzY2FsZTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUuc2NyZWVuU2NhbGVZID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgY29udGV4dCwgaSwgbGVuLCBwYXJlbnQsIHJlZiwgc2NhbGU7XG5cdCAgICBzY2FsZSA9IHRoaXMuc2NhbGUgKiB0aGlzLnNjYWxlWTtcblx0ICAgIHJlZiA9IHRoaXMuYW5jZXN0b3JzKGNvbnRleHQgPSBmYWxzZSk7XG5cdCAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0ICAgICAgcGFyZW50ID0gcmVmW2ldO1xuXHQgICAgICBzY2FsZSA9IHNjYWxlICogcGFyZW50LnNjYWxlICogcGFyZW50LnNjYWxlWTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBzY2FsZTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUuc2NyZWVuU2NhbGVkRnJhbWUgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciBjb250ZXh0LCBmYWN0b3JYLCBmYWN0b3JZLCBmcmFtZSwgaSwgbGF5ZXJTY2FsZWRGcmFtZSwgbGF5ZXJzLCBsZW4sIHBhcmVudDtcblx0ICAgIGZyYW1lID0ge1xuXHQgICAgICB4OiAwLFxuXHQgICAgICB5OiAwLFxuXHQgICAgICB3aWR0aDogdGhpcy53aWR0aCAqIHRoaXMuc2NyZWVuU2NhbGVYKCksXG5cdCAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQgKiB0aGlzLnNjcmVlblNjYWxlWSgpXG5cdCAgICB9O1xuXHQgICAgbGF5ZXJzID0gdGhpcy5hbmNlc3RvcnMoY29udGV4dCA9IHRydWUpO1xuXHQgICAgbGF5ZXJzLnB1c2godGhpcyk7XG5cdCAgICBsYXllcnMucmV2ZXJzZSgpO1xuXHQgICAgZm9yIChpID0gMCwgbGVuID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICAgIHBhcmVudCA9IGxheWVyc1tpXTtcblx0ICAgICAgZmFjdG9yWCA9IHBhcmVudC5fcGFyZW50T3JDb250ZXh0KCkgPyBwYXJlbnQuX3BhcmVudE9yQ29udGV4dCgpLnNjcmVlblNjYWxlWCgpIDogMTtcblx0ICAgICAgZmFjdG9yWSA9IHBhcmVudC5fcGFyZW50T3JDb250ZXh0KCkgPyBwYXJlbnQuX3BhcmVudE9yQ29udGV4dCgpLnNjcmVlblNjYWxlWSgpIDogMTtcblx0ICAgICAgbGF5ZXJTY2FsZWRGcmFtZSA9IHBhcmVudC5zY2FsZWRGcmFtZSgpO1xuXHQgICAgICBmcmFtZS54ICs9IGxheWVyU2NhbGVkRnJhbWUueCAqIGZhY3Rvclg7XG5cdCAgICAgIGZyYW1lLnkgKz0gbGF5ZXJTY2FsZWRGcmFtZS55ICogZmFjdG9yWTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBmcmFtZTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUuc2NhbGVkRnJhbWUgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciBmcmFtZSwgc2NhbGVYLCBzY2FsZVk7XG5cdCAgICBmcmFtZSA9IHRoaXMuZnJhbWU7XG5cdCAgICBzY2FsZVggPSB0aGlzLnNjYWxlICogdGhpcy5zY2FsZVg7XG5cdCAgICBzY2FsZVkgPSB0aGlzLnNjYWxlICogdGhpcy5zY2FsZVk7XG5cdCAgICBmcmFtZS53aWR0aCAqPSBzY2FsZVg7XG5cdCAgICBmcmFtZS5oZWlnaHQgKj0gc2NhbGVZO1xuXHQgICAgZnJhbWUueCArPSAoMSAtIHNjYWxlWCkgKiB0aGlzLm9yaWdpblggKiB0aGlzLndpZHRoO1xuXHQgICAgZnJhbWUueSArPSAoMSAtIHNjYWxlWSkgKiB0aGlzLm9yaWdpblkgKiB0aGlzLmhlaWdodDtcblx0ICAgIHJldHVybiBmcmFtZTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5kZWZpbmUoXCJzdHlsZVwiLCB7XG5cdCAgICBpbXBvcnRhYmxlOiB0cnVlLFxuXHQgICAgZXhwb3J0YWJsZTogZmFsc2UsXG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5zdHlsZTtcblx0ICAgIH0sXG5cdCAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgIF8uZXh0ZW5kKHRoaXMuX2VsZW1lbnQuc3R5bGUsIHZhbHVlKTtcblx0ICAgICAgcmV0dXJuIHRoaXMuZW1pdChcImNoYW5nZTpzdHlsZVwiKTtcblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLmNvbXB1dGVkU3R5bGUgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciBnZXRDb21wdXRlZFN0eWxlO1xuXHQgICAgZ2V0Q29tcHV0ZWRTdHlsZSA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGU7XG5cdCAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZSA9PSBudWxsKSB7XG5cdCAgICAgIGdldENvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKHRoaXMuX2VsZW1lbnQpO1xuXHQgIH07XG5cdFxuXHQgIExheWVyLmRlZmluZShcImNsYXNzTGlzdFwiLCB7XG5cdCAgICBpbXBvcnRhYmxlOiB0cnVlLFxuXHQgICAgZXhwb3J0YWJsZTogZmFsc2UsXG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5jbGFzc0xpc3Q7XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5fY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgaWYgKHRoaXMuX2VsZW1lbnQgIT0gbnVsbCkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICB0aGlzLl9lbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0ICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJmcmFtZXJMYXllclwiKTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUuX2luc2VydEVsZW1lbnQgPSBmdW5jdGlvbigpIHtcblx0ICAgIHRoaXMuYnJpbmdUb0Zyb250KCk7XG5cdCAgICByZXR1cm4gdGhpcy5fY29udGV4dC5lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX2VsZW1lbnQpO1xuXHQgIH07XG5cdFxuXHQgIExheWVyLmRlZmluZShcImh0bWxcIiwge1xuXHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgdmFyIHJlZjtcblx0ICAgICAgcmV0dXJuICgocmVmID0gdGhpcy5fZWxlbWVudEhUTUwpICE9IG51bGwgPyByZWYuaW5uZXJIVE1MIDogdm9pZCAwKSB8fCBcIlwiO1xuXHQgICAgfSxcblx0ICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgaWYgKCF0aGlzLl9lbGVtZW50SFRNTCkge1xuXHQgICAgICAgIHRoaXMuX2VsZW1lbnRIVE1MID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0ICAgICAgICB0aGlzLl9lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX2VsZW1lbnRIVE1MKTtcblx0ICAgICAgfVxuXHQgICAgICB0aGlzLl9lbGVtZW50SFRNTC5pbm5lckhUTUwgPSB2YWx1ZTtcblx0ICAgICAgcmV0dXJuIHRoaXMuZW1pdChcImNoYW5nZTpodG1sXCIpO1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUucXVlcnlTZWxlY3RvciA9IGZ1bmN0aW9uKHF1ZXJ5KSB7XG5cdCAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5xdWVyeVNlbGVjdG9yKHF1ZXJ5KTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUucXVlcnlTZWxlY3RvckFsbCA9IGZ1bmN0aW9uKHF1ZXJ5KSB7XG5cdCAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIHJlZjtcblx0ICAgIGlmICh0aGlzLnBhcmVudCkge1xuXHQgICAgICB0aGlzLnBhcmVudC5fY2hpbGRyZW4gPSBfLndpdGhvdXQodGhpcy5wYXJlbnQuX2NoaWxkcmVuLCB0aGlzKTtcblx0ICAgIH1cblx0ICAgIGlmICgocmVmID0gdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlKSAhPSBudWxsKSB7XG5cdCAgICAgIHJlZi5yZW1vdmVDaGlsZCh0aGlzLl9lbGVtZW50KTtcblx0ICAgIH1cblx0ICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG5cdCAgICB0aGlzLl9jb250ZXh0LnJlbW92ZUxheWVyKHRoaXMpO1xuXHQgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuZW1pdChcImxheWVyOmRlc3Ryb3lcIiwgdGhpcyk7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciBjaGlsZCwgY29waWVkQ2hpbGQsIGksIGxheWVyLCBsZW4sIHJlZjtcblx0ICAgIGxheWVyID0gdGhpcy5jb3B5U2luZ2xlKCk7XG5cdCAgICByZWYgPSB0aGlzLmNoaWxkcmVuO1xuXHQgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICAgIGNoaWxkID0gcmVmW2ldO1xuXHQgICAgICBjb3BpZWRDaGlsZCA9IGNoaWxkLmNvcHkoKTtcblx0ICAgICAgY29waWVkQ2hpbGQucGFyZW50ID0gbGF5ZXI7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbGF5ZXI7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLmNvcHlTaW5nbGUgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciBjb3B5O1xuXHQgICAgY29weSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMucHJvcHMpO1xuXHQgICAgcmV0dXJuIGNvcHk7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIuZGVmaW5lKFwiaW1hZ2VcIiwge1xuXHQgICAgXCJkZWZhdWx0XCI6IFwiXCIsXG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fZ2V0UHJvcGVydHlWYWx1ZShcImltYWdlXCIpO1xuXHQgICAgfSxcblx0ICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgdmFyIGN1cnJlbnRWYWx1ZSwgZGVmYXVsdHMsIGltYWdlVXJsLCBsb2FkZXIsIHJlZjtcblx0ICAgICAgaWYgKCEoXy5pc1N0cmluZyh2YWx1ZSkgfHwgdmFsdWUgPT09IG51bGwpKSB7XG5cdCAgICAgICAgbGF5ZXJWYWx1ZVR5cGVFcnJvcihcImltYWdlXCIsIHZhbHVlKTtcblx0ICAgICAgfVxuXHQgICAgICBjdXJyZW50VmFsdWUgPSB0aGlzLl9nZXRQcm9wZXJ0eVZhbHVlKFwiaW1hZ2VcIik7XG5cdCAgICAgIGlmIChjdXJyZW50VmFsdWUgPT09IHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChcImxvYWRcIik7XG5cdCAgICAgIH1cblx0ICAgICAgZGVmYXVsdHMgPSBEZWZhdWx0cy5nZXREZWZhdWx0cyhcIkxheWVyXCIsIHt9KTtcblx0ICAgICAgaWYgKChyZWYgPSB0aGlzLmJhY2tncm91bmRDb2xvcikgIT0gbnVsbCA/IHJlZi5pc0VxdWFsKGRlZmF1bHRzLmJhY2tncm91bmRDb2xvcikgOiB2b2lkIDApIHtcblx0ICAgICAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9IG51bGw7XG5cdCAgICAgIH1cblx0ICAgICAgdGhpcy5fc2V0UHJvcGVydHlWYWx1ZShcImltYWdlXCIsIHZhbHVlKTtcblx0ICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSBcIlwiKSB7XG5cdCAgICAgICAgdGhpcy5zdHlsZVtcImJhY2tncm91bmQtaW1hZ2VcIl0gPSBudWxsO1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHQgICAgICBpbWFnZVVybCA9IHZhbHVlO1xuXHQgICAgICBpZiAodGhpcy5fYWx3YXlzVXNlSW1hZ2VDYWNoZSA9PT0gZmFsc2UgJiYgVXRpbHMuaXNMb2NhbEFzc2V0VXJsKGltYWdlVXJsKSkge1xuXHQgICAgICAgIGltYWdlVXJsICs9IFwiP25vY2FjaGU9XCIgKyBOb0NhY2hlRGF0ZUtleTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAodGhpcy5fZG9tRXZlbnRNYW5hZ2VyLmxpc3RlbmVycyhFdmVudHMuSW1hZ2VMb2FkZWQpIHx8IHRoaXMuX2RvbUV2ZW50TWFuYWdlci5saXN0ZW5lcnMoRXZlbnRzLkltYWdlTG9hZEVycm9yKSkge1xuXHQgICAgICAgIGxvYWRlciA9IG5ldyBJbWFnZSgpO1xuXHQgICAgICAgIGxvYWRlci5uYW1lID0gaW1hZ2VVcmw7XG5cdCAgICAgICAgbG9hZGVyLnNyYyA9IGltYWdlVXJsO1xuXHQgICAgICAgIGxvYWRlci5vbmxvYWQgPSAoZnVuY3Rpb24oX3RoaXMpIHtcblx0ICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgX3RoaXMuc3R5bGVbXCJiYWNrZ3JvdW5kLWltYWdlXCJdID0gXCJ1cmwoJ1wiICsgaW1hZ2VVcmwgKyBcIicpXCI7XG5cdCAgICAgICAgICAgIHJldHVybiBfdGhpcy5lbWl0KEV2ZW50cy5JbWFnZUxvYWRlZCwgbG9hZGVyKTtcblx0ICAgICAgICAgIH07XG5cdCAgICAgICAgfSkodGhpcyk7XG5cdCAgICAgICAgcmV0dXJuIGxvYWRlci5vbmVycm9yID0gKGZ1bmN0aW9uKF90aGlzKSB7XG5cdCAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBfdGhpcy5lbWl0KEV2ZW50cy5JbWFnZUxvYWRFcnJvciwgbG9hZGVyKTtcblx0ICAgICAgICAgIH07XG5cdCAgICAgICAgfSkodGhpcyk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGVbXCJiYWNrZ3JvdW5kLWltYWdlXCJdID0gXCJ1cmwoJ1wiICsgaW1hZ2VVcmwgKyBcIicpXCI7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgTGF5ZXIuZGVmaW5lKFwicGFyZW50XCIsIHtcblx0ICAgIGVudW1lcmFibGU6IGZhbHNlLFxuXHQgICAgZXhwb3J0YWJsZTogZmFsc2UsXG5cdCAgICBpbXBvcnRhYmxlOiB0cnVlLFxuXHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCB8fCBudWxsO1xuXHQgICAgfSxcblx0ICAgIHNldDogZnVuY3Rpb24obGF5ZXIpIHtcblx0ICAgICAgaWYgKGxheWVyID09PSB0aGlzLl9wYXJlbnQpIHtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKCFsYXllciBpbnN0YW5jZW9mIExheWVyKSB7XG5cdCAgICAgICAgdGhyb3cgRXJyb3IoXCJMYXllci5wYXJlbnQgbmVlZHMgdG8gYmUgYSBMYXllciBvYmplY3RcIik7XG5cdCAgICAgIH1cblx0ICAgICAgVXRpbHMuZG9tQ29tcGxldGVDYW5jZWwodGhpcy5fX2luc2VydEVsZW1lbnQpO1xuXHQgICAgICBpZiAodGhpcy5fcGFyZW50KSB7XG5cdCAgICAgICAgdGhpcy5fcGFyZW50Ll9jaGlsZHJlbiA9IF8ud2l0aG91dCh0aGlzLl9wYXJlbnQuX2NoaWxkcmVuLCB0aGlzKTtcblx0ICAgICAgICB0aGlzLl9wYXJlbnQuX2VsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcy5fZWxlbWVudCk7XG5cdCAgICAgICAgdGhpcy5fcGFyZW50LmVtaXQoXCJjaGFuZ2U6Y2hpbGRyZW5cIiwge1xuXHQgICAgICAgICAgYWRkZWQ6IFtdLFxuXHQgICAgICAgICAgcmVtb3ZlZDogW3RoaXNdXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgdGhpcy5fcGFyZW50LmVtaXQoXCJjaGFuZ2U6c3ViTGF5ZXJzXCIsIHtcblx0ICAgICAgICAgIGFkZGVkOiBbXSxcblx0ICAgICAgICAgIHJlbW92ZWQ6IFt0aGlzXVxuXHQgICAgICAgIH0pO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChsYXllcikge1xuXHQgICAgICAgIGxheWVyLl9lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX2VsZW1lbnQpO1xuXHQgICAgICAgIGxheWVyLl9jaGlsZHJlbi5wdXNoKHRoaXMpO1xuXHQgICAgICAgIGxheWVyLmVtaXQoXCJjaGFuZ2U6Y2hpbGRyZW5cIiwge1xuXHQgICAgICAgICAgYWRkZWQ6IFt0aGlzXSxcblx0ICAgICAgICAgIHJlbW92ZWQ6IFtdXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgbGF5ZXIuZW1pdChcImNoYW5nZTpzdWJMYXllcnNcIiwge1xuXHQgICAgICAgICAgYWRkZWQ6IFt0aGlzXSxcblx0ICAgICAgICAgIHJlbW92ZWQ6IFtdXG5cdCAgICAgICAgfSk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdGhpcy5faW5zZXJ0RWxlbWVudCgpO1xuXHQgICAgICB9XG5cdCAgICAgIHRoaXMuX3BhcmVudCA9IGxheWVyO1xuXHQgICAgICB0aGlzLmJyaW5nVG9Gcm9udCgpO1xuXHQgICAgICB0aGlzLmVtaXQoXCJjaGFuZ2U6cGFyZW50XCIpO1xuXHQgICAgICByZXR1cm4gdGhpcy5lbWl0KFwiY2hhbmdlOnN1cGVyTGF5ZXJcIik7XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIExheWVyLmRlZmluZShcImNoaWxkcmVuXCIsIHtcblx0ICAgIGVudW1lcmFibGU6IGZhbHNlLFxuXHQgICAgZXhwb3J0YWJsZTogZmFsc2UsXG5cdCAgICBpbXBvcnRhYmxlOiBmYWxzZSxcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiBfLmNsb25lKHRoaXMuX2NoaWxkcmVuKTtcblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgTGF5ZXIuZGVmaW5lKFwic2libGluZ3NcIiwge1xuXHQgICAgZW51bWVyYWJsZTogZmFsc2UsXG5cdCAgICBleHBvcnRhYmxlOiBmYWxzZSxcblx0ICAgIGltcG9ydGFibGU6IGZhbHNlLFxuXHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgaWYgKHRoaXMucGFyZW50ID09PSBudWxsKSB7XG5cdCAgICAgICAgcmV0dXJuIF8uZmlsdGVyKHRoaXMuX2NvbnRleHQuZ2V0TGF5ZXJzKCksIChmdW5jdGlvbihfdGhpcykge1xuXHQgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGxheWVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBsYXllciAhPT0gX3RoaXMgJiYgbGF5ZXIucGFyZW50ID09PSBudWxsO1xuXHQgICAgICAgICAgfTtcblx0ICAgICAgICB9KSh0aGlzKSk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIF8ud2l0aG91dCh0aGlzLnBhcmVudC5jaGlsZHJlbiwgdGhpcyk7XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIExheWVyLmRlZmluZShcImRlc2NlbmRhbnRzXCIsIHtcblx0ICAgIGVudW1lcmFibGU6IGZhbHNlLFxuXHQgICAgZXhwb3J0YWJsZTogZmFsc2UsXG5cdCAgICBpbXBvcnRhYmxlOiBmYWxzZSxcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHZhciBmLCByZXN1bHQ7XG5cdCAgICAgIHJlc3VsdCA9IFtdO1xuXHQgICAgICBmID0gZnVuY3Rpb24obGF5ZXIpIHtcblx0ICAgICAgICByZXN1bHQucHVzaChsYXllcik7XG5cdCAgICAgICAgcmV0dXJuIGxheWVyLmNoaWxkcmVuLm1hcChmKTtcblx0ICAgICAgfTtcblx0ICAgICAgdGhpcy5jaGlsZHJlbi5tYXAoZik7XG5cdCAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uKGxheWVyKSB7XG5cdCAgICByZXR1cm4gbGF5ZXIucGFyZW50ID0gdGhpcztcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbihsYXllcikge1xuXHQgICAgaWYgKGluZGV4T2YuY2FsbCh0aGlzLmNoaWxkcmVuLCBsYXllcikgPCAwKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHJldHVybiBsYXllci5wYXJlbnQgPSBudWxsO1xuXHQgIH07XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5jaGlsZHJlbldpdGhOYW1lID0gZnVuY3Rpb24obmFtZSkge1xuXHQgICAgcmV0dXJuIF8uZmlsdGVyKHRoaXMuY2hpbGRyZW4sIGZ1bmN0aW9uKGxheWVyKSB7XG5cdCAgICAgIHJldHVybiBsYXllci5uYW1lID09PSBuYW1lO1xuXHQgICAgfSk7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLnNpYmxpbmdzV2l0aE5hbWUgPSBmdW5jdGlvbihuYW1lKSB7XG5cdCAgICByZXR1cm4gXy5maWx0ZXIodGhpcy5zaWJsaW5nTGF5ZXJzLCBmdW5jdGlvbihsYXllcikge1xuXHQgICAgICByZXR1cm4gbGF5ZXIubmFtZSA9PT0gbmFtZTtcblx0ICAgIH0pO1xuXHQgIH07XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5hbmNlc3RvcnMgPSBmdW5jdGlvbihjb250ZXh0KSB7XG5cdCAgICB2YXIgY3VycmVudExheWVyLCBwYXJlbnRzO1xuXHQgICAgaWYgKGNvbnRleHQgPT0gbnVsbCkge1xuXHQgICAgICBjb250ZXh0ID0gZmFsc2U7XG5cdCAgICB9XG5cdCAgICBwYXJlbnRzID0gW107XG5cdCAgICBjdXJyZW50TGF5ZXIgPSB0aGlzO1xuXHQgICAgaWYgKGNvbnRleHQgPT09IGZhbHNlKSB7XG5cdCAgICAgIHdoaWxlIChjdXJyZW50TGF5ZXIucGFyZW50KSB7XG5cdCAgICAgICAgcGFyZW50cy5wdXNoKGN1cnJlbnRMYXllci5wYXJlbnQpO1xuXHQgICAgICAgIGN1cnJlbnRMYXllciA9IGN1cnJlbnRMYXllci5wYXJlbnQ7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHdoaWxlIChjdXJyZW50TGF5ZXIuX3BhcmVudE9yQ29udGV4dCgpKSB7XG5cdCAgICAgICAgcGFyZW50cy5wdXNoKGN1cnJlbnRMYXllci5fcGFyZW50T3JDb250ZXh0KCkpO1xuXHQgICAgICAgIGN1cnJlbnRMYXllciA9IGN1cnJlbnRMYXllci5fcGFyZW50T3JDb250ZXh0KCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBwYXJlbnRzO1xuXHQgIH07XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5jaGlsZHJlbkFib3ZlID0gZnVuY3Rpb24ocG9pbnQsIG9yaWdpblgsIG9yaWdpblkpIHtcblx0ICAgIGlmIChvcmlnaW5YID09IG51bGwpIHtcblx0ICAgICAgb3JpZ2luWCA9IDA7XG5cdCAgICB9XG5cdCAgICBpZiAob3JpZ2luWSA9PSBudWxsKSB7XG5cdCAgICAgIG9yaWdpblkgPSAwO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIF8uZmlsdGVyKHRoaXMuY2hpbGRyZW4sIGZ1bmN0aW9uKGxheWVyKSB7XG5cdCAgICAgIHJldHVybiBVdGlscy5mcmFtZVBvaW50Rm9yT3JpZ2luKGxheWVyLmZyYW1lLCBvcmlnaW5YLCBvcmlnaW5ZKS55IDwgcG9pbnQueTtcblx0ICAgIH0pO1xuXHQgIH07XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5jaGlsZHJlbkJlbG93ID0gZnVuY3Rpb24ocG9pbnQsIG9yaWdpblgsIG9yaWdpblkpIHtcblx0ICAgIGlmIChvcmlnaW5YID09IG51bGwpIHtcblx0ICAgICAgb3JpZ2luWCA9IDA7XG5cdCAgICB9XG5cdCAgICBpZiAob3JpZ2luWSA9PSBudWxsKSB7XG5cdCAgICAgIG9yaWdpblkgPSAwO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIF8uZmlsdGVyKHRoaXMuY2hpbGRyZW4sIGZ1bmN0aW9uKGxheWVyKSB7XG5cdCAgICAgIHJldHVybiBVdGlscy5mcmFtZVBvaW50Rm9yT3JpZ2luKGxheWVyLmZyYW1lLCBvcmlnaW5YLCBvcmlnaW5ZKS55ID4gcG9pbnQueTtcblx0ICAgIH0pO1xuXHQgIH07XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5jaGlsZHJlbkxlZnQgPSBmdW5jdGlvbihwb2ludCwgb3JpZ2luWCwgb3JpZ2luWSkge1xuXHQgICAgaWYgKG9yaWdpblggPT0gbnVsbCkge1xuXHQgICAgICBvcmlnaW5YID0gMDtcblx0ICAgIH1cblx0ICAgIGlmIChvcmlnaW5ZID09IG51bGwpIHtcblx0ICAgICAgb3JpZ2luWSA9IDA7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gXy5maWx0ZXIodGhpcy5jaGlsZHJlbiwgZnVuY3Rpb24obGF5ZXIpIHtcblx0ICAgICAgcmV0dXJuIFV0aWxzLmZyYW1lUG9pbnRGb3JPcmlnaW4obGF5ZXIuZnJhbWUsIG9yaWdpblgsIG9yaWdpblkpLnggPCBwb2ludC54O1xuXHQgICAgfSk7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLmNoaWxkcmVuUmlnaHQgPSBmdW5jdGlvbihwb2ludCwgb3JpZ2luWCwgb3JpZ2luWSkge1xuXHQgICAgaWYgKG9yaWdpblggPT0gbnVsbCkge1xuXHQgICAgICBvcmlnaW5YID0gMDtcblx0ICAgIH1cblx0ICAgIGlmIChvcmlnaW5ZID09IG51bGwpIHtcblx0ICAgICAgb3JpZ2luWSA9IDA7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gXy5maWx0ZXIodGhpcy5jaGlsZHJlbiwgZnVuY3Rpb24obGF5ZXIpIHtcblx0ICAgICAgcmV0dXJuIFV0aWxzLmZyYW1lUG9pbnRGb3JPcmlnaW4obGF5ZXIuZnJhbWUsIG9yaWdpblgsIG9yaWdpblkpLnggPiBwb2ludC54O1xuXHQgICAgfSk7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLl9wYXJlbnRPckNvbnRleHQgPSBmdW5jdGlvbigpIHtcblx0ICAgIGlmICh0aGlzLnBhcmVudCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5wYXJlbnQ7XG5cdCAgICB9XG5cdCAgICBpZiAodGhpcy5fY29udGV4dC5fcGFyZW50KSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0Ll9wYXJlbnQ7XG5cdCAgICB9XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIuZGVmaW5lKFwic3VwZXJMYXllclwiLCB7XG5cdCAgICBlbnVtZXJhYmxlOiBmYWxzZSxcblx0ICAgIGV4cG9ydGFibGU6IGZhbHNlLFxuXHQgICAgaW1wb3J0YWJsZTogZmFsc2UsXG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5wYXJlbnQ7XG5cdCAgICB9LFxuXHQgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5wYXJlbnQgPSB2YWx1ZTtcblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgTGF5ZXIuZGVmaW5lKFwic3ViTGF5ZXJzXCIsIHtcblx0ICAgIGVudW1lcmFibGU6IGZhbHNlLFxuXHQgICAgZXhwb3J0YWJsZTogZmFsc2UsXG5cdCAgICBpbXBvcnRhYmxlOiBmYWxzZSxcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuO1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBMYXllci5kZWZpbmUoXCJzaWJsaW5nTGF5ZXJzXCIsIHtcblx0ICAgIGVudW1lcmFibGU6IGZhbHNlLFxuXHQgICAgZXhwb3J0YWJsZTogZmFsc2UsXG5cdCAgICBpbXBvcnRhYmxlOiBmYWxzZSxcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLnNpYmxpbmdzO1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUuc3VwZXJMYXllcnMgPSBmdW5jdGlvbihjb250ZXh0KSB7XG5cdCAgICBpZiAoY29udGV4dCA9PSBudWxsKSB7XG5cdCAgICAgIGNvbnRleHQgPSBmYWxzZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0aGlzLmFuY2VzdG9ycyhjb250ZXh0KTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUuYWRkU3ViTGF5ZXIgPSBmdW5jdGlvbihsYXllcikge1xuXHQgICAgcmV0dXJuIHRoaXMuYWRkQ2hpbGQobGF5ZXIpO1xuXHQgIH07XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5yZW1vdmVTdWJMYXllciA9IGZ1bmN0aW9uKGxheWVyKSB7XG5cdCAgICByZXR1cm4gdGhpcy5yZW1vdmVDaGlsZChsYXllcik7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLnN1YkxheWVyc0J5TmFtZSA9IGZ1bmN0aW9uKG5hbWUpIHtcblx0ICAgIHJldHVybiB0aGlzLmNoaWxkcmVuV2l0aE5hbWUobmFtZSk7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLnNpYmxpbmdMYXllcnNCeU5hbWUgPSBmdW5jdGlvbihuYW1lKSB7XG5cdCAgICByZXR1cm4gdGhpcy5zaWJsaW5nc1dpdGhOYW1lKG5hbWUpO1xuXHQgIH07XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5zdWJMYXllcnNBYm92ZSA9IGZ1bmN0aW9uKHBvaW50LCBvcmlnaW5YLCBvcmlnaW5ZKSB7XG5cdCAgICBpZiAob3JpZ2luWCA9PSBudWxsKSB7XG5cdCAgICAgIG9yaWdpblggPSAwO1xuXHQgICAgfVxuXHQgICAgaWYgKG9yaWdpblkgPT0gbnVsbCkge1xuXHQgICAgICBvcmlnaW5ZID0gMDtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0aGlzLmNoaWxkcmVuQWJvdmUocG9pbnQsIG9yaWdpblgsIG9yaWdpblkpO1xuXHQgIH07XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5zdWJMYXllcnNCZWxvdyA9IGZ1bmN0aW9uKHBvaW50LCBvcmlnaW5YLCBvcmlnaW5ZKSB7XG5cdCAgICBpZiAob3JpZ2luWCA9PSBudWxsKSB7XG5cdCAgICAgIG9yaWdpblggPSAwO1xuXHQgICAgfVxuXHQgICAgaWYgKG9yaWdpblkgPT0gbnVsbCkge1xuXHQgICAgICBvcmlnaW5ZID0gMDtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0aGlzLmNoaWxkcmVuQmVsb3cocG9pbnQsIG9yaWdpblgsIG9yaWdpblkpO1xuXHQgIH07XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5zdWJMYXllcnNMZWZ0ID0gZnVuY3Rpb24ocG9pbnQsIG9yaWdpblgsIG9yaWdpblkpIHtcblx0ICAgIGlmIChvcmlnaW5YID09IG51bGwpIHtcblx0ICAgICAgb3JpZ2luWCA9IDA7XG5cdCAgICB9XG5cdCAgICBpZiAob3JpZ2luWSA9PSBudWxsKSB7XG5cdCAgICAgIG9yaWdpblkgPSAwO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5MZWZ0KHBvaW50LCBvcmlnaW5YLCBvcmlnaW5ZKTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUuc3ViTGF5ZXJzUmlnaHQgPSBmdW5jdGlvbihwb2ludCwgb3JpZ2luWCwgb3JpZ2luWSkge1xuXHQgICAgaWYgKG9yaWdpblggPT0gbnVsbCkge1xuXHQgICAgICBvcmlnaW5YID0gMDtcblx0ICAgIH1cblx0ICAgIGlmIChvcmlnaW5ZID09IG51bGwpIHtcblx0ICAgICAgb3JpZ2luWSA9IDA7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcy5jaGlsZHJlblJpZ2h0KHBvaW50LCBvcmlnaW5YLCBvcmlnaW5ZKTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUuX3N1cGVyT3JQYXJlbnRMYXllciA9IGZ1bmN0aW9uKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX3BhcmVudE9yQ29udGV4dCgpO1xuXHQgIH07XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5hbmltYXRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHQgICAgdmFyIGFuaW1hdGlvbiwgc3RhcnQ7XG5cdCAgICBzdGFydCA9IG9wdGlvbnMuc3RhcnQ7XG5cdCAgICBpZiAoc3RhcnQgPT0gbnVsbCkge1xuXHQgICAgICBzdGFydCA9IHRydWU7XG5cdCAgICB9XG5cdCAgICBkZWxldGUgb3B0aW9ucy5zdGFydDtcblx0ICAgIG9wdGlvbnMubGF5ZXIgPSB0aGlzO1xuXHQgICAgYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbihvcHRpb25zKTtcblx0ICAgIGlmIChzdGFydCkge1xuXHQgICAgICBhbmltYXRpb24uc3RhcnQoKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBhbmltYXRpb247XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLmFuaW1hdGlvbnMgPSBmdW5jdGlvbigpIHtcblx0ICAgIHJldHVybiBfLmZpbHRlcih0aGlzLl9jb250ZXh0LmFuaW1hdGlvbnMsIChmdW5jdGlvbihfdGhpcykge1xuXHQgICAgICByZXR1cm4gZnVuY3Rpb24oYW5pbWF0aW9uKSB7XG5cdCAgICAgICAgcmV0dXJuIGFuaW1hdGlvbi5vcHRpb25zLmxheWVyID09PSBfdGhpcztcblx0ICAgICAgfTtcblx0ICAgIH0pKHRoaXMpKTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUuYW5pbWF0aW5nUHJvcGVydGllcyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIGFuaW1hdGlvbiwgaSwgaiwgbGVuLCBsZW4xLCBwcm9wZXJ0aWVzLCBwcm9wZXJ0eU5hbWUsIHJlZiwgcmVmMTtcblx0ICAgIHByb3BlcnRpZXMgPSB7fTtcblx0ICAgIHJlZiA9IHRoaXMuYW5pbWF0aW9ucygpO1xuXHQgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICAgIGFuaW1hdGlvbiA9IHJlZltpXTtcblx0ICAgICAgcmVmMSA9IGFuaW1hdGlvbi5hbmltYXRpbmdQcm9wZXJ0aWVzKCk7XG5cdCAgICAgIGZvciAoaiA9IDAsIGxlbjEgPSByZWYxLmxlbmd0aDsgaiA8IGxlbjE7IGorKykge1xuXHQgICAgICAgIHByb3BlcnR5TmFtZSA9IHJlZjFbal07XG5cdCAgICAgICAgcHJvcGVydGllc1twcm9wZXJ0eU5hbWVdID0gYW5pbWF0aW9uO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcHJvcGVydGllcztcblx0ICB9O1xuXHRcblx0ICBMYXllci5kZWZpbmUoXCJpc0FuaW1hdGluZ1wiLCB7XG5cdCAgICBlbnVtZXJhYmxlOiBmYWxzZSxcblx0ICAgIGV4cG9ydGFibGU6IGZhbHNlLFxuXHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0aW9ucygpLmxlbmd0aCAhPT0gMDtcblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLmFuaW1hdGVTdG9wID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgcmVmO1xuXHQgICAgXy5pbnZva2UodGhpcy5hbmltYXRpb25zKCksIFwic3RvcFwiKTtcblx0ICAgIHJldHVybiAocmVmID0gdGhpcy5fZHJhZ2dhYmxlKSAhPSBudWxsID8gcmVmLmFuaW1hdGVTdG9wKCkgOiB2b2lkIDA7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLmJyaW5nVG9Gcm9udCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuaW5kZXggPSBfLm1heChfLnVuaW9uKFswXSwgdGhpcy5zaWJsaW5nTGF5ZXJzLm1hcChmdW5jdGlvbihsYXllcikge1xuXHQgICAgICByZXR1cm4gbGF5ZXIuaW5kZXg7XG5cdCAgICB9KSkpICsgMTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUuc2VuZFRvQmFjayA9IGZ1bmN0aW9uKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuaW5kZXggPSBfLm1pbihfLnVuaW9uKFswXSwgdGhpcy5zaWJsaW5nTGF5ZXJzLm1hcChmdW5jdGlvbihsYXllcikge1xuXHQgICAgICByZXR1cm4gbGF5ZXIuaW5kZXg7XG5cdCAgICB9KSkpIC0gMTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUucGxhY2VCZWZvcmUgPSBmdW5jdGlvbihsYXllcikge1xuXHQgICAgdmFyIGksIGwsIGxlbiwgcmVmO1xuXHQgICAgaWYgKGluZGV4T2YuY2FsbCh0aGlzLnNpYmxpbmdMYXllcnMsIGxheWVyKSA8IDApIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgcmVmID0gdGhpcy5zaWJsaW5nTGF5ZXJzO1xuXHQgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICAgIGwgPSByZWZbaV07XG5cdCAgICAgIGlmIChsLmluZGV4IDw9IGxheWVyLmluZGV4KSB7XG5cdCAgICAgICAgbC5pbmRleCAtPSAxO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcy5pbmRleCA9IGxheWVyLmluZGV4ICsgMTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUucGxhY2VCZWhpbmQgPSBmdW5jdGlvbihsYXllcikge1xuXHQgICAgdmFyIGksIGwsIGxlbiwgcmVmO1xuXHQgICAgaWYgKGluZGV4T2YuY2FsbCh0aGlzLnNpYmxpbmdMYXllcnMsIGxheWVyKSA8IDApIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgcmVmID0gdGhpcy5zaWJsaW5nTGF5ZXJzO1xuXHQgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICAgIGwgPSByZWZbaV07XG5cdCAgICAgIGlmIChsLmluZGV4ID49IGxheWVyLmluZGV4KSB7XG5cdCAgICAgICAgbC5pbmRleCArPSAxO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcy5pbmRleCA9IGxheWVyLmluZGV4IC0gMTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5kZWZpbmUoXCJzdGF0ZXNcIiwge1xuXHQgICAgZW51bWVyYWJsZTogZmFsc2UsXG5cdCAgICBleHBvcnRhYmxlOiBmYWxzZSxcblx0ICAgIGltcG9ydGFibGU6IGZhbHNlLFxuXHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlcyAhPSBudWxsID8gdGhpcy5fc3RhdGVzIDogdGhpcy5fc3RhdGVzID0gbmV3IExheWVyU3RhdGVzKHRoaXMpO1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBMYXllci5kZWZpbmUoXCJkcmFnZ2FibGVcIiwge1xuXHQgICAgaW1wb3J0YWJsZTogZmFsc2UsXG5cdCAgICBleHBvcnRhYmxlOiBmYWxzZSxcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9kcmFnZ2FibGUgIT0gbnVsbCA/IHRoaXMuX2RyYWdnYWJsZSA6IHRoaXMuX2RyYWdnYWJsZSA9IG5ldyBMYXllckRyYWdnYWJsZSh0aGlzKTtcblx0ICAgIH0sXG5cdCAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgIGlmIChfLmlzQm9vbGVhbih2YWx1ZSkpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5kcmFnZ2FibGUuZW5hYmxlZCA9IHZhbHVlO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIExheWVyLmRlZmluZShcInBpbmNoYWJsZVwiLCB7XG5cdCAgICBpbXBvcnRhYmxlOiBmYWxzZSxcblx0ICAgIGV4cG9ydGFibGU6IGZhbHNlLFxuXHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX3BpbmNoYWJsZSAhPSBudWxsID8gdGhpcy5fcGluY2hhYmxlIDogdGhpcy5fcGluY2hhYmxlID0gbmV3IExheWVyUGluY2hhYmxlKHRoaXMpO1xuXHQgICAgfSxcblx0ICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgaWYgKF8uaXNCb29sZWFuKHZhbHVlKSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLnBpbmNoYWJsZS5lbmFibGVkID0gdmFsdWU7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgTGF5ZXIuZGVmaW5lKFwic2Nyb2xsRnJhbWVcIiwge1xuXHQgICAgaW1wb3J0YWJsZTogZmFsc2UsXG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICB2YXIgZnJhbWU7XG5cdCAgICAgIHJldHVybiBmcmFtZSA9IHtcblx0ICAgICAgICB4OiB0aGlzLnNjcm9sbFgsXG5cdCAgICAgICAgeTogdGhpcy5zY3JvbGxZLFxuXHQgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuXHQgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcblx0ICAgICAgfTtcblx0ICAgIH0sXG5cdCAgICBzZXQ6IGZ1bmN0aW9uKGZyYW1lKSB7XG5cdCAgICAgIHRoaXMuc2Nyb2xsWCA9IGZyYW1lLng7XG5cdCAgICAgIHJldHVybiB0aGlzLnNjcm9sbFkgPSBmcmFtZS55O1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBMYXllci5kZWZpbmUoXCJzY3JvbGxYXCIsIHtcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50LnNjcm9sbExlZnQ7XG5cdCAgICB9LFxuXHQgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICBpZiAoIV8uaXNOdW1iZXIodmFsdWUpKSB7XG5cdCAgICAgICAgbGF5ZXJWYWx1ZVR5cGVFcnJvcihcInNjcm9sbFhcIiwgdmFsdWUpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50LnNjcm9sbExlZnQgPSB2YWx1ZTtcblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgTGF5ZXIuZGVmaW5lKFwic2Nyb2xsWVwiLCB7XG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5zY3JvbGxUb3A7XG5cdCAgICB9LFxuXHQgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICBpZiAoIV8uaXNOdW1iZXIodmFsdWUpKSB7XG5cdCAgICAgICAgbGF5ZXJWYWx1ZVR5cGVFcnJvcihcInNjcm9sbFlcIiwgdmFsdWUpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50LnNjcm9sbFRvcCA9IHZhbHVlO1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBMYXllci5kZWZpbmUoXCJfZG9tRXZlbnRNYW5hZ2VyXCIsIHtcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmRvbUV2ZW50TWFuYWdlci53cmFwKHRoaXMuX2VsZW1lbnQpO1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIGFyZ3MsIGV2ZW50TmFtZSwgcmVmLCB2ZWxvY2l0eTtcblx0ICAgIGV2ZW50TmFtZSA9IGFyZ3VtZW50c1swXSwgYXJncyA9IDIgPD0gYXJndW1lbnRzLmxlbmd0aCA/IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSA6IFtdO1xuXHQgICAgaWYgKHRoaXMuX2NhbmNlbENsaWNrRXZlbnRJbkRyYWdTZXNzaW9uKSB7XG5cdCAgICAgIGlmIChldmVudE5hbWUgPT09IEV2ZW50cy5DbGljayB8fCBldmVudE5hbWUgPT09IEV2ZW50cy5UYXAgfHwgZXZlbnROYW1lID09PSBFdmVudHMuVGFwU3RhcnQgfHwgZXZlbnROYW1lID09PSBFdmVudHMuVGFwRW5kIHx8IGV2ZW50TmFtZSA9PT0gRXZlbnRzLkxvbmdQcmVzcyB8fCBldmVudE5hbWUgPT09IEV2ZW50cy5Mb25nUHJlc3NTdGFydCB8fCBldmVudE5hbWUgPT09IEV2ZW50cy5Mb25nUHJlc3NFbmQpIHtcblx0ICAgICAgICBpZiAodGhpcy5fcGFyZW50RHJhZ2dhYmxlTGF5ZXIoKSkge1xuXHQgICAgICAgICAgdmVsb2NpdHkgPSAocmVmID0gdGhpcy5fcGFyZW50RHJhZ2dhYmxlTGF5ZXIoKSkgIT0gbnVsbCA/IHJlZi5kcmFnZ2FibGUudmVsb2NpdHkgOiB2b2lkIDA7XG5cdCAgICAgICAgICBpZiAoTWF0aC5hYnModmVsb2NpdHkueCkgPiB0aGlzLl9jYW5jZWxDbGlja0V2ZW50SW5EcmFnU2Vzc2lvblZlbG9jaXR5KSB7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIGlmIChNYXRoLmFicyh2ZWxvY2l0eS55KSA+IHRoaXMuX2NhbmNlbENsaWNrRXZlbnRJbkRyYWdTZXNzaW9uVmVsb2NpdHkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIExheWVyLl9fc3VwZXJfXy5lbWl0LmFwcGx5KHRoaXMsIFtldmVudE5hbWVdLmNvbmNhdChzbGljZS5jYWxsKGFyZ3MpLCBbdGhpc10pKTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcblx0ICAgIExheWVyLl9fc3VwZXJfXy5vbmNlLmNhbGwodGhpcywgZXZlbnROYW1lLCBsaXN0ZW5lcik7XG5cdCAgICByZXR1cm4gdGhpcy5fYWRkTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuXHQgICAgaWYgKCFldmVudE5hbWUpIHtcblx0ICAgICAgdGhyb3cgRXJyb3IoXCJMYXllci5vbiBuZWVkcyBhIHZhbGlkIGV2ZW50IG5hbWVcIik7XG5cdCAgICB9XG5cdCAgICBpZiAoIWxpc3RlbmVyKSB7XG5cdCAgICAgIHRocm93IEVycm9yKFwiTGF5ZXIub24gbmVlZHMgYW4gZXZlbnQgbGlzdGVuZXJcIik7XG5cdCAgICB9XG5cdCAgICBMYXllci5fX3N1cGVyX18uYWRkTGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudE5hbWUsIGxpc3RlbmVyKTtcblx0ICAgIHJldHVybiB0aGlzLl9hZGRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG5cdCAgICBpZiAoIWV2ZW50TmFtZSkge1xuXHQgICAgICB0aHJvdyBFcnJvcihcIkxheWVyLm9mZiBuZWVkcyBhIHZhbGlkIGV2ZW50IG5hbWVcIik7XG5cdCAgICB9XG5cdCAgICBMYXllci5fX3N1cGVyX18ucmVtb3ZlTGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudE5hbWUsIGxpc3RlbmVyKTtcblx0ICAgIHJldHVybiB0aGlzLl9yZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUuX2FkZExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuXHQgICAgaWYgKCFfLnN0YXJ0c1dpdGgoZXZlbnROYW1lLCBcImNoYW5nZTpcIikpIHtcblx0ICAgICAgdGhpcy5pZ25vcmVFdmVudHMgPSBmYWxzZTtcblx0ICAgIH1cblx0ICAgIGlmIChVdGlscy5kb21WYWxpZEV2ZW50KHRoaXMuX2VsZW1lbnQsIGV2ZW50TmFtZSkgfHwgaW5kZXhPZi5jYWxsKF8udmFsdWVzKEdlc3R1cmVzKSwgZXZlbnROYW1lKSA+PSAwKSB7XG5cdCAgICAgIGlmICghdGhpcy5fZG9tRXZlbnRNYW5hZ2VyLmxpc3RlbmVycyhldmVudE5hbWUpLmxlbmd0aCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9kb21FdmVudE1hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIChmdW5jdGlvbihfdGhpcykge1xuXHQgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdCAgICAgICAgICAgIHJldHVybiBfdGhpcy5lbWl0KGV2ZW50TmFtZSwgZXZlbnQpO1xuXHQgICAgICAgICAgfTtcblx0ICAgICAgICB9KSh0aGlzKSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUuX3JlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuXHQgICAgaWYgKCF0aGlzLmxpc3RlbmVycyhldmVudE5hbWUpLmxlbmd0aCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fZG9tRXZlbnRNYW5hZ2VyLnJlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpO1xuXHQgICAgfVxuXHQgIH07XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5fcGFyZW50RHJhZ2dhYmxlTGF5ZXIgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciBpLCBsYXllciwgbGVuLCByZWYsIHJlZjE7XG5cdCAgICByZWYgPSB0aGlzLmFuY2VzdG9ycygpO1xuXHQgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICAgIGxheWVyID0gcmVmW2ldO1xuXHQgICAgICBpZiAoKHJlZjEgPSBsYXllci5fZHJhZ2dhYmxlKSAhPSBudWxsID8gcmVmMS5lbmFibGVkIDogdm9pZCAwKSB7XG5cdCAgICAgICAgcmV0dXJuIGxheWVyO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbnVsbDtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUub24gPSBMYXllci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5vZmYgPSBMYXllci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24oY2IpIHtcblx0ICAgIHJldHVybiB0aGlzLm9uKEV2ZW50cy5DbGljaywgY2IpO1xuXHQgIH07XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5vbkRvdWJsZUNsaWNrID0gZnVuY3Rpb24oY2IpIHtcblx0ICAgIHJldHVybiB0aGlzLm9uKEV2ZW50cy5Eb3VibGVDbGljaywgY2IpO1xuXHQgIH07XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5vblNjcm9sbFN0YXJ0ID0gZnVuY3Rpb24oY2IpIHtcblx0ICAgIHJldHVybiB0aGlzLm9uKEV2ZW50cy5TY3JvbGxTdGFydCwgY2IpO1xuXHQgIH07XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5vblNjcm9sbCA9IGZ1bmN0aW9uKGNiKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vbihFdmVudHMuU2Nyb2xsLCBjYik7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLm9uU2Nyb2xsRW5kID0gZnVuY3Rpb24oY2IpIHtcblx0ICAgIHJldHVybiB0aGlzLm9uKEV2ZW50cy5TY3JvbGxFbmQsIGNiKTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUub25TY3JvbGxBbmltYXRpb25EaWRTdGFydCA9IGZ1bmN0aW9uKGNiKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vbihFdmVudHMuU2Nyb2xsQW5pbWF0aW9uRGlkU3RhcnQsIGNiKTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUub25TY3JvbGxBbmltYXRpb25EaWRFbmQgPSBmdW5jdGlvbihjYikge1xuXHQgICAgcmV0dXJuIHRoaXMub24oRXZlbnRzLlNjcm9sbEFuaW1hdGlvbkRpZEVuZCwgY2IpO1xuXHQgIH07XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5vblRvdWNoU3RhcnQgPSBmdW5jdGlvbihjYikge1xuXHQgICAgcmV0dXJuIHRoaXMub24oRXZlbnRzLlRvdWNoU3RhcnQsIGNiKTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUub25Ub3VjaEVuZCA9IGZ1bmN0aW9uKGNiKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vbihFdmVudHMuVG91Y2hFbmQsIGNiKTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUub25Ub3VjaE1vdmUgPSBmdW5jdGlvbihjYikge1xuXHQgICAgcmV0dXJuIHRoaXMub24oRXZlbnRzLlRvdWNoTW92ZSwgY2IpO1xuXHQgIH07XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5vbk1vdXNlVXAgPSBmdW5jdGlvbihjYikge1xuXHQgICAgcmV0dXJuIHRoaXMub24oRXZlbnRzLk1vdXNlVXAsIGNiKTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUub25Nb3VzZURvd24gPSBmdW5jdGlvbihjYikge1xuXHQgICAgcmV0dXJuIHRoaXMub24oRXZlbnRzLk1vdXNlRG93biwgY2IpO1xuXHQgIH07XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5vbk1vdXNlT3ZlciA9IGZ1bmN0aW9uKGNiKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vbihFdmVudHMuTW91c2VPdmVyLCBjYik7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLm9uTW91c2VPdXQgPSBmdW5jdGlvbihjYikge1xuXHQgICAgcmV0dXJuIHRoaXMub24oRXZlbnRzLk1vdXNlT3V0LCBjYik7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLm9uTW91c2VNb3ZlID0gZnVuY3Rpb24oY2IpIHtcblx0ICAgIHJldHVybiB0aGlzLm9uKEV2ZW50cy5Nb3VzZU1vdmUsIGNiKTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUub25Nb3VzZVdoZWVsID0gZnVuY3Rpb24oY2IpIHtcblx0ICAgIHJldHVybiB0aGlzLm9uKEV2ZW50cy5Nb3VzZVdoZWVsLCBjYik7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLm9uQW5pbWF0aW9uU3RhcnQgPSBmdW5jdGlvbihjYikge1xuXHQgICAgcmV0dXJuIHRoaXMub24oRXZlbnRzLkFuaW1hdGlvblN0YXJ0LCBjYik7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLm9uQW5pbWF0aW9uU3RvcCA9IGZ1bmN0aW9uKGNiKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vbihFdmVudHMuQW5pbWF0aW9uU3RvcCwgY2IpO1xuXHQgIH07XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5vbkFuaW1hdGlvbkVuZCA9IGZ1bmN0aW9uKGNiKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vbihFdmVudHMuQW5pbWF0aW9uRW5kLCBjYik7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLm9uQW5pbWF0aW9uRGlkU3RhcnQgPSBmdW5jdGlvbihjYikge1xuXHQgICAgcmV0dXJuIHRoaXMub24oRXZlbnRzLkFuaW1hdGlvbkRpZFN0YXJ0LCBjYik7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLm9uQW5pbWF0aW9uRGlkU3RvcCA9IGZ1bmN0aW9uKGNiKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vbihFdmVudHMuQW5pbWF0aW9uRGlkU3RvcCwgY2IpO1xuXHQgIH07XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5vbkFuaW1hdGlvbkRpZEVuZCA9IGZ1bmN0aW9uKGNiKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vbihFdmVudHMuQW5pbWF0aW9uRGlkRW5kLCBjYik7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLm9uSW1hZ2VMb2FkZWQgPSBmdW5jdGlvbihjYikge1xuXHQgICAgcmV0dXJuIHRoaXMub24oRXZlbnRzLkltYWdlTG9hZGVkLCBjYik7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLm9uSW1hZ2VMb2FkRXJyb3IgPSBmdW5jdGlvbihjYikge1xuXHQgICAgcmV0dXJuIHRoaXMub24oRXZlbnRzLkltYWdlTG9hZEVycm9yLCBjYik7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLm9uTW92ZSA9IGZ1bmN0aW9uKGNiKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vbihFdmVudHMuTW92ZSwgY2IpO1xuXHQgIH07XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5vbkRyYWdTdGFydCA9IGZ1bmN0aW9uKGNiKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vbihFdmVudHMuRHJhZ1N0YXJ0LCBjYik7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLm9uRHJhZ1dpbGxNb3ZlID0gZnVuY3Rpb24oY2IpIHtcblx0ICAgIHJldHVybiB0aGlzLm9uKEV2ZW50cy5EcmFnV2lsbE1vdmUsIGNiKTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUub25EcmFnTW92ZSA9IGZ1bmN0aW9uKGNiKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vbihFdmVudHMuRHJhZ01vdmUsIGNiKTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUub25EcmFnRGlkTW92ZSA9IGZ1bmN0aW9uKGNiKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vbihFdmVudHMuRHJhZ0RpZE1vdmUsIGNiKTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUub25EcmFnID0gZnVuY3Rpb24oY2IpIHtcblx0ICAgIHJldHVybiB0aGlzLm9uKEV2ZW50cy5EcmFnLCBjYik7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLm9uRHJhZ0VuZCA9IGZ1bmN0aW9uKGNiKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vbihFdmVudHMuRHJhZ0VuZCwgY2IpO1xuXHQgIH07XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5vbkRyYWdBbmltYXRpb25TdGFydCA9IGZ1bmN0aW9uKGNiKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vbihFdmVudHMuRHJhZ0FuaW1hdGlvblN0YXJ0LCBjYik7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLm9uRHJhZ0FuaW1hdGlvbkVuZCA9IGZ1bmN0aW9uKGNiKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vbihFdmVudHMuRHJhZ0FuaW1hdGlvbkVuZCwgY2IpO1xuXHQgIH07XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5vbkRpcmVjdGlvbkxvY2tTdGFydCA9IGZ1bmN0aW9uKGNiKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vbihFdmVudHMuRGlyZWN0aW9uTG9ja1N0YXJ0LCBjYik7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLm9uU3RhdGVEaWRTd2l0Y2ggPSBmdW5jdGlvbihjYikge1xuXHQgICAgcmV0dXJuIHRoaXMub24oRXZlbnRzLlN0YXRlRGlkU3dpdGNoLCBjYik7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLm9uU3RhdGVXaWxsU3dpdGNoID0gZnVuY3Rpb24oY2IpIHtcblx0ICAgIHJldHVybiB0aGlzLm9uKEV2ZW50cy5TdGF0ZVdpbGxTd2l0Y2gsIGNiKTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUub25UYXAgPSBmdW5jdGlvbihjYikge1xuXHQgICAgcmV0dXJuIHRoaXMub24oRXZlbnRzLlRhcCwgY2IpO1xuXHQgIH07XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5vblRhcFN0YXJ0ID0gZnVuY3Rpb24oY2IpIHtcblx0ICAgIHJldHVybiB0aGlzLm9uKEV2ZW50cy5UYXBTdGFydCwgY2IpO1xuXHQgIH07XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5vblRhcEVuZCA9IGZ1bmN0aW9uKGNiKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vbihFdmVudHMuVGFwRW5kLCBjYik7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLm9uRG91YmxlVGFwID0gZnVuY3Rpb24oY2IpIHtcblx0ICAgIHJldHVybiB0aGlzLm9uKEV2ZW50cy5Eb3VibGVUYXAsIGNiKTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUub25Gb3JjZVRhcCA9IGZ1bmN0aW9uKGNiKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vbihFdmVudHMuRm9yY2VUYXAsIGNiKTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUub25Gb3JjZVRhcENoYW5nZSA9IGZ1bmN0aW9uKGNiKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vbihFdmVudHMuRm9yY2VUYXBDaGFuZ2UsIGNiKTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUub25Gb3JjZVRhcFN0YXJ0ID0gZnVuY3Rpb24oY2IpIHtcblx0ICAgIHJldHVybiB0aGlzLm9uKEV2ZW50cy5Gb3JjZVRhcFN0YXJ0LCBjYik7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLm9uRm9yY2VUYXBFbmQgPSBmdW5jdGlvbihjYikge1xuXHQgICAgcmV0dXJuIHRoaXMub24oRXZlbnRzLkZvcmNlVGFwRW5kLCBjYik7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLm9uTG9uZ1ByZXNzID0gZnVuY3Rpb24oY2IpIHtcblx0ICAgIHJldHVybiB0aGlzLm9uKEV2ZW50cy5Mb25nUHJlc3MsIGNiKTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUub25Mb25nUHJlc3NTdGFydCA9IGZ1bmN0aW9uKGNiKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vbihFdmVudHMuTG9uZ1ByZXNzU3RhcnQsIGNiKTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUub25Mb25nUHJlc3NFbmQgPSBmdW5jdGlvbihjYikge1xuXHQgICAgcmV0dXJuIHRoaXMub24oRXZlbnRzLkxvbmdQcmVzc0VuZCwgY2IpO1xuXHQgIH07XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5vblN3aXBlID0gZnVuY3Rpb24oY2IpIHtcblx0ICAgIHJldHVybiB0aGlzLm9uKEV2ZW50cy5Td2lwZSwgY2IpO1xuXHQgIH07XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5vblN3aXBlU3RhcnQgPSBmdW5jdGlvbihjYikge1xuXHQgICAgcmV0dXJuIHRoaXMub24oRXZlbnRzLlN3aXBlU3RhcnQsIGNiKTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUub25Td2lwZUVuZCA9IGZ1bmN0aW9uKGNiKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vbihFdmVudHMuU3dpcGVFbmQsIGNiKTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUub25Td2lwZVVwID0gZnVuY3Rpb24oY2IpIHtcblx0ICAgIHJldHVybiB0aGlzLm9uKEV2ZW50cy5Td2lwZVVwLCBjYik7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLm9uU3dpcGVVcFN0YXJ0ID0gZnVuY3Rpb24oY2IpIHtcblx0ICAgIHJldHVybiB0aGlzLm9uKEV2ZW50cy5Td2lwZVVwU3RhcnQsIGNiKTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUub25Td2lwZVVwRW5kID0gZnVuY3Rpb24oY2IpIHtcblx0ICAgIHJldHVybiB0aGlzLm9uKEV2ZW50cy5Td2lwZVVwRW5kLCBjYik7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLm9uU3dpcGVEb3duID0gZnVuY3Rpb24oY2IpIHtcblx0ICAgIHJldHVybiB0aGlzLm9uKEV2ZW50cy5Td2lwZURvd24sIGNiKTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUub25Td2lwZURvd25TdGFydCA9IGZ1bmN0aW9uKGNiKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vbihFdmVudHMuU3dpcGVEb3duU3RhcnQsIGNiKTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUub25Td2lwZURvd25FbmQgPSBmdW5jdGlvbihjYikge1xuXHQgICAgcmV0dXJuIHRoaXMub24oRXZlbnRzLlN3aXBlRG93bkVuZCwgY2IpO1xuXHQgIH07XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5vblN3aXBlTGVmdCA9IGZ1bmN0aW9uKGNiKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vbihFdmVudHMuU3dpcGVMZWZ0LCBjYik7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLm9uU3dpcGVMZWZ0U3RhcnQgPSBmdW5jdGlvbihjYikge1xuXHQgICAgcmV0dXJuIHRoaXMub24oRXZlbnRzLlN3aXBlTGVmdFN0YXJ0LCBjYik7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLm9uU3dpcGVMZWZ0RW5kID0gZnVuY3Rpb24oY2IpIHtcblx0ICAgIHJldHVybiB0aGlzLm9uKEV2ZW50cy5Td2lwZUxlZnRFbmQsIGNiKTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUub25Td2lwZVJpZ2h0ID0gZnVuY3Rpb24oY2IpIHtcblx0ICAgIHJldHVybiB0aGlzLm9uKEV2ZW50cy5Td2lwZVJpZ2h0LCBjYik7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLm9uU3dpcGVSaWdodFN0YXJ0ID0gZnVuY3Rpb24oY2IpIHtcblx0ICAgIHJldHVybiB0aGlzLm9uKEV2ZW50cy5Td2lwZVJpZ2h0U3RhcnQsIGNiKTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUub25Td2lwZVJpZ2h0RW5kID0gZnVuY3Rpb24oY2IpIHtcblx0ICAgIHJldHVybiB0aGlzLm9uKEV2ZW50cy5Td2lwZVJpZ2h0RW5kLCBjYik7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLm9uUGFuID0gZnVuY3Rpb24oY2IpIHtcblx0ICAgIHJldHVybiB0aGlzLm9uKEV2ZW50cy5QYW4sIGNiKTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUub25QYW5TdGFydCA9IGZ1bmN0aW9uKGNiKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vbihFdmVudHMuUGFuU3RhcnQsIGNiKTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUub25QYW5FbmQgPSBmdW5jdGlvbihjYikge1xuXHQgICAgcmV0dXJuIHRoaXMub24oRXZlbnRzLlBhbkVuZCwgY2IpO1xuXHQgIH07XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5vblBhbkxlZnQgPSBmdW5jdGlvbihjYikge1xuXHQgICAgcmV0dXJuIHRoaXMub24oRXZlbnRzLlBhbkxlZnQsIGNiKTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUub25QYW5SaWdodCA9IGZ1bmN0aW9uKGNiKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vbihFdmVudHMuUGFuUmlnaHQsIGNiKTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUub25QYW5VcCA9IGZ1bmN0aW9uKGNiKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vbihFdmVudHMuUGFuVXAsIGNiKTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUub25QYW5Eb3duID0gZnVuY3Rpb24oY2IpIHtcblx0ICAgIHJldHVybiB0aGlzLm9uKEV2ZW50cy5QYW5Eb3duLCBjYik7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLm9uUGluY2ggPSBmdW5jdGlvbihjYikge1xuXHQgICAgcmV0dXJuIHRoaXMub24oRXZlbnRzLlBpbmNoLCBjYik7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLm9uUGluY2hTdGFydCA9IGZ1bmN0aW9uKGNiKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vbihFdmVudHMuUGluY2hTdGFydCwgY2IpO1xuXHQgIH07XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5vblBpbmNoRW5kID0gZnVuY3Rpb24oY2IpIHtcblx0ICAgIHJldHVybiB0aGlzLm9uKEV2ZW50cy5QaW5jaEVuZCwgY2IpO1xuXHQgIH07XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5vblNjYWxlID0gZnVuY3Rpb24oY2IpIHtcblx0ICAgIHJldHVybiB0aGlzLm9uKEV2ZW50cy5TY2FsZSwgY2IpO1xuXHQgIH07XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5vblNjYWxlU3RhcnQgPSBmdW5jdGlvbihjYikge1xuXHQgICAgcmV0dXJuIHRoaXMub24oRXZlbnRzLlNjYWxlU3RhcnQsIGNiKTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUub25TY2FsZUVuZCA9IGZ1bmN0aW9uKGNiKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vbihFdmVudHMuU2NhbGVFbmQsIGNiKTtcblx0ICB9O1xuXHRcblx0ICBMYXllci5wcm90b3R5cGUub25Sb3RhdGUgPSBmdW5jdGlvbihjYikge1xuXHQgICAgcmV0dXJuIHRoaXMub24oRXZlbnRzLlJvdGF0ZSwgY2IpO1xuXHQgIH07XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5vblJvdGF0ZVN0YXJ0ID0gZnVuY3Rpb24oY2IpIHtcblx0ICAgIHJldHVybiB0aGlzLm9uKEV2ZW50cy5Sb3RhdGVTdGFydCwgY2IpO1xuXHQgIH07XG5cdFxuXHQgIExheWVyLnByb3RvdHlwZS5vblJvdGF0ZUVuZCA9IGZ1bmN0aW9uKGNiKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vbihFdmVudHMuUm90YXRlRW5kLCBjYik7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXIucHJvdG90eXBlLnRvSW5zcGVjdCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIHJvdW5kO1xuXHQgICAgcm91bmQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICBpZiAocGFyc2VJbnQodmFsdWUpID09PSB2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIFV0aWxzLnJvdW5kKHZhbHVlLCAxKTtcblx0ICAgIH07XG5cdCAgICBpZiAodGhpcy5uYW1lKSB7XG5cdCAgICAgIHJldHVybiBcIjxcIiArIHRoaXMuY29uc3RydWN0b3IubmFtZSArIFwiIGlkOlwiICsgdGhpcy5pZCArIFwiIG5hbWU6XCIgKyB0aGlzLm5hbWUgKyBcIiAoXCIgKyAocm91bmQodGhpcy54KSkgKyBcIixcIiArIChyb3VuZCh0aGlzLnkpKSArIFwiKSBcIiArIChyb3VuZCh0aGlzLndpZHRoKSkgKyBcInhcIiArIChyb3VuZCh0aGlzLmhlaWdodCkpICsgXCI+XCI7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gXCI8XCIgKyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyBcIiBpZDpcIiArIHRoaXMuaWQgKyBcIiAoXCIgKyAocm91bmQodGhpcy54KSkgKyBcIixcIiArIChyb3VuZCh0aGlzLnkpKSArIFwiKSBcIiArIChyb3VuZCh0aGlzLndpZHRoKSkgKyBcInhcIiArIChyb3VuZCh0aGlzLmhlaWdodCkpICsgXCI+XCI7XG5cdCAgfTtcblx0XG5cdCAgcmV0dXJuIExheWVyO1xuXHRcblx0fSkoQmFzZUNsYXNzKTtcblxuXG4vKioqLyB9LFxuLyogMTQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBGcmFtZXJDU1MsIFV0aWxzO1xuXHRcblx0VXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHRcblx0RnJhbWVyQ1NTID0gXCJib2R5IHtcXG5cdG1hcmdpbjogMDtcXG59XFxuXFxuLmZyYW1lckNvbnRleHQge1xcblx0cG9zaXRpb246IGFic29sdXRlO1xcblx0bGVmdDogMDtcXG5cdHRvcDogMDtcXG5cdHJpZ2h0OiAwO1xcblx0Ym90dG9tOiAwO1xcblx0cG9pbnRlci1ldmVudHM6IG5vbmU7XFxufVxcblxcbi5mcmFtZXJMYXllciB7XFxuXHRkaXNwbGF5OiBibG9jaztcXG5cdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG5cdGxlZnQ6IDA7XFxuXHR0b3A6IDA7XFxuXHRiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcblx0YmFja2dyb3VuZC1wb3NpdGlvbjogY2VudGVyO1xcblx0YmFja2dyb3VuZC1zaXplOiBjb3ZlcjtcXG5cdC13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOiB0b3VjaDtcXG5cdC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXG5cdC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxufVxcblxcbi5mcmFtZXJMYXllciBpbnB1dCxcXG4uZnJhbWVyTGF5ZXIgdGV4dGFyZWEsXFxuLmZyYW1lckxheWVyIHNlbGVjdCxcXG4uZnJhbWVyTGF5ZXIgb3B0aW9uLFxcbi5mcmFtZXJMYXllciBkaXZbY29udGVudGVkaXRhYmxlPXRydWVdXFxue1xcblx0cG9pbnRlci1ldmVudHM6IGF1dG87XFxuXHQtd2Via2l0LXVzZXItc2VsZWN0OiBhdXRvO1xcbn1cXG5cXG4uZnJhbWVyRGVidWcge1xcblx0cGFkZGluZzogNnB4O1xcblx0Y29sb3I6ICNmZmY7XFxuXHRmb250OiAxMHB4LzFlbSBNb25hY287XFxufVxcblwiO1xuXHRcblx0VXRpbHMuZG9tQ29tcGxldGUoZnVuY3Rpb24oKSB7XG5cdCAgcmV0dXJuIFV0aWxzLmluc2VydENTUyhGcmFtZXJDU1MpO1xuXHR9KTtcblxuXG4vKioqLyB9LFxuLyogMTUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBFdmVudHMsIEdlc3R1cmVzLCBVdGlscywgXyxcblx0ICBpbmRleE9mID0gW10uaW5kZXhPZiB8fCBmdW5jdGlvbihpdGVtKSB7IGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHsgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKSByZXR1cm4gaTsgfSByZXR1cm4gLTE7IH07XG5cdFxuXHRVdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdFxuXHRfID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKS5fO1xuXHRcblx0R2VzdHVyZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KS5HZXN0dXJlcztcblx0XG5cdEV2ZW50cyA9IHt9O1xuXHRcblx0RXZlbnRzLlRvdWNoU3RhcnQgPSBcInRvdWNoc3RhcnRcIjtcblx0XG5cdEV2ZW50cy5Ub3VjaEVuZCA9IFwidG91Y2hlbmRcIjtcblx0XG5cdEV2ZW50cy5Ub3VjaE1vdmUgPSBcInRvdWNobW92ZVwiO1xuXHRcblx0RXZlbnRzLk1vdXNlVXAgPSBcIm1vdXNldXBcIjtcblx0XG5cdEV2ZW50cy5Nb3VzZURvd24gPSBcIm1vdXNlZG93blwiO1xuXHRcblx0RXZlbnRzLk1vdXNlT3ZlciA9IFwibW91c2VvdmVyXCI7XG5cdFxuXHRFdmVudHMuTW91c2VPdXQgPSBcIm1vdXNlb3V0XCI7XG5cdFxuXHRFdmVudHMuTW91c2VNb3ZlID0gXCJtb3VzZW1vdmVcIjtcblx0XG5cdEV2ZW50cy5Nb3VzZVdoZWVsID0gXCJtb3VzZXdoZWVsXCI7XG5cdFxuXHRFdmVudHMuRG91YmxlQ2xpY2sgPSBcImRibGNsaWNrXCI7XG5cdFxuXHRFdmVudHMuTW91c2VEb3VibGVDbGljayA9IFwiZGJsY2xpY2tcIjtcblx0XG5cdGlmICghVXRpbHMuaXNUb3VjaCgpKSB7XG5cdCAgRXZlbnRzLlRvdWNoU3RhcnQgPSBFdmVudHMuTW91c2VEb3duO1xuXHQgIEV2ZW50cy5Ub3VjaEVuZCA9IEV2ZW50cy5Nb3VzZVVwO1xuXHQgIEV2ZW50cy5Ub3VjaE1vdmUgPSBFdmVudHMuTW91c2VNb3ZlO1xuXHR9XG5cdFxuXHRFdmVudHMuQ2xpY2sgPSBFdmVudHMuVG91Y2hFbmQ7XG5cdFxuXHRFdmVudHMuQW5pbWF0aW9uU3RhcnQgPSBcInN0YXJ0XCI7XG5cdFxuXHRFdmVudHMuQW5pbWF0aW9uU3RvcCA9IFwic3RvcFwiO1xuXHRcblx0RXZlbnRzLkFuaW1hdGlvbkVuZCA9IFwiZW5kXCI7XG5cdFxuXHRFdmVudHMuQW5pbWF0aW9uRGlkU3RhcnQgPSBcInN0YXJ0XCI7XG5cdFxuXHRFdmVudHMuQW5pbWF0aW9uRGlkU3RvcCA9IFwic3RvcFwiO1xuXHRcblx0RXZlbnRzLkFuaW1hdGlvbkRpZEVuZCA9IFwiZW5kXCI7XG5cdFxuXHRFdmVudHMuU2Nyb2xsID0gXCJzY3JvbGxcIjtcblx0XG5cdEV2ZW50cy5JbWFnZUxvYWRlZCA9IFwibG9hZFwiO1xuXHRcblx0RXZlbnRzLkltYWdlTG9hZEVycm9yID0gXCJlcnJvclwiO1xuXHRcblx0Xy5leHRlbmQoRXZlbnRzLCBHZXN0dXJlcyk7XG5cdFxuXHRFdmVudHMudG91Y2hFdmVudCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdCAgdmFyIHJlZiwgcmVmMSwgdG91Y2hFdmVudDtcblx0ICB0b3VjaEV2ZW50ID0gKHJlZiA9IGV2ZW50LnRvdWNoZXMpICE9IG51bGwgPyByZWZbMF0gOiB2b2lkIDA7XG5cdCAgaWYgKHRvdWNoRXZlbnQgPT0gbnVsbCkge1xuXHQgICAgdG91Y2hFdmVudCA9IChyZWYxID0gZXZlbnQuY2hhbmdlZFRvdWNoZXMpICE9IG51bGwgPyByZWYxWzBdIDogdm9pZCAwO1xuXHQgIH1cblx0ICBpZiAodG91Y2hFdmVudCA9PSBudWxsKSB7XG5cdCAgICB0b3VjaEV2ZW50ID0gZXZlbnQ7XG5cdCAgfVxuXHQgIHJldHVybiB0b3VjaEV2ZW50O1xuXHR9O1xuXHRcblx0RXZlbnRzLndyYXAgPSBmdW5jdGlvbihlbGVtZW50KSB7XG5cdCAgcmV0dXJuIEZyYW1lci5DdXJyZW50Q29udGV4dC5kb21FdmVudE1hbmFnZXIud3JhcChlbGVtZW50KTtcblx0fTtcblx0XG5cdEV2ZW50cy5pc0dlc3R1cmUgPSBmdW5jdGlvbihldmVudE5hbWUpIHtcblx0ICByZXR1cm4gaW5kZXhPZi5jYWxsKEdlc3R1cmVzLCBldmVudE5hbWUpID49IDA7XG5cdH07XG5cdFxuXHRleHBvcnRzLkV2ZW50cyA9IEV2ZW50cztcblxuXG4vKioqLyB9LFxuLyogMTYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdHZhciBHZXN0dXJlcztcblx0XG5cdEdlc3R1cmVzID0ge307XG5cdFxuXHRHZXN0dXJlcy5UYXAgPSBcInRhcFwiO1xuXHRcblx0R2VzdHVyZXMuVGFwU3RhcnQgPSBcInRhcHN0YXJ0XCI7XG5cdFxuXHRHZXN0dXJlcy5UYXBFbmQgPSBcInRhcGVuZFwiO1xuXHRcblx0R2VzdHVyZXMuRG91YmxlVGFwID0gXCJkb3VibGV0YXBcIjtcblx0XG5cdEdlc3R1cmVzLkZvcmNlVGFwID0gXCJmb3JjZXRhcFwiO1xuXHRcblx0R2VzdHVyZXMuRm9yY2VUYXBDaGFuZ2UgPSBcImZvcmNldGFwY2hhbmdlXCI7XG5cdFxuXHRHZXN0dXJlcy5Gb3JjZVRhcFN0YXJ0ID0gXCJmb3JjZXRhcHN0YXJ0XCI7XG5cdFxuXHRHZXN0dXJlcy5Gb3JjZVRhcEVuZCA9IFwiZm9yY2V0YXBlbmRcIjtcblx0XG5cdEdlc3R1cmVzLkxvbmdQcmVzcyA9IFwibG9uZ3ByZXNzXCI7XG5cdFxuXHRHZXN0dXJlcy5Mb25nUHJlc3NTdGFydCA9IFwibG9uZ3ByZXNzc3RhcnRcIjtcblx0XG5cdEdlc3R1cmVzLkxvbmdQcmVzc0VuZCA9IFwibG9uZ3ByZXNzZW5kXCI7XG5cdFxuXHRHZXN0dXJlcy5Td2lwZSA9IFwic3dpcGVcIjtcblx0XG5cdEdlc3R1cmVzLlN3aXBlU3RhcnQgPSBcInN3aXBlc3RhcnRcIjtcblx0XG5cdEdlc3R1cmVzLlN3aXBlRW5kID0gXCJzd2lwZWVuZFwiO1xuXHRcblx0R2VzdHVyZXMuU3dpcGVVcCA9IFwic3dpcGV1cFwiO1xuXHRcblx0R2VzdHVyZXMuU3dpcGVVcFN0YXJ0ID0gXCJzd2lwZXVwc3RhcnRcIjtcblx0XG5cdEdlc3R1cmVzLlN3aXBlVXBFbmQgPSBcInN3aXBldXBlbmRcIjtcblx0XG5cdEdlc3R1cmVzLlN3aXBlRG93biA9IFwic3dpcGVkb3duXCI7XG5cdFxuXHRHZXN0dXJlcy5Td2lwZURvd25TdGFydCA9IFwic3dpcGVkb3duc3RhcnRcIjtcblx0XG5cdEdlc3R1cmVzLlN3aXBlRG93bkVuZCA9IFwic3dpcGVkb3duZW5kXCI7XG5cdFxuXHRHZXN0dXJlcy5Td2lwZUxlZnQgPSBcInN3aXBlbGVmdFwiO1xuXHRcblx0R2VzdHVyZXMuU3dpcGVMZWZ0U3RhcnQgPSBcInN3aXBlbGVmdHN0YXJ0XCI7XG5cdFxuXHRHZXN0dXJlcy5Td2lwZUxlZnRFbmQgPSBcInN3aXBlbGVmdGVuZFwiO1xuXHRcblx0R2VzdHVyZXMuU3dpcGVSaWdodCA9IFwic3dpcGVyaWdodFwiO1xuXHRcblx0R2VzdHVyZXMuU3dpcGVSaWdodFN0YXJ0ID0gXCJzd2lwZXJpZ2h0c3RhcnRcIjtcblx0XG5cdEdlc3R1cmVzLlN3aXBlUmlnaHRFbmQgPSBcInN3aXBlcmlnaHRlbmRcIjtcblx0XG5cdEdlc3R1cmVzLkVkZ2VTd2lwZSA9IFwiZWRnZXN3aXBlXCI7XG5cdFxuXHRHZXN0dXJlcy5FZGdlU3dpcGVTdGFydCA9IFwiZWRnZXN3aXBlc3RhcnRcIjtcblx0XG5cdEdlc3R1cmVzLkVkZ2VTd2lwZUVuZCA9IFwiZWRnZXN3aXBlZW5kXCI7XG5cdFxuXHRHZXN0dXJlcy5FZGdlU3dpcGVUb3AgPSBcImVkZ2Vzd2lwZXRvcFwiO1xuXHRcblx0R2VzdHVyZXMuRWRnZVN3aXBlVG9wU3RhcnQgPSBcImVkZ2Vzd2lwZXRvcHN0YXJ0XCI7XG5cdFxuXHRHZXN0dXJlcy5FZGdlU3dpcGVUb3BFbmQgPSBcImVkZ2Vzd2lwZXRvcGVuZFwiO1xuXHRcblx0R2VzdHVyZXMuRWRnZVN3aXBlUmlnaHQgPSBcImVkZ2Vzd2lwZXJpZ2h0XCI7XG5cdFxuXHRHZXN0dXJlcy5FZGdlU3dpcGVSaWdodFN0YXJ0ID0gXCJlZGdlc3dpcGVyaWdodHN0YXJ0XCI7XG5cdFxuXHRHZXN0dXJlcy5FZGdlU3dpcGVSaWdodEVuZCA9IFwiZWRnZXN3aXBlcmlnaHRlbmRcIjtcblx0XG5cdEdlc3R1cmVzLkVkZ2VTd2lwZUJvdHRvbSA9IFwiZWRnZXN3aXBlYm90dG9tXCI7XG5cdFxuXHRHZXN0dXJlcy5FZGdlU3dpcGVCb3R0b21TdGFydCA9IFwiZWRnZXN3aXBlYm90dG9tc3RhcnRcIjtcblx0XG5cdEdlc3R1cmVzLkVkZ2VTd2lwZUJvdHRvbUVuZCA9IFwiZWRnZXN3aXBlYm90dG9tZW5kXCI7XG5cdFxuXHRHZXN0dXJlcy5FZGdlU3dpcGVMZWZ0ID0gXCJlZGdlc3dpcGVsZWZ0XCI7XG5cdFxuXHRHZXN0dXJlcy5FZGdlU3dpcGVMZWZ0U3RhcnQgPSBcImVkZ2Vzd2lwZWxlZnRzdGFydFwiO1xuXHRcblx0R2VzdHVyZXMuRWRnZVN3aXBlTGVmdEVuZCA9IFwiZWRnZXN3aXBlbGVmdGVuZFwiO1xuXHRcblx0R2VzdHVyZXMuUGFuID0gXCJwYW5cIjtcblx0XG5cdEdlc3R1cmVzLlBhblN0YXJ0ID0gXCJwYW5zdGFydFwiO1xuXHRcblx0R2VzdHVyZXMuUGFuRW5kID0gXCJwYW5lbmRcIjtcblx0XG5cdEdlc3R1cmVzLlBhbkxlZnQgPSBcInBhbmxlZnRcIjtcblx0XG5cdEdlc3R1cmVzLlBhblJpZ2h0ID0gXCJwYW5yaWdodFwiO1xuXHRcblx0R2VzdHVyZXMuUGFuVXAgPSBcInBhbnVwXCI7XG5cdFxuXHRHZXN0dXJlcy5QYW5Eb3duID0gXCJwYW5kb3duXCI7XG5cdFxuXHRHZXN0dXJlcy5QaW5jaCA9IFwicGluY2hcIjtcblx0XG5cdEdlc3R1cmVzLlBpbmNoU3RhcnQgPSBcInBpbmNoc3RhcnRcIjtcblx0XG5cdEdlc3R1cmVzLlBpbmNoRW5kID0gXCJwaW5jaGVuZFwiO1xuXHRcblx0R2VzdHVyZXMuU2NhbGUgPSBcInNjYWxlXCI7XG5cdFxuXHRHZXN0dXJlcy5TY2FsZVN0YXJ0ID0gXCJzY2FsZXN0YXJ0XCI7XG5cdFxuXHRHZXN0dXJlcy5TY2FsZUVuZCA9IFwic2NhbGVlbmRcIjtcblx0XG5cdEdlc3R1cmVzLlJvdGF0ZSA9IFwicm90YXRlXCI7XG5cdFxuXHRHZXN0dXJlcy5Sb3RhdGVTdGFydCA9IFwicm90YXRlc3RhcnRcIjtcblx0XG5cdEdlc3R1cmVzLlJvdGF0ZUVuZCA9IFwicm90YXRlZW5kXCI7XG5cdFxuXHRleHBvcnRzLkdlc3R1cmVzID0gR2VzdHVyZXM7XG5cblxuLyoqKi8gfSxcbi8qIDE3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgT3JpZ2luYWxzLCBVdGlscywgXztcblx0XG5cdF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpLl87XG5cdFxuXHRVdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdFxuXHRPcmlnaW5hbHMgPSB7XG5cdCAgTGF5ZXI6IHtcblx0ICAgIGJhY2tncm91bmRDb2xvcjogXCJyZ2JhKDEyMywxMjMsMTIzLDAuNSlcIixcblx0ICAgIGNvbG9yOiBcIndoaXRlXCIsXG5cdCAgICBzaGFkb3dDb2xvcjogXCJyZ2JhKDEyMywxMjMsMTIzLDAuNSlcIixcblx0ICAgIGJvcmRlckNvbG9yOiBcInJnYmEoMTIzLDEyMywxMjMsMC41KVwiLFxuXHQgICAgd2lkdGg6IDIwMCxcblx0ICAgIGhlaWdodDogMjAwXG5cdCAgfSxcblx0ICBBbmltYXRpb246IHtcblx0ICAgIGN1cnZlOiBcImVhc2VcIixcblx0ICAgIHRpbWU6IDFcblx0ICB9LFxuXHQgIENvbnRleHQ6IHtcblx0ICAgIHBlcnNwZWN0aXZlOiAwLFxuXHQgICAgcGVyc3BlY3RpdmVPcmlnaW5YOiAwLjUsXG5cdCAgICBwZXJzcGVjdGl2ZU9yaWdpblk6IDAuNSxcblx0ICAgIHBhcmVudDogbnVsbCxcblx0ICAgIG5hbWU6IG51bGxcblx0ICB9LFxuXHQgIERldmljZUNvbXBvbmVudDoge1xuXHQgICAgZnVsbFNjcmVlbjogZmFsc2UsXG5cdCAgICBwYWRkaW5nOiA1MCxcblx0ICAgIGRldmljZVR5cGU6IFwiYXBwbGUtaXBob25lLTZzLXNpbHZlclwiLFxuXHQgICAgZGV2aWNlWm9vbTogXCJmaXRcIixcblx0ICAgIGNvbnRlbnRab29tOiAxLFxuXHQgICAgb3JpZW50YXRpb246IFwicG9ydHJhaXRcIixcblx0ICAgIGtleWJvYXJkOiBmYWxzZSxcblx0ICAgIGFuaW1hdGlvbk9wdGlvbnM6IHtcblx0ICAgICAgdGltZTogLjMsXG5cdCAgICAgIGN1cnZlOiBcImVhc2UtaW4tb3V0XCJcblx0ICAgIH1cblx0ICB9LFxuXHQgIExheWVyRHJhZ2dhYmxlOiB7XG5cdCAgICBtb21lbnR1bTogdHJ1ZSxcblx0ICAgIG1vbWVudHVtT3B0aW9uczoge1xuXHQgICAgICBmcmljdGlvbjogMi4xLFxuXHQgICAgICB0b2xlcmFuY2U6IDFcblx0ICAgIH0sXG5cdCAgICBib3VuY2U6IHRydWUsXG5cdCAgICBib3VuY2VPcHRpb25zOiB7XG5cdCAgICAgIGZyaWN0aW9uOiA0MCxcblx0ICAgICAgdGVuc2lvbjogMjAwLFxuXHQgICAgICB0b2xlcmFuY2U6IDFcblx0ICAgIH0sXG5cdCAgICBkaXJlY3Rpb25Mb2NrOiBmYWxzZSxcblx0ICAgIGRpcmVjdGlvbkxvY2tUaHJlc2hvbGQ6IHtcblx0ICAgICAgeDogMTAsXG5cdCAgICAgIHk6IDEwXG5cdCAgICB9LFxuXHQgICAgb3ZlcmRyYWc6IHRydWUsXG5cdCAgICBvdmVyZHJhZ1NjYWxlOiAwLjUsXG5cdCAgICBwaXhlbEFsaWduOiB0cnVlLFxuXHQgICAgdmVsb2NpdHlUaW1lb3V0OiAxMDAsXG5cdCAgICB2ZWxvY2l0eVNjYWxlOiA4OTBcblx0ICB9LFxuXHQgIEZyaWN0aW9uU2ltdWxhdG9yOiB7XG5cdCAgICBmcmljdGlvbjogMixcblx0ICAgIHRvbGVyYW5jZTogMSAvIDEwXG5cdCAgfSxcblx0ICBTcHJpbmdTaW11bGF0b3I6IHtcblx0ICAgIHRlbnNpb246IDUwMCxcblx0ICAgIGZyaWN0aW9uOiAxMCxcblx0ICAgIHRvbGVyYW5jZTogMSAvIDEwMDAwXG5cdCAgfSxcblx0ICBNb21lbnR1bUJvdW5jZVNpbXVsYXRvcjoge1xuXHQgICAgbW9tZW50dW06IHtcblx0ICAgICAgZnJpY3Rpb246IDIsXG5cdCAgICAgIHRvbGVyYW5jZTogMTBcblx0ICAgIH0sXG5cdCAgICBib3VuY2U6IHtcblx0ICAgICAgdGVuc2lvbjogNTAwLFxuXHQgICAgICBmcmljdGlvbjogMTAsXG5cdCAgICAgIHRvbGVyYW5jZTogMVxuXHQgICAgfVxuXHQgIH1cblx0fTtcblx0XG5cdGV4cG9ydHMuRGVmYXVsdHMgPSB7XG5cdCAgZ2V0RGVmYXVsdHM6IGZ1bmN0aW9uKGNsYXNzTmFtZSwgb3B0aW9ucykge1xuXHQgICAgdmFyIGRlZmF1bHRzLCBrLCByZWYsIHY7XG5cdCAgICBpZiAoIU9yaWdpbmFscy5oYXNPd25Qcm9wZXJ0eShjbGFzc05hbWUpKSB7XG5cdCAgICAgIHJldHVybiB7fTtcblx0ICAgIH1cblx0ICAgIGlmICghRnJhbWVyLkRlZmF1bHRzLmhhc093blByb3BlcnR5KGNsYXNzTmFtZSkpIHtcblx0ICAgICAgcmV0dXJuIHt9O1xuXHQgICAgfVxuXHQgICAgZGVmYXVsdHMgPSBfLmNsb25lKE9yaWdpbmFsc1tjbGFzc05hbWVdKTtcblx0ICAgIHJlZiA9IEZyYW1lci5EZWZhdWx0c1tjbGFzc05hbWVdO1xuXHQgICAgZm9yIChrIGluIHJlZikge1xuXHQgICAgICB2ID0gcmVmW2tdO1xuXHQgICAgICBkZWZhdWx0c1trXSA9IF8uaXNGdW5jdGlvbih2KSA/IHYoKSA6IHY7XG5cdCAgICB9XG5cdCAgICBmb3IgKGsgaW4gZGVmYXVsdHMpIHtcblx0ICAgICAgdiA9IGRlZmF1bHRzW2tdO1xuXHQgICAgICBpZiAoIW9wdGlvbnMuaGFzT3duUHJvcGVydHkoaykpIHtcblx0ICAgICAgICBvcHRpb25zW2tdID0gdjtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIG9wdGlvbnM7XG5cdCAgfSxcblx0ICBzZXR1cDogZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgY2xhc3NOYW1lLCBjbGFzc1ZhbHVlcywgaywgcmVmLCB2O1xuXHQgICAgaWYgKHdpbmRvdy5GcmFtZXJEZWZhdWx0cykge1xuXHQgICAgICByZWYgPSB3aW5kb3cuRnJhbWVyRGVmYXVsdHM7XG5cdCAgICAgIGZvciAoY2xhc3NOYW1lIGluIHJlZikge1xuXHQgICAgICAgIGNsYXNzVmFsdWVzID0gcmVmW2NsYXNzTmFtZV07XG5cdCAgICAgICAgZm9yIChrIGluIGNsYXNzVmFsdWVzKSB7XG5cdCAgICAgICAgICB2ID0gY2xhc3NWYWx1ZXNba107XG5cdCAgICAgICAgICBPcmlnaW5hbHNbY2xhc3NOYW1lXVtrXSA9IHY7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gZXhwb3J0cy5EZWZhdWx0cy5yZXNldCgpO1xuXHQgIH0sXG5cdCAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgcmV0dXJuIHdpbmRvdy5GcmFtZXIuRGVmYXVsdHMgPSBfLmNsb25lKE9yaWdpbmFscyk7XG5cdCAgfVxuXHR9O1xuXG5cbi8qKiovIH0sXG4vKiAxOCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIEFuaW1hdG9yQ2xhc3NCZXppZXJQcmVzZXRzLCBBbmltYXRvckNsYXNzZXMsIEJhc2VDbGFzcywgQmV6aWVyQ3VydmVBbmltYXRvciwgQ29uZmlnLCBEZWZhdWx0cywgTGluZWFyQW5pbWF0b3IsIFNwcmluZ0RIT0FuaW1hdG9yLCBTcHJpbmdSSzRBbmltYXRvciwgVXRpbHMsIF8sIGV2YWx1YXRlUmVsYXRpdmVQcm9wZXJ0eSwgaXNSZWxhdGl2ZVByb3BlcnR5LCBudW1iZXJSRSwgcmVsYXRpdmVQcm9wZXJ0eVJFLFxuXHQgIHNsaWNlID0gW10uc2xpY2UsXG5cdCAgYmluZCA9IGZ1bmN0aW9uKGZuLCBtZSl7IHJldHVybiBmdW5jdGlvbigpeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH0sXG5cdCAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuXHQgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcblx0ICBpbmRleE9mID0gW10uaW5kZXhPZiB8fCBmdW5jdGlvbihpdGVtKSB7IGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHsgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKSByZXR1cm4gaTsgfSByZXR1cm4gLTE7IH07XG5cdFxuXHRfID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKS5fO1xuXHRcblx0VXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHRcblx0Q29uZmlnID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCkuQ29uZmlnO1xuXHRcblx0RGVmYXVsdHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KS5EZWZhdWx0cztcblx0XG5cdEJhc2VDbGFzcyA9IF9fd2VicGFja19yZXF1aXJlX18oNikuQmFzZUNsYXNzO1xuXHRcblx0TGluZWFyQW5pbWF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KS5MaW5lYXJBbmltYXRvcjtcblx0XG5cdEJlemllckN1cnZlQW5pbWF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKS5CZXppZXJDdXJ2ZUFuaW1hdG9yO1xuXHRcblx0U3ByaW5nUks0QW5pbWF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKS5TcHJpbmdSSzRBbmltYXRvcjtcblx0XG5cdFNwcmluZ0RIT0FuaW1hdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCkuU3ByaW5nREhPQW5pbWF0b3I7XG5cdFxuXHRBbmltYXRvckNsYXNzZXMgPSB7XG5cdCAgXCJsaW5lYXJcIjogTGluZWFyQW5pbWF0b3IsXG5cdCAgXCJiZXppZXItY3VydmVcIjogQmV6aWVyQ3VydmVBbmltYXRvcixcblx0ICBcInNwcmluZy1yazRcIjogU3ByaW5nUks0QW5pbWF0b3IsXG5cdCAgXCJzcHJpbmctZGhvXCI6IFNwcmluZ0RIT0FuaW1hdG9yXG5cdH07XG5cdFxuXHRBbmltYXRvckNsYXNzZXNbXCJzcHJpbmdcIl0gPSBBbmltYXRvckNsYXNzZXNbXCJzcHJpbmctcms0XCJdO1xuXHRcblx0QW5pbWF0b3JDbGFzc2VzW1wiY3ViaWMtYmV6aWVyXCJdID0gQW5pbWF0b3JDbGFzc2VzW1wiYmV6aWVyLWN1cnZlXCJdO1xuXHRcblx0QW5pbWF0b3JDbGFzc0JlemllclByZXNldHMgPSBbXCJlYXNlXCIsIFwiZWFzZS1pblwiLCBcImVhc2Utb3V0XCIsIFwiZWFzZS1pbi1vdXRcIl07XG5cdFxuXHRudW1iZXJSRSA9IC9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvO1xuXHRcblx0cmVsYXRpdmVQcm9wZXJ0eVJFID0gbmV3IFJlZ0V4cCgnXig/OihbKy1dKT18KSgnICsgbnVtYmVyUkUuc291cmNlICsgJykoW2EteiVdKikkJywgJ2knKTtcblx0XG5cdGlzUmVsYXRpdmVQcm9wZXJ0eSA9IGZ1bmN0aW9uKHYpIHtcblx0ICByZXR1cm4gXy5pc1N0cmluZyh2KSAmJiByZWxhdGl2ZVByb3BlcnR5UkUudGVzdCh2KTtcblx0fTtcblx0XG5cdGV2YWx1YXRlUmVsYXRpdmVQcm9wZXJ0eSA9IGZ1bmN0aW9uKHRhcmdldCwgaywgdikge1xuXHQgIHZhciBtYXRjaCwgbnVtYmVyLCByZWYsIHJlc3QsIHNpZ24sIHVuaXQ7XG5cdCAgcmVmID0gcmVsYXRpdmVQcm9wZXJ0eVJFLmV4ZWModiksIG1hdGNoID0gcmVmWzBdLCBzaWduID0gcmVmWzFdLCBudW1iZXIgPSByZWZbMl0sIHVuaXQgPSByZWZbM10sIHJlc3QgPSA1IDw9IHJlZi5sZW5ndGggPyBzbGljZS5jYWxsKHJlZiwgNCkgOiBbXTtcblx0ICBpZiAoc2lnbikge1xuXHQgICAgcmV0dXJuIHRhcmdldFtrXSArIChzaWduICsgMSkgKiBudW1iZXI7XG5cdCAgfVxuXHQgIHJldHVybiArbnVtYmVyO1xuXHR9O1xuXHRcblx0ZXhwb3J0cy5BbmltYXRpb24gPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuXHQgIGV4dGVuZChBbmltYXRpb24sIHN1cGVyQ2xhc3MpO1xuXHRcblx0ICBmdW5jdGlvbiBBbmltYXRpb24ob3B0aW9ucykge1xuXHQgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuXHQgICAgICBvcHRpb25zID0ge307XG5cdCAgICB9XG5cdCAgICB0aGlzLl91cGRhdGVDb2xvclZhbHVlID0gYmluZCh0aGlzLl91cGRhdGVDb2xvclZhbHVlLCB0aGlzKTtcblx0ICAgIHRoaXMuX3VwZGF0ZU51bWJlclZhbHVlID0gYmluZCh0aGlzLl91cGRhdGVOdW1iZXJWYWx1ZSwgdGhpcyk7XG5cdCAgICB0aGlzLl91cGRhdGVWYWx1ZXMgPSBiaW5kKHRoaXMuX3VwZGF0ZVZhbHVlcywgdGhpcyk7XG5cdCAgICB0aGlzLl91cGRhdGUgPSBiaW5kKHRoaXMuX3VwZGF0ZSwgdGhpcyk7XG5cdCAgICB0aGlzLl9zdGFydCA9IGJpbmQodGhpcy5fc3RhcnQsIHRoaXMpO1xuXHQgICAgdGhpcy5zdGFydCA9IGJpbmQodGhpcy5zdGFydCwgdGhpcyk7XG5cdCAgICBvcHRpb25zID0gRGVmYXVsdHMuZ2V0RGVmYXVsdHMoXCJBbmltYXRpb25cIiwgb3B0aW9ucyk7XG5cdCAgICBBbmltYXRpb24uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICB0aGlzLm9wdGlvbnMgPSBfLmNsb25lKF8uZGVmYXVsdHMob3B0aW9ucywge1xuXHQgICAgICBsYXllcjogbnVsbCxcblx0ICAgICAgcHJvcGVydGllczoge30sXG5cdCAgICAgIGN1cnZlOiBcImxpbmVhclwiLFxuXHQgICAgICBjdXJ2ZU9wdGlvbnM6IHt9LFxuXHQgICAgICB0aW1lOiAxLFxuXHQgICAgICByZXBlYXQ6IDAsXG5cdCAgICAgIGRlbGF5OiAwLFxuXHQgICAgICBkZWJ1ZzogZmFsc2UsXG5cdCAgICAgIGNvbG9yTW9kZWw6IFwiaHVzbFwiXG5cdCAgICB9KSk7XG5cdCAgICBpZiAob3B0aW9ucy5vcmlnaW4pIHtcblx0ICAgICAgY29uc29sZS53YXJuKFwiQW5pbWF0aW9uLm9yaWdpbjogcGxlYXNlIHVzZSBsYXllci5vcmlnaW5YIGFuZCBsYXllci5vcmlnaW5ZXCIpO1xuXHQgICAgfVxuXHQgICAgdGhpcy5vcHRpb25zLnByb3BlcnRpZXMgPSBBbmltYXRpb24uZmlsdGVyQW5pbWF0YWJsZVByb3BlcnRpZXModGhpcy5vcHRpb25zLnByb3BlcnRpZXMpO1xuXHQgICAgdGhpcy5fcGFyc2VBbmltYXRvck9wdGlvbnMoKTtcblx0ICAgIHRoaXMuX29yaWdpbmFsU3RhdGUgPSB0aGlzLl9jdXJyZW50U3RhdGUoKTtcblx0ICAgIHRoaXMuX3JlcGVhdENvdW50ZXIgPSB0aGlzLm9wdGlvbnMucmVwZWF0O1xuXHQgIH1cblx0XG5cdCAgQW5pbWF0aW9uLmRlZmluZShcImlzQW5pbWF0aW5nXCIsIHtcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiBpbmRleE9mLmNhbGwodGhpcy5vcHRpb25zLmxheWVyLmNvbnRleHQuYW5pbWF0aW9ucywgdGhpcykgPj0gMDtcblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgQW5pbWF0aW9uLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIEFuaW1hdG9yQ2xhc3MsIGFuaW1hdGlvbiwgaywgcHJvcGVydHksIHJlZiwgcmVmMSwgcmVmMiwgdjtcblx0ICAgIGlmICh0aGlzLm9wdGlvbnMubGF5ZXIgPT09IG51bGwpIHtcblx0ICAgICAgY29uc29sZS5lcnJvcihcIkFuaW1hdGlvbjogbWlzc2luZyBsYXllclwiKTtcblx0ICAgIH1cblx0ICAgIEFuaW1hdG9yQ2xhc3MgPSB0aGlzLl9hbmltYXRvckNsYXNzKCk7XG5cdCAgICBpZiAodGhpcy5vcHRpb25zLmRlYnVnKSB7XG5cdCAgICAgIGNvbnNvbGUubG9nKFwiQW5pbWF0aW9uLnN0YXJ0IFwiICsgQW5pbWF0b3JDbGFzcy5uYW1lLCB0aGlzLm9wdGlvbnMuY3VydmVPcHRpb25zKTtcblx0ICAgIH1cblx0ICAgIHRoaXMuX2FuaW1hdG9yID0gbmV3IEFuaW1hdG9yQ2xhc3ModGhpcy5vcHRpb25zLmN1cnZlT3B0aW9ucyk7XG5cdCAgICB0aGlzLl90YXJnZXQgPSB0aGlzLm9wdGlvbnMubGF5ZXI7XG5cdCAgICB0aGlzLl9zdGF0ZUEgPSB0aGlzLl9jdXJyZW50U3RhdGUoKTtcblx0ICAgIHRoaXMuX3N0YXRlQiA9IHt9O1xuXHQgICAgcmVmID0gdGhpcy5vcHRpb25zLnByb3BlcnRpZXM7XG5cdCAgICBmb3IgKGsgaW4gcmVmKSB7XG5cdCAgICAgIHYgPSByZWZba107XG5cdCAgICAgIGlmIChfLmlzRnVuY3Rpb24odikpIHtcblx0ICAgICAgICB2ID0gdih0aGlzLm9wdGlvbnMubGF5ZXIsIGspO1xuXHQgICAgICB9IGVsc2UgaWYgKGlzUmVsYXRpdmVQcm9wZXJ0eSh2KSkge1xuXHQgICAgICAgIHYgPSBldmFsdWF0ZVJlbGF0aXZlUHJvcGVydHkodGhpcy5fdGFyZ2V0LCBrLCB2KTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAodGhpcy5fc3RhdGVBW2tdICE9PSB2KSB7XG5cdCAgICAgICAgdGhpcy5fc3RhdGVCW2tdID0gdjtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKF8ua2V5cyh0aGlzLl9zdGF0ZUEpLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICBjb25zb2xlLndhcm4oXCJBbmltYXRpb246IG5vdGhpbmcgdG8gYW5pbWF0ZSwgbm8gYW5pbWF0YWJsZSBwcm9wZXJ0aWVzXCIpO1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgICBpZiAoXy5pc0VxdWFsKHRoaXMuX3N0YXRlQSwgdGhpcy5fc3RhdGVCKSkge1xuXHQgICAgICBjb25zb2xlLndhcm4oXCJBbmltYXRpb246IG5vdGhpbmcgdG8gYW5pbWF0ZSwgYWxsIHByb3BlcnRpZXMgYXJlIGVxdWFsIHRvIHdoYXQgaXQgaXMgbm93XCIpO1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgICByZWYxID0gdGhpcy5fdGFyZ2V0LmFuaW1hdGluZ1Byb3BlcnRpZXMoKTtcblx0ICAgIGZvciAocHJvcGVydHkgaW4gcmVmMSkge1xuXHQgICAgICBhbmltYXRpb24gPSByZWYxW3Byb3BlcnR5XTtcblx0ICAgICAgaWYgKHRoaXMuX3N0YXRlQS5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcblx0ICAgICAgICBhbmltYXRpb24uc3RvcCgpO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChwcm9wZXJ0eSA9PT0gXCJ4XCIgJiYgKHRoaXMuX3N0YXRlQS5oYXNPd25Qcm9wZXJ0eShcIm1pblhcIikgfHwgdGhpcy5fc3RhdGVBLmhhc093blByb3BlcnR5KFwibWlkWFwiKSB8fCB0aGlzLl9zdGF0ZUEuaGFzT3duUHJvcGVydHkoXCJtYXhYXCIpKSkge1xuXHQgICAgICAgIGFuaW1hdGlvbi5zdG9wKCk7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHByb3BlcnR5ID09PSBcInlcIiAmJiAodGhpcy5fc3RhdGVBLmhhc093blByb3BlcnR5KFwibWluWVwiKSB8fCB0aGlzLl9zdGF0ZUEuaGFzT3duUHJvcGVydHkoXCJtaWRZXCIpIHx8IHRoaXMuX3N0YXRlQS5oYXNPd25Qcm9wZXJ0eShcIm1heFlcIikpKSB7XG5cdCAgICAgICAgYW5pbWF0aW9uLnN0b3AoKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKHRoaXMub3B0aW9ucy5kZWJ1Zykge1xuXHQgICAgICBjb25zb2xlLmxvZyhcIkFuaW1hdGlvbi5zdGFydFwiKTtcblx0ICAgICAgcmVmMiA9IHRoaXMuX3N0YXRlQjtcblx0ICAgICAgZm9yIChrIGluIHJlZjIpIHtcblx0ICAgICAgICB2ID0gcmVmMltrXTtcblx0ICAgICAgICBjb25zb2xlLmxvZyhcIlxcdFwiICsgayArIFwiOiBcIiArIHRoaXMuX3N0YXRlQVtrXSArIFwiIC0+IFwiICsgdGhpcy5fc3RhdGVCW2tdKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKHRoaXMuX3JlcGVhdENvdW50ZXIgPiAwKSB7XG5cdCAgICAgIHRoaXMub25jZShcImVuZFwiLCAoZnVuY3Rpb24oX3RoaXMpIHtcblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICB2YXIgcmVmMztcblx0ICAgICAgICAgIHJlZjMgPSBfdGhpcy5fc3RhdGVBO1xuXHQgICAgICAgICAgZm9yIChrIGluIHJlZjMpIHtcblx0ICAgICAgICAgICAgdiA9IHJlZjNba107XG5cdCAgICAgICAgICAgIF90aGlzLl90YXJnZXRba10gPSB2O1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgX3RoaXMuX3JlcGVhdENvdW50ZXItLTtcblx0ICAgICAgICAgIHJldHVybiBfdGhpcy5zdGFydCgpO1xuXHQgICAgICAgIH07XG5cdCAgICAgIH0pKHRoaXMpKTtcblx0ICAgIH1cblx0ICAgIGlmICh0aGlzLm9wdGlvbnMuZGVsYXkpIHtcblx0ICAgICAgVXRpbHMuZGVsYXkodGhpcy5vcHRpb25zLmRlbGF5LCB0aGlzLl9zdGFydCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aGlzLl9zdGFydCgpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfTtcblx0XG5cdCAgQW5pbWF0aW9uLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oZW1pdCkge1xuXHQgICAgaWYgKGVtaXQgPT0gbnVsbCkge1xuXHQgICAgICBlbWl0ID0gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIHRoaXMub3B0aW9ucy5sYXllci5jb250ZXh0LnJlbW92ZUFuaW1hdGlvbih0aGlzKTtcblx0ICAgIGlmIChlbWl0KSB7XG5cdCAgICAgIHRoaXMuZW1pdChcInN0b3BcIik7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gRnJhbWVyLkxvb3Aub2ZmKFwidXBkYXRlXCIsIHRoaXMuX3VwZGF0ZSk7XG5cdCAgfTtcblx0XG5cdCAgQW5pbWF0aW9uLnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgYW5pbWF0aW9uLCBvcHRpb25zO1xuXHQgICAgb3B0aW9ucyA9IF8uY2xvbmUodGhpcy5vcHRpb25zKTtcblx0ICAgIG9wdGlvbnMucHJvcGVydGllcyA9IHRoaXMuX29yaWdpbmFsU3RhdGU7XG5cdCAgICBhbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKG9wdGlvbnMpO1xuXHQgICAgcmV0dXJuIGFuaW1hdGlvbjtcblx0ICB9O1xuXHRcblx0ICBBbmltYXRpb24ucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbigpIHtcblx0ICAgIHJldHVybiBuZXcgQW5pbWF0aW9uKF8uY2xvbmUodGhpcy5vcHRpb25zKSk7XG5cdCAgfTtcblx0XG5cdCAgQW5pbWF0aW9uLnByb3RvdHlwZS5yZXZlcnQgPSBmdW5jdGlvbigpIHtcblx0ICAgIHJldHVybiB0aGlzLnJldmVyc2UoKTtcblx0ICB9O1xuXHRcblx0ICBBbmltYXRpb24ucHJvdG90eXBlLmludmVyc2UgPSBmdW5jdGlvbigpIHtcblx0ICAgIHJldHVybiB0aGlzLnJldmVyc2UoKTtcblx0ICB9O1xuXHRcblx0ICBBbmltYXRpb24ucHJvdG90eXBlLmludmVydCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpO1xuXHQgIH07XG5cdFxuXHQgIEFuaW1hdGlvbi5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdCAgICBBbmltYXRpb24uX19zdXBlcl9fLmVtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgIHJldHVybiB0aGlzLm9wdGlvbnMubGF5ZXIuZW1pdChldmVudCwgdGhpcyk7XG5cdCAgfTtcblx0XG5cdCAgQW5pbWF0aW9uLnByb3RvdHlwZS5hbmltYXRpbmdQcm9wZXJ0aWVzID0gZnVuY3Rpb24oKSB7XG5cdCAgICByZXR1cm4gXy5rZXlzKHRoaXMuX3N0YXRlQSk7XG5cdCAgfTtcblx0XG5cdCAgQW5pbWF0aW9uLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciBrLCByZWYsIHJlc3VsdHMsIHY7XG5cdCAgICB0aGlzLm9wdGlvbnMubGF5ZXIuY29udGV4dC5hZGRBbmltYXRpb24odGhpcyk7XG5cdCAgICB0aGlzLmVtaXQoXCJzdGFydFwiKTtcblx0ICAgIEZyYW1lci5Mb29wLm9uKFwidXBkYXRlXCIsIHRoaXMuX3VwZGF0ZSk7XG5cdCAgICB0aGlzLl92YWx1ZVVwZGF0ZXJzID0ge307XG5cdCAgICByZWYgPSB0aGlzLl9zdGF0ZUI7XG5cdCAgICByZXN1bHRzID0gW107XG5cdCAgICBmb3IgKGsgaW4gcmVmKSB7XG5cdCAgICAgIHYgPSByZWZba107XG5cdCAgICAgIGlmIChDb2xvci5pc0NvbG9yT2JqZWN0KHYpIHx8IENvbG9yLmlzQ29sb3JPYmplY3QodGhpcy5fc3RhdGVBW2tdKSkge1xuXHQgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLl92YWx1ZVVwZGF0ZXJzW2tdID0gdGhpcy5fdXBkYXRlQ29sb3JWYWx1ZSk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMuX3ZhbHVlVXBkYXRlcnNba10gPSB0aGlzLl91cGRhdGVOdW1iZXJWYWx1ZSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiByZXN1bHRzO1xuXHQgIH07XG5cdFxuXHQgIEFuaW1hdGlvbi5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uKGRlbHRhKSB7XG5cdCAgICB2YXIgZW1pdDtcblx0ICAgIGlmICh0aGlzLl9hbmltYXRvci5maW5pc2hlZCgpKSB7XG5cdCAgICAgIHRoaXMuX3VwZGF0ZVZhbHVlcygxKTtcblx0ICAgICAgdGhpcy5zdG9wKGVtaXQgPSBmYWxzZSk7XG5cdCAgICAgIHRoaXMuZW1pdChcImVuZFwiKTtcblx0ICAgICAgcmV0dXJuIHRoaXMuZW1pdChcInN0b3BcIik7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gdGhpcy5fdXBkYXRlVmFsdWVzKHRoaXMuX2FuaW1hdG9yLm5leHQoZGVsdGEpKTtcblx0ICAgIH1cblx0ICB9O1xuXHRcblx0ICBBbmltYXRpb24ucHJvdG90eXBlLl91cGRhdGVWYWx1ZXMgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgdmFyIGssIHJlZiwgdjtcblx0ICAgIHJlZiA9IHRoaXMuX3N0YXRlQjtcblx0ICAgIGZvciAoayBpbiByZWYpIHtcblx0ICAgICAgdiA9IHJlZltrXTtcblx0ICAgICAgdGhpcy5fdmFsdWVVcGRhdGVyc1trXShrLCB2YWx1ZSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbnVsbDtcblx0ICB9O1xuXHRcblx0ICBBbmltYXRpb24ucHJvdG90eXBlLl91cGRhdGVOdW1iZXJWYWx1ZSA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcblx0ICAgIHJldHVybiB0aGlzLl90YXJnZXRba2V5XSA9IFV0aWxzLm1hcFJhbmdlKHZhbHVlLCAwLCAxLCB0aGlzLl9zdGF0ZUFba2V5XSwgdGhpcy5fc3RhdGVCW2tleV0pO1xuXHQgIH07XG5cdFxuXHQgIEFuaW1hdGlvbi5wcm90b3R5cGUuX3VwZGF0ZUNvbG9yVmFsdWUgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fdGFyZ2V0W2tleV0gPSBDb2xvci5taXgodGhpcy5fc3RhdGVBW2tleV0sIHRoaXMuX3N0YXRlQltrZXldLCB2YWx1ZSwgZmFsc2UsIHRoaXMub3B0aW9ucy5jb2xvck1vZGVsKTtcblx0ICB9O1xuXHRcblx0ICBBbmltYXRpb24ucHJvdG90eXBlLl9jdXJyZW50U3RhdGUgPSBmdW5jdGlvbigpIHtcblx0ICAgIHJldHVybiBfLnBpY2sodGhpcy5vcHRpb25zLmxheWVyLCBfLmtleXModGhpcy5vcHRpb25zLnByb3BlcnRpZXMpKTtcblx0ICB9O1xuXHRcblx0ICBBbmltYXRpb24ucHJvdG90eXBlLl9hbmltYXRvckNsYXNzID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgYW5pbWF0b3JDbGFzc05hbWUsIHBhcnNlZEN1cnZlO1xuXHQgICAgcGFyc2VkQ3VydmUgPSBVdGlscy5wYXJzZUZ1bmN0aW9uKHRoaXMub3B0aW9ucy5jdXJ2ZSk7XG5cdCAgICBhbmltYXRvckNsYXNzTmFtZSA9IHBhcnNlZEN1cnZlLm5hbWUudG9Mb3dlckNhc2UoKTtcblx0ICAgIGlmIChBbmltYXRvckNsYXNzZXMuaGFzT3duUHJvcGVydHkoYW5pbWF0b3JDbGFzc05hbWUpKSB7XG5cdCAgICAgIHJldHVybiBBbmltYXRvckNsYXNzZXNbYW5pbWF0b3JDbGFzc05hbWVdO1xuXHQgICAgfVxuXHQgICAgaWYgKGluZGV4T2YuY2FsbChBbmltYXRvckNsYXNzQmV6aWVyUHJlc2V0cywgYW5pbWF0b3JDbGFzc05hbWUpID49IDApIHtcblx0ICAgICAgcmV0dXJuIEJlemllckN1cnZlQW5pbWF0b3I7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gTGluZWFyQW5pbWF0b3I7XG5cdCAgfTtcblx0XG5cdCAgQW5pbWF0aW9uLnByb3RvdHlwZS5fcGFyc2VBbmltYXRvck9wdGlvbnMgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciBhbmltYXRvckNsYXNzLCBhbmltYXRvckNsYXNzTmFtZSwgYmFzZSwgYmFzZTEsIGksIGosIGssIGwsIGxlbiwgbGVuMSwgcGFyc2VkQ3VydmUsIHJlZiwgcmVmMSwgcmVzdWx0cywgdmFsdWU7XG5cdCAgICBhbmltYXRvckNsYXNzID0gdGhpcy5fYW5pbWF0b3JDbGFzcygpO1xuXHQgICAgcGFyc2VkQ3VydmUgPSBVdGlscy5wYXJzZUZ1bmN0aW9uKHRoaXMub3B0aW9ucy5jdXJ2ZSk7XG5cdCAgICBhbmltYXRvckNsYXNzTmFtZSA9IHBhcnNlZEN1cnZlLm5hbWUudG9Mb3dlckNhc2UoKTtcblx0ICAgIGlmIChhbmltYXRvckNsYXNzID09PSBMaW5lYXJBbmltYXRvciB8fCBhbmltYXRvckNsYXNzID09PSBCZXppZXJDdXJ2ZUFuaW1hdG9yKSB7XG5cdCAgICAgIGlmIChfLmlzU3RyaW5nKHRoaXMub3B0aW9ucy5jdXJ2ZU9wdGlvbnMpIHx8IF8uaXNBcnJheSh0aGlzLm9wdGlvbnMuY3VydmVPcHRpb25zKSkge1xuXHQgICAgICAgIHRoaXMub3B0aW9ucy5jdXJ2ZU9wdGlvbnMgPSB7XG5cdCAgICAgICAgICB2YWx1ZXM6IHRoaXMub3B0aW9ucy5jdXJ2ZU9wdGlvbnNcblx0ICAgICAgICB9O1xuXHQgICAgICB9XG5cdCAgICAgIGlmICgoYmFzZSA9IHRoaXMub3B0aW9ucy5jdXJ2ZU9wdGlvbnMpLnRpbWUgPT0gbnVsbCkge1xuXHQgICAgICAgIGJhc2UudGltZSA9IHRoaXMub3B0aW9ucy50aW1lO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICBpZiAoKGFuaW1hdG9yQ2xhc3MgPT09IEJlemllckN1cnZlQW5pbWF0b3IpICYmIGluZGV4T2YuY2FsbChBbmltYXRvckNsYXNzQmV6aWVyUHJlc2V0cywgYW5pbWF0b3JDbGFzc05hbWUpID49IDApIHtcblx0ICAgICAgdGhpcy5vcHRpb25zLmN1cnZlT3B0aW9ucy52YWx1ZXMgPSBhbmltYXRvckNsYXNzTmFtZTtcblx0ICAgICAgaWYgKChiYXNlMSA9IHRoaXMub3B0aW9ucy5jdXJ2ZU9wdGlvbnMpLnRpbWUgPT0gbnVsbCkge1xuXHQgICAgICAgIGJhc2UxLnRpbWUgPSB0aGlzLm9wdGlvbnMudGltZTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKHBhcnNlZEN1cnZlLmFyZ3MubGVuZ3RoKSB7XG5cdCAgICAgIGlmIChhbmltYXRvckNsYXNzID09PSBCZXppZXJDdXJ2ZUFuaW1hdG9yKSB7XG5cdCAgICAgICAgdGhpcy5vcHRpb25zLmN1cnZlT3B0aW9ucy52YWx1ZXMgPSBwYXJzZWRDdXJ2ZS5hcmdzLm1hcChmdW5jdGlvbih2KSB7XG5cdCAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2KSB8fCAwO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChhbmltYXRvckNsYXNzID09PSBTcHJpbmdSSzRBbmltYXRvcikge1xuXHQgICAgICAgIHJlZiA9IFtcInRlbnNpb25cIiwgXCJmcmljdGlvblwiLCBcInZlbG9jaXR5XCIsIFwidG9sZXJhbmNlXCJdO1xuXHQgICAgICAgIGZvciAoaSA9IGogPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBqIDwgbGVuOyBpID0gKytqKSB7XG5cdCAgICAgICAgICBrID0gcmVmW2ldO1xuXHQgICAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHBhcnNlZEN1cnZlLmFyZ3NbaV0pO1xuXHQgICAgICAgICAgaWYgKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIHRoaXMub3B0aW9ucy5jdXJ2ZU9wdGlvbnNba10gPSB2YWx1ZTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKGFuaW1hdG9yQ2xhc3MgPT09IFNwcmluZ0RIT0FuaW1hdG9yKSB7XG5cdCAgICAgICAgcmVmMSA9IFtcInN0aWZmbmVzc1wiLCBcImRhbXBpbmdcIiwgXCJtYXNzXCIsIFwidG9sZXJhbmNlXCJdO1xuXHQgICAgICAgIHJlc3VsdHMgPSBbXTtcblx0ICAgICAgICBmb3IgKGkgPSBsID0gMCwgbGVuMSA9IHJlZjEubGVuZ3RoOyBsIDwgbGVuMTsgaSA9ICsrbCkge1xuXHQgICAgICAgICAgayA9IHJlZjFbaV07XG5cdCAgICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQocGFyc2VkQ3VydmUuYXJnc1tpXSk7XG5cdCAgICAgICAgICBpZiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMub3B0aW9ucy5jdXJ2ZU9wdGlvbnNba10gPSB2YWx1ZSk7XG5cdCAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXN1bHRzLnB1c2godm9pZCAwKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXHRcblx0ICBBbmltYXRpb24uZmlsdGVyQW5pbWF0YWJsZVByb3BlcnRpZXMgPSBmdW5jdGlvbihwcm9wZXJ0aWVzKSB7XG5cdCAgICB2YXIgYW5pbWF0YWJsZVByb3BlcnRpZXMsIGssIHY7XG5cdCAgICBhbmltYXRhYmxlUHJvcGVydGllcyA9IHt9O1xuXHQgICAgZm9yIChrIGluIHByb3BlcnRpZXMpIHtcblx0ICAgICAgdiA9IHByb3BlcnRpZXNba107XG5cdCAgICAgIGlmIChfLmlzTnVtYmVyKHYpIHx8IF8uaXNGdW5jdGlvbih2KSB8fCBpc1JlbGF0aXZlUHJvcGVydHkodikgfHwgQ29sb3IuaXNDb2xvck9iamVjdCh2KSB8fCB2ID09PSBudWxsKSB7XG5cdCAgICAgICAgYW5pbWF0YWJsZVByb3BlcnRpZXNba10gPSB2O1xuXHQgICAgICB9IGVsc2UgaWYgKF8uaXNTdHJpbmcodikpIHtcblx0ICAgICAgICBpZiAoQ29sb3IuaXNDb2xvclN0cmluZyh2KSkge1xuXHQgICAgICAgICAgYW5pbWF0YWJsZVByb3BlcnRpZXNba10gPSBuZXcgQ29sb3Iodik7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gYW5pbWF0YWJsZVByb3BlcnRpZXM7XG5cdCAgfTtcblx0XG5cdCAgQW5pbWF0aW9uLnByb3RvdHlwZS50b0luc3BlY3QgPSBmdW5jdGlvbigpIHtcblx0ICAgIHJldHVybiBcIjxcIiArIHRoaXMuY29uc3RydWN0b3IubmFtZSArIFwiIGlkOlwiICsgdGhpcy5pZCArIFwiIGlzQW5pbWF0aW5nOlwiICsgdGhpcy5pc0FuaW1hdGluZyArIFwiIFtcIiArIChfLmtleXModGhpcy5vcHRpb25zLnByb3BlcnRpZXMpKSArIFwiXT5cIjtcblx0ICB9O1xuXHRcblx0ICBBbmltYXRpb24ucHJvdG90eXBlLm9uQW5pbWF0aW9uU3RhcnQgPSBmdW5jdGlvbihjYikge1xuXHQgICAgcmV0dXJuIHRoaXMub24oRXZlbnRzLkFuaW1hdGlvblN0YXJ0LCBjYik7XG5cdCAgfTtcblx0XG5cdCAgQW5pbWF0aW9uLnByb3RvdHlwZS5vbkFuaW1hdGlvblN0b3AgPSBmdW5jdGlvbihjYikge1xuXHQgICAgcmV0dXJuIHRoaXMub24oRXZlbnRzLkFuaW1hdGlvblN0b3AsIGNiKTtcblx0ICB9O1xuXHRcblx0ICBBbmltYXRpb24ucHJvdG90eXBlLm9uQW5pbWF0aW9uRW5kID0gZnVuY3Rpb24oY2IpIHtcblx0ICAgIHJldHVybiB0aGlzLm9uKEV2ZW50cy5BbmltYXRpb25FbmQsIGNiKTtcblx0ICB9O1xuXHRcblx0ICBBbmltYXRpb24ucHJvdG90eXBlLm9uQW5pbWF0aW9uRGlkU3RhcnQgPSBmdW5jdGlvbihjYikge1xuXHQgICAgcmV0dXJuIHRoaXMub24oRXZlbnRzLkFuaW1hdGlvbkRpZFN0YXJ0LCBjYik7XG5cdCAgfTtcblx0XG5cdCAgQW5pbWF0aW9uLnByb3RvdHlwZS5vbkFuaW1hdGlvbkRpZFN0b3AgPSBmdW5jdGlvbihjYikge1xuXHQgICAgcmV0dXJuIHRoaXMub24oRXZlbnRzLkFuaW1hdGlvbkRpZFN0b3AsIGNiKTtcblx0ICB9O1xuXHRcblx0ICBBbmltYXRpb24ucHJvdG90eXBlLm9uQW5pbWF0aW9uRGlkRW5kID0gZnVuY3Rpb24oY2IpIHtcblx0ICAgIHJldHVybiB0aGlzLm9uKEV2ZW50cy5BbmltYXRpb25EaWRFbmQsIGNiKTtcblx0ICB9O1xuXHRcblx0ICByZXR1cm4gQW5pbWF0aW9uO1xuXHRcblx0fSkoQmFzZUNsYXNzKTtcblxuXG4vKioqLyB9LFxuLyogMTkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBBbmltYXRvciwgVXRpbHMsXG5cdCAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuXHQgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblx0XG5cdFV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0XG5cdEFuaW1hdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCkuQW5pbWF0b3I7XG5cdFxuXHRleHBvcnRzLkxpbmVhckFuaW1hdG9yID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcblx0ICBleHRlbmQoTGluZWFyQW5pbWF0b3IsIHN1cGVyQ2xhc3MpO1xuXHRcblx0ICBmdW5jdGlvbiBMaW5lYXJBbmltYXRvcigpIHtcblx0ICAgIHJldHVybiBMaW5lYXJBbmltYXRvci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICB9XG5cdFxuXHQgIExpbmVhckFuaW1hdG9yLnByb3RvdHlwZS5zZXR1cCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0ICAgIHRoaXMub3B0aW9ucyA9IF8uZGVmYXVsdHMob3B0aW9ucywge1xuXHQgICAgICB0aW1lOiAxLFxuXHQgICAgICBwcmVjaXNpb246IDEgLyAxMDAwXG5cdCAgICB9KTtcblx0ICAgIHJldHVybiB0aGlzLl90aW1lID0gMDtcblx0ICB9O1xuXHRcblx0ICBMaW5lYXJBbmltYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKGRlbHRhKSB7XG5cdCAgICB0aGlzLl90aW1lICs9IGRlbHRhO1xuXHQgICAgaWYgKHRoaXMuZmluaXNoZWQoKSkge1xuXHQgICAgICByZXR1cm4gMTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0aGlzLl90aW1lIC8gdGhpcy5vcHRpb25zLnRpbWU7XG5cdCAgfTtcblx0XG5cdCAgTGluZWFyQW5pbWF0b3IucHJvdG90eXBlLmZpbmlzaGVkID0gZnVuY3Rpb24oKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fdGltZSA+PSB0aGlzLm9wdGlvbnMudGltZSAtIHRoaXMub3B0aW9ucy5wcmVjaXNpb247XG5cdCAgfTtcblx0XG5cdCAgcmV0dXJuIExpbmVhckFuaW1hdG9yO1xuXHRcblx0fSkoQW5pbWF0b3IpO1xuXG5cbi8qKiovIH0sXG4vKiAyMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIENvbmZpZywgVXRpbHM7XG5cdFxuXHRVdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdFxuXHRDb25maWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KS5Db25maWc7XG5cdFxuXHRleHBvcnRzLkFuaW1hdG9yID0gKGZ1bmN0aW9uKCkge1xuXHQgIFwiVGhlIGFuaW1hdG9yIGNsYXNzIGlzIGEgdmVyeSBzaW1wbGUgY2xhc3MgdGhhdFxcblx0LSBUYWtlcyBhIHNldCBvZiBpbnB1dCB2YWx1ZXMgYXQgc2V0dXAoe2lucHV0IHZhbHVlc30pXFxuXHQtIEVtaXRzIGFuIG91dHB1dCB2YWx1ZSBmb3IgcHJvZ3Jlc3MgKDAgLT4gMSkgaW4gdmFsdWUocHJvZ3Jlc3MpXCI7XG5cdCAgZnVuY3Rpb24gQW5pbWF0b3Iob3B0aW9ucykge1xuXHQgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuXHQgICAgICBvcHRpb25zID0ge307XG5cdCAgICB9XG5cdCAgICB0aGlzLnNldHVwKG9wdGlvbnMpO1xuXHQgIH1cblx0XG5cdCAgQW5pbWF0b3IucHJvdG90eXBlLnNldHVwID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHQgICAgdGhyb3cgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG5cdCAgfTtcblx0XG5cdCAgQW5pbWF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbihkZWx0YSkge1xuXHQgICAgdGhyb3cgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG5cdCAgfTtcblx0XG5cdCAgQW5pbWF0b3IucHJvdG90eXBlLmZpbmlzaGVkID0gZnVuY3Rpb24oKSB7XG5cdCAgICB0aHJvdyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcblx0ICB9O1xuXHRcblx0ICByZXR1cm4gQW5pbWF0b3I7XG5cblx0fSkoKTtcblxuXG4vKioqLyB9LFxuLyogMjEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBBbmltYXRvciwgQmV6aWVyQ3VydmVEZWZhdWx0cywgVW5pdEJlemllciwgVXRpbHMsIF8sXG5cdCAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuXHQgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblx0XG5cdF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpLl87XG5cdFxuXHRVdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdFxuXHRBbmltYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oMjApLkFuaW1hdG9yO1xuXHRcblx0QmV6aWVyQ3VydmVEZWZhdWx0cyA9IHtcblx0ICBcImxpbmVhclwiOiBbMCwgMCwgMSwgMV0sXG5cdCAgXCJlYXNlXCI6IFsuMjUsIC4xLCAuMjUsIDFdLFxuXHQgIFwiZWFzZS1pblwiOiBbLjQyLCAwLCAxLCAxXSxcblx0ICBcImVhc2Utb3V0XCI6IFswLCAwLCAuNTgsIDFdLFxuXHQgIFwiZWFzZS1pbi1vdXRcIjogWy40MiwgMCwgLjU4LCAxXVxuXHR9O1xuXHRcblx0ZXhwb3J0cy5CZXppZXJDdXJ2ZUFuaW1hdG9yID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcblx0ICBleHRlbmQoQmV6aWVyQ3VydmVBbmltYXRvciwgc3VwZXJDbGFzcyk7XG5cdFxuXHQgIGZ1bmN0aW9uIEJlemllckN1cnZlQW5pbWF0b3IoKSB7XG5cdCAgICByZXR1cm4gQmV6aWVyQ3VydmVBbmltYXRvci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICB9XG5cdFxuXHQgIEJlemllckN1cnZlQW5pbWF0b3IucHJvdG90eXBlLnNldHVwID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHQgICAgaWYgKF8uaXNTdHJpbmcob3B0aW9ucykgJiYgQmV6aWVyQ3VydmVEZWZhdWx0cy5oYXNPd25Qcm9wZXJ0eShvcHRpb25zLnRvTG93ZXJDYXNlKCkpKSB7XG5cdCAgICAgIG9wdGlvbnMgPSB7XG5cdCAgICAgICAgdmFsdWVzOiBCZXppZXJDdXJ2ZURlZmF1bHRzW29wdGlvbnMudG9Mb3dlckNhc2UoKV1cblx0ICAgICAgfTtcblx0ICAgIH1cblx0ICAgIGlmIChvcHRpb25zLnZhbHVlcyAmJiBfLmlzU3RyaW5nKG9wdGlvbnMudmFsdWVzKSAmJiBCZXppZXJDdXJ2ZURlZmF1bHRzLmhhc093blByb3BlcnR5KG9wdGlvbnMudmFsdWVzLnRvTG93ZXJDYXNlKCkpKSB7XG5cdCAgICAgIG9wdGlvbnMgPSB7XG5cdCAgICAgICAgdmFsdWVzOiBCZXppZXJDdXJ2ZURlZmF1bHRzW29wdGlvbnMudmFsdWVzLnRvTG93ZXJDYXNlKCldLFxuXHQgICAgICAgIHRpbWU6IG9wdGlvbnMudGltZVxuXHQgICAgICB9O1xuXHQgICAgfVxuXHQgICAgaWYgKF8uaXNBcnJheShvcHRpb25zKSAmJiBvcHRpb25zLmxlbmd0aCA9PT0gNCkge1xuXHQgICAgICBvcHRpb25zID0ge1xuXHQgICAgICAgIHZhbHVlczogb3B0aW9uc1xuXHQgICAgICB9O1xuXHQgICAgfVxuXHQgICAgdGhpcy5vcHRpb25zID0gXy5kZWZhdWx0cyhvcHRpb25zLCB7XG5cdCAgICAgIHZhbHVlczogQmV6aWVyQ3VydmVEZWZhdWx0c1tcImVhc2UtaW4tb3V0XCJdLFxuXHQgICAgICB0aW1lOiAxLFxuXHQgICAgICBwcmVjaXNpb246IDEgLyAxMDAwXG5cdCAgICB9KTtcblx0ICAgIHJldHVybiB0aGlzLl91bml0QmV6aWVyID0gbmV3IFVuaXRCZXppZXIodGhpcy5vcHRpb25zLnZhbHVlc1swXSwgdGhpcy5vcHRpb25zLnZhbHVlc1sxXSwgdGhpcy5vcHRpb25zLnZhbHVlc1syXSwgdGhpcy5vcHRpb25zLnZhbHVlc1szXSwgdGhpcy5fdGltZSA9IDApO1xuXHQgIH07XG5cdFxuXHQgIEJlemllckN1cnZlQW5pbWF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbihkZWx0YSkge1xuXHQgICAgdGhpcy5fdGltZSArPSBkZWx0YTtcblx0ICAgIGlmICh0aGlzLmZpbmlzaGVkKCkpIHtcblx0ICAgICAgcmV0dXJuIDE7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcy5fdW5pdEJlemllci5zb2x2ZSh0aGlzLl90aW1lIC8gdGhpcy5vcHRpb25zLnRpbWUpO1xuXHQgIH07XG5cdFxuXHQgIEJlemllckN1cnZlQW5pbWF0b3IucHJvdG90eXBlLmZpbmlzaGVkID0gZnVuY3Rpb24oKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fdGltZSA+PSB0aGlzLm9wdGlvbnMudGltZSAtIHRoaXMub3B0aW9ucy5wcmVjaXNpb247XG5cdCAgfTtcblx0XG5cdCAgcmV0dXJuIEJlemllckN1cnZlQW5pbWF0b3I7XG5cdFxuXHR9KShBbmltYXRvcik7XG5cdFxuXHRVbml0QmV6aWVyID0gKGZ1bmN0aW9uKCkge1xuXHQgIFVuaXRCZXppZXIucHJvdG90eXBlLmVwc2lsb24gPSAxZS02O1xuXHRcblx0ICBmdW5jdGlvbiBVbml0QmV6aWVyKHAxeCwgcDF5LCBwMngsIHAyeSkge1xuXHQgICAgdGhpcy5jeCA9IDMuMCAqIHAxeDtcblx0ICAgIHRoaXMuYnggPSAzLjAgKiAocDJ4IC0gcDF4KSAtIHRoaXMuY3g7XG5cdCAgICB0aGlzLmF4ID0gMS4wIC0gdGhpcy5jeCAtIHRoaXMuYng7XG5cdCAgICB0aGlzLmN5ID0gMy4wICogcDF5O1xuXHQgICAgdGhpcy5ieSA9IDMuMCAqIChwMnkgLSBwMXkpIC0gdGhpcy5jeTtcblx0ICAgIHRoaXMuYXkgPSAxLjAgLSB0aGlzLmN5IC0gdGhpcy5ieTtcblx0ICB9XG5cdFxuXHQgIFVuaXRCZXppZXIucHJvdG90eXBlLnNhbXBsZUN1cnZlWCA9IGZ1bmN0aW9uKHQpIHtcblx0ICAgIHJldHVybiAoKHRoaXMuYXggKiB0ICsgdGhpcy5ieCkgKiB0ICsgdGhpcy5jeCkgKiB0O1xuXHQgIH07XG5cdFxuXHQgIFVuaXRCZXppZXIucHJvdG90eXBlLnNhbXBsZUN1cnZlWSA9IGZ1bmN0aW9uKHQpIHtcblx0ICAgIHJldHVybiAoKHRoaXMuYXkgKiB0ICsgdGhpcy5ieSkgKiB0ICsgdGhpcy5jeSkgKiB0O1xuXHQgIH07XG5cdFxuXHQgIFVuaXRCZXppZXIucHJvdG90eXBlLnNhbXBsZUN1cnZlRGVyaXZhdGl2ZVggPSBmdW5jdGlvbih0KSB7XG5cdCAgICByZXR1cm4gKDMuMCAqIHRoaXMuYXggKiB0ICsgMi4wICogdGhpcy5ieCkgKiB0ICsgdGhpcy5jeDtcblx0ICB9O1xuXHRcblx0ICBVbml0QmV6aWVyLnByb3RvdHlwZS5zb2x2ZUN1cnZlWCA9IGZ1bmN0aW9uKHgpIHtcblx0ICAgIHZhciBkMiwgaSwgdDAsIHQxLCB0MiwgeDI7XG5cdCAgICB0MiA9IHg7XG5cdCAgICBpID0gMDtcblx0ICAgIHdoaWxlIChpIDwgOCkge1xuXHQgICAgICB4MiA9IHRoaXMuc2FtcGxlQ3VydmVYKHQyKSAtIHg7XG5cdCAgICAgIGlmIChNYXRoLmFicyh4MikgPCB0aGlzLmVwc2lsb24pIHtcblx0ICAgICAgICByZXR1cm4gdDI7XG5cdCAgICAgIH1cblx0ICAgICAgZDIgPSB0aGlzLnNhbXBsZUN1cnZlRGVyaXZhdGl2ZVgodDIpO1xuXHQgICAgICBpZiAoTWF0aC5hYnMoZDIpIDwgdGhpcy5lcHNpbG9uKSB7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIH1cblx0ICAgICAgdDIgPSB0MiAtIHgyIC8gZDI7XG5cdCAgICAgIGkrKztcblx0ICAgIH1cblx0ICAgIHQwID0gMC4wO1xuXHQgICAgdDEgPSAxLjA7XG5cdCAgICB0MiA9IHg7XG5cdCAgICBpZiAodDIgPCB0MCkge1xuXHQgICAgICByZXR1cm4gdDA7XG5cdCAgICB9XG5cdCAgICBpZiAodDIgPiB0MSkge1xuXHQgICAgICByZXR1cm4gdDE7XG5cdCAgICB9XG5cdCAgICB3aGlsZSAodDAgPCB0MSkge1xuXHQgICAgICB4MiA9IHRoaXMuc2FtcGxlQ3VydmVYKHQyKTtcblx0ICAgICAgaWYgKE1hdGguYWJzKHgyIC0geCkgPCB0aGlzLmVwc2lsb24pIHtcblx0ICAgICAgICByZXR1cm4gdDI7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHggPiB4Mikge1xuXHQgICAgICAgIHQwID0gdDI7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdDEgPSB0Mjtcblx0ICAgICAgfVxuXHQgICAgICB0MiA9ICh0MSAtIHQwKSAqIC41ICsgdDA7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdDI7XG5cdCAgfTtcblx0XG5cdCAgVW5pdEJlemllci5wcm90b3R5cGUuc29sdmUgPSBmdW5jdGlvbih4KSB7XG5cdCAgICByZXR1cm4gdGhpcy5zYW1wbGVDdXJ2ZVkodGhpcy5zb2x2ZUN1cnZlWCh4KSk7XG5cdCAgfTtcblx0XG5cdCAgcmV0dXJuIFVuaXRCZXppZXI7XG5cblx0fSkoKTtcblxuXG4vKioqLyB9LFxuLyogMjIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBBbmltYXRvciwgSW50ZWdyYXRvciwgVXRpbHMsXG5cdCAgYmluZCA9IGZ1bmN0aW9uKGZuLCBtZSl7IHJldHVybiBmdW5jdGlvbigpeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH0sXG5cdCAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuXHQgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblx0XG5cdFV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0XG5cdEFuaW1hdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCkuQW5pbWF0b3I7XG5cdFxuXHRJbnRlZ3JhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMykuSW50ZWdyYXRvcjtcblx0XG5cdGV4cG9ydHMuU3ByaW5nUks0QW5pbWF0b3IgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuXHQgIGV4dGVuZChTcHJpbmdSSzRBbmltYXRvciwgc3VwZXJDbGFzcyk7XG5cdFxuXHQgIGZ1bmN0aW9uIFNwcmluZ1JLNEFuaW1hdG9yKCkge1xuXHQgICAgdGhpcy5maW5pc2hlZCA9IGJpbmQodGhpcy5maW5pc2hlZCwgdGhpcyk7XG5cdCAgICByZXR1cm4gU3ByaW5nUks0QW5pbWF0b3IuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgfVxuXHRcblx0ICBTcHJpbmdSSzRBbmltYXRvci5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cdCAgICB0aGlzLm9wdGlvbnMgPSBfLmRlZmF1bHRzKG9wdGlvbnMsIHtcblx0ICAgICAgdGVuc2lvbjogMjUwLFxuXHQgICAgICBmcmljdGlvbjogMjUsXG5cdCAgICAgIHZlbG9jaXR5OiAwLFxuXHQgICAgICB0b2xlcmFuY2U6IDEgLyAxMDAwMCxcblx0ICAgICAgdGltZTogbnVsbFxuXHQgICAgfSk7XG5cdCAgICB0aGlzLl90aW1lID0gMDtcblx0ICAgIHRoaXMuX3ZhbHVlID0gMDtcblx0ICAgIHRoaXMuX3ZlbG9jaXR5ID0gdGhpcy5vcHRpb25zLnZlbG9jaXR5O1xuXHQgICAgdGhpcy5fc3RvcFNwcmluZyA9IGZhbHNlO1xuXHQgICAgcmV0dXJuIHRoaXMuX2ludGVncmF0b3IgPSBuZXcgSW50ZWdyYXRvcigoZnVuY3Rpb24oX3RoaXMpIHtcblx0ICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0YXRlKSB7XG5cdCAgICAgICAgcmV0dXJuIC1fdGhpcy5vcHRpb25zLnRlbnNpb24gKiBzdGF0ZS54IC0gX3RoaXMub3B0aW9ucy5mcmljdGlvbiAqIHN0YXRlLnY7XG5cdCAgICAgIH07XG5cdCAgICB9KSh0aGlzKSk7XG5cdCAgfTtcblx0XG5cdCAgU3ByaW5nUks0QW5pbWF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbihkZWx0YSkge1xuXHQgICAgdmFyIGZpbmFsVmVsb2NpdHksIG5ldDFEVmVsb2NpdHksIG5ldEZsb2F0LCBuZXRWYWx1ZUlzTG93LCBuZXRWZWxvY2l0eUlzTG93LCBzdGF0ZUFmdGVyLCBzdGF0ZUJlZm9yZTtcblx0ICAgIGlmICh0aGlzLmZpbmlzaGVkKCkpIHtcblx0ICAgICAgcmV0dXJuIDE7XG5cdCAgICB9XG5cdCAgICB0aGlzLl90aW1lICs9IGRlbHRhO1xuXHQgICAgc3RhdGVCZWZvcmUgPSB7fTtcblx0ICAgIHN0YXRlQWZ0ZXIgPSB7fTtcblx0ICAgIHN0YXRlQmVmb3JlLnggPSB0aGlzLl92YWx1ZSAtIDE7XG5cdCAgICBzdGF0ZUJlZm9yZS52ID0gdGhpcy5fdmVsb2NpdHk7XG5cdCAgICBzdGF0ZUFmdGVyID0gdGhpcy5faW50ZWdyYXRvci5pbnRlZ3JhdGVTdGF0ZShzdGF0ZUJlZm9yZSwgZGVsdGEpO1xuXHQgICAgdGhpcy5fdmFsdWUgPSAxICsgc3RhdGVBZnRlci54O1xuXHQgICAgZmluYWxWZWxvY2l0eSA9IHN0YXRlQWZ0ZXIudjtcblx0ICAgIG5ldEZsb2F0ID0gc3RhdGVBZnRlci54O1xuXHQgICAgbmV0MURWZWxvY2l0eSA9IHN0YXRlQWZ0ZXIudjtcblx0ICAgIG5ldFZhbHVlSXNMb3cgPSBNYXRoLmFicyhuZXRGbG9hdCkgPCB0aGlzLm9wdGlvbnMudG9sZXJhbmNlO1xuXHQgICAgbmV0VmVsb2NpdHlJc0xvdyA9IE1hdGguYWJzKG5ldDFEVmVsb2NpdHkpIDwgdGhpcy5vcHRpb25zLnRvbGVyYW5jZTtcblx0ICAgIHRoaXMuX3N0b3BTcHJpbmcgPSBuZXRWYWx1ZUlzTG93ICYmIG5ldFZlbG9jaXR5SXNMb3c7XG5cdCAgICB0aGlzLl92ZWxvY2l0eSA9IGZpbmFsVmVsb2NpdHk7XG5cdCAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG5cdCAgfTtcblx0XG5cdCAgU3ByaW5nUks0QW5pbWF0b3IucHJvdG90eXBlLmZpbmlzaGVkID0gZnVuY3Rpb24oKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fc3RvcFNwcmluZztcblx0ICB9O1xuXHRcblx0ICByZXR1cm4gU3ByaW5nUks0QW5pbWF0b3I7XG5cdFxuXHR9KShBbmltYXRvcik7XG5cblxuLyoqKi8gfSxcbi8qIDIzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgQ29uZmlnLCBVdGlscztcblx0XG5cdFV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0XG5cdENvbmZpZyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpLkNvbmZpZztcblx0XG5cdGV4cG9ydHMuSW50ZWdyYXRvciA9IChmdW5jdGlvbigpIHtcblx0ICBcIlVzYWdlOlxcblx0LSBJbnN0YW50aWF0ZSB3aXRoIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyAoc3RhdGUpIC0+IGFjY2VsZXJhdGlvblxcblx0LSBDYWxsIGludGVncmF0ZVN0YXRlIHdpdGggc3RhdGU9e3gsIHZ9IGFuZCBkZWx0YVwiO1xuXHQgIGZ1bmN0aW9uIEludGVncmF0b3IoX2FjY2VsZXJhdGlvbkZvclN0YXRlKSB7XG5cdCAgICB0aGlzLl9hY2NlbGVyYXRpb25Gb3JTdGF0ZSA9IF9hY2NlbGVyYXRpb25Gb3JTdGF0ZTtcblx0ICAgIGlmICghXy5pc0Z1bmN0aW9uKHRoaXMuX2FjY2VsZXJhdGlvbkZvclN0YXRlKSkge1xuXHQgICAgICBjb25zb2xlLndhcm4oXCJJbnRlZ3JhdG9yOiBhbiBpbnRlZ3JhdG9yIG11c3QgYmUgY29uc3RydWN0ZWQgd2l0aCBhbiBhY2NlbGVyYXRpb24gZnVuY3Rpb25cIik7XG5cdCAgICAgIHRoaXMuX2FjY2VsZXJhdGlvbkZvclN0YXRlID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgcmV0dXJuIDA7XG5cdCAgICAgIH07XG5cdCAgICB9XG5cdCAgfVxuXHRcblx0ICBJbnRlZ3JhdG9yLnByb3RvdHlwZS5pbnRlZ3JhdGVTdGF0ZSA9IGZ1bmN0aW9uKHN0YXRlLCBkdCkge1xuXHQgICAgdmFyIGEsIGIsIGMsIGQsIGR2ZHQsIGR4ZHQ7XG5cdCAgICBhID0gdGhpcy5fZXZhbHVhdGVTdGF0ZShzdGF0ZSk7XG5cdCAgICBiID0gdGhpcy5fZXZhbHVhdGVTdGF0ZVdpdGhEZXJpdmF0aXZlKHN0YXRlLCBkdCAqIDAuNSwgYSk7XG5cdCAgICBjID0gdGhpcy5fZXZhbHVhdGVTdGF0ZVdpdGhEZXJpdmF0aXZlKHN0YXRlLCBkdCAqIDAuNSwgYik7XG5cdCAgICBkID0gdGhpcy5fZXZhbHVhdGVTdGF0ZVdpdGhEZXJpdmF0aXZlKHN0YXRlLCBkdCwgYyk7XG5cdCAgICBkeGR0ID0gMS4wIC8gNi4wICogKGEuZHggKyAyLjAgKiAoYi5keCArIGMuZHgpICsgZC5keCk7XG5cdCAgICBkdmR0ID0gMS4wIC8gNi4wICogKGEuZHYgKyAyLjAgKiAoYi5kdiArIGMuZHYpICsgZC5kdik7XG5cdCAgICBzdGF0ZS54ID0gc3RhdGUueCArIGR4ZHQgKiBkdDtcblx0ICAgIHN0YXRlLnYgPSBzdGF0ZS52ICsgZHZkdCAqIGR0O1xuXHQgICAgcmV0dXJuIHN0YXRlO1xuXHQgIH07XG5cdFxuXHQgIEludGVncmF0b3IucHJvdG90eXBlLl9ldmFsdWF0ZVN0YXRlID0gZnVuY3Rpb24oaW5pdGlhbFN0YXRlKSB7XG5cdCAgICB2YXIgb3V0cHV0O1xuXHQgICAgb3V0cHV0ID0ge307XG5cdCAgICBvdXRwdXQuZHggPSBpbml0aWFsU3RhdGUudjtcblx0ICAgIG91dHB1dC5kdiA9IHRoaXMuX2FjY2VsZXJhdGlvbkZvclN0YXRlKGluaXRpYWxTdGF0ZSk7XG5cdCAgICByZXR1cm4gb3V0cHV0O1xuXHQgIH07XG5cdFxuXHQgIEludGVncmF0b3IucHJvdG90eXBlLl9ldmFsdWF0ZVN0YXRlV2l0aERlcml2YXRpdmUgPSBmdW5jdGlvbihpbml0aWFsU3RhdGUsIGR0LCBkZXJpdmF0aXZlKSB7XG5cdCAgICB2YXIgb3V0cHV0LCBzdGF0ZTtcblx0ICAgIHN0YXRlID0ge307XG5cdCAgICBzdGF0ZS54ID0gaW5pdGlhbFN0YXRlLnggKyBkZXJpdmF0aXZlLmR4ICogZHQ7XG5cdCAgICBzdGF0ZS52ID0gaW5pdGlhbFN0YXRlLnYgKyBkZXJpdmF0aXZlLmR2ICogZHQ7XG5cdCAgICBvdXRwdXQgPSB7fTtcblx0ICAgIG91dHB1dC5keCA9IHN0YXRlLnY7XG5cdCAgICBvdXRwdXQuZHYgPSB0aGlzLl9hY2NlbGVyYXRpb25Gb3JTdGF0ZShzdGF0ZSk7XG5cdCAgICByZXR1cm4gb3V0cHV0O1xuXHQgIH07XG5cdFxuXHQgIHJldHVybiBJbnRlZ3JhdG9yO1xuXG5cdH0pKCk7XG5cblxuLyoqKi8gfSxcbi8qIDI0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgQW5pbWF0b3IsIFV0aWxzLFxuXHQgIGJpbmQgPSBmdW5jdGlvbihmbiwgbWUpeyByZXR1cm4gZnVuY3Rpb24oKXsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9OyB9LFxuXHQgIGV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcblx0ICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cdFxuXHRVdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdFxuXHRBbmltYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oMjApLkFuaW1hdG9yO1xuXHRcblx0ZXhwb3J0cy5TcHJpbmdESE9BbmltYXRvciA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG5cdCAgZXh0ZW5kKFNwcmluZ0RIT0FuaW1hdG9yLCBzdXBlckNsYXNzKTtcblx0XG5cdCAgZnVuY3Rpb24gU3ByaW5nREhPQW5pbWF0b3IoKSB7XG5cdCAgICB0aGlzLmZpbmlzaGVkID0gYmluZCh0aGlzLmZpbmlzaGVkLCB0aGlzKTtcblx0ICAgIHJldHVybiBTcHJpbmdESE9BbmltYXRvci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICB9XG5cdFxuXHQgIFNwcmluZ0RIT0FuaW1hdG9yLnByb3RvdHlwZS5zZXR1cCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0ICAgIHRoaXMub3B0aW9ucyA9IF8uZGVmYXVsdHMob3B0aW9ucywge1xuXHQgICAgICB2ZWxvY2l0eTogMCxcblx0ICAgICAgdG9sZXJhbmNlOiAxIC8gMTAwMDAsXG5cdCAgICAgIHN0aWZmbmVzczogNTAsXG5cdCAgICAgIGRhbXBpbmc6IDIsXG5cdCAgICAgIG1hc3M6IDAuMixcblx0ICAgICAgdGltZTogbnVsbFxuXHQgICAgfSk7XG5cdCAgICBjb25zb2xlLmxvZyhcIlNwcmluZ0RIT0FuaW1hdG9yLm9wdGlvbnNcIiwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblx0ICAgIHRoaXMuX3RpbWUgPSAwO1xuXHQgICAgdGhpcy5fdmFsdWUgPSAwO1xuXHQgICAgcmV0dXJuIHRoaXMuX3ZlbG9jaXR5ID0gdGhpcy5vcHRpb25zLnZlbG9jaXR5O1xuXHQgIH07XG5cdFxuXHQgIFNwcmluZ0RIT0FuaW1hdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oZGVsdGEpIHtcblx0ICAgIHZhciBGX2RhbXBlciwgRl9zcHJpbmcsIGIsIGs7XG5cdCAgICBpZiAodGhpcy5maW5pc2hlZCgpKSB7XG5cdCAgICAgIHJldHVybiAxO1xuXHQgICAgfVxuXHQgICAgdGhpcy5fdGltZSArPSBkZWx0YTtcblx0ICAgIGsgPSAwIC0gdGhpcy5vcHRpb25zLnN0aWZmbmVzcztcblx0ICAgIGIgPSAwIC0gdGhpcy5vcHRpb25zLmRhbXBpbmc7XG5cdCAgICBGX3NwcmluZyA9IGsgKiAodGhpcy5fdmFsdWUgLSAxKTtcblx0ICAgIEZfZGFtcGVyID0gYiAqIHRoaXMuX3ZlbG9jaXR5O1xuXHQgICAgdGhpcy5fdmVsb2NpdHkgKz0gKChGX3NwcmluZyArIEZfZGFtcGVyKSAvIHRoaXMub3B0aW9ucy5tYXNzKSAqIGRlbHRhO1xuXHQgICAgdGhpcy5fdmFsdWUgKz0gdGhpcy5fdmVsb2NpdHkgKiBkZWx0YTtcblx0ICAgIHJldHVybiB0aGlzLl92YWx1ZTtcblx0ICB9O1xuXHRcblx0ICBTcHJpbmdESE9BbmltYXRvci5wcm90b3R5cGUuZmluaXNoZWQgPSBmdW5jdGlvbigpIHtcblx0ICAgIHJldHVybiB0aGlzLl90aW1lID4gMCAmJiBNYXRoLmFicyh0aGlzLl92ZWxvY2l0eSkgPCB0aGlzLm9wdGlvbnMudG9sZXJhbmNlO1xuXHQgIH07XG5cdFxuXHQgIHJldHVybiBTcHJpbmdESE9BbmltYXRvcjtcblx0XG5cdH0pKEFuaW1hdG9yKTtcblxuXG4vKioqLyB9LFxuLyogMjUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdHZhciBfRm9yY2UyRFByb3BlcnRpZXMsIF9XZWJraXRQcm9wZXJ0aWVzLCBmaWx0ZXJGb3JtYXQ7XG5cdFxuXHRmaWx0ZXJGb3JtYXQgPSBmdW5jdGlvbih2YWx1ZSwgdW5pdCkge1xuXHQgIHJldHVybiBcIlwiICsgKFV0aWxzLnJvdW5kKHZhbHVlLCAyKSkgKyB1bml0O1xuXHR9O1xuXHRcblx0X1dlYmtpdFByb3BlcnRpZXMgPSBbW1wiYmx1clwiLCBcImJsdXJcIiwgMCwgXCJweFwiXSwgW1wiYnJpZ2h0bmVzc1wiLCBcImJyaWdodG5lc3NcIiwgMTAwLCBcIiVcIl0sIFtcInNhdHVyYXRlXCIsIFwic2F0dXJhdGVcIiwgMTAwLCBcIiVcIl0sIFtcImh1ZS1yb3RhdGVcIiwgXCJodWVSb3RhdGVcIiwgMCwgXCJkZWdcIl0sIFtcImNvbnRyYXN0XCIsIFwiY29udHJhc3RcIiwgMTAwLCBcIiVcIl0sIFtcImludmVydFwiLCBcImludmVydFwiLCAwLCBcIiVcIl0sIFtcImdyYXlzY2FsZVwiLCBcImdyYXlzY2FsZVwiLCAwLCBcIiVcIl0sIFtcInNlcGlhXCIsIFwic2VwaWFcIiwgMCwgXCIlXCJdXTtcblx0XG5cdF9Gb3JjZTJEUHJvcGVydGllcyA9IHtcblx0ICBcInpcIjogMCxcblx0ICBcInNjYWxlWFwiOiAxLFxuXHQgIFwic2NhbGVZXCI6IDEsXG5cdCAgXCJzY2FsZVpcIjogMSxcblx0ICBcInNrZXdYXCI6IDAsXG5cdCAgXCJza2V3WVwiOiAwLFxuXHQgIFwicm90YXRpb25YXCI6IDAsXG5cdCAgXCJyb3RhdGlvbllcIjogMFxuXHR9O1xuXHRcblx0ZXhwb3J0cy5MYXllclN0eWxlID0ge1xuXHQgIHdpZHRoOiBmdW5jdGlvbihsYXllcikge1xuXHQgICAgcmV0dXJuIGxheWVyLl9wcm9wZXJ0aWVzLndpZHRoICsgXCJweFwiO1xuXHQgIH0sXG5cdCAgaGVpZ2h0OiBmdW5jdGlvbihsYXllcikge1xuXHQgICAgcmV0dXJuIGxheWVyLl9wcm9wZXJ0aWVzLmhlaWdodCArIFwicHhcIjtcblx0ICB9LFxuXHQgIGRpc3BsYXk6IGZ1bmN0aW9uKGxheWVyKSB7XG5cdCAgICBpZiAobGF5ZXIuX3Byb3BlcnRpZXMudmlzaWJsZSA9PT0gdHJ1ZSkge1xuXHQgICAgICByZXR1cm4gXCJibG9ja1wiO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIFwibm9uZVwiO1xuXHQgIH0sXG5cdCAgb3BhY2l0eTogZnVuY3Rpb24obGF5ZXIpIHtcblx0ICAgIHJldHVybiBsYXllci5fcHJvcGVydGllcy5vcGFjaXR5O1xuXHQgIH0sXG5cdCAgd2Via2l0VHJhbnNmb3JtU3R5bGU6IGZ1bmN0aW9uKGxheWVyKSB7XG5cdCAgICBpZiAobGF5ZXIuX3Byb3BlcnRpZXMuZmxhdCkge1xuXHQgICAgICByZXR1cm4gXCJmbGF0XCI7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gXCJwcmVzZXJ2ZS0zZFwiO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgd2Via2l0QmFja2ZhY2VWaXNpYmlsaXR5OiBmdW5jdGlvbihsYXllcikge1xuXHQgICAgaWYgKGxheWVyLl9wcm9wZXJ0aWVzLmJhY2tmYWNlVmlzaWJsZSkge1xuXHQgICAgICByZXR1cm4gXCJ2aXNpYmxlXCI7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gXCJoaWRkZW5cIjtcblx0ICAgIH1cblx0ICB9LFxuXHQgIG92ZXJmbG93OiBmdW5jdGlvbihsYXllcikge1xuXHQgICAgaWYgKGxheWVyLl9wcm9wZXJ0aWVzLnNjcm9sbEhvcml6b250YWwgPT09IHRydWUgfHwgbGF5ZXIuX3Byb3BlcnRpZXMuc2Nyb2xsVmVydGljYWwgPT09IHRydWUpIHtcblx0ICAgICAgcmV0dXJuIFwiYXV0b1wiO1xuXHQgICAgfVxuXHQgICAgaWYgKGxheWVyLl9wcm9wZXJ0aWVzLmNsaXAgPT09IHRydWUpIHtcblx0ICAgICAgcmV0dXJuIFwiaGlkZGVuXCI7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gXCJ2aXNpYmxlXCI7XG5cdCAgfSxcblx0ICBvdmVyZmxvd1g6IGZ1bmN0aW9uKGxheWVyKSB7XG5cdCAgICBpZiAobGF5ZXIuX3Byb3BlcnRpZXMuc2Nyb2xsSG9yaXpvbnRhbCA9PT0gdHJ1ZSkge1xuXHQgICAgICByZXR1cm4gXCJzY3JvbGxcIjtcblx0ICAgIH1cblx0ICAgIGlmIChsYXllci5fcHJvcGVydGllcy5jbGlwID09PSB0cnVlKSB7XG5cdCAgICAgIHJldHVybiBcImhpZGRlblwiO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIFwidmlzaWJsZVwiO1xuXHQgIH0sXG5cdCAgb3ZlcmZsb3dZOiBmdW5jdGlvbihsYXllcikge1xuXHQgICAgaWYgKGxheWVyLl9wcm9wZXJ0aWVzLnNjcm9sbFZlcnRpY2FsID09PSB0cnVlKSB7XG5cdCAgICAgIHJldHVybiBcInNjcm9sbFwiO1xuXHQgICAgfVxuXHQgICAgaWYgKGxheWVyLl9wcm9wZXJ0aWVzLmNsaXAgPT09IHRydWUpIHtcblx0ICAgICAgcmV0dXJuIFwiaGlkZGVuXCI7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gXCJ2aXNpYmxlXCI7XG5cdCAgfSxcblx0ICB6SW5kZXg6IGZ1bmN0aW9uKGxheWVyKSB7XG5cdCAgICByZXR1cm4gbGF5ZXIuX3Byb3BlcnRpZXMuaW5kZXg7XG5cdCAgfSxcblx0ICB3ZWJraXRGaWx0ZXI6IGZ1bmN0aW9uKGxheWVyKSB7XG5cdCAgICB2YXIgY3NzLCBjc3NOYW1lLCBmYWxsYmFjaywgaSwgbGF5ZXJOYW1lLCBsZW4sIHJlZiwgdW5pdDtcblx0ICAgIGNzcyA9IFtdO1xuXHQgICAgZm9yIChpID0gMCwgbGVuID0gX1dlYmtpdFByb3BlcnRpZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0ICAgICAgcmVmID0gX1dlYmtpdFByb3BlcnRpZXNbaV0sIGNzc05hbWUgPSByZWZbMF0sIGxheWVyTmFtZSA9IHJlZlsxXSwgZmFsbGJhY2sgPSByZWZbMl0sIHVuaXQgPSByZWZbM107XG5cdCAgICAgIGlmIChsYXllci5fcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShsYXllck5hbWUpICYmIGxheWVyW2xheWVyTmFtZV0gIT09IGZhbGxiYWNrKSB7XG5cdCAgICAgICAgY3NzLnB1c2goY3NzTmFtZSArIFwiKFwiICsgKGZpbHRlckZvcm1hdChsYXllcltsYXllck5hbWVdLCB1bml0KSkgKyBcIilcIik7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBjc3Muam9pbihcIiBcIik7XG5cdCAgfSxcblx0ICB3ZWJraXRUcmFuc2Zvcm06IGZ1bmN0aW9uKGxheWVyKSB7XG5cdCAgICBpZiAobGF5ZXIuX3ByZWZlcjJkIHx8IGxheWVyLl9wcm9wZXJ0aWVzLmZvcmNlMmQpIHtcblx0ICAgICAgcmV0dXJuIGV4cG9ydHMuTGF5ZXJTdHlsZS53ZWJraXRUcmFuc2Zvcm1Gb3JjZTJkKGxheWVyKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBcInRyYW5zbGF0ZTNkKCBcIiArIGxheWVyLl9wcm9wZXJ0aWVzLnggKyBcInB4LCBcIiArIGxheWVyLl9wcm9wZXJ0aWVzLnkgKyBcInB4LCBcIiArIGxheWVyLl9wcm9wZXJ0aWVzLnogKyBcInB4KSBzY2FsZTNkKCBcIiArIChsYXllci5fcHJvcGVydGllcy5zY2FsZVggKiBsYXllci5fcHJvcGVydGllcy5zY2FsZSkgKyBcIiwgXCIgKyAobGF5ZXIuX3Byb3BlcnRpZXMuc2NhbGVZICogbGF5ZXIuX3Byb3BlcnRpZXMuc2NhbGUpICsgXCIsIFwiICsgbGF5ZXIuX3Byb3BlcnRpZXMuc2NhbGVaICsgXCIpIHNrZXcoXCIgKyBsYXllci5fcHJvcGVydGllcy5za2V3ICsgXCJkZWcsXCIgKyBsYXllci5fcHJvcGVydGllcy5za2V3ICsgXCJkZWcpIHNrZXdYKFwiICsgbGF5ZXIuX3Byb3BlcnRpZXMuc2tld1ggKyBcImRlZykgc2tld1koXCIgKyBsYXllci5fcHJvcGVydGllcy5za2V3WSArIFwiZGVnKSB0cmFuc2xhdGVaKFwiICsgbGF5ZXIuX3Byb3BlcnRpZXMub3JpZ2luWiArIFwicHgpIHJvdGF0ZVgoXCIgKyBsYXllci5fcHJvcGVydGllcy5yb3RhdGlvblggKyBcImRlZykgcm90YXRlWShcIiArIGxheWVyLl9wcm9wZXJ0aWVzLnJvdGF0aW9uWSArIFwiZGVnKSByb3RhdGVaKFwiICsgbGF5ZXIuX3Byb3BlcnRpZXMucm90YXRpb25aICsgXCJkZWcpIHRyYW5zbGF0ZVooXCIgKyAoLWxheWVyLl9wcm9wZXJ0aWVzLm9yaWdpblopICsgXCJweClcIjtcblx0ICB9LFxuXHQgIHdlYmtpdFRyYW5zZm9ybUZvcmNlMmQ6IGZ1bmN0aW9uKGxheWVyKSB7XG5cdCAgICB2YXIgY3NzLCBwLCB2O1xuXHQgICAgY3NzID0gW107XG5cdCAgICBmb3IgKHAgaW4gX0ZvcmNlMkRQcm9wZXJ0aWVzKSB7XG5cdCAgICAgIHYgPSBfRm9yY2UyRFByb3BlcnRpZXNbcF07XG5cdCAgICAgIGlmIChsYXllci5fcHJvcGVydGllc1twXSAhPT0gdikge1xuXHQgICAgICAgIGNvbnNvbGUud2FybihcIkxheWVyIHByb3BlcnR5ICdcIiArIHAgKyBcIicnIHdpbGwgYmUgaWdub3JlZCB3aXRoIGZvcmNlMmQgZW5hYmxlZFwiKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgY3NzLnB1c2goXCJ0cmFuc2xhdGUoXCIgKyBsYXllci5fcHJvcGVydGllcy54ICsgXCJweCxcIiArIGxheWVyLl9wcm9wZXJ0aWVzLnkgKyBcInB4KVwiKTtcblx0ICAgIGNzcy5wdXNoKFwic2NhbGUoXCIgKyBsYXllci5fcHJvcGVydGllcy5zY2FsZSArIFwiKVwiKTtcblx0ICAgIGNzcy5wdXNoKFwic2tldyhcIiArIGxheWVyLl9wcm9wZXJ0aWVzLnNrZXcgKyBcImRlZyxcIiArIGxheWVyLl9wcm9wZXJ0aWVzLnNrZXcgKyBcImRlZylcIik7XG5cdCAgICBjc3MucHVzaChcInJvdGF0ZShcIiArIGxheWVyLl9wcm9wZXJ0aWVzLnJvdGF0aW9uWiArIFwiZGVnKVwiKTtcblx0ICAgIHJldHVybiBjc3Muam9pbihcIiBcIik7XG5cdCAgfSxcblx0ICB3ZWJraXRUcmFuc2Zvcm1PcmlnaW46IGZ1bmN0aW9uKGxheWVyKSB7XG5cdCAgICByZXR1cm4gKGxheWVyLl9wcm9wZXJ0aWVzLm9yaWdpblggKiAxMDApICsgXCIlIFwiICsgKGxheWVyLl9wcm9wZXJ0aWVzLm9yaWdpblkgKiAxMDApICsgXCIlXCI7XG5cdCAgfSxcblx0ICB3ZWJraXRQZXJzcGVjdGl2ZTogZnVuY3Rpb24obGF5ZXIpIHtcblx0ICAgIHJldHVybiBcIlwiICsgbGF5ZXIuX3Byb3BlcnRpZXMucGVyc3BlY3RpdmU7XG5cdCAgfSxcblx0ICB3ZWJraXRQZXJzcGVjdGl2ZU9yaWdpbjogZnVuY3Rpb24obGF5ZXIpIHtcblx0ICAgIHJldHVybiAobGF5ZXIuX3Byb3BlcnRpZXMucGVyc3BlY3RpdmVPcmlnaW5YICogMTAwKSArIFwiJSBcIiArIChsYXllci5fcHJvcGVydGllcy5wZXJzcGVjdGl2ZU9yaWdpblkgKiAxMDApICsgXCIlXCI7XG5cdCAgfSxcblx0ICBwb2ludGVyRXZlbnRzOiBmdW5jdGlvbihsYXllcikge1xuXHQgICAgaWYgKGxheWVyLl9wcm9wZXJ0aWVzLmlnbm9yZUV2ZW50cykge1xuXHQgICAgICByZXR1cm4gXCJub25lXCI7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gXCJhdXRvXCI7XG5cdCAgICB9XG5cdCAgfSxcblx0ICBib3hTaGFkb3c6IGZ1bmN0aW9uKGxheWVyKSB7XG5cdCAgICB2YXIgcHJvcHM7XG5cdCAgICBwcm9wcyA9IGxheWVyLl9wcm9wZXJ0aWVzO1xuXHQgICAgaWYgKCFwcm9wcy5zaGFkb3dDb2xvcikge1xuXHQgICAgICByZXR1cm4gXCJcIjtcblx0ICAgIH0gZWxzZSBpZiAocHJvcHMuc2hhZG93WCA9PT0gMCAmJiBwcm9wcy5zaGFkb3dZID09PSAwICYmIHByb3BzLnNoYWRvd0JsdXIgPT09IDAgJiYgcHJvcHMuc2hhZG93U3ByZWFkID09PSAwKSB7XG5cdCAgICAgIHJldHVybiBcIlwiO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGxheWVyLl9wcm9wZXJ0aWVzLnNoYWRvd1ggKyBcInB4IFwiICsgbGF5ZXIuX3Byb3BlcnRpZXMuc2hhZG93WSArIFwicHggXCIgKyBsYXllci5fcHJvcGVydGllcy5zaGFkb3dCbHVyICsgXCJweCBcIiArIGxheWVyLl9wcm9wZXJ0aWVzLnNoYWRvd1NwcmVhZCArIFwicHggXCIgKyBsYXllci5fcHJvcGVydGllcy5zaGFkb3dDb2xvcjtcblx0ICB9LFxuXHQgIGJhY2tncm91bmRDb2xvcjogZnVuY3Rpb24obGF5ZXIpIHtcblx0ICAgIHJldHVybiBsYXllci5fcHJvcGVydGllcy5iYWNrZ3JvdW5kQ29sb3I7XG5cdCAgfSxcblx0ICBjb2xvcjogZnVuY3Rpb24obGF5ZXIpIHtcblx0ICAgIHJldHVybiBsYXllci5fcHJvcGVydGllcy5jb2xvcjtcblx0ICB9LFxuXHQgIGJvcmRlclJhZGl1czogZnVuY3Rpb24obGF5ZXIpIHtcblx0ICAgIGlmICghXy5pc051bWJlcihsYXllci5fcHJvcGVydGllcy5ib3JkZXJSYWRpdXMpKSB7XG5cdCAgICAgIHJldHVybiBsYXllci5fcHJvcGVydGllcy5ib3JkZXJSYWRpdXM7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbGF5ZXIuX3Byb3BlcnRpZXMuYm9yZGVyUmFkaXVzICsgXCJweFwiO1xuXHQgIH0sXG5cdCAgYm9yZGVyOiBmdW5jdGlvbihsYXllcikge1xuXHQgICAgcmV0dXJuIGxheWVyLl9wcm9wZXJ0aWVzLmJvcmRlcldpZHRoICsgXCJweCBzb2xpZCBcIiArIGxheWVyLl9wcm9wZXJ0aWVzLmJvcmRlckNvbG9yO1xuXHQgIH1cblx0fTtcblxuXG4vKioqLyB9LFxuLyogMjYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBCYXNlQ2xhc3MsIERlZmF1bHRzLCBFdmVudHMsIExheWVyU3RhdGVzSWdub3JlZEtleXMsIF8sXG5cdCAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuXHQgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcblx0ICBpbmRleE9mID0gW10uaW5kZXhPZiB8fCBmdW5jdGlvbihpdGVtKSB7IGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHsgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKSByZXR1cm4gaTsgfSByZXR1cm4gLTE7IH0sXG5cdCAgc2xpY2UgPSBbXS5zbGljZTtcblx0XG5cdF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpLl87XG5cdFxuXHRFdmVudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KS5FdmVudHM7XG5cdFxuXHRCYXNlQ2xhc3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpLkJhc2VDbGFzcztcblx0XG5cdERlZmF1bHRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNykuRGVmYXVsdHM7XG5cdFxuXHRMYXllclN0YXRlc0lnbm9yZWRLZXlzID0gW1wiaWdub3JlRXZlbnRzXCJdO1xuXHRcblx0RXZlbnRzLlN0YXRlV2lsbFN3aXRjaCA9IFwid2lsbFN3aXRjaFwiO1xuXHRcblx0RXZlbnRzLlN0YXRlRGlkU3dpdGNoID0gXCJkaWRTd2l0Y2hcIjtcblx0XG5cdGV4cG9ydHMuTGF5ZXJTdGF0ZXMgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuXHQgIGV4dGVuZChMYXllclN0YXRlcywgc3VwZXJDbGFzcyk7XG5cdFxuXHQgIGZ1bmN0aW9uIExheWVyU3RhdGVzKGxheWVyKSB7XG5cdCAgICB0aGlzLmxheWVyID0gbGF5ZXI7XG5cdCAgICB0aGlzLl9zdGF0ZXMgPSB7fTtcblx0ICAgIHRoaXMuX29yZGVyZWRTdGF0ZXMgPSBbXTtcblx0ICAgIHRoaXMuYW5pbWF0aW9uT3B0aW9ucyA9IHt9O1xuXHQgICAgdGhpcy5hZGQoXCJkZWZhdWx0XCIsIHRoaXMubGF5ZXIucHJvcHMpO1xuXHQgICAgdGhpcy5fY3VycmVudFN0YXRlID0gXCJkZWZhdWx0XCI7XG5cdCAgICB0aGlzLl9wcmV2aW91c1N0YXRlcyA9IFtdO1xuXHQgICAgTGF5ZXJTdGF0ZXMuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgfVxuXHRcblx0ICBMYXllclN0YXRlcy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oc3RhdGVOYW1lLCBwcm9wZXJ0aWVzKSB7XG5cdCAgICB2YXIgZXJyb3IsIGssIHY7XG5cdCAgICBpZiAoXy5pc09iamVjdChzdGF0ZU5hbWUpKSB7XG5cdCAgICAgIGZvciAoayBpbiBzdGF0ZU5hbWUpIHtcblx0ICAgICAgICB2ID0gc3RhdGVOYW1lW2tdO1xuXHQgICAgICAgIHRoaXMuYWRkKGssIHYpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIGVycm9yID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgIHRocm93IEVycm9yKFwiVXNhZ2UgZXhhbXBsZTogbGF5ZXIuc3RhdGVzLmFkZChcXFwic29tZU5hbWVcXFwiLCB7eDo1MDB9KVwiKTtcblx0ICAgIH07XG5cdCAgICBpZiAoIV8uaXNTdHJpbmcoc3RhdGVOYW1lKSkge1xuXHQgICAgICBlcnJvcigpO1xuXHQgICAgfVxuXHQgICAgaWYgKCFfLmlzT2JqZWN0KHByb3BlcnRpZXMpKSB7XG5cdCAgICAgIGVycm9yKCk7XG5cdCAgICB9XG5cdCAgICB0aGlzLl9vcmRlcmVkU3RhdGVzLnB1c2goc3RhdGVOYW1lKTtcblx0ICAgIHJldHVybiB0aGlzLl9zdGF0ZXNbc3RhdGVOYW1lXSA9IExheWVyU3RhdGVzLmZpbHRlclN0YXRlUHJvcGVydGllcyhwcm9wZXJ0aWVzKTtcblx0ICB9O1xuXHRcblx0ICBMYXllclN0YXRlcy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oc3RhdGVOYW1lKSB7XG5cdCAgICBpZiAoIXRoaXMuX3N0YXRlcy5oYXNPd25Qcm9wZXJ0eShzdGF0ZU5hbWUpKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIGRlbGV0ZSB0aGlzLl9zdGF0ZXNbc3RhdGVOYW1lXTtcblx0ICAgIHJldHVybiB0aGlzLl9vcmRlcmVkU3RhdGVzID0gXy53aXRob3V0KHRoaXMuX29yZGVyZWRTdGF0ZXMsIHN0YXRlTmFtZSk7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXJTdGF0ZXMucHJvdG90eXBlW1wic3dpdGNoXCJdID0gZnVuY3Rpb24oc3RhdGVOYW1lLCBhbmltYXRpb25PcHRpb25zLCBpbnN0YW50KSB7XG5cdCAgICB2YXIgYW5pbWF0YWJsZVByb3BlcnR5S2V5cywgYW5pbWF0aW5nS2V5cywgaywgcHJvcGVydGllcywgcHJvcGVydHlOYW1lLCByZWYsIHJlZjEsIHYsIHZhbHVlO1xuXHQgICAgaWYgKGluc3RhbnQgPT0gbnVsbCkge1xuXHQgICAgICBpbnN0YW50ID0gZmFsc2U7XG5cdCAgICB9XG5cdCAgICBpZiAoIXRoaXMuX3N0YXRlcy5oYXNPd25Qcm9wZXJ0eShzdGF0ZU5hbWUpKSB7XG5cdCAgICAgIHRocm93IEVycm9yKFwiTm8gc3VjaCBzdGF0ZTogJ1wiICsgc3RhdGVOYW1lICsgXCInXCIpO1xuXHQgICAgfVxuXHQgICAgdGhpcy5lbWl0KEV2ZW50cy5TdGF0ZVdpbGxTd2l0Y2gsIHRoaXMuX2N1cnJlbnRTdGF0ZSwgc3RhdGVOYW1lLCB0aGlzKTtcblx0ICAgIHRoaXMuX3ByZXZpb3VzU3RhdGVzLnB1c2godGhpcy5fY3VycmVudFN0YXRlKTtcblx0ICAgIHRoaXMuX2N1cnJlbnRTdGF0ZSA9IHN0YXRlTmFtZTtcblx0ICAgIHByb3BlcnRpZXMgPSB7fTtcblx0ICAgIGFuaW1hdGluZ0tleXMgPSB0aGlzLmFuaW1hdGluZ0tleXMoKTtcblx0ICAgIHJlZiA9IHRoaXMuX3N0YXRlc1tzdGF0ZU5hbWVdO1xuXHQgICAgZm9yIChwcm9wZXJ0eU5hbWUgaW4gcmVmKSB7XG5cdCAgICAgIHZhbHVlID0gcmVmW3Byb3BlcnR5TmFtZV07XG5cdCAgICAgIGlmIChpbmRleE9mLmNhbGwoTGF5ZXJTdGF0ZXNJZ25vcmVkS2V5cywgcHJvcGVydHlOYW1lKSA+PSAwKSB7XG5cdCAgICAgICAgY29udGludWU7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKGluZGV4T2YuY2FsbChhbmltYXRpbmdLZXlzLCBwcm9wZXJ0eU5hbWUpIDwgMCkge1xuXHQgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChfLmlzRnVuY3Rpb24odmFsdWUpKSB7XG5cdCAgICAgICAgdmFsdWUgPSB2YWx1ZS5jYWxsKHRoaXMubGF5ZXIsIHRoaXMubGF5ZXIsIHByb3BlcnR5TmFtZSwgc3RhdGVOYW1lKTtcblx0ICAgICAgfVxuXHQgICAgICBwcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV0gPSB2YWx1ZTtcblx0ICAgIH1cblx0ICAgIGFuaW1hdGFibGVQcm9wZXJ0eUtleXMgPSBbXTtcblx0ICAgIGZvciAoayBpbiBwcm9wZXJ0aWVzKSB7XG5cdCAgICAgIHYgPSBwcm9wZXJ0aWVzW2tdO1xuXHQgICAgICBpZiAoXy5pc051bWJlcih2KSkge1xuXHQgICAgICAgIGFuaW1hdGFibGVQcm9wZXJ0eUtleXMucHVzaChrKTtcblx0ICAgICAgfSBlbHNlIGlmIChDb2xvci5pc0NvbG9yT2JqZWN0KHYpKSB7XG5cdCAgICAgICAgYW5pbWF0YWJsZVByb3BlcnR5S2V5cy5wdXNoKGspO1xuXHQgICAgICB9IGVsc2UgaWYgKHYgPT09IG51bGwpIHtcblx0ICAgICAgICBhbmltYXRhYmxlUHJvcGVydHlLZXlzLnB1c2goayk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIGlmIChhbmltYXRhYmxlUHJvcGVydHlLZXlzLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICBpbnN0YW50ID0gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIGlmIChpbnN0YW50ID09PSB0cnVlKSB7XG5cdCAgICAgIHRoaXMubGF5ZXIucHJvcHMgPSBwcm9wZXJ0aWVzO1xuXHQgICAgICByZXR1cm4gdGhpcy5lbWl0KEV2ZW50cy5TdGF0ZURpZFN3aXRjaCwgXy5sYXN0KHRoaXMuX3ByZXZpb3VzU3RhdGVzKSwgdGhpcy5fY3VycmVudFN0YXRlLCB0aGlzKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlmIChhbmltYXRpb25PcHRpb25zID09IG51bGwpIHtcblx0ICAgICAgICBhbmltYXRpb25PcHRpb25zID0gdGhpcy5hbmltYXRpb25PcHRpb25zO1xuXHQgICAgICB9XG5cdCAgICAgIGFuaW1hdGlvbk9wdGlvbnMucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XG5cdCAgICAgIGlmICgocmVmMSA9IHRoaXMuX2FuaW1hdGlvbikgIT0gbnVsbCkge1xuXHQgICAgICAgIHJlZjEuc3RvcCgpO1xuXHQgICAgICB9XG5cdCAgICAgIHRoaXMuX2FuaW1hdGlvbiA9IHRoaXMubGF5ZXIuYW5pbWF0ZShhbmltYXRpb25PcHRpb25zKTtcblx0ICAgICAgcmV0dXJuIHRoaXMuX2FuaW1hdGlvbi5vbmNlKFwic3RvcFwiLCAoZnVuY3Rpb24oX3RoaXMpIHtcblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICBmb3IgKGsgaW4gcHJvcGVydGllcykge1xuXHQgICAgICAgICAgICB2ID0gcHJvcGVydGllc1trXTtcblx0ICAgICAgICAgICAgaWYgKCEoXy5pc051bWJlcih2KSB8fCBDb2xvci5pc0NvbG9yT2JqZWN0KHYpKSkge1xuXHQgICAgICAgICAgICAgIF90aGlzLmxheWVyW2tdID0gdjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgaWYgKF8ubGFzdChfdGhpcy5fcHJldmlvdXNTdGF0ZXMpICE9PSBzdGF0ZU5hbWUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIF90aGlzLmVtaXQoRXZlbnRzLlN0YXRlRGlkU3dpdGNoLCBfLmxhc3QoX3RoaXMuX3ByZXZpb3VzU3RhdGVzKSwgX3RoaXMuX2N1cnJlbnRTdGF0ZSwgX3RoaXMpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICAgIH0pKHRoaXMpKTtcblx0ICAgIH1cblx0ICB9O1xuXHRcblx0ICBMYXllclN0YXRlcy5wcm90b3R5cGUuc3dpdGNoSW5zdGFudCA9IGZ1bmN0aW9uKHN0YXRlTmFtZSkge1xuXHQgICAgcmV0dXJuIHRoaXNbXCJzd2l0Y2hcIl0oc3RhdGVOYW1lLCBudWxsLCB0cnVlKTtcblx0ICB9O1xuXHRcblx0ICBMYXllclN0YXRlcy5kZWZpbmUoXCJzdGF0ZVwiLCB7XG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFN0YXRlO1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBMYXllclN0YXRlcy5kZWZpbmUoXCJjdXJyZW50XCIsIHtcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50U3RhdGU7XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIExheWVyU3RhdGVzLmRlZmluZShcImFsbFwiLCB7XG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gXy5jbG9uZSh0aGlzLl9vcmRlcmVkU3RhdGVzKTtcblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgTGF5ZXJTdGF0ZXMucHJvdG90eXBlLnN0YXRlcyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgcmV0dXJuIF8uY2xvbmUodGhpcy5fb3JkZXJlZFN0YXRlcyk7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXJTdGF0ZXMucHJvdG90eXBlLmFuaW1hdGluZ0tleXMgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciBrZXlzLCByZWYsIHN0YXRlLCBzdGF0ZU5hbWU7XG5cdCAgICBrZXlzID0gW107XG5cdCAgICByZWYgPSB0aGlzLl9zdGF0ZXM7XG5cdCAgICBmb3IgKHN0YXRlTmFtZSBpbiByZWYpIHtcblx0ICAgICAgc3RhdGUgPSByZWZbc3RhdGVOYW1lXTtcblx0ICAgICAga2V5cyA9IF8udW5pb24oa2V5cywgXy5rZXlzKHN0YXRlKSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4ga2V5cztcblx0ICB9O1xuXHRcblx0ICBMYXllclN0YXRlcy5wcm90b3R5cGUucHJldmlvdXMgPSBmdW5jdGlvbihzdGF0ZXMsIGFuaW1hdGlvbk9wdGlvbnMpIHtcblx0ICAgIGlmIChzdGF0ZXMgPT0gbnVsbCkge1xuXHQgICAgICBzdGF0ZXMgPSB0aGlzLnN0YXRlcygpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXNbXCJzd2l0Y2hcIl0oVXRpbHMuYXJyYXlQcmV2KHN0YXRlcywgdGhpcy5fY3VycmVudFN0YXRlKSwgYW5pbWF0aW9uT3B0aW9ucyk7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXJTdGF0ZXMucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciBzdGF0ZXM7XG5cdCAgICBzdGF0ZXMgPSBVdGlscy5hcnJheUZyb21Bcmd1bWVudHMoYXJndW1lbnRzKTtcblx0ICAgIGlmICghc3RhdGVzLmxlbmd0aCkge1xuXHQgICAgICBzdGF0ZXMgPSB0aGlzLnN0YXRlcygpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXNbXCJzd2l0Y2hcIl0oVXRpbHMuYXJyYXlOZXh0KHN0YXRlcywgdGhpcy5fY3VycmVudFN0YXRlKSk7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXJTdGF0ZXMucHJvdG90eXBlLmxhc3QgPSBmdW5jdGlvbihhbmltYXRpb25PcHRpb25zKSB7XG5cdCAgICByZXR1cm4gdGhpc1tcInN3aXRjaFwiXShfLmxhc3QodGhpcy5fcHJldmlvdXNTdGF0ZXMpLCBhbmltYXRpb25PcHRpb25zKTtcblx0ICB9O1xuXHRcblx0ICBMYXllclN0YXRlcy5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIGFyZ3MsIHJlZjtcblx0ICAgIGFyZ3MgPSAxIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBzbGljZS5jYWxsKGFyZ3VtZW50cywgMCkgOiBbXTtcblx0ICAgIExheWVyU3RhdGVzLl9fc3VwZXJfXy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICByZXR1cm4gKHJlZiA9IHRoaXMubGF5ZXIpLmVtaXQuYXBwbHkocmVmLCBhcmdzKTtcblx0ICB9O1xuXHRcblx0ICBMYXllclN0YXRlcy5maWx0ZXJTdGF0ZVByb3BlcnRpZXMgPSBmdW5jdGlvbihwcm9wZXJ0aWVzKSB7XG5cdCAgICB2YXIgaywgc3RhdGVQcm9wZXJ0aWVzLCB2O1xuXHQgICAgc3RhdGVQcm9wZXJ0aWVzID0ge307XG5cdCAgICBmb3IgKGsgaW4gcHJvcGVydGllcykge1xuXHQgICAgICB2ID0gcHJvcGVydGllc1trXTtcblx0ICAgICAgaWYgKF8uaXNTdHJpbmcodikgJiYgXy5lbmRzV2l0aChrLnRvTG93ZXJDYXNlKCksIFwiY29sb3JcIikgJiYgQ29sb3IuaXNDb2xvclN0cmluZyh2KSkge1xuXHQgICAgICAgIHN0YXRlUHJvcGVydGllc1trXSA9IG5ldyBDb2xvcih2KTtcblx0ICAgICAgfSBlbHNlIGlmIChfLmlzTnVtYmVyKHYpIHx8IF8uaXNGdW5jdGlvbih2KSB8fCBfLmlzQm9vbGVhbih2KSB8fCBfLmlzU3RyaW5nKHYpIHx8IENvbG9yLmlzQ29sb3JPYmplY3QodikgfHwgdiA9PT0gbnVsbCkge1xuXHQgICAgICAgIHN0YXRlUHJvcGVydGllc1trXSA9IHY7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBzdGF0ZVByb3BlcnRpZXM7XG5cdCAgfTtcblx0XG5cdCAgcmV0dXJuIExheWVyU3RhdGVzO1xuXHRcblx0fSkoQmFzZUNsYXNzKTtcblxuXG4vKioqLyB9LFxuLyogMjcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBCYXNlQ2xhc3MsIERlZmF1bHRzLCBFdmVudEJ1ZmZlciwgRXZlbnRzLCBHZXN0dXJlcywgU2ltdWxhdGlvbiwgVXRpbHMsIF8sXG5cdCAgYmluZCA9IGZ1bmN0aW9uKGZuLCBtZSl7IHJldHVybiBmdW5jdGlvbigpeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH0sXG5cdCAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuXHQgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblx0XG5cdF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpLl87XG5cdFxuXHRVdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdFxuXHRCYXNlQ2xhc3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpLkJhc2VDbGFzcztcblx0XG5cdEV2ZW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpLkV2ZW50cztcblx0XG5cdFNpbXVsYXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KS5TaW11bGF0aW9uO1xuXHRcblx0RGVmYXVsdHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KS5EZWZhdWx0cztcblx0XG5cdEV2ZW50QnVmZmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMykuRXZlbnRCdWZmZXI7XG5cdFxuXHRHZXN0dXJlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpLkdlc3R1cmVzO1xuXHRcblx0RXZlbnRzLk1vdmUgPSBcIm1vdmVcIjtcblx0XG5cdEV2ZW50cy5EcmFnU3RhcnQgPSBcImRyYWdzdGFydFwiO1xuXHRcblx0RXZlbnRzLkRyYWdXaWxsTW92ZSA9IFwiZHJhZ3dpbGxtb3ZlXCI7XG5cdFxuXHRFdmVudHMuRHJhZ01vdmUgPSBcImRyYWdtb3ZlXCI7XG5cdFxuXHRFdmVudHMuRHJhZ0RpZE1vdmUgPSBcImRyYWdtb3ZlXCI7XG5cdFxuXHRFdmVudHMuRHJhZyA9IFwiZHJhZ21vdmVcIjtcblx0XG5cdEV2ZW50cy5EcmFnRW5kID0gXCJkcmFnZW5kXCI7XG5cdFxuXHRFdmVudHMuRHJhZ0FuaW1hdGlvblN0YXJ0ID0gXCJkcmFnYW5pbWF0aW9uc3RhcnRcIjtcblx0XG5cdEV2ZW50cy5EcmFnQW5pbWF0aW9uRW5kID0gXCJkcmFnYW5pbWF0aW9uZW5kXCI7XG5cdFxuXHRFdmVudHMuRGlyZWN0aW9uTG9ja1N0YXJ0ID0gXCJkaXJlY3Rpb25sb2Nrc3RhcnRcIjtcblx0XG5cdEV2ZW50cy5EcmFnU2Vzc2lvblN0YXJ0ID0gXCJkcmFnc2Vzc2lvbnN0YXJ0XCI7XG5cdFxuXHRFdmVudHMuRHJhZ1Nlc3Npb25Nb3ZlID0gXCJkcmFnc2Vzc2lvbm1vdmVcIjtcblx0XG5cdEV2ZW50cy5EcmFnU2Vzc2lvbkVuZCA9IFwiZHJhZ3Nlc3Npb25lbmRcIjtcblx0XG5cdEV2ZW50cy5EcmFnQW5pbWF0aW9uRGlkU3RhcnQgPSBFdmVudHMuRHJhZ0FuaW1hdGlvblN0YXJ0O1xuXHRcblx0RXZlbnRzLkRyYWdBbmltYXRpb25EaWRFbmQgPSBFdmVudHMuRHJhZ0FuaW1hdGlvbkVuZDtcblx0XG5cdEV2ZW50cy5EaXJlY3Rpb25Mb2NrRGlkU3RhcnQgPSBFdmVudHMuRGlyZWN0aW9uTG9ja1N0YXJ0O1xuXHRcblx0XCJcXG7ilIzilIDilIDilIDilIDilIDilIDilJAgICAgICAgICAgICAgICAgICAg4pSCXFxu4pSCICAgICAg4pSCXFxu4pSCICAgICAg4pSCICDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilrYg4pSCIOKXgOKUgOKUgOKUgOKUgOKWtlxcbuKUgiAgICAgIOKUglxcbuKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUmCAgICAgICAgICAgICAgICAgICDilIJcXG5cXG7ilZDilZDilZDilZDilZDilZDilZDilZAgIOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkOKVkCDilZDilZDilZDilZDilZDilZDilZBcXG5cXG4gIERyYWcgICAgICAgICBNb21lbnR1bSAgICAgIEJvdW5jZVxcblwiO1xuXHRcblx0ZXhwb3J0cy5MYXllckRyYWdnYWJsZSA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG5cdCAgZXh0ZW5kKExheWVyRHJhZ2dhYmxlLCBzdXBlckNsYXNzKTtcblx0XG5cdCAgTGF5ZXJEcmFnZ2FibGUuZGVmaW5lKFwic3BlZWRYXCIsIExheWVyRHJhZ2dhYmxlLnNpbXBsZVByb3BlcnR5KFwic3BlZWRYXCIsIDEpKTtcblx0XG5cdCAgTGF5ZXJEcmFnZ2FibGUuZGVmaW5lKFwic3BlZWRZXCIsIExheWVyRHJhZ2dhYmxlLnNpbXBsZVByb3BlcnR5KFwic3BlZWRZXCIsIDEpKTtcblx0XG5cdCAgTGF5ZXJEcmFnZ2FibGUuZGVmaW5lKFwiaG9yaXpvbnRhbFwiLCBMYXllckRyYWdnYWJsZS5zaW1wbGVQcm9wZXJ0eShcImhvcml6b250YWxcIiwgdHJ1ZSkpO1xuXHRcblx0ICBMYXllckRyYWdnYWJsZS5kZWZpbmUoXCJ2ZXJ0aWNhbFwiLCBMYXllckRyYWdnYWJsZS5zaW1wbGVQcm9wZXJ0eShcInZlcnRpY2FsXCIsIHRydWUpKTtcblx0XG5cdCAgTGF5ZXJEcmFnZ2FibGUuZGVmaW5lKFwibW9tZW50dW1WZWxvY2l0eU11bHRpcGxpZXJcIiwgTGF5ZXJEcmFnZ2FibGUuc2ltcGxlUHJvcGVydHkoXCJtb21lbnR1bVZlbG9jaXR5TXVsdGlwbGllclwiLCA4MDApKTtcblx0XG5cdCAgTGF5ZXJEcmFnZ2FibGUuZGVmaW5lKFwiZGlyZWN0aW9uTG9ja1wiLCBMYXllckRyYWdnYWJsZS5zaW1wbGVQcm9wZXJ0eShcImRpcmVjdGlvbkxvY2tcIiwgdHJ1ZSkpO1xuXHRcblx0ICBMYXllckRyYWdnYWJsZS5kZWZpbmUoXCJkaXJlY3Rpb25Mb2NrVGhyZXNob2xkXCIsIExheWVyRHJhZ2dhYmxlLnNpbXBsZVByb3BlcnR5KFwiZGlyZWN0aW9uTG9ja1RocmVzaG9sZFwiLCB7XG5cdCAgICB4OiAxMCxcblx0ICAgIHk6IDEwXG5cdCAgfSkpO1xuXHRcblx0ICBMYXllckRyYWdnYWJsZS5kZWZpbmUoXCJwcm9wYWdhdGVFdmVudHNcIiwgTGF5ZXJEcmFnZ2FibGUuc2ltcGxlUHJvcGVydHkoXCJwcm9wYWdhdGVFdmVudHNcIiwgdHJ1ZSkpO1xuXHRcblx0ICBMYXllckRyYWdnYWJsZS5kZWZpbmUoXCJjb25zdHJhaW50c1wiLCB7XG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fY29uc3RyYWludHM7XG5cdCAgICB9LFxuXHQgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICBpZiAodmFsdWUgJiYgXy5pc09iamVjdCh2YWx1ZSkpIHtcblx0ICAgICAgICB2YWx1ZSA9IF8ucGljayh2YWx1ZSwgW1wieFwiLCBcInlcIiwgXCJ3aWR0aFwiLCBcImhlaWdodFwiXSk7XG5cdCAgICAgICAgdmFsdWUgPSBfLmRlZmF1bHRzKHZhbHVlLCB7XG5cdCAgICAgICAgICB4OiAwLFxuXHQgICAgICAgICAgeTogMCxcblx0ICAgICAgICAgIHdpZHRoOiAwLFxuXHQgICAgICAgICAgaGVpZ2h0OiAwXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgdGhpcy5fY29uc3RyYWludHMgPSB2YWx1ZTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB0aGlzLl9jb25zdHJhaW50cyA9IHtcblx0ICAgICAgICAgIHg6IDAsXG5cdCAgICAgICAgICB5OiAwLFxuXHQgICAgICAgICAgd2lkdGg6IDAsXG5cdCAgICAgICAgICBoZWlnaHQ6IDBcblx0ICAgICAgICB9O1xuXHQgICAgICB9XG5cdCAgICAgIGlmICh0aGlzLl9jb25zdHJhaW50cykge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl91cGRhdGVTaW11bGF0aW9uQ29uc3RyYWludHModGhpcy5fY29uc3RyYWludHMpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIExheWVyRHJhZ2dhYmxlLmRlZmluZShcImlzRHJhZ2dpbmdcIiwge1xuXHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX2lzRHJhZ2dpbmcgfHwgZmFsc2U7XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIExheWVyRHJhZ2dhYmxlLmRlZmluZShcImlzQW5pbWF0aW5nXCIsIHtcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9pc0FuaW1hdGluZyB8fCBmYWxzZTtcblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgTGF5ZXJEcmFnZ2FibGUuZGVmaW5lKFwiaXNNb3ZpbmdcIiwge1xuXHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX2lzTW92aW5nIHx8IGZhbHNlO1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBMYXllckRyYWdnYWJsZS5kZWZpbmUoXCJsYXllclN0YXJ0UG9pbnRcIiwge1xuXHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX2xheWVyU3RhcnRQb2ludCB8fCB0aGlzLmxheWVyLnBvaW50O1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBMYXllckRyYWdnYWJsZS5kZWZpbmUoXCJjdXJzb3JTdGFydFBvaW50XCIsIHtcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9jdXJzb3JTdGFydFBvaW50IHx8IHtcblx0ICAgICAgICB4OiAwLFxuXHQgICAgICAgIHk6IDBcblx0ICAgICAgfTtcblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgTGF5ZXJEcmFnZ2FibGUuZGVmaW5lKFwibGF5ZXJDdXJzb3JPZmZzZXRcIiwge1xuXHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX2xheWVyQ3Vyc29yT2Zmc2V0IHx8IHtcblx0ICAgICAgICB4OiAwLFxuXHQgICAgICAgIHk6IDBcblx0ICAgICAgfTtcblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgTGF5ZXJEcmFnZ2FibGUuZGVmaW5lKFwib2Zmc2V0XCIsIHtcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHZhciBvZmZzZXQ7XG5cdCAgICAgIGlmICghdGhpcy5fY29ycmVjdGVkTGF5ZXJTdGFydFBvaW50KSB7XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgIHg6IDAsXG5cdCAgICAgICAgICB5OiAwXG5cdCAgICAgICAgfTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gb2Zmc2V0ID0ge1xuXHQgICAgICAgIHg6IHRoaXMubGF5ZXIueCAtIHRoaXMuX2NvcnJlY3RlZExheWVyU3RhcnRQb2ludC54LFxuXHQgICAgICAgIHk6IHRoaXMubGF5ZXIueSAtIHRoaXMuX2NvcnJlY3RlZExheWVyU3RhcnRQb2ludC55XG5cdCAgICAgIH07XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIGZ1bmN0aW9uIExheWVyRHJhZ2dhYmxlKGxheWVyKSB7XG5cdCAgICB2YXIgb3B0aW9ucztcblx0ICAgIHRoaXMubGF5ZXIgPSBsYXllcjtcblx0ICAgIHRoaXMuX3N0b3BTaW11bGF0aW9uID0gYmluZCh0aGlzLl9zdG9wU2ltdWxhdGlvbiwgdGhpcyk7XG5cdCAgICB0aGlzLl9vblNpbXVsYXRpb25TdG9wID0gYmluZCh0aGlzLl9vblNpbXVsYXRpb25TdG9wLCB0aGlzKTtcblx0ICAgIHRoaXMuX29uU2ltdWxhdGlvblN0ZXAgPSBiaW5kKHRoaXMuX29uU2ltdWxhdGlvblN0ZXAsIHRoaXMpO1xuXHQgICAgdGhpcy5fdG91Y2hFbmQgPSBiaW5kKHRoaXMuX3RvdWNoRW5kLCB0aGlzKTtcblx0ICAgIHRoaXMuX3RvdWNoTW92ZSA9IGJpbmQodGhpcy5fdG91Y2hNb3ZlLCB0aGlzKTtcblx0ICAgIHRoaXMuX3RvdWNoU3RhcnQgPSBiaW5kKHRoaXMuX3RvdWNoU3RhcnQsIHRoaXMpO1xuXHQgICAgdGhpcy5fdXBkYXRlTGF5ZXJQb3NpdGlvbiA9IGJpbmQodGhpcy5fdXBkYXRlTGF5ZXJQb3NpdGlvbiwgdGhpcyk7XG5cdCAgICB0aGlzLnRvdWNoU3RhcnQgPSBiaW5kKHRoaXMudG91Y2hTdGFydCwgdGhpcyk7XG5cdCAgICBvcHRpb25zID0gRGVmYXVsdHMuZ2V0RGVmYXVsdHMoXCJMYXllckRyYWdnYWJsZVwiLCB7fSk7XG5cdCAgICBMYXllckRyYWdnYWJsZS5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgIF8uZXh0ZW5kKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcblx0ICAgIHRoaXMuX2V2ZW50QnVmZmVyID0gbmV3IEV2ZW50QnVmZmVyO1xuXHQgICAgdGhpcy5fY29uc3RyYWludHMgPSBudWxsO1xuXHQgICAgdGhpcy5faWdub3JlVXBkYXRlTGF5ZXJQb3NpdGlvbiA9IHRydWU7XG5cdCAgICB0aGlzLmF0dGFjaCgpO1xuXHQgIH1cblx0XG5cdCAgTGF5ZXJEcmFnZ2FibGUucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdGhpcy5sYXllci5vbihHZXN0dXJlcy5UYXBTdGFydCwgdGhpcy50b3VjaFN0YXJ0KTtcblx0ICAgIHRoaXMubGF5ZXIub24oXCJjaGFuZ2U6eFwiLCB0aGlzLl91cGRhdGVMYXllclBvc2l0aW9uKTtcblx0ICAgIHJldHVybiB0aGlzLmxheWVyLm9uKFwiY2hhbmdlOnlcIiwgdGhpcy5fdXBkYXRlTGF5ZXJQb3NpdGlvbik7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXJEcmFnZ2FibGUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdGhpcy5sYXllci5vZmYoR2VzdHVyZXMuVGFwU3RhcnQsIHRoaXMudG91Y2hTdGFydCk7XG5cdCAgICB0aGlzLmxheWVyLm9mZihHZXN0dXJlcy5QYW4sIHRoaXMuX3RvdWNoTW92ZSk7XG5cdCAgICByZXR1cm4gdGhpcy5sYXllci5vZmYoR2VzdHVyZXMuUGFuRW5kLCB0aGlzLl90b3VjaEVuZCk7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXJEcmFnZ2FibGUucHJvdG90eXBlLnVwZGF0ZVBvc2l0aW9uID0gZnVuY3Rpb24ocG9pbnQpIHtcblx0ICAgIHJldHVybiBwb2ludDtcblx0ICB9O1xuXHRcblx0ICBMYXllckRyYWdnYWJsZS5wcm90b3R5cGUudG91Y2hTdGFydCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdCAgICByZXR1cm4gdGhpcy5fdG91Y2hTdGFydChldmVudCk7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXJEcmFnZ2FibGUucHJvdG90eXBlLl91cGRhdGVMYXllclBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG5cdCAgICBpZiAodGhpcy5faWdub3JlVXBkYXRlTGF5ZXJQb3NpdGlvbiA9PT0gdHJ1ZSkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcy5fcG9pbnQgPSB0aGlzLmxheWVyLnBvaW50O1xuXHQgIH07XG5cdFxuXHQgIExheWVyRHJhZ2dhYmxlLnByb3RvdHlwZS5fdG91Y2hTdGFydCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdCAgICB2YXIgYW5pbWF0aW9uLCBpLCBsZW4sIHByb3BlcnRpZXMsIHJlZiwgdG91Y2hFdmVudDtcblx0ICAgIEV2ZW50cy53cmFwKGRvY3VtZW50KS5hZGRFdmVudExpc3RlbmVyKEdlc3R1cmVzLlBhbiwgdGhpcy5fdG91Y2hNb3ZlKTtcblx0ICAgIEV2ZW50cy53cmFwKGRvY3VtZW50KS5hZGRFdmVudExpc3RlbmVyKEdlc3R1cmVzLlRhcEVuZCwgdGhpcy5fdG91Y2hFbmQpO1xuXHQgICAgdGhpcy5faXNNb3ZpbmcgPSB0aGlzLmlzQW5pbWF0aW5nO1xuXHQgICAgcmVmID0gdGhpcy5sYXllci5hbmltYXRpb25zKCk7XG5cdCAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0ICAgICAgYW5pbWF0aW9uID0gcmVmW2ldO1xuXHQgICAgICBwcm9wZXJ0aWVzID0gYW5pbWF0aW9uLm9wdGlvbnMucHJvcGVydGllcztcblx0ICAgICAgaWYgKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoXCJ4XCIpIHx8IHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoXCJ5XCIpKSB7XG5cdCAgICAgICAgYW5pbWF0aW9uLnN0b3AoKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgdGhpcy5fc3RvcFNpbXVsYXRpb24oKTtcblx0ICAgIHRoaXMuX3Jlc2V0ZGlyZWN0aW9uTG9jaygpO1xuXHQgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0ICAgIGlmICh0aGlzLnByb3BhZ2F0ZUV2ZW50cyA9PT0gZmFsc2UpIHtcblx0ICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdCAgICB9XG5cdCAgICB0b3VjaEV2ZW50ID0gRXZlbnRzLnRvdWNoRXZlbnQoZXZlbnQpO1xuXHQgICAgdGhpcy5fZXZlbnRCdWZmZXIucHVzaCh7XG5cdCAgICAgIHg6IHRvdWNoRXZlbnQuY2xpZW50WCxcblx0ICAgICAgeTogdG91Y2hFdmVudC5jbGllbnRZLFxuXHQgICAgICB0OiBEYXRlLm5vdygpXG5cdCAgICB9KTtcblx0ICAgIHRoaXMuX2xheWVyU3RhcnRQb2ludCA9IHRoaXMubGF5ZXIucG9pbnQ7XG5cdCAgICB0aGlzLl9jb3JyZWN0ZWRMYXllclN0YXJ0UG9pbnQgPSB0aGlzLmxheWVyLnBvaW50O1xuXHQgICAgaWYgKHRoaXMuY29uc3RyYWludHMgJiYgdGhpcy5ib3VuY2UpIHtcblx0ICAgICAgdGhpcy5fY29ycmVjdGVkTGF5ZXJTdGFydFBvaW50ID0gdGhpcy5fY29uc3RyYWluUG9zaXRpb24odGhpcy5fY29ycmVjdGVkTGF5ZXJTdGFydFBvaW50LCB0aGlzLmNvbnN0cmFpbnRzLCAxIC8gdGhpcy5vdmVyZHJhZ1NjYWxlKTtcblx0ICAgIH1cblx0ICAgIHRoaXMuX2N1cnNvclN0YXJ0UG9pbnQgPSB7XG5cdCAgICAgIHg6IHRvdWNoRXZlbnQuY2xpZW50WCxcblx0ICAgICAgeTogdG91Y2hFdmVudC5jbGllbnRZXG5cdCAgICB9O1xuXHQgICAgdGhpcy5fbGF5ZXJDdXJzb3JPZmZzZXQgPSB7XG5cdCAgICAgIHg6IHRvdWNoRXZlbnQuY2xpZW50WCAtIHRoaXMuX2NvcnJlY3RlZExheWVyU3RhcnRQb2ludC54LFxuXHQgICAgICB5OiB0b3VjaEV2ZW50LmNsaWVudFkgLSB0aGlzLl9jb3JyZWN0ZWRMYXllclN0YXJ0UG9pbnQueVxuXHQgICAgfTtcblx0ICAgIHRoaXMuX3BvaW50ID0gdGhpcy5fY29ycmVjdGVkTGF5ZXJTdGFydFBvaW50O1xuXHQgICAgdGhpcy5faWdub3JlVXBkYXRlTGF5ZXJQb3NpdGlvbiA9IGZhbHNlO1xuXHQgICAgcmV0dXJuIHRoaXMuZW1pdChFdmVudHMuRHJhZ1Nlc3Npb25TdGFydCwgZXZlbnQpO1xuXHQgIH07XG5cdFxuXHQgIExheWVyRHJhZ2dhYmxlLnByb3RvdHlwZS5fdG91Y2hNb3ZlID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0ICAgIHZhciBvZmZzZXQsIHBvaW50LCBzY2FsZVgsIHNjYWxlWSwgdG91Y2hFdmVudDtcblx0ICAgIGlmICghdGhpcy5lbmFibGVkKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIGlmICghdGhpcy5fcG9pbnQpIHtcblx0ICAgICAgdGhpcy50b3VjaFN0YXJ0KGV2ZW50KTtcblx0ICAgIH1cblx0ICAgIHRoaXMuX2xhc3RFdmVudCA9IGV2ZW50O1xuXHQgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0ICAgIGlmICh0aGlzLnByb3BhZ2F0ZUV2ZW50cyA9PT0gZmFsc2UpIHtcblx0ICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdCAgICB9XG5cdCAgICB0b3VjaEV2ZW50ID0gRXZlbnRzLnRvdWNoRXZlbnQoZXZlbnQpO1xuXHQgICAgdGhpcy5fZXZlbnRCdWZmZXIucHVzaCh7XG5cdCAgICAgIHg6IHRvdWNoRXZlbnQuY2xpZW50WCxcblx0ICAgICAgeTogdG91Y2hFdmVudC5jbGllbnRZLFxuXHQgICAgICB0OiBEYXRlLm5vdygpXG5cdCAgICB9KTtcblx0ICAgIHBvaW50ID0gXy5jbG9uZSh0aGlzLl9wb2ludCk7XG5cdCAgICBzY2FsZVggPSAxIC8gdGhpcy5sYXllci5jYW52YXNTY2FsZVgoKSAqIHRoaXMubGF5ZXIuc2NhbGUgKiB0aGlzLmxheWVyLnNjYWxlWDtcblx0ICAgIHNjYWxlWSA9IDEgLyB0aGlzLmxheWVyLmNhbnZhc1NjYWxlWSgpICogdGhpcy5sYXllci5zY2FsZSAqIHRoaXMubGF5ZXIuc2NhbGVZO1xuXHQgICAgaWYgKHRoaXMuaG9yaXpvbnRhbCkge1xuXHQgICAgICBwb2ludC54ID0gdGhpcy5fcG9pbnQueCArIChldmVudC5kZWx0YS54ICogc2NhbGVYICogdGhpcy5zcGVlZFgpO1xuXHQgICAgfVxuXHQgICAgaWYgKHRoaXMudmVydGljYWwpIHtcblx0ICAgICAgcG9pbnQueSA9IHRoaXMuX3BvaW50LnkgKyAoZXZlbnQuZGVsdGEueSAqIHNjYWxlWSAqIHRoaXMuc3BlZWRZKTtcblx0ICAgIH1cblx0ICAgIHRoaXMuX3BvaW50ID0gXy5jbG9uZShwb2ludCk7XG5cdCAgICBpZiAodGhpcy5fY29uc3RyYWludHMpIHtcblx0ICAgICAgcG9pbnQgPSB0aGlzLl9jb25zdHJhaW5Qb3NpdGlvbihwb2ludCwgdGhpcy5fY29uc3RyYWludHMsIHRoaXMub3ZlcmRyYWdTY2FsZSk7XG5cdCAgICB9XG5cdCAgICBpZiAodGhpcy5kaXJlY3Rpb25Mb2NrKSB7XG5cdCAgICAgIGlmICghdGhpcy5fZGlyZWN0aW9uTG9ja0VuYWJsZWRYICYmICF0aGlzLl9kaXJlY3Rpb25Mb2NrRW5hYmxlZFkpIHtcblx0ICAgICAgICBvZmZzZXQgPSBldmVudC5vZmZzZXQ7XG5cdCAgICAgICAgb2Zmc2V0LnggPSBvZmZzZXQueCAqIHRoaXMuc3BlZWRYICogKDEgLyB0aGlzLmxheWVyLmNhbnZhc1NjYWxlWCgpKSAqIHRoaXMubGF5ZXIuc2NhbGVYICogdGhpcy5sYXllci5zY2FsZTtcblx0ICAgICAgICBvZmZzZXQueSA9IG9mZnNldC55ICogdGhpcy5zcGVlZFkgKiAoMSAvIHRoaXMubGF5ZXIuY2FudmFzU2NhbGVZKCkpICogdGhpcy5sYXllci5zY2FsZVkgKiB0aGlzLmxheWVyLnNjYWxlO1xuXHQgICAgICAgIHRoaXMuX3VwZGF0ZWRpcmVjdGlvbkxvY2sob2Zmc2V0KTtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbkxvY2tFbmFibGVkWCkge1xuXHQgICAgICAgICAgcG9pbnQueCA9IHRoaXMuX2xheWVyU3RhcnRQb2ludC54O1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uTG9ja0VuYWJsZWRZKSB7XG5cdCAgICAgICAgICBwb2ludC55ID0gdGhpcy5fbGF5ZXJTdGFydFBvaW50Lnk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICBpZiAocG9pbnQueCAhPT0gdGhpcy5fbGF5ZXJTdGFydFBvaW50LnggfHwgcG9pbnQueSAhPT0gdGhpcy5fbGF5ZXJTdGFydFBvaW50LnkpIHtcblx0ICAgICAgaWYgKCF0aGlzLl9pc0RyYWdnaW5nKSB7XG5cdCAgICAgICAgdGhpcy5faXNEcmFnZ2luZyA9IHRydWU7XG5cdCAgICAgICAgdGhpcy5faXNNb3ZpbmcgPSB0cnVlO1xuXHQgICAgICAgIHRoaXMuZW1pdChFdmVudHMuRHJhZ1N0YXJ0LCBldmVudCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcpIHtcblx0ICAgICAgdGhpcy5lbWl0KEV2ZW50cy5EcmFnV2lsbE1vdmUsIGV2ZW50KTtcblx0ICAgIH1cblx0ICAgIGlmICh0aGlzLnBpeGVsQWxpZ24pIHtcblx0ICAgICAgaWYgKHRoaXMuaG9yaXpvbnRhbCkge1xuXHQgICAgICAgIHBvaW50LnggPSBwYXJzZUludChwb2ludC54KTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAodGhpcy52ZXJ0aWNhbCkge1xuXHQgICAgICAgIHBvaW50LnkgPSBwYXJzZUludChwb2ludC55KTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgdGhpcy5faWdub3JlVXBkYXRlTGF5ZXJQb3NpdGlvbiA9IHRydWU7XG5cdCAgICB0aGlzLmxheWVyLnBvaW50ID0gdGhpcy51cGRhdGVQb3NpdGlvbihwb2ludCk7XG5cdCAgICB0aGlzLl9pZ25vcmVVcGRhdGVMYXllclBvc2l0aW9uID0gZmFsc2U7XG5cdCAgICBpZiAodGhpcy5pc0RyYWdnaW5nKSB7XG5cdCAgICAgIHRoaXMuZW1pdChFdmVudHMuTW92ZSwgdGhpcy5sYXllci5wb2ludCk7XG5cdCAgICAgIHRoaXMuZW1pdChFdmVudHMuRHJhZ0RpZE1vdmUsIGV2ZW50KTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0aGlzLmVtaXQoRXZlbnRzLkRyYWdTZXNzaW9uTW92ZSwgZXZlbnQpO1xuXHQgIH07XG5cdFxuXHQgIExheWVyRHJhZ2dhYmxlLnByb3RvdHlwZS5fdG91Y2hFbmQgPSBmdW5jdGlvbihldmVudCkge1xuXHQgICAgRXZlbnRzLndyYXAoZG9jdW1lbnQpLnJlbW92ZUV2ZW50TGlzdGVuZXIoR2VzdHVyZXMuUGFuLCB0aGlzLl90b3VjaE1vdmUpO1xuXHQgICAgRXZlbnRzLndyYXAoZG9jdW1lbnQpLnJlbW92ZUV2ZW50TGlzdGVuZXIoR2VzdHVyZXMuVGFwRW5kLCB0aGlzLl90b3VjaEVuZCk7XG5cdCAgICBpZiAodGhpcy5wcm9wYWdhdGVFdmVudHMgPT09IGZhbHNlKSB7XG5cdCAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHQgICAgfVxuXHQgICAgdGhpcy5fc3RhcnRTaW11bGF0aW9uKCk7XG5cdCAgICB0aGlzLmVtaXQoRXZlbnRzLkRyYWdTZXNzaW9uRW5kLCBldmVudCk7XG5cdCAgICBpZiAodGhpcy5faXNEcmFnZ2luZykge1xuXHQgICAgICB0aGlzLmVtaXQoRXZlbnRzLkRyYWdFbmQsIGV2ZW50KTtcblx0ICAgIH1cblx0ICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcblx0ICAgIHJldHVybiB0aGlzLl9pZ25vcmVVcGRhdGVMYXllclBvc2l0aW9uID0gdHJ1ZTtcblx0ICB9O1xuXHRcblx0ICBMYXllckRyYWdnYWJsZS5kZWZpbmUoXCJjb25zdHJhaW50c09mZnNldFwiLCB7XG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICB2YXIgY29uc3RyYWluZWRQb2ludCwgbWF4WCwgbWF4WSwgbWluWCwgbWluWSwgb2Zmc2V0LCBwb2ludCwgcmVmO1xuXHQgICAgICBpZiAoIXRoaXMuY29uc3RyYWludHMpIHtcblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgeDogMCxcblx0ICAgICAgICAgIHk6IDBcblx0ICAgICAgICB9O1xuXHQgICAgICB9XG5cdCAgICAgIHJlZiA9IHRoaXMuX2NhbGN1bGF0ZUNvbnN0cmFpbnRzKHRoaXMuY29uc3RyYWludHMpLCBtaW5YID0gcmVmLm1pblgsIG1heFggPSByZWYubWF4WCwgbWluWSA9IHJlZi5taW5ZLCBtYXhZID0gcmVmLm1heFk7XG5cdCAgICAgIHBvaW50ID0gdGhpcy5sYXllci5wb2ludDtcblx0ICAgICAgY29uc3RyYWluZWRQb2ludCA9IHtcblx0ICAgICAgICB4OiBVdGlscy5jbGFtcChwb2ludC54LCBtaW5YLCBtYXhYKSxcblx0ICAgICAgICB5OiBVdGlscy5jbGFtcChwb2ludC55LCBtaW5ZLCBtYXhZKVxuXHQgICAgICB9O1xuXHQgICAgICBvZmZzZXQgPSB7XG5cdCAgICAgICAgeDogcG9pbnQueCAtIGNvbnN0cmFpbmVkUG9pbnQueCxcblx0ICAgICAgICB5OiBwb2ludC55IC0gY29uc3RyYWluZWRQb2ludC55XG5cdCAgICAgIH07XG5cdCAgICAgIHJldHVybiBvZmZzZXQ7XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIExheWVyRHJhZ2dhYmxlLmRlZmluZShcImlzQmV5b25kQ29uc3RyYWludHNcIiwge1xuXHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgdmFyIGNvbnN0cmFpbnRzT2Zmc2V0O1xuXHQgICAgICBjb25zdHJhaW50c09mZnNldCA9IHRoaXMuY29uc3RyYWludHNPZmZzZXQ7XG5cdCAgICAgIGlmIChjb25zdHJhaW50c09mZnNldC54ICE9PSAwKSB7XG5cdCAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKGNvbnN0cmFpbnRzT2Zmc2V0LnkgIT09IDApIHtcblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIExheWVyRHJhZ2dhYmxlLnByb3RvdHlwZS5fY2xhbXBBbmRTY2FsZSA9IGZ1bmN0aW9uKHZhbHVlLCBtaW4sIG1heCwgc2NhbGUpIHtcblx0ICAgIGlmICh2YWx1ZSA8IG1pbikge1xuXHQgICAgICB2YWx1ZSA9IG1pbiArICh2YWx1ZSAtIG1pbikgKiBzY2FsZTtcblx0ICAgIH1cblx0ICAgIGlmICh2YWx1ZSA+IG1heCkge1xuXHQgICAgICB2YWx1ZSA9IG1heCArICh2YWx1ZSAtIG1heCkgKiBzY2FsZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9O1xuXHRcblx0ICBMYXllckRyYWdnYWJsZS5wcm90b3R5cGUuX2NhbGN1bGF0ZUNvbnN0cmFpbnRzID0gZnVuY3Rpb24oYm91bmRzKSB7XG5cdCAgICB2YXIgY29uc3RyYWludHM7XG5cdCAgICBpZiAoIWJvdW5kcykge1xuXHQgICAgICByZXR1cm4gY29uc3RyYWludHMgPSB7XG5cdCAgICAgICAgbWluWDogSW5maW5pdHksXG5cdCAgICAgICAgbWF4WDogSW5maW5pdHksXG5cdCAgICAgICAgbWluWTogSW5maW5pdHksXG5cdCAgICAgICAgbWF4WTogSW5maW5pdHlcblx0ICAgICAgfTtcblx0ICAgIH1cblx0ICAgIGlmIChib3VuZHMud2lkdGggPCB0aGlzLmxheWVyLndpZHRoKSB7XG5cdCAgICAgIGJvdW5kcy53aWR0aCA9IHRoaXMubGF5ZXIud2lkdGg7XG5cdCAgICB9XG5cdCAgICBpZiAoYm91bmRzLmhlaWdodCA8IHRoaXMubGF5ZXIuaGVpZ2h0KSB7XG5cdCAgICAgIGJvdW5kcy5oZWlnaHQgPSB0aGlzLmxheWVyLmhlaWdodDtcblx0ICAgIH1cblx0ICAgIGNvbnN0cmFpbnRzID0ge1xuXHQgICAgICBtaW5YOiBVdGlscy5mcmFtZUdldE1pblgoYm91bmRzKSxcblx0ICAgICAgbWF4WDogVXRpbHMuZnJhbWVHZXRNYXhYKGJvdW5kcyksXG5cdCAgICAgIG1pblk6IFV0aWxzLmZyYW1lR2V0TWluWShib3VuZHMpLFxuXHQgICAgICBtYXhZOiBVdGlscy5mcmFtZUdldE1heFkoYm91bmRzKVxuXHQgICAgfTtcblx0ICAgIGNvbnN0cmFpbnRzLm1heFggLT0gdGhpcy5sYXllci53aWR0aDtcblx0ICAgIGNvbnN0cmFpbnRzLm1heFkgLT0gdGhpcy5sYXllci5oZWlnaHQ7XG5cdCAgICByZXR1cm4gY29uc3RyYWludHM7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXJEcmFnZ2FibGUucHJvdG90eXBlLl9jb25zdHJhaW5Qb3NpdGlvbiA9IGZ1bmN0aW9uKHByb3Bvc2VkUG9pbnQsIGJvdW5kcywgc2NhbGUpIHtcblx0ICAgIHZhciBtYXhYLCBtYXhZLCBtaW5YLCBtaW5ZLCBwb2ludCwgcmVmO1xuXHQgICAgcmVmID0gdGhpcy5fY2FsY3VsYXRlQ29uc3RyYWludHModGhpcy5fY29uc3RyYWludHMpLCBtaW5YID0gcmVmLm1pblgsIG1heFggPSByZWYubWF4WCwgbWluWSA9IHJlZi5taW5ZLCBtYXhZID0gcmVmLm1heFk7XG5cdCAgICBpZiAodGhpcy5vdmVyZHJhZykge1xuXHQgICAgICBwb2ludCA9IHtcblx0ICAgICAgICB4OiB0aGlzLl9jbGFtcEFuZFNjYWxlKHByb3Bvc2VkUG9pbnQueCwgbWluWCwgbWF4WCwgc2NhbGUpLFxuXHQgICAgICAgIHk6IHRoaXMuX2NsYW1wQW5kU2NhbGUocHJvcG9zZWRQb2ludC55LCBtaW5ZLCBtYXhZLCBzY2FsZSlcblx0ICAgICAgfTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHBvaW50ID0ge1xuXHQgICAgICAgIHg6IFV0aWxzLmNsYW1wKHByb3Bvc2VkUG9pbnQueCwgbWluWCwgbWF4WCksXG5cdCAgICAgICAgeTogVXRpbHMuY2xhbXAocHJvcG9zZWRQb2ludC55LCBtaW5ZLCBtYXhZKVxuXHQgICAgICB9O1xuXHQgICAgfVxuXHQgICAgaWYgKHRoaXMuc3BlZWRYID09PSAwIHx8IHRoaXMuaG9yaXpvbnRhbCA9PT0gZmFsc2UpIHtcblx0ICAgICAgcG9pbnQueCA9IHByb3Bvc2VkUG9pbnQueDtcblx0ICAgIH1cblx0ICAgIGlmICh0aGlzLnNwZWVkWSA9PT0gMCB8fCB0aGlzLnZlcnRpY2FsID09PSBmYWxzZSkge1xuXHQgICAgICBwb2ludC55ID0gcHJvcG9zZWRQb2ludC55O1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHBvaW50O1xuXHQgIH07XG5cdFxuXHQgIExheWVyRHJhZ2dhYmxlLmRlZmluZShcInZlbG9jaXR5XCIsIHtcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIGlmICh0aGlzLmlzQW5pbWF0aW5nKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGN1bGF0ZVNpbXVsYXRpb25WZWxvY2l0eSgpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiB0aGlzLl9ldmVudEJ1ZmZlci52ZWxvY2l0eTtcblx0ICAgICAgcmV0dXJuIHtcblx0ICAgICAgICB4OiAwLFxuXHQgICAgICAgIHk6IDBcblx0ICAgICAgfTtcblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgTGF5ZXJEcmFnZ2FibGUuZGVmaW5lKFwiYW5nbGVcIiwge1xuXHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50QnVmZmVyLmFuZ2xlO1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBMYXllckRyYWdnYWJsZS5kZWZpbmUoXCJkaXJlY3Rpb25cIiwge1xuXHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgdmFyIHZlbG9jaXR5O1xuXHQgICAgICB2ZWxvY2l0eSA9IHRoaXMudmVsb2NpdHk7XG5cdCAgICAgIGlmIChNYXRoLmFicyh2ZWxvY2l0eS54KSA+IE1hdGguYWJzKHZlbG9jaXR5LnkpKSB7XG5cdCAgICAgICAgaWYgKHZlbG9jaXR5LnggPiAwKSB7XG5cdCAgICAgICAgICByZXR1cm4gXCJyaWdodFwiO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gXCJsZWZ0XCI7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgaWYgKHZlbG9jaXR5LnkgPiAwKSB7XG5cdCAgICAgICAgICByZXR1cm4gXCJkb3duXCI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBcInVwXCI7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgTGF5ZXJEcmFnZ2FibGUucHJvdG90eXBlLmNhbGN1bGF0ZVZlbG9jaXR5ID0gZnVuY3Rpb24oKSB7XG5cdCAgICByZXR1cm4gdGhpcy52ZWxvY2l0eTtcblx0ICB9O1xuXHRcblx0ICBMYXllckRyYWdnYWJsZS5wcm90b3R5cGUuX2NhbGN1bGF0ZVNpbXVsYXRpb25WZWxvY2l0eSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIHZlbG9jaXR5LCB4RmluaXNoZWQsIHlGaW5pc2hlZDtcblx0ICAgIHhGaW5pc2hlZCA9IHRoaXMuX3NpbXVsYXRpb24ueC5maW5pc2hlZCgpO1xuXHQgICAgeUZpbmlzaGVkID0gdGhpcy5fc2ltdWxhdGlvbi55LmZpbmlzaGVkKCk7XG5cdCAgICB2ZWxvY2l0eSA9IHtcblx0ICAgICAgeDogMCxcblx0ICAgICAgeTogMFxuXHQgICAgfTtcblx0ICAgIGlmICgheEZpbmlzaGVkKSB7XG5cdCAgICAgIHZlbG9jaXR5LnggPSB0aGlzLl9zaW11bGF0aW9uLnguc2ltdWxhdG9yLnN0YXRlLnYgLyB0aGlzLm1vbWVudHVtVmVsb2NpdHlNdWx0aXBsaWVyO1xuXHQgICAgfVxuXHQgICAgaWYgKCF5RmluaXNoZWQpIHtcblx0ICAgICAgdmVsb2NpdHkueSA9IHRoaXMuX3NpbXVsYXRpb24ueS5zaW11bGF0b3Iuc3RhdGUudiAvIHRoaXMubW9tZW50dW1WZWxvY2l0eU11bHRpcGxpZXI7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdmVsb2NpdHk7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXJEcmFnZ2FibGUucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudE5hbWUsIGV2ZW50KSB7XG5cdCAgICB0aGlzLmxheWVyLmVtaXQoZXZlbnROYW1lLCBldmVudCk7XG5cdCAgICByZXR1cm4gTGF5ZXJEcmFnZ2FibGUuX19zdXBlcl9fLmVtaXQuY2FsbCh0aGlzLCBldmVudE5hbWUsIGV2ZW50KTtcblx0ICB9O1xuXHRcblx0ICBMYXllckRyYWdnYWJsZS5wcm90b3R5cGUuX3VwZGF0ZWRpcmVjdGlvbkxvY2sgPSBmdW5jdGlvbihjb3JyZWN0ZWREZWx0YSkge1xuXHQgICAgdGhpcy5fZGlyZWN0aW9uTG9ja0VuYWJsZWRYID0gTWF0aC5hYnMoY29ycmVjdGVkRGVsdGEueSkgPiB0aGlzLmRpcmVjdGlvbkxvY2tUaHJlc2hvbGQueTtcblx0ICAgIHRoaXMuX2RpcmVjdGlvbkxvY2tFbmFibGVkWSA9IE1hdGguYWJzKGNvcnJlY3RlZERlbHRhLngpID4gdGhpcy5kaXJlY3Rpb25Mb2NrVGhyZXNob2xkLng7XG5cdCAgICBpZiAodGhpcy5fZGlyZWN0aW9uTG9ja0VuYWJsZWRYIHx8IHRoaXMuX2RpcmVjdGlvbkxvY2tFbmFibGVkWSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5lbWl0KEV2ZW50cy5EaXJlY3Rpb25Mb2NrU3RhcnQsIHtcblx0ICAgICAgICB4OiB0aGlzLl9kaXJlY3Rpb25Mb2NrRW5hYmxlZFgsXG5cdCAgICAgICAgeTogdGhpcy5fZGlyZWN0aW9uTG9ja0VuYWJsZWRZXG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgIH07XG5cdFxuXHQgIExheWVyRHJhZ2dhYmxlLnByb3RvdHlwZS5fcmVzZXRkaXJlY3Rpb25Mb2NrID0gZnVuY3Rpb24oKSB7XG5cdCAgICB0aGlzLl9kaXJlY3Rpb25Mb2NrRW5hYmxlZFggPSBmYWxzZTtcblx0ICAgIHJldHVybiB0aGlzLl9kaXJlY3Rpb25Mb2NrRW5hYmxlZFkgPSBmYWxzZTtcblx0ICB9O1xuXHRcblx0ICBMYXllckRyYWdnYWJsZS5wcm90b3R5cGUuX3NldHVwU2ltdWxhdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHQgICAgaWYgKHRoaXMuX3NpbXVsYXRpb24pIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgdGhpcy5fc2ltdWxhdGlvbiA9IHtcblx0ICAgICAgeDogdGhpcy5fc2V0dXBTaW11bGF0aW9uRm9yQXhpcyhcInhcIiksXG5cdCAgICAgIHk6IHRoaXMuX3NldHVwU2ltdWxhdGlvbkZvckF4aXMoXCJ5XCIpXG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZVNpbXVsYXRpb25Db25zdHJhaW50cyh0aGlzLmNvbnN0cmFpbnRzKTtcblx0ICB9O1xuXHRcblx0ICBMYXllckRyYWdnYWJsZS5wcm90b3R5cGUuX3NldHVwU2ltdWxhdGlvbkZvckF4aXMgPSBmdW5jdGlvbihheGlzKSB7XG5cdCAgICB2YXIgcHJvcGVydGllcywgc2ltdWxhdGlvbjtcblx0ICAgIHByb3BlcnRpZXMgPSB7fTtcblx0ICAgIHByb3BlcnRpZXNbYXhpc10gPSB0cnVlO1xuXHQgICAgc2ltdWxhdGlvbiA9IG5ldyBTaW11bGF0aW9uKHtcblx0ICAgICAgbGF5ZXI6IHRoaXMubGF5ZXIsXG5cdCAgICAgIHByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdCAgICAgIG1vZGVsOiBcImluZXJ0aWFsLXNjcm9sbFwiLFxuXHQgICAgICBtb2RlbE9wdGlvbnM6IHtcblx0ICAgICAgICBtb21lbnR1bTogdGhpcy5tb21lbnR1bU9wdGlvbnMsXG5cdCAgICAgICAgYm91bmNlOiB0aGlzLmJvdW5jZU9wdGlvbnNcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICBzaW11bGF0aW9uLm9uKEV2ZW50cy5TaW11bGF0aW9uU3RlcCwgKGZ1bmN0aW9uKF90aGlzKSB7XG5cdCAgICAgIHJldHVybiBmdW5jdGlvbihzdGF0ZSkge1xuXHQgICAgICAgIHJldHVybiBfdGhpcy5fb25TaW11bGF0aW9uU3RlcChheGlzLCBzdGF0ZSk7XG5cdCAgICAgIH07XG5cdCAgICB9KSh0aGlzKSk7XG5cdCAgICBzaW11bGF0aW9uLm9uKEV2ZW50cy5TaW11bGF0aW9uU3RvcCwgKGZ1bmN0aW9uKF90aGlzKSB7XG5cdCAgICAgIHJldHVybiBmdW5jdGlvbihzdGF0ZSkge1xuXHQgICAgICAgIHJldHVybiBfdGhpcy5fb25TaW11bGF0aW9uU3RvcChheGlzLCBzdGF0ZSk7XG5cdCAgICAgIH07XG5cdCAgICB9KSh0aGlzKSk7XG5cdCAgICByZXR1cm4gc2ltdWxhdGlvbjtcblx0ICB9O1xuXHRcblx0ICBMYXllckRyYWdnYWJsZS5wcm90b3R5cGUuX3VwZGF0ZVNpbXVsYXRpb25Db25zdHJhaW50cyA9IGZ1bmN0aW9uKGNvbnN0cmFpbnRzKSB7XG5cdCAgICB2YXIgbWF4WCwgbWF4WSwgbWluWCwgbWluWSwgcmVmO1xuXHQgICAgaWYgKCF0aGlzLl9zaW11bGF0aW9uKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIGlmIChjb25zdHJhaW50cykge1xuXHQgICAgICByZWYgPSB0aGlzLl9jYWxjdWxhdGVDb25zdHJhaW50cyh0aGlzLl9jb25zdHJhaW50cyksIG1pblggPSByZWYubWluWCwgbWF4WCA9IHJlZi5tYXhYLCBtaW5ZID0gcmVmLm1pblksIG1heFkgPSByZWYubWF4WTtcblx0ICAgICAgdGhpcy5fc2ltdWxhdGlvbi54LnNpbXVsYXRvci5vcHRpb25zID0ge1xuXHQgICAgICAgIG1pbjogbWluWCxcblx0ICAgICAgICBtYXg6IG1heFhcblx0ICAgICAgfTtcblx0ICAgICAgcmV0dXJuIHRoaXMuX3NpbXVsYXRpb24ueS5zaW11bGF0b3Iub3B0aW9ucyA9IHtcblx0ICAgICAgICBtaW46IG1pblksXG5cdCAgICAgICAgbWF4OiBtYXhZXG5cdCAgICAgIH07XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aGlzLl9zaW11bGF0aW9uLnguc2ltdWxhdG9yLm9wdGlvbnMgPSB7XG5cdCAgICAgICAgbWluOiAtSW5maW5pdHksXG5cdCAgICAgICAgbWF4OiArSW5maW5pdHlcblx0ICAgICAgfTtcblx0ICAgICAgcmV0dXJuIHRoaXMuX3NpbXVsYXRpb24ueS5zaW11bGF0b3Iub3B0aW9ucyA9IHtcblx0ICAgICAgICBtaW46IC1JbmZpbml0eSxcblx0ICAgICAgICBtYXg6ICtJbmZpbml0eVxuXHQgICAgICB9O1xuXHQgICAgfVxuXHQgIH07XG5cdFxuXHQgIExheWVyRHJhZ2dhYmxlLnByb3RvdHlwZS5fb25TaW11bGF0aW9uU3RlcCA9IGZ1bmN0aW9uKGF4aXMsIHN0YXRlKSB7XG5cdCAgICB2YXIgZGVsdGEsIG1heFgsIG1heFksIG1pblgsIG1pblksIHJlZiwgdXBkYXRlUG9pbnQ7XG5cdCAgICBpZiAoYXhpcyA9PT0gXCJ4XCIgJiYgdGhpcy5ob3Jpem9udGFsID09PSBmYWxzZSkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICBpZiAoYXhpcyA9PT0gXCJ5XCIgJiYgdGhpcy52ZXJ0aWNhbCA9PT0gZmFsc2UpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgaWYgKHRoaXMuY29uc3RyYWludHMpIHtcblx0ICAgICAgaWYgKHRoaXMuYm91bmNlKSB7XG5cdCAgICAgICAgZGVsdGEgPSBzdGF0ZS54IC0gdGhpcy5sYXllcltheGlzXTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByZWYgPSB0aGlzLl9jYWxjdWxhdGVDb25zdHJhaW50cyh0aGlzLl9jb25zdHJhaW50cyksIG1pblggPSByZWYubWluWCwgbWF4WCA9IHJlZi5tYXhYLCBtaW5ZID0gcmVmLm1pblksIG1heFkgPSByZWYubWF4WTtcblx0ICAgICAgICBpZiAoYXhpcyA9PT0gXCJ4XCIpIHtcblx0ICAgICAgICAgIGRlbHRhID0gVXRpbHMuY2xhbXAoc3RhdGUueCwgbWluWCwgbWF4WCkgLSB0aGlzLmxheWVyW2F4aXNdO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoYXhpcyA9PT0gXCJ5XCIpIHtcblx0ICAgICAgICAgIGRlbHRhID0gVXRpbHMuY2xhbXAoc3RhdGUueCwgbWluWSwgbWF4WSkgLSB0aGlzLmxheWVyW2F4aXNdO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZGVsdGEgPSBzdGF0ZS54IC0gdGhpcy5sYXllcltheGlzXTtcblx0ICAgIH1cblx0ICAgIHVwZGF0ZVBvaW50ID0gdGhpcy5sYXllci5wb2ludDtcblx0ICAgIGlmIChheGlzID09PSBcInhcIikge1xuXHQgICAgICB1cGRhdGVQb2ludFtheGlzXSA9IHVwZGF0ZVBvaW50W2F4aXNdICsgZGVsdGE7XG5cdCAgICB9XG5cdCAgICBpZiAoYXhpcyA9PT0gXCJ5XCIpIHtcblx0ICAgICAgdXBkYXRlUG9pbnRbYXhpc10gPSB1cGRhdGVQb2ludFtheGlzXSArIGRlbHRhO1xuXHQgICAgfVxuXHQgICAgdGhpcy51cGRhdGVQb3NpdGlvbih1cGRhdGVQb2ludCk7XG5cdCAgICB0aGlzLmxheWVyW2F4aXNdID0gdGhpcy51cGRhdGVQb3NpdGlvbih1cGRhdGVQb2ludClbYXhpc107XG5cdCAgICByZXR1cm4gdGhpcy5lbWl0KEV2ZW50cy5Nb3ZlLCB0aGlzLmxheWVyLnBvaW50KTtcblx0ICB9O1xuXHRcblx0ICBMYXllckRyYWdnYWJsZS5wcm90b3R5cGUuX29uU2ltdWxhdGlvblN0b3AgPSBmdW5jdGlvbihheGlzLCBzdGF0ZSkge1xuXHQgICAgaWYgKGF4aXMgPT09IFwieFwiICYmIHRoaXMuaG9yaXpvbnRhbCA9PT0gZmFsc2UpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgaWYgKGF4aXMgPT09IFwieVwiICYmIHRoaXMudmVydGljYWwgPT09IGZhbHNlKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIGlmICghdGhpcy5fc2ltdWxhdGlvbikge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICBpZiAodGhpcy5waXhlbEFsaWduKSB7XG5cdCAgICAgIHRoaXMubGF5ZXJbYXhpc10gPSBwYXJzZUludCh0aGlzLmxheWVyW2F4aXNdKTtcblx0ICAgIH1cblx0ICAgIGlmICh0aGlzLl9zaW11bGF0aW9uLnguZmluaXNoZWQoKSAmJiB0aGlzLl9zaW11bGF0aW9uLnkuZmluaXNoZWQoKSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fc3RvcFNpbXVsYXRpb24oKTtcblx0ICAgIH1cblx0ICB9O1xuXHRcblx0ICBMYXllckRyYWdnYWJsZS5wcm90b3R5cGUuX3N0YXJ0U2ltdWxhdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIG1heFgsIG1heFksIG1pblgsIG1pblksIHJlZiwgc3RhcnRTaW11bGF0aW9uWCwgc3RhcnRTaW11bGF0aW9uWSwgdmVsb2NpdHksIHZlbG9jaXR5WCwgdmVsb2NpdHlZO1xuXHQgICAgaWYgKCEodGhpcy5tb21lbnR1bSB8fCB0aGlzLmJvdW5jZSkpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgaWYgKHRoaXMuaXNCZXlvbmRDb25zdHJhaW50cyA9PT0gZmFsc2UgJiYgdGhpcy5tb21lbnR1bSA9PT0gZmFsc2UpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgaWYgKHRoaXMuaXNCZXlvbmRDb25zdHJhaW50cyA9PT0gZmFsc2UgJiYgdGhpcy5pc0RyYWdnaW5nID09PSBmYWxzZSkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICByZWYgPSB0aGlzLl9jYWxjdWxhdGVDb25zdHJhaW50cyh0aGlzLl9jb25zdHJhaW50cyksIG1pblggPSByZWYubWluWCwgbWF4WCA9IHJlZi5tYXhYLCBtaW5ZID0gcmVmLm1pblksIG1heFkgPSByZWYubWF4WTtcblx0ICAgIHN0YXJ0U2ltdWxhdGlvblggPSB0aGlzLm92ZXJkcmFnID09PSB0cnVlIHx8ICh0aGlzLmxheWVyLnggPiBtaW5YICYmIHRoaXMubGF5ZXIueCA8IG1heFgpO1xuXHQgICAgc3RhcnRTaW11bGF0aW9uWSA9IHRoaXMub3ZlcmRyYWcgPT09IHRydWUgfHwgKHRoaXMubGF5ZXIueSA+IG1pblkgJiYgdGhpcy5sYXllci55IDwgbWF4WSk7XG5cdCAgICBpZiAoKHN0YXJ0U2ltdWxhdGlvblggPT09IHN0YXJ0U2ltdWxhdGlvblkgJiYgc3RhcnRTaW11bGF0aW9uWSA9PT0gZmFsc2UpKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHZlbG9jaXR5ID0gdGhpcy52ZWxvY2l0eTtcblx0ICAgIHZlbG9jaXR5WCA9IHZlbG9jaXR5LnggKiB0aGlzLm1vbWVudHVtVmVsb2NpdHlNdWx0aXBsaWVyICogdGhpcy5zcGVlZFggKiAoMSAvIHRoaXMubGF5ZXIuY2FudmFzU2NhbGVYKCkpICogdGhpcy5sYXllci5zY2FsZVggKiB0aGlzLmxheWVyLnNjYWxlO1xuXHQgICAgdmVsb2NpdHlZID0gdmVsb2NpdHkueSAqIHRoaXMubW9tZW50dW1WZWxvY2l0eU11bHRpcGxpZXIgKiB0aGlzLnNwZWVkWSAqICgxIC8gdGhpcy5sYXllci5jYW52YXNTY2FsZVkoKSkgKiB0aGlzLmxheWVyLnNjYWxlWSAqIHRoaXMubGF5ZXIuc2NhbGU7XG5cdCAgICB0aGlzLl9zZXR1cFNpbXVsYXRpb24oKTtcblx0ICAgIHRoaXMuX2lzQW5pbWF0aW5nID0gdHJ1ZTtcblx0ICAgIHRoaXMuX2lzTW92aW5nID0gdHJ1ZTtcblx0ICAgIHRoaXMuX3NpbXVsYXRpb24ueC5zaW11bGF0b3Iuc2V0U3RhdGUoe1xuXHQgICAgICB4OiB0aGlzLmxheWVyLngsXG5cdCAgICAgIHY6IHZlbG9jaXR5WFxuXHQgICAgfSk7XG5cdCAgICBpZiAoc3RhcnRTaW11bGF0aW9uWCkge1xuXHQgICAgICB0aGlzLl9zaW11bGF0aW9uLnguc3RhcnQoKTtcblx0ICAgIH1cblx0ICAgIHRoaXMuX3NpbXVsYXRpb24ueS5zaW11bGF0b3Iuc2V0U3RhdGUoe1xuXHQgICAgICB4OiB0aGlzLmxheWVyLnksXG5cdCAgICAgIHY6IHZlbG9jaXR5WVxuXHQgICAgfSk7XG5cdCAgICBpZiAoc3RhcnRTaW11bGF0aW9uWSkge1xuXHQgICAgICB0aGlzLl9zaW11bGF0aW9uLnkuc3RhcnQoKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0aGlzLmVtaXQoRXZlbnRzLkRyYWdBbmltYXRpb25TdGFydCk7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXJEcmFnZ2FibGUucHJvdG90eXBlLl9zdG9wU2ltdWxhdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIHJlZiwgcmVmMTtcblx0ICAgIHRoaXMuX2lzQW5pbWF0aW5nID0gZmFsc2U7XG5cdCAgICBpZiAoIXRoaXMuX3NpbXVsYXRpb24pIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgaWYgKChyZWYgPSB0aGlzLl9zaW11bGF0aW9uKSAhPSBudWxsKSB7XG5cdCAgICAgIHJlZi54LnN0b3AoKTtcblx0ICAgIH1cblx0ICAgIGlmICgocmVmMSA9IHRoaXMuX3NpbXVsYXRpb24pICE9IG51bGwpIHtcblx0ICAgICAgcmVmMS55LnN0b3AoKTtcblx0ICAgIH1cblx0ICAgIHRoaXMuX3NpbXVsYXRpb24gPSBudWxsO1xuXHQgICAgdGhpcy5lbWl0KEV2ZW50cy5Nb3ZlLCB0aGlzLmxheWVyLnBvaW50KTtcblx0ICAgIHJldHVybiB0aGlzLmVtaXQoRXZlbnRzLkRyYWdBbmltYXRpb25FbmQpO1xuXHQgIH07XG5cdFxuXHQgIExheWVyRHJhZ2dhYmxlLnByb3RvdHlwZS5hbmltYXRlU3RvcCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX3N0b3BTaW11bGF0aW9uKCk7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXJEcmFnZ2FibGUucHJvdG90eXBlLm9uTW92ZSA9IGZ1bmN0aW9uKGNiKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vbihFdmVudHMuTW92ZSwgY2IpO1xuXHQgIH07XG5cdFxuXHQgIExheWVyRHJhZ2dhYmxlLnByb3RvdHlwZS5vbkRyYWdTdGFydCA9IGZ1bmN0aW9uKGNiKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vbihFdmVudHMuRHJhZ1N0YXJ0LCBjYik7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXJEcmFnZ2FibGUucHJvdG90eXBlLm9uRHJhZ1dpbGxNb3ZlID0gZnVuY3Rpb24oY2IpIHtcblx0ICAgIHJldHVybiB0aGlzLm9uKEV2ZW50cy5EcmFnV2lsbE1vdmUsIGNiKTtcblx0ICB9O1xuXHRcblx0ICBMYXllckRyYWdnYWJsZS5wcm90b3R5cGUub25EcmFnTW92ZSA9IGZ1bmN0aW9uKGNiKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vbihFdmVudHMuRHJhZ01vdmUsIGNiKTtcblx0ICB9O1xuXHRcblx0ICBMYXllckRyYWdnYWJsZS5wcm90b3R5cGUub25EcmFnRGlkTW92ZSA9IGZ1bmN0aW9uKGNiKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vbihFdmVudHMuRHJhZ0RpZE1vdmUsIGNiKTtcblx0ICB9O1xuXHRcblx0ICBMYXllckRyYWdnYWJsZS5wcm90b3R5cGUub25EcmFnID0gZnVuY3Rpb24oY2IpIHtcblx0ICAgIHJldHVybiB0aGlzLm9uKEV2ZW50cy5EcmFnLCBjYik7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXJEcmFnZ2FibGUucHJvdG90eXBlLm9uRHJhZ0VuZCA9IGZ1bmN0aW9uKGNiKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vbihFdmVudHMuRHJhZ0VuZCwgY2IpO1xuXHQgIH07XG5cdFxuXHQgIExheWVyRHJhZ2dhYmxlLnByb3RvdHlwZS5vbkRyYWdBbmltYXRpb25TdGFydCA9IGZ1bmN0aW9uKGNiKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vbihFdmVudHMuRHJhZ0FuaW1hdGlvblN0YXJ0LCBjYik7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXJEcmFnZ2FibGUucHJvdG90eXBlLm9uRHJhZ0FuaW1hdGlvbkVuZCA9IGZ1bmN0aW9uKGNiKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vbihFdmVudHMuRHJhZ0FuaW1hdGlvbkVuZCwgY2IpO1xuXHQgIH07XG5cdFxuXHQgIExheWVyRHJhZ2dhYmxlLnByb3RvdHlwZS5vbkRpcmVjdGlvbkxvY2tTdGFydCA9IGZ1bmN0aW9uKGNiKSB7XG5cdCAgICByZXR1cm4gdGhpcy5vbihFdmVudHMuRGlyZWN0aW9uTG9ja1N0YXJ0LCBjYik7XG5cdCAgfTtcblx0XG5cdCAgcmV0dXJuIExheWVyRHJhZ2dhYmxlO1xuXHRcblx0fSkoQmFzZUNsYXNzKTtcblxuXG4vKioqLyB9LFxuLyogMjggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBCYXNlQ2xhc3MsIENvbmZpZywgRGVmYXVsdHMsIEV2ZW50cywgRnJpY3Rpb25TaW11bGF0b3IsIE1vbWVudHVtQm91bmNlU2ltdWxhdG9yLCBTaW11bGF0b3JDbGFzc2VzLCBTcHJpbmdTaW11bGF0b3IsIFV0aWxzLCBfLFxuXHQgIGJpbmQgPSBmdW5jdGlvbihmbiwgbWUpeyByZXR1cm4gZnVuY3Rpb24oKXsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9OyB9LFxuXHQgIGV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcblx0ICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXG5cdCAgaW5kZXhPZiA9IFtdLmluZGV4T2YgfHwgZnVuY3Rpb24oaXRlbSkgeyBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7IGlmIChpIGluIHRoaXMgJiYgdGhpc1tpXSA9PT0gaXRlbSkgcmV0dXJuIGk7IH0gcmV0dXJuIC0xOyB9O1xuXHRcblx0XyA9IF9fd2VicGFja19yZXF1aXJlX18oMSkuXztcblx0XG5cdFV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0XG5cdENvbmZpZyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpLkNvbmZpZztcblx0XG5cdERlZmF1bHRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNykuRGVmYXVsdHM7XG5cdFxuXHRCYXNlQ2xhc3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpLkJhc2VDbGFzcztcblx0XG5cdEV2ZW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpLkV2ZW50cztcblx0XG5cdFNwcmluZ1NpbXVsYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpLlNwcmluZ1NpbXVsYXRvcjtcblx0XG5cdEZyaWN0aW9uU2ltdWxhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSkuRnJpY3Rpb25TaW11bGF0b3I7XG5cdFxuXHRNb21lbnR1bUJvdW5jZVNpbXVsYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpLk1vbWVudHVtQm91bmNlU2ltdWxhdG9yO1xuXHRcblx0RXZlbnRzLlNpbXVsYXRpb25TdGFydCA9ICdzaW11bGF0aW9uU3RhcnQnO1xuXHRcblx0RXZlbnRzLlNpbXVsYXRpb25TdGVwID0gJ3NpbXVsYXRpb25TdGVwJztcblx0XG5cdEV2ZW50cy5TaW11bGF0aW9uU3RvcCA9ICdzaW11bGF0aW9uU3RvcCc7XG5cdFxuXHRTaW11bGF0b3JDbGFzc2VzID0ge1xuXHQgIFwic3ByaW5nXCI6IFNwcmluZ1NpbXVsYXRvcixcblx0ICBcImZyaWN0aW9uXCI6IEZyaWN0aW9uU2ltdWxhdG9yLFxuXHQgIFwiaW5lcnRpYWwtc2Nyb2xsXCI6IE1vbWVudHVtQm91bmNlU2ltdWxhdG9yXG5cdH07XG5cdFxuXHRleHBvcnRzLlNpbXVsYXRpb24gPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuXHQgIGV4dGVuZChTaW11bGF0aW9uLCBzdXBlckNsYXNzKTtcblx0XG5cdCAgZnVuY3Rpb24gU2ltdWxhdGlvbihvcHRpb25zKSB7XG5cdCAgICB2YXIgU2ltdWxhdG9yQ2xhc3M7XG5cdCAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG5cdCAgICAgIG9wdGlvbnMgPSB7fTtcblx0ICAgIH1cblx0ICAgIHRoaXMuX3VwZGF0ZSA9IGJpbmQodGhpcy5fdXBkYXRlLCB0aGlzKTtcblx0ICAgIHRoaXMuX3N0YXJ0ID0gYmluZCh0aGlzLl9zdGFydCwgdGhpcyk7XG5cdCAgICB0aGlzLnN0YXJ0ID0gYmluZCh0aGlzLnN0YXJ0LCB0aGlzKTtcblx0ICAgIFNpbXVsYXRpb24uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICB0aGlzLm9wdGlvbnMgPSBfLmRlZmF1bHRzKG9wdGlvbnMsIHtcblx0ICAgICAgbGF5ZXI6IG51bGwsXG5cdCAgICAgIHByb3BlcnRpZXM6IHt9LFxuXHQgICAgICBtb2RlbDogXCJzcHJpbmdcIixcblx0ICAgICAgbW9kZWxPcHRpb25zOiB7fSxcblx0ICAgICAgZGVsYXk6IDAsXG5cdCAgICAgIGRlYnVnOiBmYWxzZVxuXHQgICAgfSk7XG5cdCAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG5cdCAgICBTaW11bGF0b3JDbGFzcyA9IFNpbXVsYXRvckNsYXNzZXNbdGhpcy5vcHRpb25zLm1vZGVsXSB8fCBTcHJpbmdTaW11bGF0b3I7XG5cdCAgICB0aGlzLl9zaW11bGF0b3IgPSBuZXcgU2ltdWxhdG9yQ2xhc3ModGhpcy5vcHRpb25zLm1vZGVsT3B0aW9ucyk7XG5cdCAgfVxuXHRcblx0ICBTaW11bGF0aW9uLnByb3RvdHlwZS5hbmltYXRpbmdQcm9wZXJ0aWVzID0gZnVuY3Rpb24oKSB7XG5cdCAgICByZXR1cm4gXy5rZXlzKHRoaXMub3B0aW9ucy5wcm9wZXJ0aWVzKTtcblx0ICB9O1xuXHRcblx0ICBTaW11bGF0aW9uLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIGFuaW1hdGluZ1Byb3BlcnRpZXMsIGFuaW1hdGlvbiwgcHJvcGVydHksIHJlZjtcblx0ICAgIGlmICh0aGlzLm9wdGlvbnMubGF5ZXIgPT09IG51bGwpIHtcblx0ICAgICAgY29uc29sZS5lcnJvcihcIlNpbXVsYXRpb246IG1pc3NpbmcgbGF5ZXJcIik7XG5cdCAgICB9XG5cdCAgICBpZiAodGhpcy5vcHRpb25zLmRlYnVnKSB7XG5cdCAgICAgIGNvbnNvbGUubG9nKFwiU2ltdWxhdGlvbi5zdGFydCBcIiArIHRoaXMuX3NpbXVsYXRvci5jb25zdHJ1Y3Rvci5uYW1lLCB0aGlzLm9wdGlvbnMubW9kZWxPcHRpb25zKTtcblx0ICAgIH1cblx0ICAgIGFuaW1hdGluZ1Byb3BlcnRpZXMgPSB0aGlzLmFuaW1hdGluZ1Byb3BlcnRpZXMoKTtcblx0ICAgIHJlZiA9IHRoaXMub3B0aW9ucy5sYXllci5hbmltYXRpbmdQcm9wZXJ0aWVzKCk7XG5cdCAgICBmb3IgKHByb3BlcnR5IGluIHJlZikge1xuXHQgICAgICBhbmltYXRpb24gPSByZWZbcHJvcGVydHldO1xuXHQgICAgICBpZiAoaW5kZXhPZi5jYWxsKGFuaW1hdGluZ1Byb3BlcnRpZXMsIHByb3BlcnR5KSA+PSAwKSB7XG5cdCAgICAgICAgYW5pbWF0aW9uLnN0b3AoKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKHRoaXMub3B0aW9ucy5kZWxheSkge1xuXHQgICAgICBVdGlscy5kZWxheSh0aGlzLm9wdGlvbnMuZGVsYXksIHRoaXMuX3N0YXJ0KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRoaXMuX3N0YXJ0KCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9O1xuXHRcblx0ICBTaW11bGF0aW9uLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oZW1pdCkge1xuXHQgICAgaWYgKGVtaXQgPT0gbnVsbCkge1xuXHQgICAgICBlbWl0ID0gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIGlmICghdGhpcy5fcnVubmluZykge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG5cdCAgICB0aGlzLm9wdGlvbnMubGF5ZXIuY29udGV4dC5yZW1vdmVBbmltYXRpb24odGhpcyk7XG5cdCAgICBpZiAoZW1pdCkge1xuXHQgICAgICB0aGlzLmVtaXQoRXZlbnRzLlNpbXVsYXRpb25TdG9wKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBGcmFtZXIuTG9vcC5vZmYoXCJ1cGRhdGVcIiwgdGhpcy5fdXBkYXRlKTtcblx0ICB9O1xuXHRcblx0ICBTaW11bGF0aW9uLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0ICAgIFNpbXVsYXRpb24uX19zdXBlcl9fLmVtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgIHJldHVybiB0aGlzLm9wdGlvbnMubGF5ZXIuZW1pdChldmVudCwgdGhpcyk7XG5cdCAgfTtcblx0XG5cdCAgU2ltdWxhdGlvbi5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cdCAgICBpZiAodGhpcy5fcnVubmluZykge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICB0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcblx0ICAgIHRoaXMub3B0aW9ucy5sYXllci5jb250ZXh0LmFkZEFuaW1hdGlvbih0aGlzKTtcblx0ICAgIHRoaXMuZW1pdChFdmVudHMuU2ltdWxhdGlvblN0YXJ0KTtcblx0ICAgIHJldHVybiBGcmFtZXIuTG9vcC5vbihcInVwZGF0ZVwiLCB0aGlzLl91cGRhdGUpO1xuXHQgIH07XG5cdFxuXHQgIFNpbXVsYXRpb24ucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbihkZWx0YSkge1xuXHQgICAgdmFyIGVtaXQsIHJlc3VsdDtcblx0ICAgIGlmICh0aGlzLl9zaW11bGF0b3IuZmluaXNoZWQoKSkge1xuXHQgICAgICB0aGlzLnN0b3AoZW1pdCA9IGZhbHNlKTtcblx0ICAgICAgdGhpcy5lbWl0KFwiZW5kXCIpO1xuXHQgICAgICByZXR1cm4gdGhpcy5lbWl0KEV2ZW50cy5TaW11bGF0aW9uU3RvcCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXN1bHQgPSB0aGlzLl9zaW11bGF0b3IubmV4dChkZWx0YSk7XG5cdCAgICAgIHJldHVybiB0aGlzLmVtaXQoRXZlbnRzLlNpbXVsYXRpb25TdGVwLCByZXN1bHQsIGRlbHRhKTtcblx0ICAgIH1cblx0ICB9O1xuXHRcblx0ICBTaW11bGF0aW9uLmRlZmluZShcInNpbXVsYXRvclwiLCB7XG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fc2ltdWxhdG9yO1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBTaW11bGF0aW9uLnByb3RvdHlwZS5maW5pc2hlZCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX3NpbXVsYXRvci5maW5pc2hlZCgpO1xuXHQgIH07XG5cdFxuXHQgIHJldHVybiBTaW11bGF0aW9uO1xuXHRcblx0fSkoQmFzZUNsYXNzKTtcblxuXG4vKioqLyB9LFxuLyogMjkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBEZWZhdWx0cywgSW50ZWdyYXRvciwgU2ltdWxhdG9yLCBVdGlscyxcblx0ICBiaW5kID0gZnVuY3Rpb24oZm4sIG1lKXsgcmV0dXJuIGZ1bmN0aW9uKCl7IHJldHVybiBmbi5hcHBseShtZSwgYXJndW1lbnRzKTsgfTsgfSxcblx0ICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG5cdCAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXHRcblx0VXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHRcblx0RGVmYXVsdHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KS5EZWZhdWx0cztcblx0XG5cdFNpbXVsYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oMzApLlNpbXVsYXRvcjtcblx0XG5cdEludGVncmF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKS5JbnRlZ3JhdG9yO1xuXHRcblx0ZXhwb3J0cy5TcHJpbmdTaW11bGF0b3IgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuXHQgIGV4dGVuZChTcHJpbmdTaW11bGF0b3IsIHN1cGVyQ2xhc3MpO1xuXHRcblx0ICBmdW5jdGlvbiBTcHJpbmdTaW11bGF0b3IoKSB7XG5cdCAgICB0aGlzLmZpbmlzaGVkID0gYmluZCh0aGlzLmZpbmlzaGVkLCB0aGlzKTtcblx0ICAgIHJldHVybiBTcHJpbmdTaW11bGF0b3IuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgfVxuXHRcblx0ICBTcHJpbmdTaW11bGF0b3IucHJvdG90eXBlLnNldHVwID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHQgICAgdGhpcy5vcHRpb25zID0gRGVmYXVsdHMuZ2V0RGVmYXVsdHMoXCJTcHJpbmdTaW11bGF0b3JcIiwgb3B0aW9ucyk7XG5cdCAgICB0aGlzLm9wdGlvbnMgPSBfLmRlZmF1bHRzKG9wdGlvbnMsIHtcblx0ICAgICAgdmVsb2NpdHk6IDAsXG5cdCAgICAgIHBvc2l0aW9uOiAwLFxuXHQgICAgICBvZmZzZXQ6IDBcblx0ICAgIH0pO1xuXHQgICAgdGhpcy5fc3RhdGUgPSB7XG5cdCAgICAgIHg6IHRoaXMub3B0aW9ucy5wb3NpdGlvbixcblx0ICAgICAgdjogdGhpcy5vcHRpb25zLnZlbG9jaXR5XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIHRoaXMuX2ludGVncmF0b3IgPSBuZXcgSW50ZWdyYXRvcigoZnVuY3Rpb24oX3RoaXMpIHtcblx0ICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0YXRlKSB7XG5cdCAgICAgICAgcmV0dXJuIC1fdGhpcy5vcHRpb25zLnRlbnNpb24gKiBzdGF0ZS54IC0gX3RoaXMub3B0aW9ucy5mcmljdGlvbiAqIHN0YXRlLnY7XG5cdCAgICAgIH07XG5cdCAgICB9KSh0aGlzKSk7XG5cdCAgfTtcblx0XG5cdCAgU3ByaW5nU2ltdWxhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oZGVsdGEpIHtcblx0ICAgIHRoaXMuX3N0YXRlID0gdGhpcy5faW50ZWdyYXRvci5pbnRlZ3JhdGVTdGF0ZSh0aGlzLl9zdGF0ZSwgZGVsdGEpO1xuXHQgICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGUoKTtcblx0ICB9O1xuXHRcblx0ICBTcHJpbmdTaW11bGF0b3IucHJvdG90eXBlLmZpbmlzaGVkID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgcG9zaXRpb25OZWFyWmVybywgdmVsb2NpdHlOZWFyWmVybztcblx0ICAgIHBvc2l0aW9uTmVhclplcm8gPSBNYXRoLmFicyh0aGlzLl9zdGF0ZS54KSA8IHRoaXMub3B0aW9ucy50b2xlcmFuY2U7XG5cdCAgICB2ZWxvY2l0eU5lYXJaZXJvID0gTWF0aC5hYnModGhpcy5fc3RhdGUudikgPCB0aGlzLm9wdGlvbnMudG9sZXJhbmNlO1xuXHQgICAgcmV0dXJuIHBvc2l0aW9uTmVhclplcm8gJiYgdmVsb2NpdHlOZWFyWmVybztcblx0ICB9O1xuXHRcblx0ICBTcHJpbmdTaW11bGF0b3IucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24oc3RhdGUpIHtcblx0ICAgIHJldHVybiB0aGlzLl9zdGF0ZSA9IHtcblx0ICAgICAgeDogc3RhdGUueCAtIHRoaXMub3B0aW9ucy5vZmZzZXQsXG5cdCAgICAgIHY6IHN0YXRlLnZcblx0ICAgIH07XG5cdCAgfTtcblx0XG5cdCAgU3ByaW5nU2ltdWxhdG9yLnByb3RvdHlwZS5nZXRTdGF0ZSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIHN0YXRlO1xuXHQgICAgcmV0dXJuIHN0YXRlID0ge1xuXHQgICAgICB4OiB0aGlzLl9zdGF0ZS54ICsgdGhpcy5vcHRpb25zLm9mZnNldCxcblx0ICAgICAgdjogdGhpcy5fc3RhdGUudlxuXHQgICAgfTtcblx0ICB9O1xuXHRcblx0ICByZXR1cm4gU3ByaW5nU2ltdWxhdG9yO1xuXHRcblx0fSkoU2ltdWxhdG9yKTtcblxuXG4vKioqLyB9LFxuLyogMzAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBCYXNlQ2xhc3MsIENvbmZpZywgVXRpbHMsIF8sXG5cdCAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuXHQgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblx0XG5cdFV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0XG5cdF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpLl87XG5cdFxuXHRDb25maWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KS5Db25maWc7XG5cdFxuXHRCYXNlQ2xhc3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpLkJhc2VDbGFzcztcblx0XG5cdGV4cG9ydHMuU2ltdWxhdG9yID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcblx0ICBcIlRoZSBzaW11bGF0b3IgY2xhc3MgcnVucyBhIHBoeXNpY3Mgc2ltdWxhdGlvbiBiYXNlZCBvbiBhIHNldCBvZiBpbnB1dCB2YWx1ZXNcXG5hdCBzZXR1cCh7aW5wdXQgdmFsdWVzfSksIGFuZCBlbWl0cyBhbiBvdXRwdXQgc3RhdGUge3gsIHZ9XCI7XG5cdCAgZXh0ZW5kKFNpbXVsYXRvciwgc3VwZXJDbGFzcyk7XG5cdFxuXHQgIFNpbXVsYXRvci5kZWZpbmUoXCJzdGF0ZVwiLCB7XG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gXy5jbG9uZSh0aGlzLl9zdGF0ZSk7XG5cdCAgICB9LFxuXHQgICAgc2V0OiBmdW5jdGlvbihzdGF0ZSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fc3RhdGUgPSBfLmNsb25lKHN0YXRlKTtcblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgZnVuY3Rpb24gU2ltdWxhdG9yKG9wdGlvbnMpIHtcblx0ICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcblx0ICAgICAgb3B0aW9ucyA9IHt9O1xuXHQgICAgfVxuXHQgICAgdGhpcy5fc3RhdGUgPSB7XG5cdCAgICAgIHg6IDAsXG5cdCAgICAgIHY6IDBcblx0ICAgIH07XG5cdCAgICB0aGlzLm9wdGlvbnMgPSBudWxsO1xuXHQgICAgdGhpcy5zZXR1cChvcHRpb25zKTtcblx0ICB9XG5cdFxuXHQgIFNpbXVsYXRvci5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cdCAgICB0aHJvdyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcblx0ICB9O1xuXHRcblx0ICBTaW11bGF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbihkZWx0YSkge1xuXHQgICAgdGhyb3cgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG5cdCAgfTtcblx0XG5cdCAgU2ltdWxhdG9yLnByb3RvdHlwZS5maW5pc2hlZCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdGhyb3cgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG5cdCAgfTtcblx0XG5cdCAgcmV0dXJuIFNpbXVsYXRvcjtcblx0XG5cdH0pKEJhc2VDbGFzcyk7XG5cblxuLyoqKi8gfSxcbi8qIDMxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgRGVmYXVsdHMsIEludGVncmF0b3IsIFNpbXVsYXRvciwgVXRpbHMsXG5cdCAgYmluZCA9IGZ1bmN0aW9uKGZuLCBtZSl7IHJldHVybiBmdW5jdGlvbigpeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH0sXG5cdCAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuXHQgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblx0XG5cdFV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0XG5cdERlZmF1bHRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNykuRGVmYXVsdHM7XG5cdFxuXHRTaW11bGF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKS5TaW11bGF0b3I7XG5cdFxuXHRJbnRlZ3JhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMykuSW50ZWdyYXRvcjtcblx0XG5cdGV4cG9ydHMuRnJpY3Rpb25TaW11bGF0b3IgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuXHQgIGV4dGVuZChGcmljdGlvblNpbXVsYXRvciwgc3VwZXJDbGFzcyk7XG5cdFxuXHQgIGZ1bmN0aW9uIEZyaWN0aW9uU2ltdWxhdG9yKCkge1xuXHQgICAgdGhpcy5maW5pc2hlZCA9IGJpbmQodGhpcy5maW5pc2hlZCwgdGhpcyk7XG5cdCAgICByZXR1cm4gRnJpY3Rpb25TaW11bGF0b3IuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgfVxuXHRcblx0ICBGcmljdGlvblNpbXVsYXRvci5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cdCAgICB0aGlzLm9wdGlvbnMgPSBEZWZhdWx0cy5nZXREZWZhdWx0cyhcIkZyaWN0aW9uU2ltdWxhdG9yXCIsIG9wdGlvbnMpO1xuXHQgICAgdGhpcy5vcHRpb25zID0gXy5kZWZhdWx0cyhvcHRpb25zLCB7XG5cdCAgICAgIHZlbG9jaXR5OiAwLFxuXHQgICAgICBwb3NpdGlvbjogMFxuXHQgICAgfSk7XG5cdCAgICB0aGlzLl9zdGF0ZSA9IHtcblx0ICAgICAgeDogdGhpcy5vcHRpb25zLnBvc2l0aW9uLFxuXHQgICAgICB2OiB0aGlzLm9wdGlvbnMudmVsb2NpdHlcblx0ICAgIH07XG5cdCAgICByZXR1cm4gdGhpcy5faW50ZWdyYXRvciA9IG5ldyBJbnRlZ3JhdG9yKChmdW5jdGlvbihfdGhpcykge1xuXHQgICAgICByZXR1cm4gZnVuY3Rpb24oc3RhdGUpIHtcblx0ICAgICAgICByZXR1cm4gLShfdGhpcy5vcHRpb25zLmZyaWN0aW9uICogc3RhdGUudik7XG5cdCAgICAgIH07XG5cdCAgICB9KSh0aGlzKSk7XG5cdCAgfTtcblx0XG5cdCAgRnJpY3Rpb25TaW11bGF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbihkZWx0YSkge1xuXHQgICAgdGhpcy5fc3RhdGUgPSB0aGlzLl9pbnRlZ3JhdG9yLmludGVncmF0ZVN0YXRlKHRoaXMuX3N0YXRlLCBkZWx0YSk7XG5cdCAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG5cdCAgfTtcblx0XG5cdCAgRnJpY3Rpb25TaW11bGF0b3IucHJvdG90eXBlLmZpbmlzaGVkID0gZnVuY3Rpb24oKSB7XG5cdCAgICByZXR1cm4gTWF0aC5hYnModGhpcy5fc3RhdGUudikgPCB0aGlzLm9wdGlvbnMudG9sZXJhbmNlO1xuXHQgIH07XG5cdFxuXHQgIHJldHVybiBGcmljdGlvblNpbXVsYXRvcjtcblx0XG5cdH0pKFNpbXVsYXRvcik7XG5cblxuLyoqKi8gfSxcbi8qIDMyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgRGVmYXVsdHMsIEZyaWN0aW9uU2ltdWxhdG9yLCBTaW11bGF0b3IsIFNwcmluZ1NpbXVsYXRvciwgVXRpbHMsXG5cdCAgYmluZCA9IGZ1bmN0aW9uKGZuLCBtZSl7IHJldHVybiBmdW5jdGlvbigpeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH0sXG5cdCAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuXHQgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblx0XG5cdFV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0XG5cdERlZmF1bHRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNykuRGVmYXVsdHM7XG5cdFxuXHRTaW11bGF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKS5TaW11bGF0b3I7XG5cdFxuXHRTcHJpbmdTaW11bGF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KS5TcHJpbmdTaW11bGF0b3I7XG5cdFxuXHRGcmljdGlvblNpbXVsYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpLkZyaWN0aW9uU2ltdWxhdG9yO1xuXHRcblx0ZXhwb3J0cy5Nb21lbnR1bUJvdW5jZVNpbXVsYXRvciA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG5cdCAgZXh0ZW5kKE1vbWVudHVtQm91bmNlU2ltdWxhdG9yLCBzdXBlckNsYXNzKTtcblx0XG5cdCAgZnVuY3Rpb24gTW9tZW50dW1Cb3VuY2VTaW11bGF0b3IoKSB7XG5cdCAgICB0aGlzLmZpbmlzaGVkID0gYmluZCh0aGlzLmZpbmlzaGVkLCB0aGlzKTtcblx0ICAgIHJldHVybiBNb21lbnR1bUJvdW5jZVNpbXVsYXRvci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICB9XG5cdFxuXHQgIE1vbWVudHVtQm91bmNlU2ltdWxhdG9yLnByb3RvdHlwZS5zZXR1cCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0ICAgIHRoaXMub3B0aW9ucyA9IERlZmF1bHRzLmdldERlZmF1bHRzKFwiTW9tZW50dW1Cb3VuY2VTaW11bGF0b3JcIiwgb3B0aW9ucyk7XG5cdCAgICB0aGlzLm9wdGlvbnMgPSBfLmRlZmF1bHRzKG9wdGlvbnMsIHtcblx0ICAgICAgdmVsb2NpdHk6IDAsXG5cdCAgICAgIHBvc2l0aW9uOiAwLFxuXHQgICAgICBtaW46IDAsXG5cdCAgICAgIG1heDogMFxuXHQgICAgfSk7XG5cdCAgICB0aGlzLl9mcmljdGlvblNpbXVsYXRvciA9IG5ldyBGcmljdGlvblNpbXVsYXRvcih7XG5cdCAgICAgIGZyaWN0aW9uOiB0aGlzLm9wdGlvbnMubW9tZW50dW0uZnJpY3Rpb24sXG5cdCAgICAgIHRvbGVyYW5jZTogdGhpcy5vcHRpb25zLm1vbWVudHVtLnRvbGVyYW5jZSxcblx0ICAgICAgdmVsb2NpdHk6IHRoaXMub3B0aW9ucy52ZWxvY2l0eSxcblx0ICAgICAgcG9zaXRpb246IHRoaXMub3B0aW9ucy5wb3NpdGlvblxuXHQgICAgfSk7XG5cdCAgICB0aGlzLl9zcHJpbmdTaW11bGF0b3IgPSBuZXcgU3ByaW5nU2ltdWxhdG9yKHtcblx0ICAgICAgdGVuc2lvbjogdGhpcy5vcHRpb25zLmJvdW5jZS50ZW5zaW9uLFxuXHQgICAgICBmcmljdGlvbjogdGhpcy5vcHRpb25zLmJvdW5jZS5mcmljdGlvbixcblx0ICAgICAgdG9sZXJhbmNlOiB0aGlzLm9wdGlvbnMuYm91bmNlLnRvbGVyYW5jZSxcblx0ICAgICAgdmVsb2NpdHk6IHRoaXMub3B0aW9ucy52ZWxvY2l0eSxcblx0ICAgICAgcG9zaXRpb246IHRoaXMub3B0aW9ucy5wb3NpdGlvblxuXHQgICAgfSk7XG5cdCAgICB0aGlzLl9zdGF0ZSA9IHtcblx0ICAgICAgeDogdGhpcy5vcHRpb25zLnBvc2l0aW9uLFxuXHQgICAgICB2OiB0aGlzLm9wdGlvbnMudmVsb2NpdHlcblx0ICAgIH07XG5cdCAgICByZXR1cm4gdGhpcy5fdXNlU3ByaW5nID0gZmFsc2U7XG5cdCAgfTtcblx0XG5cdCAgTW9tZW50dW1Cb3VuY2VTaW11bGF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbihkZWx0YSkge1xuXHQgICAgaWYgKHRoaXMuX3VzZVNwcmluZykge1xuXHQgICAgICB0aGlzLl9zdGF0ZSA9IHRoaXMuX3NwcmluZ1NpbXVsYXRvci5uZXh0KGRlbHRhKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRoaXMuX3N0YXRlID0gdGhpcy5fZnJpY3Rpb25TaW11bGF0b3IubmV4dChkZWx0YSk7XG5cdCAgICAgIHRoaXMuX3RyeVRyYW5zaXRpb25Ub1NwcmluZyh0aGlzLl9zdGF0ZSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG5cdCAgfTtcblx0XG5cdCAgTW9tZW50dW1Cb3VuY2VTaW11bGF0b3IucHJvdG90eXBlLmZpbmlzaGVkID0gZnVuY3Rpb24oKSB7XG5cdCAgICBpZiAodGhpcy5fdXNlU3ByaW5nKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9zcHJpbmdTaW11bGF0b3IuZmluaXNoZWQoKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0aGlzLl9mcmljdGlvblNpbXVsYXRvci5maW5pc2hlZCgpO1xuXHQgIH07XG5cdFxuXHQgIE1vbWVudHVtQm91bmNlU2ltdWxhdG9yLnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG5cdCAgICB2YXIgYm91bmQ7XG5cdCAgICB0aGlzLl9zdGF0ZSA9IHtcblx0ICAgICAgeDogc3RhdGUueCxcblx0ICAgICAgdjogc3RhdGUudlxuXHQgICAgfTtcblx0ICAgIHRoaXMuX2ZyaWN0aW9uU2ltdWxhdG9yLnNldFN0YXRlKHRoaXMuX3N0YXRlKTtcblx0ICAgIGlmICh0aGlzLl9pc1ZhbGlkU3RhdGUoKSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fdHJ5VHJhbnNpdGlvblRvU3ByaW5nKCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpZiAodGhpcy5fc3RhdGUueCA8PSB0aGlzLm9wdGlvbnMubWluKSB7XG5cdCAgICAgICAgYm91bmQgPSB0aGlzLm9wdGlvbnMubWluO1xuXHQgICAgICB9XG5cdCAgICAgIGlmICh0aGlzLl9zdGF0ZS54ID49IHRoaXMub3B0aW9ucy5tYXgpIHtcblx0ICAgICAgICBib3VuZCA9IHRoaXMub3B0aW9ucy5tYXg7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zaXRpb25Ub1NwcmluZyhib3VuZCk7XG5cdCAgICB9XG5cdCAgfTtcblx0XG5cdCAgTW9tZW50dW1Cb3VuY2VTaW11bGF0b3IucHJvdG90eXBlLl90cnlUcmFuc2l0aW9uVG9TcHJpbmcgPSBmdW5jdGlvbihmb3JjZSkge1xuXHQgICAgdmFyIGFib3ZlTWF4V2l0aFZlbG9jaXR5LCBiZWxvd01pbldpdGhWZWxvY2l0eSwgYm91bmQ7XG5cdCAgICBiZWxvd01pbldpdGhWZWxvY2l0eSA9IHRoaXMuX3N0YXRlLnggPCB0aGlzLm9wdGlvbnMubWluICYmIHRoaXMuX3N0YXRlLnYgPD0gMDtcblx0ICAgIGFib3ZlTWF4V2l0aFZlbG9jaXR5ID0gdGhpcy5fc3RhdGUueCA+IHRoaXMub3B0aW9ucy5tYXggJiYgdGhpcy5fc3RhdGUudiA+PSAwO1xuXHQgICAgaWYgKGJlbG93TWluV2l0aFZlbG9jaXR5IHx8IGFib3ZlTWF4V2l0aFZlbG9jaXR5KSB7XG5cdCAgICAgIGlmIChiZWxvd01pbldpdGhWZWxvY2l0eSkge1xuXHQgICAgICAgIGJvdW5kID0gdGhpcy5vcHRpb25zLm1pbjtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoYWJvdmVNYXhXaXRoVmVsb2NpdHkpIHtcblx0ICAgICAgICBib3VuZCA9IHRoaXMub3B0aW9ucy5tYXg7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zaXRpb25Ub1NwcmluZyhib3VuZCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gdGhpcy5fdXNlU3ByaW5nID0gZmFsc2U7XG5cdCAgICB9XG5cdCAgfTtcblx0XG5cdCAgTW9tZW50dW1Cb3VuY2VTaW11bGF0b3IucHJvdG90eXBlLl90cmFuc2l0aW9uVG9TcHJpbmcgPSBmdW5jdGlvbihib3VuZCkge1xuXHQgICAgdGhpcy5fdXNlU3ByaW5nID0gdHJ1ZTtcblx0ICAgIHRoaXMuX3NwcmluZ1NpbXVsYXRvci5vcHRpb25zLm9mZnNldCA9IGJvdW5kO1xuXHQgICAgcmV0dXJuIHRoaXMuX3NwcmluZ1NpbXVsYXRvci5zZXRTdGF0ZSh0aGlzLl9zdGF0ZSk7XG5cdCAgfTtcblx0XG5cdCAgTW9tZW50dW1Cb3VuY2VTaW11bGF0b3IucHJvdG90eXBlLl9pc1ZhbGlkU3RhdGUgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciBhYm92ZU1heFRyYXZlbGluZ0JhY2ssIGJlbG93TWluVHJhdmVsaW5nQmFjaywgYm91bmQsIGNoZWNrLCBmcmljdGlvbiwgc29sdXRpb247XG5cdCAgICBiZWxvd01pblRyYXZlbGluZ0JhY2sgPSB0aGlzLl9zdGF0ZS54IDwgdGhpcy5vcHRpb25zLm1pbiAmJiB0aGlzLl9zdGF0ZS52ID4gMDtcblx0ICAgIGFib3ZlTWF4VHJhdmVsaW5nQmFjayA9IHRoaXMuX3N0YXRlLnggPiB0aGlzLm9wdGlvbnMubWF4ICYmIHRoaXMuX3N0YXRlLnYgPCAwO1xuXHQgICAgY2hlY2sgPSBmYWxzZTtcblx0ICAgIGlmIChiZWxvd01pblRyYXZlbGluZ0JhY2spIHtcblx0ICAgICAgYm91bmQgPSB0aGlzLm9wdGlvbnMubWluO1xuXHQgICAgICBjaGVjayA9IHRydWU7XG5cdCAgICB9IGVsc2UgaWYgKGFib3ZlTWF4VHJhdmVsaW5nQmFjaykge1xuXHQgICAgICBib3VuZCA9IHRoaXMub3B0aW9ucy5tYXg7XG5cdCAgICAgIGNoZWNrID0gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIGlmIChjaGVjaykge1xuXHQgICAgICBmcmljdGlvbiA9IHRoaXMuX2ZyaWN0aW9uU2ltdWxhdG9yLm9wdGlvbnMuZnJpY3Rpb247XG5cdCAgICAgIHNvbHV0aW9uID0gMSAtIChmcmljdGlvbiAqIChib3VuZCAtIHRoaXMuX3N0YXRlLngpKSAvIHRoaXMuX3N0YXRlLnY7XG5cdCAgICAgIHJldHVybiBzb2x1dGlvbiA+IDA7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9O1xuXHRcblx0ICByZXR1cm4gTW9tZW50dW1Cb3VuY2VTaW11bGF0b3I7XG5cdFxuXHR9KShTaW11bGF0b3IpO1xuXG5cbi8qKiovIH0sXG4vKiAzMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIEJhc2VDbGFzcywgRXZlbnRzLCBVdGlscywgXyxcblx0ICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG5cdCAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXHRcblx0XyA9IF9fd2VicGFja19yZXF1aXJlX18oMSkuXztcblx0XG5cdFV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0XG5cdEJhc2VDbGFzcyA9IF9fd2VicGFja19yZXF1aXJlX18oNikuQmFzZUNsYXNzO1xuXHRcblx0RXZlbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSkuRXZlbnRzO1xuXHRcblx0RXZlbnRzLkV2ZW50QnVmZmVyUmVzZXQgPSBcImV2ZW50YnVmZmVycmVzZXRcIjtcblx0XG5cdEV2ZW50cy5FdmVudEJ1ZmZlclVwZGF0ZWQgPSBcImV2ZW50YnVmZmVydXBkYXRlZFwiO1xuXHRcblx0ZXhwb3J0cy5FdmVudEJ1ZmZlciA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG5cdCAgZXh0ZW5kKEV2ZW50QnVmZmVyLCBzdXBlckNsYXNzKTtcblx0XG5cdCAgZnVuY3Rpb24gRXZlbnRCdWZmZXIob3B0aW9ucykge1xuXHQgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuXHQgICAgICBvcHRpb25zID0ge307XG5cdCAgICB9XG5cdCAgICB0aGlzLm9wdGlvbnMgPSBfLmRlZmF1bHRzKG9wdGlvbnMsIHtcblx0ICAgICAgdmVsb2NpdHlUaW1lb3V0OiAxMDBcblx0ICAgIH0pO1xuXHQgICAgdGhpcy5fZXZlbnRzID0gW107XG5cdCAgfVxuXHRcblx0ICBFdmVudEJ1ZmZlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdCAgICB0aGlzLl9ldmVudHMucHVzaChldmVudCk7XG5cdCAgICByZXR1cm4gdGhpcy5lbWl0KEV2ZW50cy5FdmVudEJ1ZmZlclVwZGF0ZWQsIGV2ZW50KTtcblx0ICB9O1xuXHRcblx0ICBFdmVudEJ1ZmZlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcblx0ICAgIHRoaXMuX2V2ZW50cy5sZW5ndGggPSAwO1xuXHQgICAgcmV0dXJuIHRoaXMuZW1pdChFdmVudHMuRXZlbnRCdWZmZXJSZXNldCk7XG5cdCAgfTtcblx0XG5cdCAgRXZlbnRCdWZmZXIuZGVmaW5lKFwibGVuZ3RoXCIsIHtcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9ldmVudHMubGVuZ3RoO1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBFdmVudEJ1ZmZlci5kZWZpbmUoXCJmaXJzdFwiLCB7XG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzWzBdO1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBFdmVudEJ1ZmZlci5kZWZpbmUoXCJvZmZzZXRcIiwge1xuXHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgdmFyIGN1cnJlbnQsIGZpcnN0LCBvZmZzZXQ7XG5cdCAgICAgIGlmIChldmVudHMubGVuZ3RoIDwgMikge1xuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICB4OiAwLFxuXHQgICAgICAgICAgeTogMFxuXHQgICAgICAgIH07XG5cdCAgICAgIH1cblx0ICAgICAgY3VycmVudCA9IGV2ZW50c1tldmVudHMubGVuZ3RoIC0gMV07XG5cdCAgICAgIGZpcnN0ID0gZXZlbnRzWzBdO1xuXHQgICAgICByZXR1cm4gb2Zmc2V0ID0ge1xuXHQgICAgICAgIHg6IGN1cnJlbnQueCAtIGZpcnN0LngsXG5cdCAgICAgICAgeTogY3VycmVudC55IC0gZmlyc3QueVxuXHQgICAgICB9O1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBFdmVudEJ1ZmZlci5kZWZpbmUoXCJldmVudHNcIiwge1xuXHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgdmFyIHRpbWVvdXQ7XG5cdCAgICAgIHRpbWVvdXQgPSBEYXRlLm5vdygpIC0gdGhpcy5vcHRpb25zLnZlbG9jaXR5VGltZW91dDtcblx0ICAgICAgcmV0dXJuIF8uZmlsdGVyKHRoaXMuX2V2ZW50cywgKGZ1bmN0aW9uKF90aGlzKSB7XG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdCAgICAgICAgICByZXR1cm4gZXZlbnQudCA+IHRpbWVvdXQ7XG5cdCAgICAgICAgfTtcblx0ICAgICAgfSkodGhpcykpO1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBFdmVudEJ1ZmZlci5kZWZpbmUoXCJhbmdsZVwiLCB7XG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICB2YXIgZXZlbnRzLCBwMSwgcDI7XG5cdCAgICAgIGV2ZW50cyA9IHRoaXMuZXZlbnRzO1xuXHQgICAgICBpZiAoZXZlbnRzLmxlbmd0aCA8IDIpIHtcblx0ICAgICAgICByZXR1cm4gMDtcblx0ICAgICAgfVxuXHQgICAgICBwMSA9IGV2ZW50c1swXTtcblx0ICAgICAgcDIgPSBldmVudHNbMV07XG5cdCAgICAgIHJldHVybiBNYXRoLmF0YW4yKHAyLnkgLSBwMS55LCBwMi54IC0gcDEueCkgKiAxODAgLyBNYXRoLlBJO1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBFdmVudEJ1ZmZlci5kZWZpbmUoXCJ2ZWxvY2l0eVwiLCB7XG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICB2YXIgY3VycmVudCwgZXZlbnRzLCBmaXJzdCwgdGltZSwgdmVsb2NpdHk7XG5cdCAgICAgIGV2ZW50cyA9IHRoaXMuZXZlbnRzO1xuXHQgICAgICBpZiAoZXZlbnRzLmxlbmd0aCA8IDIpIHtcblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgeDogMCxcblx0ICAgICAgICAgIHk6IDBcblx0ICAgICAgICB9O1xuXHQgICAgICB9XG5cdCAgICAgIGN1cnJlbnQgPSBldmVudHNbZXZlbnRzLmxlbmd0aCAtIDFdO1xuXHQgICAgICBmaXJzdCA9IGV2ZW50c1swXTtcblx0ICAgICAgdGltZSA9IGN1cnJlbnQudCAtIGZpcnN0LnQ7XG5cdCAgICAgIHZlbG9jaXR5ID0ge1xuXHQgICAgICAgIHg6IChjdXJyZW50LnggLSBmaXJzdC54KSAvIHRpbWUsXG5cdCAgICAgICAgeTogKGN1cnJlbnQueSAtIGZpcnN0LnkpIC8gdGltZVxuXHQgICAgICB9O1xuXHQgICAgICBpZiAodmVsb2NpdHkueCA9PT0gSW5maW5pdHkpIHtcblx0ICAgICAgICB2ZWxvY2l0eS54ID0gMDtcblx0ICAgICAgfVxuXHQgICAgICBpZiAodmVsb2NpdHkueSA9PT0gSW5maW5pdHkpIHtcblx0ICAgICAgICB2ZWxvY2l0eS55ID0gMDtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gdmVsb2NpdHk7XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIHJldHVybiBFdmVudEJ1ZmZlcjtcblx0XG5cdH0pKEJhc2VDbGFzcyk7XG5cblxuLyoqKi8gfSxcbi8qIDM0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgQmFzZUNsYXNzLCBFdmVudHMsIEdlc3R1cmVzLCBVdGlscyxcblx0ICBiaW5kID0gZnVuY3Rpb24oZm4sIG1lKXsgcmV0dXJuIGZ1bmN0aW9uKCl7IHJldHVybiBmbi5hcHBseShtZSwgYXJndW1lbnRzKTsgfTsgfSxcblx0ICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG5cdCAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXHRcblx0VXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHRcblx0QmFzZUNsYXNzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KS5CYXNlQ2xhc3M7XG5cdFxuXHRFdmVudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KS5FdmVudHM7XG5cdFxuXHRHZXN0dXJlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpLkdlc3R1cmVzO1xuXHRcblx0RXZlbnRzLlBpbmNoU3RhcnQgPSBcInBpbmNoc3RhcnRcIjtcblx0XG5cdEV2ZW50cy5QaW5jaCA9IFwicGluY2hcIjtcblx0XG5cdEV2ZW50cy5QaW5jaEVuZCA9IFwicGluY2hlbmRcIjtcblx0XG5cdEV2ZW50cy5Sb3RhdGVTdGFydCA9IFwicm90YXRlc3RhcnRcIjtcblx0XG5cdEV2ZW50cy5Sb3RhdGUgPSBcInJvdGF0ZVwiO1xuXHRcblx0RXZlbnRzLlJvdGF0ZUVuZCA9IFwicm90YXRlZW5kXCI7XG5cdFxuXHRFdmVudHMuU2NhbGVTdGFydCA9IFwic2NhbGVzdGFydFwiO1xuXHRcblx0RXZlbnRzLlNjYWxlID0gXCJzY2FsZVwiO1xuXHRcblx0RXZlbnRzLlNjYWxlRW5kID0gXCJzY2FsZWVuZFwiO1xuXHRcblx0ZXhwb3J0cy5MYXllclBpbmNoYWJsZSA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG5cdCAgZXh0ZW5kKExheWVyUGluY2hhYmxlLCBzdXBlckNsYXNzKTtcblx0XG5cdCAgTGF5ZXJQaW5jaGFibGUuZGVmaW5lKFwiZW5hYmxlZFwiLCBMYXllclBpbmNoYWJsZS5zaW1wbGVQcm9wZXJ0eShcImVuYWJsZWRcIiwgdHJ1ZSkpO1xuXHRcblx0ICBMYXllclBpbmNoYWJsZS5kZWZpbmUoXCJ0aHJlc2hvbGRcIiwgTGF5ZXJQaW5jaGFibGUuc2ltcGxlUHJvcGVydHkoXCJ0aHJlc2hvbGRcIiwgMCkpO1xuXHRcblx0ICBMYXllclBpbmNoYWJsZS5kZWZpbmUoXCJjZW50ZXJPcmlnaW5cIiwgTGF5ZXJQaW5jaGFibGUuc2ltcGxlUHJvcGVydHkoXCJjZW50ZXJPcmlnaW5cIiwgdHJ1ZSkpO1xuXHRcblx0ICBMYXllclBpbmNoYWJsZS5kZWZpbmUoXCJzY2FsZVwiLCBMYXllclBpbmNoYWJsZS5zaW1wbGVQcm9wZXJ0eShcInNjYWxlXCIsIHRydWUpKTtcblx0XG5cdCAgTGF5ZXJQaW5jaGFibGUuZGVmaW5lKFwic2NhbGVJbmNyZW1lbnRzXCIsIExheWVyUGluY2hhYmxlLnNpbXBsZVByb3BlcnR5KFwic2NhbGVJbmNyZW1lbnRzXCIsIDApKTtcblx0XG5cdCAgTGF5ZXJQaW5jaGFibGUuZGVmaW5lKFwibWluU2NhbGVcIiwgTGF5ZXJQaW5jaGFibGUuc2ltcGxlUHJvcGVydHkoXCJtaW5TY2FsZVwiLCAwKSk7XG5cdFxuXHQgIExheWVyUGluY2hhYmxlLmRlZmluZShcIm1heFNjYWxlXCIsIExheWVyUGluY2hhYmxlLnNpbXBsZVByb3BlcnR5KFwibWF4U2NhbGVcIiwgTnVtYmVyLk1BWF9WQUxVRSkpO1xuXHRcblx0ICBMYXllclBpbmNoYWJsZS5kZWZpbmUoXCJzY2FsZUZhY3RvclwiLCBMYXllclBpbmNoYWJsZS5zaW1wbGVQcm9wZXJ0eShcInNjYWxlRmFjdG9yXCIsIDEpKTtcblx0XG5cdCAgTGF5ZXJQaW5jaGFibGUuZGVmaW5lKFwicm90YXRlXCIsIExheWVyUGluY2hhYmxlLnNpbXBsZVByb3BlcnR5KFwicm90YXRlXCIsIHRydWUpKTtcblx0XG5cdCAgTGF5ZXJQaW5jaGFibGUuZGVmaW5lKFwicm90YXRlSW5jcmVtZW50c1wiLCBMYXllclBpbmNoYWJsZS5zaW1wbGVQcm9wZXJ0eShcInJvdGF0ZUluY3JlbWVudHNcIiwgMCkpO1xuXHRcblx0ICBMYXllclBpbmNoYWJsZS5kZWZpbmUoXCJyb3RhdGVNaW5cIiwgTGF5ZXJQaW5jaGFibGUuc2ltcGxlUHJvcGVydHkoXCJyb3RhdGVNaW5cIiwgMCkpO1xuXHRcblx0ICBMYXllclBpbmNoYWJsZS5kZWZpbmUoXCJyb3RhdGVNYXhcIiwgTGF5ZXJQaW5jaGFibGUuc2ltcGxlUHJvcGVydHkoXCJyb3RhdGVNYXhcIiwgMCkpO1xuXHRcblx0ICBMYXllclBpbmNoYWJsZS5kZWZpbmUoXCJyb3RhdGVGYWN0b3JcIiwgTGF5ZXJQaW5jaGFibGUuc2ltcGxlUHJvcGVydHkoXCJyb3RhdGVGYWN0b3JcIiwgMSkpO1xuXHRcblx0ICBmdW5jdGlvbiBMYXllclBpbmNoYWJsZShsYXllcikge1xuXHQgICAgdGhpcy5sYXllciA9IGxheWVyO1xuXHQgICAgdGhpcy5fcGluY2hFbmQgPSBiaW5kKHRoaXMuX3BpbmNoRW5kLCB0aGlzKTtcblx0ICAgIHRoaXMuX3BpbmNoID0gYmluZCh0aGlzLl9waW5jaCwgdGhpcyk7XG5cdCAgICB0aGlzLl9waW5jaFN0YXJ0ID0gYmluZCh0aGlzLl9waW5jaFN0YXJ0LCB0aGlzKTtcblx0ICAgIHRoaXMuX2NlbnRlck9yaWdpbiA9IGJpbmQodGhpcy5fY2VudGVyT3JpZ2luLCB0aGlzKTtcblx0ICAgIExheWVyUGluY2hhYmxlLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgdGhpcy5fYXR0YWNoKCk7XG5cdCAgfVxuXHRcblx0ICBMYXllclBpbmNoYWJsZS5wcm90b3R5cGUuX2F0dGFjaCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdGhpcy5sYXllci5vbihHZXN0dXJlcy5QaW5jaFN0YXJ0LCB0aGlzLl9waW5jaFN0YXJ0KTtcblx0ICAgIHRoaXMubGF5ZXIub24oR2VzdHVyZXMuUGluY2gsIHRoaXMuX3BpbmNoKTtcblx0ICAgIHRoaXMubGF5ZXIub24oR2VzdHVyZXMuUGluY2hFbmQsIHRoaXMuX3BpbmNoRW5kKTtcblx0ICAgIHJldHVybiB0aGlzLmxheWVyLm9uKEdlc3R1cmVzLlRhcFN0YXJ0LCB0aGlzLl90YXBTdGFydCk7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXJQaW5jaGFibGUucHJvdG90eXBlLl9yZXNldCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdGhpcy5fc2NhbGVTdGFydCA9IG51bGw7XG5cdCAgICB0aGlzLl9yb3RhdGlvblN0YXJ0ID0gbnVsbDtcblx0ICAgIHJldHVybiB0aGlzLl9yb3RhdGlvbk9mZnNldCA9IG51bGw7XG5cdCAgfTtcblx0XG5cdCAgTGF5ZXJQaW5jaGFibGUucHJvdG90eXBlLl90YXBTdGFydCA9IGZ1bmN0aW9uKGV2ZW50KSB7fTtcblx0XG5cdCAgTGF5ZXJQaW5jaGFibGUucHJvdG90eXBlLl9jZW50ZXJPcmlnaW4gPSBmdW5jdGlvbihldmVudCkge1xuXHQgICAgdmFyIG9yaWdpbkRlbHRhLCBwaW5jaExvY2F0aW9uLCB0b3BJblN1cGVyQWZ0ZXIsIHRvcEluU3VwZXJCZWZvcmU7XG5cdCAgICB0b3BJblN1cGVyQmVmb3JlID0gVXRpbHMuY29udmVydFBvaW50KHt9LCB0aGlzLmxheWVyLCB0aGlzLmxheWVyLnN1cGVyTGF5ZXIpO1xuXHQgICAgcGluY2hMb2NhdGlvbiA9IFV0aWxzLmNvbnZlcnRQb2ludEZyb21Db250ZXh0KGV2ZW50LnRvdWNoQ2VudGVyLCB0aGlzLmxheWVyLCB0cnVlLCB0cnVlKTtcblx0ICAgIHRoaXMubGF5ZXIub3JpZ2luWCA9IHBpbmNoTG9jYXRpb24ueCAvIHRoaXMubGF5ZXIud2lkdGg7XG5cdCAgICB0aGlzLmxheWVyLm9yaWdpblkgPSBwaW5jaExvY2F0aW9uLnkgLyB0aGlzLmxheWVyLmhlaWdodDtcblx0ICAgIHRvcEluU3VwZXJBZnRlciA9IFV0aWxzLmNvbnZlcnRQb2ludCh7fSwgdGhpcy5sYXllciwgdGhpcy5sYXllci5zdXBlckxheWVyKTtcblx0ICAgIG9yaWdpbkRlbHRhID0ge1xuXHQgICAgICB4OiB0b3BJblN1cGVyQWZ0ZXIueCAtIHRvcEluU3VwZXJCZWZvcmUueCxcblx0ICAgICAgeTogdG9wSW5TdXBlckFmdGVyLnkgLSB0b3BJblN1cGVyQmVmb3JlLnlcblx0ICAgIH07XG5cdCAgICB0aGlzLmxheWVyLnggLT0gb3JpZ2luRGVsdGEueDtcblx0ICAgIHJldHVybiB0aGlzLmxheWVyLnkgLT0gb3JpZ2luRGVsdGEueTtcblx0ICB9O1xuXHRcblx0ICBMYXllclBpbmNoYWJsZS5wcm90b3R5cGUuX3BpbmNoU3RhcnQgPSBmdW5jdGlvbihldmVudCkge1xuXHQgICAgdGhpcy5fcmVzZXQoKTtcblx0ICAgIGlmICh0aGlzLmNlbnRlck9yaWdpbikge1xuXHQgICAgICB0aGlzLl9jZW50ZXJPcmlnaW4oZXZlbnQpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXMubm9ybWFsaXplUm90YXRpb24gPSBVdGlscy5yb3RhdGlvbk5vcm1hbGl6ZXIoKTtcblx0ICB9O1xuXHRcblx0ICBMYXllclBpbmNoYWJsZS5wcm90b3R5cGUuX3BpbmNoID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0ICAgIHZhciBwb2ludEEsIHBvaW50Qiwgcm90YXRpb24sIHNjYWxlO1xuXHQgICAgaWYgKGV2ZW50LmZpbmdlcnMgIT09IDIpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgcG9pbnRBID0ge1xuXHQgICAgICB4OiBldmVudC50b3VjaGVzWzBdLnBhZ2VYLFxuXHQgICAgICB5OiBldmVudC50b3VjaGVzWzBdLnBhZ2VZXG5cdCAgICB9O1xuXHQgICAgcG9pbnRCID0ge1xuXHQgICAgICB4OiBldmVudC50b3VjaGVzWzFdLnBhZ2VYLFxuXHQgICAgICB5OiBldmVudC50b3VjaGVzWzFdLnBhZ2VZXG5cdCAgICB9O1xuXHQgICAgaWYgKCEoVXRpbHMucG9pbnRUb3RhbChVdGlscy5wb2ludEFicyhVdGlscy5wb2ludFN1YnRyYWN0KHBvaW50QSwgcG9pbnRCKSkpID4gdGhpcy50aHJlc2hvbGQpKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIGlmICh0aGlzLnNjYWxlKSB7XG5cdCAgICAgIGlmICh0aGlzLl9zY2FsZVN0YXJ0ID09IG51bGwpIHtcblx0ICAgICAgICB0aGlzLl9zY2FsZVN0YXJ0ID0gdGhpcy5sYXllci5zY2FsZTtcblx0ICAgICAgfVxuXHQgICAgICBzY2FsZSA9ICgoKGV2ZW50LnNjYWxlIC0gMSkgKiB0aGlzLnNjYWxlRmFjdG9yKSArIDEpICogdGhpcy5fc2NhbGVTdGFydDtcblx0ICAgICAgaWYgKHRoaXMubWluU2NhbGUgJiYgdGhpcy5tYXhTY2FsZSkge1xuXHQgICAgICAgIHNjYWxlID0gVXRpbHMuY2xhbXAoc2NhbGUsIHRoaXMubWluU2NhbGUsIHRoaXMubWF4U2NhbGUpO1xuXHQgICAgICB9IGVsc2UgaWYgKHRoaXMubWluU2NhbGUpIHtcblx0ICAgICAgICBzY2FsZSA9IFV0aWxzLmNsYW1wKHNjYWxlLCB0aGlzLm1pblNjYWxlLCAxMDAwMDAwKTtcblx0ICAgICAgfSBlbHNlIGlmICh0aGlzLm1heFNjYWxlKSB7XG5cdCAgICAgICAgc2NhbGUgPSBVdGlscy5jbGFtcChzY2FsZSwgMC4wMDAwMSwgdGhpcy5tYXhTY2FsZSk7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHRoaXMuc2NhbGVJbmNyZW1lbnRzKSB7XG5cdCAgICAgICAgc2NhbGUgPSBVdGlscy5uZWFyZXN0SW5jcmVtZW50KHNjYWxlLCB0aGlzLnNjYWxlSW5jcmVtZW50cyk7XG5cdCAgICAgIH1cblx0ICAgICAgdGhpcy5sYXllci5zY2FsZSA9IHNjYWxlO1xuXHQgICAgICB0aGlzLmVtaXQoRXZlbnRzLlNjYWxlLCBldmVudCk7XG5cdCAgICB9XG5cdCAgICBpZiAodGhpcy5yb3RhdGUpIHtcblx0ICAgICAgaWYgKHRoaXMuX3JvdGF0aW9uU3RhcnQgPT0gbnVsbCkge1xuXHQgICAgICAgIHRoaXMuX3JvdGF0aW9uU3RhcnQgPSB0aGlzLmxheWVyLnJvdGF0aW9uO1xuXHQgICAgICB9XG5cdCAgICAgIGlmICh0aGlzLl9yb3RhdGlvbk9mZnNldCA9PSBudWxsKSB7XG5cdCAgICAgICAgdGhpcy5fcm90YXRpb25PZmZzZXQgPSBldmVudC5yb3RhdGlvbjtcblx0ICAgICAgfVxuXHQgICAgICByb3RhdGlvbiA9IGV2ZW50LnJvdGF0aW9uIC0gdGhpcy5fcm90YXRpb25PZmZzZXQgKyB0aGlzLl9yb3RhdGlvblN0YXJ0O1xuXHQgICAgICByb3RhdGlvbiA9IHJvdGF0aW9uICogdGhpcy5yb3RhdGVGYWN0b3I7XG5cdCAgICAgIHJvdGF0aW9uID0gdGhpcy5ub3JtYWxpemVSb3RhdGlvbihyb3RhdGlvbik7XG5cdCAgICAgIGlmICh0aGlzLnJvdGF0ZU1pbiAmJiB0aGlzLnJvdGF0ZU1heCkge1xuXHQgICAgICAgIHJvdGF0aW9uID0gVXRpbHMuY2xhbXAocm90YXRpb24sIHRoaXMucm90YXRlTWluLCB0aGlzLnJvdGF0ZU1heCk7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHRoaXMucm90YXRlSW5jcmVtZW50cykge1xuXHQgICAgICAgIHJvdGF0aW9uID0gVXRpbHMubmVhcmVzdEluY3JlbWVudChyb3RhdGlvbiwgdGhpcy5yb3RhdGVJbmNyZW1lbnRzKTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gdGhpcy5sYXllci5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuXHQgICAgfVxuXHQgIH07XG5cdFxuXHQgIExheWVyUGluY2hhYmxlLnByb3RvdHlwZS5fcGluY2hFbmQgPSBmdW5jdGlvbihldmVudCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX3Jlc2V0KCk7XG5cdCAgfTtcblx0XG5cdCAgcmV0dXJuIExheWVyUGluY2hhYmxlO1xuXHRcblx0fSkoQmFzZUNsYXNzKTtcblxuXG4vKioqLyB9LFxuLyogMzUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBMYXllcixcblx0ICBiaW5kID0gZnVuY3Rpb24oZm4sIG1lKXsgcmV0dXJuIGZ1bmN0aW9uKCl7IHJldHVybiBmbi5hcHBseShtZSwgYXJndW1lbnRzKTsgfTsgfSxcblx0ICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG5cdCAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXHRcblx0TGF5ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKS5MYXllcjtcblx0XG5cdFwiVG9kbzogbWFrZSBpdCB3b3JrIGluIGEgcGFyZW50IGxheWVyXCI7XG5cdFxuXHRleHBvcnRzLkJhY2tncm91bmRMYXllciA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG5cdCAgZXh0ZW5kKEJhY2tncm91bmRMYXllciwgc3VwZXJDbGFzcyk7XG5cdFxuXHQgIGZ1bmN0aW9uIEJhY2tncm91bmRMYXllcihvcHRpb25zKSB7XG5cdCAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG5cdCAgICAgIG9wdGlvbnMgPSB7fTtcblx0ICAgIH1cblx0ICAgIHRoaXMubGF5b3V0ID0gYmluZCh0aGlzLmxheW91dCwgdGhpcyk7XG5cdCAgICBpZiAob3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IgPT0gbnVsbCkge1xuXHQgICAgICBvcHRpb25zLmJhY2tncm91bmRDb2xvciA9IFwiI2ZmZlwiO1xuXHQgICAgfVxuXHQgICAgQmFja2dyb3VuZExheWVyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgdGhpcy5zZW5kVG9CYWNrKCk7XG5cdCAgICB0aGlzLmxheW91dCgpO1xuXHQgICAgdGhpcy5fY29udGV4dC5kb21FdmVudE1hbmFnZXIud3JhcCh3aW5kb3cpLmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5sYXlvdXQpO1xuXHQgIH1cblx0XG5cdCAgQmFja2dyb3VuZExheWVyLnByb3RvdHlwZS5sYXlvdXQgPSBmdW5jdGlvbigpIHtcblx0ICAgIGlmICh0aGlzLnBhcmVudCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5mcmFtZSA9IHRoaXMucGFyZW50LmZyYW1lO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuZnJhbWUgPSB0aGlzLl9jb250ZXh0LmZyYW1lO1xuXHQgICAgfVxuXHQgIH07XG5cdFxuXHQgIHJldHVybiBCYWNrZ3JvdW5kTGF5ZXI7XG5cdFxuXHR9KShMYXllcik7XG5cblxuLyoqKi8gfSxcbi8qIDM2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgTGF5ZXIsXG5cdCAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuXHQgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblx0XG5cdExheWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMykuTGF5ZXI7XG5cdFxuXHRleHBvcnRzLlZpZGVvTGF5ZXIgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuXHQgIGV4dGVuZChWaWRlb0xheWVyLCBzdXBlckNsYXNzKTtcblx0XG5cdCAgZnVuY3Rpb24gVmlkZW9MYXllcihvcHRpb25zKSB7XG5cdCAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG5cdCAgICAgIG9wdGlvbnMgPSB7fTtcblx0ICAgIH1cblx0ICAgIHRoaXMucGxheWVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInZpZGVvXCIpO1xuXHQgICAgdGhpcy5wbGF5ZXIuc2V0QXR0cmlidXRlKFwid2Via2l0LXBsYXlzaW5saW5lXCIsIFwidHJ1ZVwiKTtcblx0ICAgIHRoaXMucGxheWVyLnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG5cdCAgICB0aGlzLnBsYXllci5zdHlsZS5oZWlnaHQgPSBcIjEwMCVcIjtcblx0ICAgIFZpZGVvTGF5ZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICB0aGlzLnBsYXllci5vbiA9IHRoaXMuX2NvbnRleHQuZG9tRXZlbnRNYW5hZ2VyLndyYXAodGhpcy5wbGF5ZXIpLmFkZEV2ZW50TGlzdGVuZXI7XG5cdCAgICB0aGlzLnBsYXllci5vZmYgPSB0aGlzLl9jb250ZXh0LmRvbUV2ZW50TWFuYWdlci53cmFwKHRoaXMucGxheWVyKS5yZW1vdmVFdmVudExpc3RlbmVyO1xuXHQgICAgdGhpcy52aWRlbyA9IG9wdGlvbnMudmlkZW87XG5cdCAgICB0aGlzLl9lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMucGxheWVyKTtcblx0ICB9XG5cdFxuXHQgIFZpZGVvTGF5ZXIuZGVmaW5lKFwidmlkZW9cIiwge1xuXHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMucGxheWVyLnNyYztcblx0ICAgIH0sXG5cdCAgICBzZXQ6IGZ1bmN0aW9uKHZpZGVvKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLnBsYXllci5zcmMgPSB2aWRlbztcblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgcmV0dXJuIFZpZGVvTGF5ZXI7XG5cdFxuXHR9KShMYXllcik7XG5cblxuLyoqKi8gfSxcbi8qIDM3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgQW5pbWF0aW9uR3JvdXAsIEV2ZW50RW1pdHRlciwgXyxcblx0ICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG5cdCAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXHRcblx0XyA9IF9fd2VicGFja19yZXF1aXJlX18oMSkuXztcblx0XG5cdEV2ZW50RW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oNykuRXZlbnRFbWl0dGVyO1xuXHRcblx0QW5pbWF0aW9uR3JvdXAgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuXHQgIGV4dGVuZChBbmltYXRpb25Hcm91cCwgc3VwZXJDbGFzcyk7XG5cdFxuXHQgIGZ1bmN0aW9uIEFuaW1hdGlvbkdyb3VwKGFuaW1hdGlvbnMpIHtcblx0ICAgIGlmIChhbmltYXRpb25zID09IG51bGwpIHtcblx0ICAgICAgYW5pbWF0aW9ucyA9IFtdO1xuXHQgICAgfVxuXHQgICAgdGhpcy5zZXRBbmltYXRpb25zKGFuaW1hdGlvbnMpO1xuXHQgICAgdGhpcy5fY3VycmVudEFuaW1hdGlvbiA9IG51bGw7XG5cdCAgfVxuXHRcblx0ICBBbmltYXRpb25Hcm91cC5wcm90b3R5cGUuc2V0QW5pbWF0aW9ucyA9IGZ1bmN0aW9uKGFuaW1hdGlvbnMpIHtcblx0ICAgIHJldHVybiB0aGlzLl9hbmltYXRpb25zID0gXy5tYXAoYW5pbWF0aW9ucywgZnVuY3Rpb24oYW5pbWF0aW9uKSB7XG5cdCAgICAgIHJldHVybiBhbmltYXRpb24uY29weSgpO1xuXHQgICAgfSk7XG5cdCAgfTtcblx0XG5cdCAgQW5pbWF0aW9uR3JvdXAucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cdCAgICB0aGlzLmVtaXQoXCJzdGFydFwiKTtcblx0ICAgIF8ubWFwKHRoaXMuX2FuaW1hdGlvbnMsIChmdW5jdGlvbihfdGhpcykge1xuXHQgICAgICByZXR1cm4gZnVuY3Rpb24oYW5pbWF0aW9uLCBpbmRleCkge1xuXHQgICAgICAgIHZhciBuZXh0QW5pbWF0aW9uO1xuXHQgICAgICAgIG5leHRBbmltYXRpb24gPSBfdGhpcy5fYW5pbWF0aW9uc1tpbmRleCArIDFdO1xuXHQgICAgICAgIGlmIChuZXh0QW5pbWF0aW9uKSB7XG5cdCAgICAgICAgICByZXR1cm4gYW5pbWF0aW9uLm9uKEV2ZW50cy5BbmltYXRpb25FbmQsIGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICBuZXh0QW5pbWF0aW9uLnN0YXJ0KCk7XG5cdCAgICAgICAgICAgIHJldHVybiBfdGhpcy5fY3VycmVudEFuaW1hdGlvbiA9IGFuaW1hdGlvbjtcblx0ICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICByZXR1cm4gYW5pbWF0aW9uLm9uKEV2ZW50cy5BbmltYXRpb25FbmQsIGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICBfdGhpcy5lbWl0KFwiZW5kXCIpO1xuXHQgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2N1cnJlbnRBbmltYXRpb24gPSBudWxsO1xuXHQgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9O1xuXHQgICAgfSkodGhpcykpO1xuXHQgICAgcmV0dXJuIHRoaXMuX2FuaW1hdGlvbnNbMF0uc3RhcnQoKTtcblx0ICB9O1xuXHRcblx0ICBBbmltYXRpb25Hcm91cC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIHJlZjtcblx0ICAgIHJldHVybiAocmVmID0gdGhpcy5fY3VycmVudEFuaW1hdGlvbikgIT0gbnVsbCA/IHJlZi5zdG9wKCkgOiB2b2lkIDA7XG5cdCAgfTtcblx0XG5cdCAgcmV0dXJuIEFuaW1hdGlvbkdyb3VwO1xuXHRcblx0fSkoRXZlbnRFbWl0dGVyKTtcblxuXG4vKioqLyB9LFxuLyogMzggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBCYXNlQ2xhc3MsIENhbnZhc0NsYXNzLCBFdmVudHMsXG5cdCAgYmluZCA9IGZ1bmN0aW9uKGZuLCBtZSl7IHJldHVybiBmdW5jdGlvbigpeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH0sXG5cdCAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuXHQgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblx0XG5cdEJhc2VDbGFzcyA9IF9fd2VicGFja19yZXF1aXJlX18oNikuQmFzZUNsYXNzO1xuXHRcblx0RXZlbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSkuRXZlbnRzO1xuXHRcblx0Q2FudmFzQ2xhc3MgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuXHQgIGV4dGVuZChDYW52YXNDbGFzcywgc3VwZXJDbGFzcyk7XG5cdFxuXHQgIGZ1bmN0aW9uIENhbnZhc0NsYXNzKCkge1xuXHQgICAgdGhpcy5hZGRMaXN0ZW5lciA9IGJpbmQodGhpcy5hZGRMaXN0ZW5lciwgdGhpcyk7XG5cdCAgICByZXR1cm4gQ2FudmFzQ2xhc3MuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgfVxuXHRcblx0ICBDYW52YXNDbGFzcy5kZWZpbmUoXCJ3aWR0aFwiLCB7XG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gd2luZG93LmlubmVyV2lkdGg7XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIENhbnZhc0NsYXNzLmRlZmluZShcImhlaWdodFwiLCB7XG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gd2luZG93LmlubmVySGVpZ2h0O1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBDYW52YXNDbGFzcy5kZWZpbmUoXCJzaXplXCIsIHtcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB7XG5cdCAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG5cdCAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuXHQgICAgICB9O1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBDYW52YXNDbGFzcy5kZWZpbmUoXCJmcmFtZVwiLCB7XG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4ge1xuXHQgICAgICAgIHg6IDAsXG5cdCAgICAgICAgeTogMCxcblx0ICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcblx0ICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0XG5cdCAgICAgIH07XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIENhbnZhc0NsYXNzLmRlZmluZShcImJhY2tncm91bmRDb2xvclwiLCB7XG5cdCAgICBpbXBvcnRhYmxlOiBmYWxzZSxcblx0ICAgIGV4cG9ydGFibGU6IGZhbHNlLFxuXHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIEZyYW1lci5EZXZpY2UuYmFja2dyb3VuZC5iYWNrZ3JvdW5kQ29sb3I7XG5cdCAgICB9LFxuXHQgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICByZXR1cm4gRnJhbWVyLkRldmljZS5iYWNrZ3JvdW5kLmJhY2tncm91bmRDb2xvciA9IHZhbHVlO1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBDYW52YXNDbGFzcy5kZWZpbmUoXCJpbWFnZVwiLCB7XG5cdCAgICBpbXBvcnRhYmxlOiBmYWxzZSxcblx0ICAgIGV4cG9ydGFibGU6IGZhbHNlLFxuXHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIEZyYW1lci5EZXZpY2UuYmFja2dyb3VuZC5pbWFnZTtcblx0ICAgIH0sXG5cdCAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgIHJldHVybiBGcmFtZXIuRGV2aWNlLmJhY2tncm91bmQuaW1hZ2UgPSB2YWx1ZTtcblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgQ2FudmFzQ2xhc3MucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuXHQgICAgaWYgKGV2ZW50TmFtZSA9PT0gXCJyZXNpemVcIikge1xuXHQgICAgICBFdmVudHMud3JhcCh3aW5kb3cpLmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgKGZ1bmN0aW9uKF90aGlzKSB7XG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgcmV0dXJuIF90aGlzLmVtaXQoXCJyZXNpemVcIik7XG5cdCAgICAgICAgfTtcblx0ICAgICAgfSkodGhpcykpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIENhbnZhc0NsYXNzLl9fc3VwZXJfXy5hZGRMaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuXHQgIH07XG5cdFxuXHQgIENhbnZhc0NsYXNzLnByb3RvdHlwZS5vbiA9IENhbnZhc0NsYXNzLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblx0XG5cdCAgQ2FudmFzQ2xhc3MucHJvdG90eXBlLm9uUmVzaXplID0gZnVuY3Rpb24oY2IpIHtcblx0ICAgIHJldHVybiB0aGlzLm9uKFwicmVzaXplXCIsIGNiKTtcblx0ICB9O1xuXHRcblx0ICByZXR1cm4gQ2FudmFzQ2xhc3M7XG5cdFxuXHR9KShCYXNlQ2xhc3MpO1xuXHRcblx0ZXhwb3J0cy5DYW52YXMgPSBuZXcgQ2FudmFzQ2xhc3M7XG5cblxuLyoqKi8gfSxcbi8qIDM5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHR2YXIgYm90dG9tLCBjZW50ZXIsIGxlZnQsIHJpZ2h0LCB0b3AsIHdyYXBwZXI7XG5cdFxuXHRjZW50ZXIgPSBmdW5jdGlvbihsYXllciwgcHJvcGVydHksIG9mZnNldCkge1xuXHQgIHZhciBib3JkZXJXaWR0aCwgcGFyZW50O1xuXHQgIGlmIChvZmZzZXQgPT0gbnVsbCkge1xuXHQgICAgb2Zmc2V0ID0gMDtcblx0ICB9XG5cdCAgcGFyZW50ID0gU2NyZWVuO1xuXHQgIGlmIChsYXllci5wYXJlbnQpIHtcblx0ICAgIHBhcmVudCA9IGxheWVyLnBhcmVudDtcblx0ICB9XG5cdCAgYm9yZGVyV2lkdGggPSBwYXJlbnQuYm9yZGVyV2lkdGg7XG5cdCAgaWYgKGJvcmRlcldpZHRoID09IG51bGwpIHtcblx0ICAgIGJvcmRlcldpZHRoID0gMDtcblx0ICB9XG5cdCAgaWYgKHByb3BlcnR5ID09PSBcInhcIikge1xuXHQgICAgcmV0dXJuIChwYXJlbnQud2lkdGggLyAyKSAtIChsYXllci53aWR0aCAvIDIpIC0gYm9yZGVyV2lkdGggKyBvZmZzZXQ7XG5cdCAgfVxuXHQgIGlmIChwcm9wZXJ0eSA9PT0gXCJ5XCIpIHtcblx0ICAgIHJldHVybiAocGFyZW50LmhlaWdodCAvIDIpIC0gKGxheWVyLmhlaWdodCAvIDIpIC0gYm9yZGVyV2lkdGggKyBvZmZzZXQ7XG5cdCAgfVxuXHQgIHJldHVybiAwO1xuXHR9O1xuXHRcblx0bGVmdCA9IGZ1bmN0aW9uKGxheWVyLCBwcm9wZXJ0eSwgb2Zmc2V0KSB7XG5cdCAgdmFyIHBhcmVudDtcblx0ICBpZiAob2Zmc2V0ID09IG51bGwpIHtcblx0ICAgIG9mZnNldCA9IDA7XG5cdCAgfVxuXHQgIGlmIChwcm9wZXJ0eSAhPT0gXCJ4XCIpIHtcblx0ICAgIHRocm93IEVycm9yKFwiQWxpZ24ubGVmdCBvbmx5IHdvcmtzIGZvciB4XCIpO1xuXHQgIH1cblx0ICBwYXJlbnQgPSBTY3JlZW47XG5cdCAgaWYgKGxheWVyLnBhcmVudCkge1xuXHQgICAgcGFyZW50ID0gbGF5ZXIucGFyZW50O1xuXHQgIH1cblx0ICByZXR1cm4gMCArIG9mZnNldDtcblx0fTtcblx0XG5cdHJpZ2h0ID0gZnVuY3Rpb24obGF5ZXIsIHByb3BlcnR5LCBvZmZzZXQpIHtcblx0ICB2YXIgYm9yZGVyV2lkdGgsIHBhcmVudDtcblx0ICBpZiAob2Zmc2V0ID09IG51bGwpIHtcblx0ICAgIG9mZnNldCA9IDA7XG5cdCAgfVxuXHQgIGlmIChwcm9wZXJ0eSAhPT0gXCJ4XCIpIHtcblx0ICAgIHRocm93IEVycm9yKFwiQWxpZ24ucmlnaHQgb25seSB3b3JrcyBmb3IgeFwiKTtcblx0ICB9XG5cdCAgcGFyZW50ID0gU2NyZWVuO1xuXHQgIGlmIChsYXllci5wYXJlbnQpIHtcblx0ICAgIHBhcmVudCA9IGxheWVyLnBhcmVudDtcblx0ICB9XG5cdCAgYm9yZGVyV2lkdGggPSBwYXJlbnQuYm9yZGVyV2lkdGg7XG5cdCAgaWYgKGJvcmRlcldpZHRoID09IG51bGwpIHtcblx0ICAgIGJvcmRlcldpZHRoID0gMDtcblx0ICB9XG5cdCAgcmV0dXJuIHBhcmVudC53aWR0aCAtICgyICogYm9yZGVyV2lkdGgpIC0gbGF5ZXIud2lkdGggKyBvZmZzZXQ7XG5cdH07XG5cdFxuXHR0b3AgPSBmdW5jdGlvbihsYXllciwgcHJvcGVydHksIG9mZnNldCkge1xuXHQgIHZhciBwYXJlbnQ7XG5cdCAgaWYgKG9mZnNldCA9PSBudWxsKSB7XG5cdCAgICBvZmZzZXQgPSAwO1xuXHQgIH1cblx0ICBpZiAocHJvcGVydHkgIT09IFwieVwiKSB7XG5cdCAgICB0aHJvdyBFcnJvcihcIkFsaWduLnRvcCBvbmx5IHdvcmtzIGZvciB5XCIpO1xuXHQgIH1cblx0ICBwYXJlbnQgPSBTY3JlZW47XG5cdCAgaWYgKGxheWVyLnBhcmVudCkge1xuXHQgICAgcGFyZW50ID0gbGF5ZXIucGFyZW50O1xuXHQgIH1cblx0ICByZXR1cm4gMCArIG9mZnNldDtcblx0fTtcblx0XG5cdGJvdHRvbSA9IGZ1bmN0aW9uKGxheWVyLCBwcm9wZXJ0eSwgb2Zmc2V0KSB7XG5cdCAgdmFyIGJvcmRlcldpZHRoLCBwYXJlbnQ7XG5cdCAgaWYgKG9mZnNldCA9PSBudWxsKSB7XG5cdCAgICBvZmZzZXQgPSAwO1xuXHQgIH1cblx0ICBpZiAocHJvcGVydHkgIT09IFwieVwiKSB7XG5cdCAgICB0aHJvdyBFcnJvcihcIkFsaWduLmJvdHRvbSBvbmx5IHdvcmtzIGZvciB5XCIpO1xuXHQgIH1cblx0ICBwYXJlbnQgPSBTY3JlZW47XG5cdCAgaWYgKGxheWVyLnBhcmVudCkge1xuXHQgICAgcGFyZW50ID0gbGF5ZXIucGFyZW50O1xuXHQgIH1cblx0ICBib3JkZXJXaWR0aCA9IHBhcmVudC5ib3JkZXJXaWR0aDtcblx0ICBpZiAoYm9yZGVyV2lkdGggPT0gbnVsbCkge1xuXHQgICAgYm9yZGVyV2lkdGggPSAwO1xuXHQgIH1cblx0ICByZXR1cm4gcGFyZW50LmhlaWdodCAtICgyICogYm9yZGVyV2lkdGgpIC0gbGF5ZXIuaGVpZ2h0ICsgb2Zmc2V0O1xuXHR9O1xuXHRcblx0d3JhcHBlciA9IGZ1bmN0aW9uKGYpIHtcblx0ICByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuXHQgICAgaWYgKChhID09IG51bGwpIHx8IF8uaXNOdW1iZXIoYSkpIHtcblx0ICAgICAgcmV0dXJuIChmdW5jdGlvbihsLCBwKSB7XG5cdCAgICAgICAgcmV0dXJuIGYobCwgcCwgYSk7XG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGYoYSwgYiwgMCk7XG5cdCAgfTtcblx0fTtcblx0XG5cdGV4cG9ydHMuQWxpZ24gPSB7XG5cdCAgY2VudGVyOiB3cmFwcGVyKGNlbnRlciksXG5cdCAgbGVmdDogd3JhcHBlcihsZWZ0KSxcblx0ICByaWdodDogd3JhcHBlcihyaWdodCksXG5cdCAgdG9wOiB3cmFwcGVyKHRvcCksXG5cdCAgYm90dG9tOiB3cmFwcGVyKGJvdHRvbSlcblx0fTtcblxuXG4vKioqLyB9LFxuLyogNDAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBDb250ZXh0LCBVdGlscywgcHJpbnRDb250ZXh0LCBwcmludExheWVyLFxuXHQgIHNsaWNlID0gW10uc2xpY2U7XG5cdFxuXHRVdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdFxuXHRDb250ZXh0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MSkuQ29udGV4dDtcblx0XG5cdFwiXFxuVG9kbzpcXG4tIEJldHRlciBsb29rc1xcbi0gUmVzaXphYmxlXFxuLSBMaXZlIGluIG93biBzcGFjZSBvbiB0b3Agb2YgYWxsIEZyYW1lciBzdHVmZlxcblwiO1xuXHRcblx0cHJpbnRDb250ZXh0ID0gbnVsbDtcblx0XG5cdHByaW50TGF5ZXIgPSBudWxsO1xuXHRcblx0ZXhwb3J0cy5wcmludCA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciBhcmdzO1xuXHQgIGFyZ3MgPSAxIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBzbGljZS5jYWxsKGFyZ3VtZW50cywgMCkgOiBbXTtcblx0ICBpZiAoIXByaW50Q29udGV4dCkge1xuXHQgICAgcHJpbnRDb250ZXh0ID0gbmV3IENvbnRleHQoe1xuXHQgICAgICBuYW1lOiBcIlByaW50XCJcblx0ICAgIH0pO1xuXHQgIH1cblx0ICBwcmludENvbnRleHQucnVuKGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIHByaW50Tm9kZSwgcHJpbnRQcmVmaXgsIHVwZGF0ZTtcblx0ICAgIGlmICghcHJpbnRMYXllcikge1xuXHQgICAgICBwcmludExheWVyID0gbmV3IExheWVyO1xuXHQgICAgICBwcmludExheWVyLnNjcm9sbFZlcnRpY2FsID0gdHJ1ZTtcblx0ICAgICAgcHJpbnRMYXllci5pZ25vcmVFdmVudHMgPSBmYWxzZTtcblx0ICAgICAgcHJpbnRMYXllci5odG1sID0gXCJcIjtcblx0ICAgICAgcHJpbnRMYXllci5zdHlsZSA9IHtcblx0ICAgICAgICBcImZvbnRcIjogXCIxMnB4LzEuMzVlbSBNZW5sb1wiLFxuXHQgICAgICAgIFwiY29sb3JcIjogXCJyZ2JhKDAsMCwwLC43KVwiLFxuXHQgICAgICAgIFwicGFkZGluZ1wiOiBcIjhweFwiLFxuXHQgICAgICAgIFwicGFkZGluZy1ib3R0b21cIjogXCIzMHB4XCIsXG5cdCAgICAgICAgXCJib3JkZXItdG9wXCI6IFwiMXB4IHNvbGlkICNkOWQ5ZDlcIlxuXHQgICAgICB9O1xuXHQgICAgICBwcmludExheWVyLm9wYWNpdHkgPSAwLjk7XG5cdCAgICAgIHByaW50TGF5ZXIuc3R5bGUuekluZGV4ID0gOTk5O1xuXHQgICAgICBwcmludExheWVyLnZpc2libGUgPSB0cnVlO1xuXHQgICAgICBwcmludExheWVyLmJhY2tncm91bmRDb2xvciA9IFwid2hpdGVcIjtcblx0ICAgICAgdXBkYXRlID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgcHJpbnRMYXllci53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuXHQgICAgICAgIHByaW50TGF5ZXIuaGVpZ2h0ID0gMTYwO1xuXHQgICAgICAgIHJldHVybiBwcmludExheWVyLm1heFkgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cdCAgICAgIH07XG5cdCAgICAgIHVwZGF0ZSgpO1xuXHQgICAgICBwcmludENvbnRleHQuZG9tRXZlbnRNYW5hZ2VyLndyYXAod2luZG93KS5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHVwZGF0ZSk7XG5cdCAgICB9XG5cdCAgICBwcmludFByZWZpeCA9IFwiwrsgXCI7XG5cdCAgICBwcmludE5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHQgICAgcHJpbnROb2RlLmlubmVySFRNTCA9IF8uZXNjYXBlKHByaW50UHJlZml4ICsgYXJncy5tYXAoZnVuY3Rpb24ob2JqKSB7XG5cdCAgICAgIHJldHVybiBVdGlscy5pbnNwZWN0KG9iaik7XG5cdCAgICB9KS5qb2luKFwiLCBcIikpICsgXCI8YnI+XCI7XG5cdCAgICBwcmludE5vZGUuc3R5bGVbXCItd2Via2l0LXVzZXItc2VsZWN0XCJdID0gXCJ0ZXh0XCI7XG5cdCAgICBwcmludE5vZGUuc3R5bGVbXCJjdXJzb3JcIl0gPSBcImF1dG9cIjtcblx0ICAgIHJldHVybiBwcmludExheWVyLl9lbGVtZW50LmFwcGVuZENoaWxkKHByaW50Tm9kZSk7XG5cdCAgfSk7XG5cdCAgcmV0dXJuIFV0aWxzLmRlbGF5KDAsIGZ1bmN0aW9uKCkge1xuXHQgICAgcmV0dXJuIHByaW50TGF5ZXIuX2VsZW1lbnQuc2Nyb2xsVG9wID0gcHJpbnRMYXllci5fZWxlbWVudC5zY3JvbGxIZWlnaHQ7XG5cdCAgfSk7XG5cdH07XG5cblxuLyoqKi8gfSxcbi8qIDQxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgQmFzZUNsYXNzLCBDb25maWcsIERPTUV2ZW50TWFuYWdlciwgRGVmYXVsdHMsIFV0aWxzLCBfLFxuXHQgIGV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcblx0ICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXG5cdCAgaW5kZXhPZiA9IFtdLmluZGV4T2YgfHwgZnVuY3Rpb24oaXRlbSkgeyBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7IGlmIChpIGluIHRoaXMgJiYgdGhpc1tpXSA9PT0gaXRlbSkgcmV0dXJuIGk7IH0gcmV0dXJuIC0xOyB9O1xuXHRcblx0XyA9IF9fd2VicGFja19yZXF1aXJlX18oMSkuXztcblx0XG5cdFV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0XG5cdENvbmZpZyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpLkNvbmZpZztcblx0XG5cdERlZmF1bHRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNykuRGVmYXVsdHM7XG5cdFxuXHRCYXNlQ2xhc3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpLkJhc2VDbGFzcztcblx0XG5cdERPTUV2ZW50TWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oNDIpLkRPTUV2ZW50TWFuYWdlcjtcblx0XG5cdFxuXHQvKlxuXHRcblx0QW4gZWFzeSB3YXkgdG8gdGhpbmsgb2YgdGhlIGNvbnRleHQgaXMgYSBidWNrZXQgb2YgdGhpbmdzIHJlbGF0ZWQgdG8gYSBzZXQgb2YgbGF5ZXJzLiBUaGVyZVxuXHRpcyBhbHdheXMgYXQgbGVhc3Qgb25lIGNvbnRleHQgb24gdGhlIHNjcmVlbiwgYnV0IG9mdGVuIG1hbnkgbW9yZS4gRm9yIGV4YW1wbGUsIHRoZSBkZXZpY2UgaGFzXG5cdGEgc3BlY2lhbCBjb250ZXh0IGFuZCByZXBsYWNlcyB0aGUgZGVmYXVsdCBvbmUgKHNvIGl0IHJlbmRlcnMgaW4gdGhlIHNjcmVlbiksIGFuZCB0aGUgcHJpbnRcblx0ZnVuY3Rpb24gdXNlcyBvbiB0byBkcmF3IHRoZSBjb25zb2xlLlxuXHRcblx0VGhlIGRlZmF1bHQgY29udGV4dCBsaXZlcyB1bmRlciBGcmFtZXIuRGVmYXVsdENvbnRleHQgYW5kIHRoZSBjdXJyZW50IG9uZSBpblxuXHRGcmFtZXIuQ3VycmVudENvbnRleHQuIFlvdSBjYW4gY3JlYXRlIGxheWVycyBpbiBhbnkgY29udGV4dCBieSB1c2luZyB0aGUgcnVuIGZ1bmN0aW9uLlxuXHRcblx0QSBjb250ZXh0IGtlZXBzIHRyYWNrIG9mIGV2ZXJ5dGluZyBhcm91bmQgdGhvc2UgbGF5ZXJzLCBzbyBpdCBjYW4gY2xlYW4gaXQgdXAgYWdhaW4uIFdlIHVzZVxuXHR0aGlzIGEgbG90IGluIEZyYW1lciBTdHVkaW8ncyBhdXRvY29tcGxldGUgZnVuY3Rpb24uIEFzeW5jIHRoaW5ncyBsaWtlIHJ1bm5pbmcgYW5pbWF0aW9ucyBhbmRcblx0dGltZXJzIGdldCBzdG9wcGVkIHRvby5cblx0XG5cdENvbnRleHRzIGNhbiBsaXZlIGluc2lkZSBhbm90aGVyIGNvbnRleHQgKHdpdGggYSBsYXllciBhcyBhIHBhcmVudCkgc28geW91IGNhbiBvbmx5IHJlbG9hZFxuXHRhIHBhcnQgb2YgYSBwcm90b3R5cGUuIFRoaXMgaXMgbWFpbmx5IGhvdyBkZXZpY2Ugd29ya3MuXG5cdFxuXHRBbm90aGVyIGZlYXR1cmUgaXMgdG8gdGVtcG9yYXJpbHkgZnJlZXplL3Jlc3VtZSBhIGNvbnRleHQuIElmIHlvdSBmcmVlemUgaXQsIGFsbCB1c2VyIGV2ZW50XG5cdHdpbGwgdGVtcG9yYXJpbHkgZ2V0IGJsb2NrZWQgc28gaW4gdGhlb3J5IG5vdGhpbmcgd2lsbCBjaGFuZ2UgaW4gdGhlIGNvbnRleHQuIFlvdSBjYW4gcmVzdG9yZVxuXHR0aGVzZSBhdCBhbnkgdGltZS5cblx0ICovXG5cdFxuXHRleHBvcnRzLkNvbnRleHQgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuXHQgIGV4dGVuZChDb250ZXh0LCBzdXBlckNsYXNzKTtcblx0XG5cdCAgQ29udGV4dC5kZWZpbmUoXCJwYXJlbnRcIiwge1xuXHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudDtcblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgQ29udGV4dC5kZWZpbmUoXCJlbGVtZW50XCIsIHtcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50O1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBmdW5jdGlvbiBDb250ZXh0KG9wdGlvbnMpIHtcblx0ICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcblx0ICAgICAgb3B0aW9ucyA9IHt9O1xuXHQgICAgfVxuXHQgICAgb3B0aW9ucyA9IERlZmF1bHRzLmdldERlZmF1bHRzKFwiQ29udGV4dFwiLCBvcHRpb25zKTtcblx0ICAgIENvbnRleHQuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICBpZiAoIW9wdGlvbnMubmFtZSkge1xuXHQgICAgICB0aHJvdyBFcnJvcihcIkNvbnRleHRzIG5lZWQgYSBuYW1lXCIpO1xuXHQgICAgfVxuXHQgICAgdGhpcy5fcGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG5cdCAgICB0aGlzLl9uYW1lID0gb3B0aW9ucy5uYW1lO1xuXHQgICAgdGhpcy5wZXJzcGVjdGl2ZSA9IG9wdGlvbnMucGVyc3BlY3RpdmU7XG5cdCAgICB0aGlzLnBlcnNwZWN0aXZlT3JpZ2luWCA9IG9wdGlvbnMucGVyc3BlY3RpdmVPcmlnaW5YO1xuXHQgICAgdGhpcy5wZXJzcGVjdGl2ZU9yaWdpblkgPSBvcHRpb25zLnBlcnNwZWN0aXZlT3JpZ2luWTtcblx0ICAgIHRoaXMucmVzZXQoKTtcblx0ICB9XG5cdFxuXHQgIENvbnRleHQucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG5cdCAgICB0aGlzLl9jcmVhdGVET01FdmVudE1hbmFnZXIoKTtcblx0ICAgIHRoaXMuX2NyZWF0ZVJvb3RFbGVtZW50KCk7XG5cdCAgICB0aGlzLnJlc2V0TGF5ZXJzKCk7XG5cdCAgICB0aGlzLnJlc2V0QW5pbWF0aW9ucygpO1xuXHQgICAgdGhpcy5yZXNldFRpbWVycygpO1xuXHQgICAgdGhpcy5yZXNldEludGVydmFscygpO1xuXHQgICAgcmV0dXJuIHRoaXMuZW1pdChcInJlc2V0XCIsIHRoaXMpO1xuXHQgIH07XG5cdFxuXHQgIENvbnRleHQuZGVmaW5lKFwibGF5ZXJzXCIsIHtcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiBfLmNsb25lKHRoaXMuX2xheWVycyk7XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIENvbnRleHQuZGVmaW5lKFwibGF5ZXJDb3VudGVyXCIsIHtcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9sYXllckNvdW50ZXI7XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIENvbnRleHQucHJvdG90eXBlLmFkZExheWVyID0gZnVuY3Rpb24obGF5ZXIpIHtcblx0ICAgIGlmIChpbmRleE9mLmNhbGwodGhpcy5fbGF5ZXJzLCBsYXllcikgPj0gMCkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICB0aGlzLl9sYXllckNvdW50ZXIrKztcblx0ICAgIHJldHVybiB0aGlzLl9sYXllcnMucHVzaChsYXllcik7XG5cdCAgfTtcblx0XG5cdCAgQ29udGV4dC5wcm90b3R5cGUucmVtb3ZlTGF5ZXIgPSBmdW5jdGlvbihsYXllcikge1xuXHQgICAgcmV0dXJuIHRoaXMuX2xheWVycyA9IF8ud2l0aG91dCh0aGlzLl9sYXllcnMsIGxheWVyKTtcblx0ICB9O1xuXHRcblx0ICBDb250ZXh0LnByb3RvdHlwZS5yZXNldExheWVycyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdGhpcy5yZXNldEdlc3R1cmVzKCk7XG5cdCAgICB0aGlzLl9sYXllcnMgPSBbXTtcblx0ICAgIHJldHVybiB0aGlzLl9sYXllckNvdW50ZXIgPSAwO1xuXHQgIH07XG5cdFxuXHQgIENvbnRleHQuZGVmaW5lKFwiYW5pbWF0aW9uc1wiLCB7XG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gXy5jbG9uZSh0aGlzLl9hbmltYXRpb25zKTtcblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgQ29udGV4dC5wcm90b3R5cGUuYWRkQW5pbWF0aW9uID0gZnVuY3Rpb24oYW5pbWF0aW9uKSB7XG5cdCAgICBpZiAoaW5kZXhPZi5jYWxsKHRoaXMuX2FuaW1hdGlvbnMsIGFuaW1hdGlvbikgPj0gMCkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcy5fYW5pbWF0aW9ucy5wdXNoKGFuaW1hdGlvbik7XG5cdCAgfTtcblx0XG5cdCAgQ29udGV4dC5wcm90b3R5cGUucmVtb3ZlQW5pbWF0aW9uID0gZnVuY3Rpb24oYW5pbWF0aW9uKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fYW5pbWF0aW9ucyA9IF8ud2l0aG91dCh0aGlzLl9hbmltYXRpb25zLCBhbmltYXRpb24pO1xuXHQgIH07XG5cdFxuXHQgIENvbnRleHQucHJvdG90eXBlLnJlc2V0QW5pbWF0aW9ucyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdGhpcy5zdG9wQW5pbWF0aW9ucygpO1xuXHQgICAgcmV0dXJuIHRoaXMuX2FuaW1hdGlvbnMgPSBbXTtcblx0ICB9O1xuXHRcblx0ICBDb250ZXh0LnByb3RvdHlwZS5zdG9wQW5pbWF0aW9ucyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgaWYgKCF0aGlzLl9hbmltYXRpb25zKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0aGlzLl9hbmltYXRpb25zLm1hcChmdW5jdGlvbihhbmltYXRpb24pIHtcblx0ICAgICAgcmV0dXJuIGFuaW1hdGlvbi5zdG9wKHRydWUpO1xuXHQgICAgfSk7XG5cdCAgfTtcblx0XG5cdCAgQ29udGV4dC5kZWZpbmUoXCJ0aW1lcnNcIiwge1xuXHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIF8uY2xvbmUodGhpcy5fdGltZXJzKTtcblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgQ29udGV4dC5wcm90b3R5cGUuYWRkVGltZXIgPSBmdW5jdGlvbih0aW1lcikge1xuXHQgICAgaWYgKGluZGV4T2YuY2FsbCh0aGlzLl90aW1lcnMsIHRpbWVyKSA+PSAwKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0aGlzLl90aW1lcnMucHVzaCh0aW1lcik7XG5cdCAgfTtcblx0XG5cdCAgQ29udGV4dC5wcm90b3R5cGUucmVtb3ZlVGltZXIgPSBmdW5jdGlvbih0aW1lcikge1xuXHQgICAgcmV0dXJuIHRoaXMuX3RpbWVycyA9IF8ud2l0aG91dCh0aGlzLl90aW1lcnMsIHRpbWVyKTtcblx0ICB9O1xuXHRcblx0ICBDb250ZXh0LnByb3RvdHlwZS5yZXNldFRpbWVycyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgaWYgKHRoaXMuX3RpbWVycykge1xuXHQgICAgICB0aGlzLl90aW1lcnMubWFwKHdpbmRvdy5jbGVhclRpbWVvdXQpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXMuX3RpbWVycyA9IFtdO1xuXHQgIH07XG5cdFxuXHQgIENvbnRleHQuZGVmaW5lKFwiaW50ZXJ2YWxzXCIsIHtcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiBfLmNsb25lKHRoaXMuX2ludGVydmFscyk7XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIENvbnRleHQucHJvdG90eXBlLmFkZEludGVydmFsID0gZnVuY3Rpb24oaW50ZXJ2YWwpIHtcblx0ICAgIGlmIChpbmRleE9mLmNhbGwodGhpcy5faW50ZXJ2YWxzLCBpbnRlcnZhbCkgPj0gMCkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcy5faW50ZXJ2YWxzLnB1c2goaW50ZXJ2YWwpO1xuXHQgIH07XG5cdFxuXHQgIENvbnRleHQucHJvdG90eXBlLnJlbW92ZUludGVydmFsID0gZnVuY3Rpb24oaW50ZXJ2YWwpIHtcblx0ICAgIHJldHVybiB0aGlzLl9pbnRlcnZhbHMgPSBfLndpdGhvdXQodGhpcy5faW50ZXJ2YWxzLCBpbnRlcnZhbCk7XG5cdCAgfTtcblx0XG5cdCAgQ29udGV4dC5wcm90b3R5cGUucmVzZXRJbnRlcnZhbHMgPSBmdW5jdGlvbigpIHtcblx0ICAgIGlmICh0aGlzLl9pbnRlcnZhbHMpIHtcblx0ICAgICAgdGhpcy5faW50ZXJ2YWxzLm1hcCh3aW5kb3cuY2xlYXJJbnRlcnZhbCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcy5faW50ZXJ2YWxzID0gW107XG5cdCAgfTtcblx0XG5cdCAgQ29udGV4dC5wcm90b3R5cGUucmVzZXRHZXN0dXJlcyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIGksIGxheWVyLCBsZW4sIHJlZjtcblx0ICAgIGlmICghdGhpcy5fbGF5ZXJzKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHJlZiA9IHRoaXMuX2xheWVycztcblx0ICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHQgICAgICBsYXllciA9IHJlZltpXTtcblx0ICAgICAgaWYgKGxheWVyLl9nZXN0dXJlcykge1xuXHQgICAgICAgIGxheWVyLl9nZXN0dXJlcy5kZXN0cm95KCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXHRcblx0ICBDb250ZXh0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbihmbikge1xuXHQgICAgdmFyIHByZXZpb3VzQ29udGV4dDtcblx0ICAgIHByZXZpb3VzQ29udGV4dCA9IEZyYW1lci5DdXJyZW50Q29udGV4dDtcblx0ICAgIEZyYW1lci5DdXJyZW50Q29udGV4dCA9IHRoaXM7XG5cdCAgICBmbigpO1xuXHQgICAgcmV0dXJuIEZyYW1lci5DdXJyZW50Q29udGV4dCA9IHByZXZpb3VzQ29udGV4dDtcblx0ICB9O1xuXHRcblx0ICBDb250ZXh0LnByb3RvdHlwZS5mcmVlemUgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciBldmVudE5hbWUsIGksIGosIGxheWVyLCBsYXllcklkLCBsYXllckxpc3RlbmVycywgbGVuLCBsZW4xLCByZWYsIHJlZjE7XG5cdCAgICBpZiAodGhpcy5fZnJvemVuRXZlbnRzICE9IG51bGwpIHtcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udGV4dCBpcyBhbHJlYWR5IGZyb3plblwiKTtcblx0ICAgIH1cblx0ICAgIHRoaXMuX2Zyb3plbkV2ZW50cyA9IHt9O1xuXHQgICAgcmVmID0gdGhpcy5fbGF5ZXJzO1xuXHQgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICAgIGxheWVyID0gcmVmW2ldO1xuXHQgICAgICBsYXllckxpc3RlbmVycyA9IHt9O1xuXHQgICAgICByZWYxID0gbGF5ZXIubGlzdGVuZXJFdmVudHMoKTtcblx0ICAgICAgZm9yIChqID0gMCwgbGVuMSA9IHJlZjEubGVuZ3RoOyBqIDwgbGVuMTsgaisrKSB7XG5cdCAgICAgICAgZXZlbnROYW1lID0gcmVmMVtqXTtcblx0ICAgICAgICBsYXllckxpc3RlbmVyc1tldmVudE5hbWVdID0gbGF5ZXIubGlzdGVuZXJzKGV2ZW50TmFtZSk7XG5cdCAgICAgIH1cblx0ICAgICAgbGF5ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG5cdCAgICAgIGxheWVySWQgPSB0aGlzLl9sYXllcnMuaW5kZXhPZihsYXllcik7XG5cdCAgICAgIHRoaXMuX2Zyb3plbkV2ZW50c1tsYXllcklkXSA9IGxheWVyTGlzdGVuZXJzO1xuXHQgICAgfVxuXHQgICAgdGhpcy5zdG9wQW5pbWF0aW9ucygpO1xuXHQgICAgdGhpcy5yZXNldFRpbWVycygpO1xuXHQgICAgcmV0dXJuIHRoaXMucmVzZXRJbnRlcnZhbHMoKTtcblx0ICB9O1xuXHRcblx0ICBDb250ZXh0LnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciBldmVudE5hbWUsIGV2ZW50cywgaSwgbGF5ZXIsIGxheWVySWQsIGxlbiwgbGlzdGVuZXIsIGxpc3RlbmVycywgcmVmO1xuXHQgICAgaWYgKHRoaXMuX2Zyb3plbkV2ZW50cyA9PSBudWxsKSB7XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnRleHQgaXMgbm90IGZyb3plbiwgY2Fubm90IHJlc3VtZVwiKTtcblx0ICAgIH1cblx0ICAgIHJlZiA9IHRoaXMuX2Zyb3plbkV2ZW50cztcblx0ICAgIGZvciAobGF5ZXJJZCBpbiByZWYpIHtcblx0ICAgICAgZXZlbnRzID0gcmVmW2xheWVySWRdO1xuXHQgICAgICBsYXllciA9IHRoaXMuX2xheWVyc1tsYXllcklkXTtcblx0ICAgICAgZm9yIChldmVudE5hbWUgaW4gZXZlbnRzKSB7XG5cdCAgICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW2V2ZW50TmFtZV07XG5cdCAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXTtcblx0ICAgICAgICAgIGxheWVyLm9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIGRlbGV0ZSB0aGlzLl9mcm96ZW5FdmVudHM7XG5cdCAgfTtcblx0XG5cdCAgQ29udGV4dC5wcm90b3R5cGUuX2NyZWF0ZURPTUV2ZW50TWFuYWdlciA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIHJlZjtcblx0ICAgIGlmICgocmVmID0gdGhpcy5kb21FdmVudE1hbmFnZXIpICE9IG51bGwpIHtcblx0ICAgICAgcmVmLnJlc2V0KCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcy5kb21FdmVudE1hbmFnZXIgPSBuZXcgRE9NRXZlbnRNYW5hZ2VyO1xuXHQgIH07XG5cdFxuXHQgIENvbnRleHQucHJvdG90eXBlLl9jcmVhdGVSb290RWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdGhpcy5fZGVzdHJveVJvb3RFbGVtZW50KCk7XG5cdCAgICB0aGlzLl9lbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0ICAgIHRoaXMuX2VsZW1lbnQuaWQgPSBcIkZyYW1lckNvbnRleHRSb290LVwiICsgdGhpcy5fbmFtZTtcblx0ICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChcImZyYW1lckNvbnRleHRcIik7XG5cdCAgICB0aGlzLl9lbGVtZW50LnN0eWxlW1wid2Via2l0UGVyc3BlY3RpdmVcIl0gPSB0aGlzLnBlcnNwZWN0aXZlO1xuXHQgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtcImJhY2tncm91bmRDb2xvclwiXSA9IHRoaXMuYmFja2dyb3VuZENvbG9yO1xuXHQgICAgdGhpcy5fX3BlbmRpbmdFbGVtZW50QXBwZW5kID0gKGZ1bmN0aW9uKF90aGlzKSB7XG5cdCAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgICAgICB2YXIgcGFyZW50RWxlbWVudCwgcmVmO1xuXHQgICAgICAgIHBhcmVudEVsZW1lbnQgPSAocmVmID0gX3RoaXMuX3BhcmVudCkgIT0gbnVsbCA/IHJlZi5fZWxlbWVudCA6IHZvaWQgMDtcblx0ICAgICAgICBpZiAocGFyZW50RWxlbWVudCA9PSBudWxsKSB7XG5cdCAgICAgICAgICBwYXJlbnRFbGVtZW50ID0gZG9jdW1lbnQuYm9keTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHBhcmVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoX3RoaXMuX2VsZW1lbnQpO1xuXHQgICAgICB9O1xuXHQgICAgfSkodGhpcyk7XG5cdCAgICByZXR1cm4gVXRpbHMuZG9tQ29tcGxldGUodGhpcy5fX3BlbmRpbmdFbGVtZW50QXBwZW5kKTtcblx0ICB9O1xuXHRcblx0ICBDb250ZXh0LnByb3RvdHlwZS5fZGVzdHJveVJvb3RFbGVtZW50ID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgcmVmO1xuXHQgICAgaWYgKChyZWYgPSB0aGlzLl9lbGVtZW50KSAhPSBudWxsID8gcmVmLnBhcmVudE5vZGUgOiB2b2lkIDApIHtcblx0ICAgICAgdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX2VsZW1lbnQpO1xuXHQgICAgfVxuXHQgICAgaWYgKHRoaXMuX19wZW5kaW5nRWxlbWVudEFwcGVuZCkge1xuXHQgICAgICBVdGlscy5kb21Db21wbGV0ZUNhbmNlbCh0aGlzLl9fcGVuZGluZ0VsZW1lbnRBcHBlbmQpO1xuXHQgICAgICB0aGlzLl9fcGVuZGluZ0VsZW1lbnRBcHBlbmQgPSBudWxsO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuXHQgIH07XG5cdFxuXHQgIENvbnRleHQuZGVmaW5lKFwid2lkdGhcIiwge1xuXHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgaWYgKHRoaXMucGFyZW50ICE9IG51bGwpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQud2lkdGg7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHdpbmRvdy5pbm5lcldpZHRoO1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBDb250ZXh0LmRlZmluZShcImhlaWdodFwiLCB7XG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICBpZiAodGhpcy5wYXJlbnQgIT0gbnVsbCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5oZWlnaHQ7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHdpbmRvdy5pbm5lckhlaWdodDtcblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgQ29udGV4dC5kZWZpbmUoXCJmcmFtZVwiLCB7XG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4ge1xuXHQgICAgICAgIHg6IDAsXG5cdCAgICAgICAgeTogMCxcblx0ICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcblx0ICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0XG5cdCAgICAgIH07XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIENvbnRleHQuZGVmaW5lKFwic2l6ZVwiLCB7XG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gXy5waWNrKHRoaXMuZnJhbWUsIFtcIndpZHRoXCIsIFwiaGVpZ2h0XCJdKTtcblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgQ29udGV4dC5kZWZpbmUoXCJwb2ludFwiLCB7XG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gXy5waWNrKHRoaXMuZnJhbWUsIFtcInhcIiwgXCJ5XCJdKTtcblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgQ29udGV4dC5kZWZpbmUoXCJjYW52YXNGcmFtZVwiLCB7XG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICBpZiAodGhpcy5wYXJlbnQgPT0gbnVsbCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmZyYW1lO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiB0aGlzLnBhcmVudC5jYW52YXNGcmFtZTtcblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgQ29udGV4dC5kZWZpbmUoXCJiYWNrZ3JvdW5kQ29sb3JcIiwge1xuXHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgaWYgKENvbG9yLmlzQ29sb3IodGhpcy5fYmFja2dyb3VuZENvbG9yKSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9iYWNrZ3JvdW5kQ29sb3I7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIFwidHJhbnNwYXJlbnRcIjtcblx0ICAgIH0sXG5cdCAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgIHZhciByZWY7XG5cdCAgICAgIGlmIChDb2xvci5pc0NvbG9yKHZhbHVlKSkge1xuXHQgICAgICAgIHRoaXMuX2JhY2tncm91bmRDb2xvciA9IHZhbHVlO1xuXHQgICAgICAgIHJldHVybiAocmVmID0gdGhpcy5fZWxlbWVudCkgIT0gbnVsbCA/IHJlZi5zdHlsZVtcImJhY2tncm91bmRDb2xvclwiXSA9IG5ldyBDb2xvcih2YWx1ZS50b1N0cmluZygpKSA6IHZvaWQgMDtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBDb250ZXh0LmRlZmluZShcInBlcnNwZWN0aXZlXCIsIHtcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9wZXJzcGVjdGl2ZTtcblx0ICAgIH0sXG5cdCAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgIHZhciByZWY7XG5cdCAgICAgIGlmIChfLmlzTnVtYmVyKHZhbHVlKSkge1xuXHQgICAgICAgIHRoaXMuX3BlcnNwZWN0aXZlID0gdmFsdWU7XG5cdCAgICAgICAgcmV0dXJuIChyZWYgPSB0aGlzLl9lbGVtZW50KSAhPSBudWxsID8gcmVmLnN0eWxlW1wid2Via2l0UGVyc3BlY3RpdmVcIl0gPSB0aGlzLl9wZXJzcGVjdGl2ZSA6IHZvaWQgMDtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBDb250ZXh0LnByb3RvdHlwZS5fdXBkYXRlUGVyc3BlY3RpdmUgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciByZWY7XG5cdCAgICByZXR1cm4gKHJlZiA9IHRoaXMuX2VsZW1lbnQpICE9IG51bGwgPyByZWYuc3R5bGVbXCJ3ZWJraXRQZXJzcGVjdGl2ZU9yaWdpblwiXSA9ICh0aGlzLnBlcnNwZWN0aXZlT3JpZ2luWCAqIDEwMCkgKyBcIiUgXCIgKyAodGhpcy5wZXJzcGVjdGl2ZU9yaWdpblkgKiAxMDApICsgXCIlXCIgOiB2b2lkIDA7XG5cdCAgfTtcblx0XG5cdCAgQ29udGV4dC5kZWZpbmUoXCJwZXJzcGVjdGl2ZU9yaWdpblhcIiwge1xuXHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgaWYgKF8uaXNOdW1iZXIodGhpcy5fcGVyc3BlY3RpdmVPcmlnaW5YKSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9wZXJzcGVjdGl2ZU9yaWdpblg7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIDAuNTtcblx0ICAgIH0sXG5cdCAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgIGlmIChfLmlzTnVtYmVyKHZhbHVlKSkge1xuXHQgICAgICAgIHRoaXMuX3BlcnNwZWN0aXZlT3JpZ2luWCA9IHZhbHVlO1xuXHQgICAgICAgIHJldHVybiB0aGlzLl91cGRhdGVQZXJzcGVjdGl2ZSgpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIENvbnRleHQuZGVmaW5lKFwicGVyc3BlY3RpdmVPcmlnaW5ZXCIsIHtcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIGlmIChfLmlzTnVtYmVyKHRoaXMuX3BlcnNwZWN0aXZlT3JpZ2luWSkpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fcGVyc3BlY3RpdmVPcmlnaW5ZO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiAuNTtcblx0ICAgIH0sXG5cdCAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgIGlmIChfLmlzTnVtYmVyKHZhbHVlKSkge1xuXHQgICAgICAgIHRoaXMuX3BlcnNwZWN0aXZlT3JpZ2luWSA9IHZhbHVlO1xuXHQgICAgICAgIHJldHVybiB0aGlzLl91cGRhdGVQZXJzcGVjdGl2ZSgpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIENvbnRleHQucHJvdG90eXBlLnRvSW5zcGVjdCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIHJvdW5kO1xuXHQgICAgcm91bmQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICBpZiAocGFyc2VJbnQodmFsdWUpID09PSB2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIFV0aWxzLnJvdW5kKHZhbHVlLCAxKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gXCI8XCIgKyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyBcIiBpZDpcIiArIHRoaXMuaWQgKyBcIiBuYW1lOlwiICsgdGhpcy5fbmFtZSArIFwiIFwiICsgKHJvdW5kKHRoaXMud2lkdGgpKSArIFwieFwiICsgKHJvdW5kKHRoaXMuaGVpZ2h0KSkgKyBcIj5cIjtcblx0ICB9O1xuXHRcblx0ICByZXR1cm4gQ29udGV4dDtcblx0XG5cdH0pKEJhc2VDbGFzcyk7XG5cblxuLyoqKi8gfSxcbi8qIDQyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgRE9NRXZlbnRNYW5hZ2VyRWxlbWVudCwgRXZlbnRFbWl0dGVyLCBFdmVudE1hbmFnZXJJZENvdW50ZXIsIFV0aWxzLCBfLFxuXHQgIGV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcblx0ICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXG5cdCAgYmluZCA9IGZ1bmN0aW9uKGZuLCBtZSl7IHJldHVybiBmdW5jdGlvbigpeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH07XG5cdFxuXHRfID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKS5fO1xuXHRcblx0RXZlbnRFbWl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KS5FdmVudEVtaXR0ZXI7XG5cdFxuXHRVdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdFxuXHRFdmVudE1hbmFnZXJJZENvdW50ZXIgPSAwO1xuXHRcblx0RE9NRXZlbnRNYW5hZ2VyRWxlbWVudCA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG5cdCAgZXh0ZW5kKERPTUV2ZW50TWFuYWdlckVsZW1lbnQsIHN1cGVyQ2xhc3MpO1xuXHRcblx0ICBmdW5jdGlvbiBET01FdmVudE1hbmFnZXJFbGVtZW50KGVsZW1lbnQxKSB7XG5cdCAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50MTtcblx0ICB9XG5cdFxuXHQgIERPTUV2ZW50TWFuYWdlckVsZW1lbnQucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnROYW1lLCBsaXN0ZW5lciwgY2FwdHVyZSkge1xuXHQgICAgaWYgKGNhcHR1cmUgPT0gbnVsbCkge1xuXHQgICAgICBjYXB0dXJlID0gZmFsc2U7XG5cdCAgICB9XG5cdCAgICBET01FdmVudE1hbmFnZXJFbGVtZW50Ll9fc3VwZXJfXy5hZGRMaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuXHQgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIGZhbHNlKTtcblx0ICB9O1xuXHRcblx0ICBET01FdmVudE1hbmFnZXJFbGVtZW50LnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcblx0ICAgIERPTUV2ZW50TWFuYWdlckVsZW1lbnQuX19zdXBlcl9fLnJlbW92ZUxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnROYW1lLCBsaXN0ZW5lcik7XG5cdCAgICByZXR1cm4gdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgZmFsc2UpO1xuXHQgIH07XG5cdFxuXHQgIERPTUV2ZW50TWFuYWdlckVsZW1lbnQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBET01FdmVudE1hbmFnZXJFbGVtZW50LnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblx0XG5cdCAgRE9NRXZlbnRNYW5hZ2VyRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IERPTUV2ZW50TWFuYWdlckVsZW1lbnQucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXHRcblx0ICByZXR1cm4gRE9NRXZlbnRNYW5hZ2VyRWxlbWVudDtcblx0XG5cdH0pKEV2ZW50RW1pdHRlcik7XG5cdFxuXHRleHBvcnRzLkRPTUV2ZW50TWFuYWdlciA9IChmdW5jdGlvbigpIHtcblx0ICBmdW5jdGlvbiBET01FdmVudE1hbmFnZXIoZWxlbWVudCkge1xuXHQgICAgdGhpcy53cmFwID0gYmluZCh0aGlzLndyYXAsIHRoaXMpO1xuXHQgICAgdGhpcy5fZWxlbWVudHMgPSB7fTtcblx0ICB9XG5cdFxuXHQgIERPTUV2ZW50TWFuYWdlci5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0ICAgIGlmICghZWxlbWVudC5fZXZlbnRNYW5hZ2VySWQpIHtcblx0ICAgICAgZWxlbWVudC5fZXZlbnRNYW5hZ2VySWQgPSBFdmVudE1hbmFnZXJJZENvdW50ZXIrKztcblx0ICAgIH1cblx0ICAgIGlmICghdGhpcy5fZWxlbWVudHNbZWxlbWVudC5fZXZlbnRNYW5hZ2VySWRdKSB7XG5cdCAgICAgIHRoaXMuX2VsZW1lbnRzW2VsZW1lbnQuX2V2ZW50TWFuYWdlcklkXSA9IG5ldyBET01FdmVudE1hbmFnZXJFbGVtZW50KGVsZW1lbnQpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRzW2VsZW1lbnQuX2V2ZW50TWFuYWdlcklkXTtcblx0ICB9O1xuXHRcblx0ICBET01FdmVudE1hbmFnZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgZWxlbWVudCwgZWxlbWVudEV2ZW50TWFuYWdlciwgcmVmLCByZXN1bHRzO1xuXHQgICAgcmVmID0gdGhpcy5fZWxlbWVudHM7XG5cdCAgICByZXN1bHRzID0gW107XG5cdCAgICBmb3IgKGVsZW1lbnQgaW4gcmVmKSB7XG5cdCAgICAgIGVsZW1lbnRFdmVudE1hbmFnZXIgPSByZWZbZWxlbWVudF07XG5cdCAgICAgIHJlc3VsdHMucHVzaChlbGVtZW50RXZlbnRNYW5hZ2VyLnJlbW92ZUFsbExpc3RlbmVycygpKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXN1bHRzO1xuXHQgIH07XG5cdFxuXHQgIHJldHVybiBET01FdmVudE1hbmFnZXI7XG5cblx0fSkoKTtcblxuXG4vKioqLyB9LFxuLyogNDMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBFdmVudE1hcHBlcnMsIEV2ZW50cywgTGF5ZXIsIFV0aWxzLCBfLCB3cmFwQ29tcG9uZW50LFxuXHQgIGJpbmQgPSBmdW5jdGlvbihmbiwgbWUpeyByZXR1cm4gZnVuY3Rpb24oKXsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9OyB9LFxuXHQgIGV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcblx0ICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXG5cdCAgc2xpY2UgPSBbXS5zbGljZSxcblx0ICBpbmRleE9mID0gW10uaW5kZXhPZiB8fCBmdW5jdGlvbihpdGVtKSB7IGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHsgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKSByZXR1cm4gaTsgfSByZXR1cm4gLTE7IH07XG5cdFxuXHRfID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKS5fO1xuXHRcblx0VXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHRcblx0TGF5ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKS5MYXllcjtcblx0XG5cdEV2ZW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpLkV2ZW50cztcblx0XG5cdFwiU2Nyb2xsQ29tcG9uZW50XFxuXFxuY29udGVudCA8TGF5ZXI+XFxuY29udGVudFNpemUgPHt3aWR0aDpuLCBoZWlnaHQ6bn0+XFxuY29udGVudEluc2V0IDx7dG9wOm4sIHJpZ2h0Om4sIGJvdHRvbTpuLCBsZWZ0Om59PiBUT0RPXFxuY29udGVudE9mZnNldCA8e3g6biwgeTpufT4gVE9ET1xcbnNjcm9sbEZyYW1lIDx7eDpuLCB5Om4sIHdpZHRoOm4sIGhlaWdodDpufT5cXG5zY3JvbGxQb2ludCA8e3g6biwgeTpufT5cXG5zY3JvbGxIb3Jpem9udGFsIDxib29sPlxcbnNjcm9sbFZlcnRpY2FsIDxib29sPlxcbnNwZWVkWCA8bnVtYmVyPlxcbnNwZWVkWSA8bnVtYmVyPlxcbmRlbGF5c0NvbnRlbnRUb3VjaGVzIDxib29sPiBUT0RPXFxubG9hZFByZXNldCg8XFxcImlvc1xcXCJ8XFxcImFuZHJvaWRcXFwiPikgVE9ET1xcbnNjcm9sbFRvUG9pbnQoPHt4Om4sIHk6bn0+LCBhbmltYXRlPXRydWUsIGFuaW1hdGlvbk9wdGlvbnM9e30pXFxuc2Nyb2xsVG9MYXllcihjb250ZW50TGF5ZXIsIG9yaWdpblg9MCwgb3JpZ2luWT0wKVxcbnNjcm9sbEZyYW1lRm9yQ29udGVudExheWVyKDx4Om4sIHk6bj4pIDx7eDpuLCB5Om4sIHdpZHRoOm4sIGhlaWdodDpufT4gVE9ET1xcbmNsb3Nlc3RDb250ZW50TGF5ZXIoPHg6biwgeTpuPikgPExheWVyPiBUT0RPXFxuXFxuU2Nyb2xsQ29tcG9uZW50IEV2ZW50c1xcblxcbihhbGwgb2YgdGhlIGRyYWdnYWJsZSBldmVudHMpXFxuU2Nyb2xsU3RhcnQgLT4gRHJhZ1N0YXJ0XFxuU2Nyb2xsV2lsbE1vdmUgLT4gRHJhZ1dpbGxNb3ZlXFxuU2Nyb2xsRGlkTW92ZSAtPiBEcmFnRGlkTW92ZVxcbnNjcm9sbCAtPiBEcmFnTW92ZSAoaHRtbCBjb21wYXQpXFxuU2Nyb2xsRW5kIC0+IERyYWdFbmRcIjtcblx0XG5cdEV2ZW50cy5TY3JvbGxTdGFydCA9IFwic2Nyb2xsc3RhcnRcIjtcblx0XG5cdEV2ZW50cy5TY3JvbGwgPSBcInNjcm9sbFwiO1xuXHRcblx0RXZlbnRzLlNjcm9sbE1vdmUgPSBFdmVudHMuU2Nyb2xsO1xuXHRcblx0RXZlbnRzLlNjcm9sbEVuZCA9IFwic2Nyb2xsZW5kXCI7XG5cdFxuXHRFdmVudHMuU2Nyb2xsQW5pbWF0aW9uRGlkU3RhcnQgPSBcInNjcm9sbGFuaW1hdGlvbmRpZHN0YXJ0XCI7XG5cdFxuXHRFdmVudHMuU2Nyb2xsQW5pbWF0aW9uRGlkRW5kID0gXCJzY3JvbGxhbmltYXRpb25kaWRlbmRcIjtcblx0XG5cdEV2ZW50TWFwcGVycyA9IHt9O1xuXHRcblx0RXZlbnRNYXBwZXJzW0V2ZW50cy5Nb3ZlXSA9IEV2ZW50cy5Nb3ZlO1xuXHRcblx0RXZlbnRNYXBwZXJzW0V2ZW50cy5TY3JvbGxTdGFydF0gPSBFdmVudHMuRHJhZ1N0YXJ0O1xuXHRcblx0RXZlbnRNYXBwZXJzW0V2ZW50cy5TY3JvbGxNb3ZlXSA9IEV2ZW50cy5EcmFnTW92ZTtcblx0XG5cdEV2ZW50TWFwcGVyc1tFdmVudHMuU2Nyb2xsRW5kXSA9IEV2ZW50cy5EcmFnRW5kO1xuXHRcblx0RXZlbnRNYXBwZXJzW0V2ZW50cy5TY3JvbGxBbmltYXRpb25EaWRTdGFydF0gPSBFdmVudHMuRHJhZ0FuaW1hdGlvblN0YXJ0O1xuXHRcblx0RXZlbnRNYXBwZXJzW0V2ZW50cy5TY3JvbGxBbmltYXRpb25EaWRFbmRdID0gRXZlbnRzLkRyYWdBbmltYXRpb25FbmQ7XG5cdFxuXHRFdmVudE1hcHBlcnNbRXZlbnRzLkRpcmVjdGlvbkxvY2tTdGFydF0gPSBFdmVudHMuRGlyZWN0aW9uTG9ja1N0YXJ0O1xuXHRcblx0ZXhwb3J0cy5TY3JvbGxDb21wb25lbnQgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuXHQgIGV4dGVuZChTY3JvbGxDb21wb25lbnQsIHN1cGVyQ2xhc3MpO1xuXHRcblx0ICBTY3JvbGxDb21wb25lbnQuZGVmaW5lKFwidmVsb2NpdHlcIiwgU2Nyb2xsQ29tcG9uZW50LnByb3h5UHJvcGVydHkoXCJjb250ZW50LmRyYWdnYWJsZS52ZWxvY2l0eVwiLCB7XG5cdCAgICBpbXBvcnRhYmxlOiBmYWxzZVxuXHQgIH0pKTtcblx0XG5cdCAgU2Nyb2xsQ29tcG9uZW50LmRlZmluZShcInNjcm9sbEhvcml6b250YWxcIiwgU2Nyb2xsQ29tcG9uZW50LnByb3h5UHJvcGVydHkoXCJjb250ZW50LmRyYWdnYWJsZS5ob3Jpem9udGFsXCIpKTtcblx0XG5cdCAgU2Nyb2xsQ29tcG9uZW50LmRlZmluZShcInNjcm9sbFZlcnRpY2FsXCIsIFNjcm9sbENvbXBvbmVudC5wcm94eVByb3BlcnR5KFwiY29udGVudC5kcmFnZ2FibGUudmVydGljYWxcIikpO1xuXHRcblx0ICBTY3JvbGxDb21wb25lbnQuZGVmaW5lKFwic3BlZWRYXCIsIFNjcm9sbENvbXBvbmVudC5wcm94eVByb3BlcnR5KFwiY29udGVudC5kcmFnZ2FibGUuc3BlZWRYXCIpKTtcblx0XG5cdCAgU2Nyb2xsQ29tcG9uZW50LmRlZmluZShcInNwZWVkWVwiLCBTY3JvbGxDb21wb25lbnQucHJveHlQcm9wZXJ0eShcImNvbnRlbnQuZHJhZ2dhYmxlLnNwZWVkWVwiKSk7XG5cdFxuXHQgIFNjcm9sbENvbXBvbmVudC5kZWZpbmUoXCJpc0RyYWdnaW5nXCIsIFNjcm9sbENvbXBvbmVudC5wcm94eVByb3BlcnR5KFwiY29udGVudC5kcmFnZ2FibGUuaXNEcmFnZ2luZ1wiLCB7XG5cdCAgICBpbXBvcnRhYmxlOiBmYWxzZVxuXHQgIH0pKTtcblx0XG5cdCAgU2Nyb2xsQ29tcG9uZW50LmRlZmluZShcImlzTW92aW5nXCIsIFNjcm9sbENvbXBvbmVudC5wcm94eVByb3BlcnR5KFwiY29udGVudC5kcmFnZ2FibGUuaXNNb3ZpbmdcIiwge1xuXHQgICAgaW1wb3J0YWJsZTogZmFsc2Vcblx0ICB9KSk7XG5cdFxuXHQgIFNjcm9sbENvbXBvbmVudC5kZWZpbmUoXCJwcm9wYWdhdGVFdmVudHNcIiwgU2Nyb2xsQ29tcG9uZW50LnByb3h5UHJvcGVydHkoXCJjb250ZW50LmRyYWdnYWJsZS5wcm9wYWdhdGVFdmVudHNcIikpO1xuXHRcblx0ICBTY3JvbGxDb21wb25lbnQuZGVmaW5lKFwiZGlyZWN0aW9uTG9ja1wiLCBTY3JvbGxDb21wb25lbnQucHJveHlQcm9wZXJ0eShcImNvbnRlbnQuZHJhZ2dhYmxlLmRpcmVjdGlvbkxvY2tcIikpO1xuXHRcblx0ICBTY3JvbGxDb21wb25lbnQuZGVmaW5lKFwiZGlyZWN0aW9uTG9ja1RocmVzaG9sZFwiLCBTY3JvbGxDb21wb25lbnQucHJveHlQcm9wZXJ0eShcImNvbnRlbnQuZHJhZ2dhYmxlLmRpcmVjdGlvbkxvY2tUaHJlc2hvbGRcIikpO1xuXHRcblx0ICBTY3JvbGxDb21wb25lbnQuZGVmaW5lKFwiY29udGVudFwiLCB7XG5cdCAgICBpbXBvcnRhYmxlOiBmYWxzZSxcblx0ICAgIGV4cG9ydGFibGU6IGZhbHNlLFxuXHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQ7XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIFNjcm9sbENvbXBvbmVudC5kZWZpbmUoXCJtb3VzZVdoZWVsU3BlZWRNdWx0aXBsaWVyXCIsIFNjcm9sbENvbXBvbmVudC5zaW1wbGVQcm9wZXJ0eShcIm1vdXNlV2hlZWxTcGVlZE11bHRpcGxpZXJcIiwgMSkpO1xuXHRcblx0ICBmdW5jdGlvbiBTY3JvbGxDb21wb25lbnQob3B0aW9ucykge1xuXHQgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuXHQgICAgICBvcHRpb25zID0ge307XG5cdCAgICB9XG5cdCAgICB0aGlzLl9vbk1vdXNlV2hlZWwgPSBiaW5kKHRoaXMuX29uTW91c2VXaGVlbCwgdGhpcyk7XG5cdCAgICB0aGlzLnVwZGF0ZUNvbnRlbnQgPSBiaW5kKHRoaXMudXBkYXRlQ29udGVudCwgdGhpcyk7XG5cdCAgICBpZiAob3B0aW9ucy5jbGlwID09IG51bGwpIHtcblx0ICAgICAgb3B0aW9ucy5jbGlwID0gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIGlmIChvcHRpb25zLm1vdXNlV2hlZWxFbmFibGVkID09IG51bGwpIHtcblx0ICAgICAgb3B0aW9ucy5tb3VzZVdoZWVsRW5hYmxlZCA9IGZhbHNlO1xuXHQgICAgfVxuXHQgICAgaWYgKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yID09IG51bGwpIHtcblx0ICAgICAgb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IgPSBudWxsO1xuXHQgICAgfVxuXHQgICAgU2Nyb2xsQ29tcG9uZW50Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgdGhpcy5fY29udGVudEluc2V0ID0gb3B0aW9ucy5jb250ZW50SW5zZXQgfHwgVXRpbHMucmVjdFplcm8oKTtcblx0ICAgIHRoaXMuc2V0Q29udGVudExheWVyKG5ldyBMYXllcik7XG5cdCAgICB0aGlzLl9hcHBseU9wdGlvbnNBbmREZWZhdWx0cyhvcHRpb25zKTtcblx0ICAgIHRoaXMuX2VuYWJsZU1vdXNlV2hlZWxIYW5kbGluZyhvcHRpb25zLm1vdXNlV2hlZWxFbmFibGVkKTtcblx0ICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KFwid3JhcFwiKSkge1xuXHQgICAgICB3cmFwQ29tcG9uZW50KHRoaXMsIG9wdGlvbnMud3JhcCk7XG5cdCAgICB9XG5cdCAgfVxuXHRcblx0ICBTY3JvbGxDb21wb25lbnQucHJvdG90eXBlLmNhbGN1bGF0ZUNvbnRlbnRGcmFtZSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIGNvbnRlbnRGcmFtZSwgc2l6ZTtcblx0ICAgIGlmICghdGhpcy5jb250ZW50KSB7XG5cdCAgICAgIHJldHVybiBVdGlscy5yZWN0WmVybygpO1xuXHQgICAgfVxuXHQgICAgY29udGVudEZyYW1lID0gdGhpcy5jb250ZW50LmNvbnRlbnRGcmFtZSgpO1xuXHQgICAgcmV0dXJuIHNpemUgPSB7XG5cdCAgICAgIHg6IDAsXG5cdCAgICAgIHk6IDAsXG5cdCAgICAgIHdpZHRoOiBNYXRoLm1heCh0aGlzLndpZHRoLCBjb250ZW50RnJhbWUueCArIGNvbnRlbnRGcmFtZS53aWR0aCksXG5cdCAgICAgIGhlaWdodDogTWF0aC5tYXgodGhpcy5oZWlnaHQsIGNvbnRlbnRGcmFtZS55ICsgY29udGVudEZyYW1lLmhlaWdodClcblx0ICAgIH07XG5cdCAgfTtcblx0XG5cdCAgU2Nyb2xsQ29tcG9uZW50LnByb3RvdHlwZS5zZXRDb250ZW50TGF5ZXIgPSBmdW5jdGlvbihsYXllcikge1xuXHQgICAgaWYgKHRoaXMuY29udGVudCkge1xuXHQgICAgICB0aGlzLl9jb250ZW50LmRlc3Ryb3koKTtcblx0ICAgIH1cblx0ICAgIHRoaXMuX2NvbnRlbnQgPSBsYXllcjtcblx0ICAgIHRoaXMuX2NvbnRlbnQucGFyZW50ID0gdGhpcztcblx0ICAgIHRoaXMuX2NvbnRlbnQubmFtZSA9IFwiY29udGVudFwiO1xuXHQgICAgdGhpcy5fY29udGVudC5jbGlwID0gdHJ1ZTtcblx0ICAgIHRoaXMuX2NvbnRlbnQuZHJhZ2dhYmxlLmVuYWJsZWQgPSB0cnVlO1xuXHQgICAgdGhpcy5fY29udGVudC5kcmFnZ2FibGUubW9tZW50dW0gPSB0cnVlO1xuXHQgICAgdGhpcy5fY29udGVudC5vbihcImNoYW5nZTpjaGlsZHJlblwiLCB0aGlzLnVwZGF0ZUNvbnRlbnQpO1xuXHQgICAgdGhpcy5vbihcImNoYW5nZTp3aWR0aFwiLCB0aGlzLnVwZGF0ZUNvbnRlbnQpO1xuXHQgICAgdGhpcy5vbihcImNoYW5nZTpoZWlnaHRcIiwgdGhpcy51cGRhdGVDb250ZW50KTtcblx0ICAgIHRoaXMudXBkYXRlQ29udGVudCgpO1xuXHQgICAgdGhpcy5zY3JvbGxQb2ludCA9IHtcblx0ICAgICAgeDogMCxcblx0ICAgICAgeTogMFxuXHQgICAgfTtcblx0ICAgIHJldHVybiB0aGlzLl9jb250ZW50O1xuXHQgIH07XG5cdFxuXHQgIFNjcm9sbENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlQ29udGVudCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIGNvbnN0cmFpbnRzRnJhbWUsIGNvbnRlbnRGcmFtZSwgcmVmO1xuXHQgICAgaWYgKCF0aGlzLmNvbnRlbnQpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgY29udGVudEZyYW1lID0gdGhpcy5jYWxjdWxhdGVDb250ZW50RnJhbWUoKTtcblx0ICAgIHRoaXMuY29udGVudC53aWR0aCA9IGNvbnRlbnRGcmFtZS53aWR0aDtcblx0ICAgIHRoaXMuY29udGVudC5oZWlnaHQgPSBjb250ZW50RnJhbWUuaGVpZ2h0O1xuXHQgICAgY29uc3RyYWludHNGcmFtZSA9IHRoaXMuY2FsY3VsYXRlQ29udGVudEZyYW1lKCk7XG5cdCAgICBjb25zdHJhaW50c0ZyYW1lID0ge1xuXHQgICAgICB4OiAtY29uc3RyYWludHNGcmFtZS53aWR0aCArIHRoaXMud2lkdGggLSB0aGlzLl9jb250ZW50SW5zZXQucmlnaHQsXG5cdCAgICAgIHk6IC1jb25zdHJhaW50c0ZyYW1lLmhlaWdodCArIHRoaXMuaGVpZ2h0IC0gdGhpcy5fY29udGVudEluc2V0LmJvdHRvbSxcblx0ICAgICAgd2lkdGg6IGNvbnN0cmFpbnRzRnJhbWUud2lkdGggKyBjb25zdHJhaW50c0ZyYW1lLndpZHRoIC0gdGhpcy53aWR0aCArIHRoaXMuX2NvbnRlbnRJbnNldC5sZWZ0ICsgdGhpcy5fY29udGVudEluc2V0LnJpZ2h0LFxuXHQgICAgICBoZWlnaHQ6IGNvbnN0cmFpbnRzRnJhbWUuaGVpZ2h0ICsgY29uc3RyYWludHNGcmFtZS5oZWlnaHQgLSB0aGlzLmhlaWdodCArIHRoaXMuX2NvbnRlbnRJbnNldC50b3AgKyB0aGlzLl9jb250ZW50SW5zZXQuYm90dG9tXG5cdCAgICB9O1xuXHQgICAgdGhpcy5jb250ZW50LmRyYWdnYWJsZS5jb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzRnJhbWU7XG5cdCAgICB0aGlzLnNjcm9sbFBvaW50ID0gdGhpcy5zY3JvbGxQb2ludDtcblx0ICAgIGlmICh0aGlzLmNvbnRlbnQuY2hpbGRyZW4ubGVuZ3RoKSB7XG5cdCAgICAgIGlmICgocmVmID0gdGhpcy5jb250ZW50LmJhY2tncm91bmRDb2xvcikgIT0gbnVsbCA/IHJlZi5pc0VxdWFsKEZyYW1lci5EZWZhdWx0cy5MYXllci5iYWNrZ3JvdW5kQ29sb3IpIDogdm9pZCAwKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5iYWNrZ3JvdW5kQ29sb3IgPSBudWxsO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfTtcblx0XG5cdCAgU2Nyb2xsQ29tcG9uZW50LmRlZmluZShcInNjcm9sbFwiLCB7XG5cdCAgICBleHBvcnRhYmxlOiBmYWxzZSxcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLnNjcm9sbEhvcml6b250YWwgPT09IHRydWUgfHwgdGhpcy5zY3JvbGxWZXJ0aWNhbCA9PT0gdHJ1ZTtcblx0ICAgIH0sXG5cdCAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgIGlmICghdGhpcy5jb250ZW50KSB7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cdCAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcblx0ICAgICAgICB0aGlzLmNvbnRlbnQuYW5pbWF0ZVN0b3AoKTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gdGhpcy5zY3JvbGxIb3Jpem9udGFsID0gdGhpcy5zY3JvbGxWZXJ0aWNhbCA9IHZhbHVlO1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBTY3JvbGxDb21wb25lbnQucHJvdG90eXBlLl9jYWxjdWxhdGVDb250ZW50UG9pbnQgPSBmdW5jdGlvbihzY3JvbGxQb2ludCkge1xuXHQgICAgdmFyIHBvaW50O1xuXHQgICAgc2Nyb2xsUG9pbnQgPSBfLmRlZmF1bHRzKHNjcm9sbFBvaW50LCB7XG5cdCAgICAgIHg6IDAsXG5cdCAgICAgIHk6IDBcblx0ICAgIH0pO1xuXHQgICAgc2Nyb2xsUG9pbnQueCAtPSB0aGlzLmNvbnRlbnRJbnNldC5sZWZ0O1xuXHQgICAgc2Nyb2xsUG9pbnQueSAtPSB0aGlzLmNvbnRlbnRJbnNldC50b3A7XG5cdCAgICBwb2ludCA9IHRoaXMuX3BvaW50SW5Db25zdHJhaW50cyhzY3JvbGxQb2ludCk7XG5cdCAgICByZXR1cm4gVXRpbHMucG9pbnRJbnZlcnQocG9pbnQpO1xuXHQgIH07XG5cdFxuXHQgIFNjcm9sbENvbXBvbmVudC5kZWZpbmUoXCJzY3JvbGxYXCIsIHtcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIGlmICghdGhpcy5jb250ZW50KSB7XG5cdCAgICAgICAgcmV0dXJuIDA7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIDAgLSB0aGlzLmNvbnRlbnQueCArIHRoaXMuY29udGVudEluc2V0LmxlZnQ7XG5cdCAgICB9LFxuXHQgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICBpZiAoIXRoaXMuY29udGVudCkge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHQgICAgICB0aGlzLmNvbnRlbnQuZHJhZ2dhYmxlLmFuaW1hdGVTdG9wKCk7XG5cdCAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQueCA9IHRoaXMuX2NhbGN1bGF0ZUNvbnRlbnRQb2ludCh7XG5cdCAgICAgICAgeDogdmFsdWUsXG5cdCAgICAgICAgeTogMFxuXHQgICAgICB9KS54O1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBTY3JvbGxDb21wb25lbnQuZGVmaW5lKFwic2Nyb2xsWVwiLCB7XG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICBpZiAoIXRoaXMuY29udGVudCkge1xuXHQgICAgICAgIHJldHVybiAwO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiAwIC0gdGhpcy5jb250ZW50LnkgKyB0aGlzLmNvbnRlbnRJbnNldC50b3A7XG5cdCAgICB9LFxuXHQgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICBpZiAoIXRoaXMuY29udGVudCkge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHQgICAgICB0aGlzLmNvbnRlbnQuZHJhZ2dhYmxlLmFuaW1hdGVTdG9wKCk7XG5cdCAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQueSA9IHRoaXMuX2NhbGN1bGF0ZUNvbnRlbnRQb2ludCh7XG5cdCAgICAgICAgeDogMCxcblx0ICAgICAgICB5OiB2YWx1ZVxuXHQgICAgICB9KS55O1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBTY3JvbGxDb21wb25lbnQuZGVmaW5lKFwic2Nyb2xsUG9pbnRcIiwge1xuXHQgICAgaW1wb3J0YWJsZTogdHJ1ZSxcblx0ICAgIGV4cG9ydGFibGU6IGZhbHNlLFxuXHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgdmFyIHBvaW50O1xuXHQgICAgICByZXR1cm4gcG9pbnQgPSB7XG5cdCAgICAgICAgeDogdGhpcy5zY3JvbGxYLFxuXHQgICAgICAgIHk6IHRoaXMuc2Nyb2xsWVxuXHQgICAgICB9O1xuXHQgICAgfSxcblx0ICAgIHNldDogZnVuY3Rpb24ocG9pbnQpIHtcblx0ICAgICAgaWYgKCF0aGlzLmNvbnRlbnQpIHtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblx0ICAgICAgdGhpcy5zY3JvbGxYID0gcG9pbnQueDtcblx0ICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsWSA9IHBvaW50Lnk7XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIFNjcm9sbENvbXBvbmVudC5kZWZpbmUoXCJzY3JvbGxGcmFtZVwiLCB7XG5cdCAgICBpbXBvcnRhYmxlOiB0cnVlLFxuXHQgICAgZXhwb3J0YWJsZTogZmFsc2UsXG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICB2YXIgcmVjdDtcblx0ICAgICAgcmVjdCA9IHRoaXMuc2Nyb2xsUG9pbnQ7XG5cdCAgICAgIHJlY3Qud2lkdGggPSB0aGlzLndpZHRoO1xuXHQgICAgICByZWN0LmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuXHQgICAgICByZXR1cm4gcmVjdDtcblx0ICAgIH0sXG5cdCAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLnNjcm9sbFBvaW50ID0gdmFsdWU7XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIFNjcm9sbENvbXBvbmVudC5kZWZpbmUoXCJjb250ZW50SW5zZXRcIiwge1xuXHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIF8uY2xvbmUodGhpcy5fY29udGVudEluc2V0KTtcblx0ICAgIH0sXG5cdCAgICBzZXQ6IGZ1bmN0aW9uKGNvbnRlbnRJbnNldCkge1xuXHQgICAgICB2YXIgY29udGVudEZyYW1lO1xuXHQgICAgICB0aGlzLl9jb250ZW50SW5zZXQgPSBVdGlscy5yZWN0WmVybyhVdGlscy5wYXJzZVJlY3QoY29udGVudEluc2V0KSk7XG5cdCAgICAgIGlmICghdGhpcy5jb250ZW50KSB7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cdCAgICAgIGNvbnRlbnRGcmFtZSA9IHRoaXMuY2FsY3VsYXRlQ29udGVudEZyYW1lKCk7XG5cdCAgICAgIGNvbnRlbnRGcmFtZS54ID0gY29udGVudEZyYW1lLnggKyB0aGlzLl9jb250ZW50SW5zZXQubGVmdDtcblx0ICAgICAgY29udGVudEZyYW1lLnkgPSBjb250ZW50RnJhbWUueSArIHRoaXMuX2NvbnRlbnRJbnNldC50b3A7XG5cdCAgICAgIHRoaXMuY29udGVudC5mcmFtZSA9IGNvbnRlbnRGcmFtZTtcblx0ICAgICAgcmV0dXJuIHRoaXMudXBkYXRlQ29udGVudCgpO1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBTY3JvbGxDb21wb25lbnQuZGVmaW5lKFwiZGlyZWN0aW9uXCIsIHtcblx0ICAgIGltcG9ydGFibGU6IGZhbHNlLFxuXHQgICAgZXhwb3J0YWJsZTogZmFsc2UsXG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICB2YXIgZGlyZWN0aW9uO1xuXHQgICAgICBkaXJlY3Rpb24gPSB0aGlzLmNvbnRlbnQuZHJhZ2dhYmxlLmRpcmVjdGlvbjtcblx0ICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJkb3duXCIpIHtcblx0ICAgICAgICByZXR1cm4gXCJ1cFwiO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChkaXJlY3Rpb24gPT09IFwidXBcIikge1xuXHQgICAgICAgIHJldHVybiBcImRvd25cIjtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoZGlyZWN0aW9uID09PSBcInJpZ2h0XCIpIHtcblx0ICAgICAgICByZXR1cm4gXCJsZWZ0XCI7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJsZWZ0XCIpIHtcblx0ICAgICAgICByZXR1cm4gXCJyaWdodFwiO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBkaXJlY3Rpb247XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIFNjcm9sbENvbXBvbmVudC5kZWZpbmUoXCJhbmdsZVwiLCB7XG5cdCAgICBpbXBvcnRhYmxlOiBmYWxzZSxcblx0ICAgIGV4cG9ydGFibGU6IGZhbHNlLFxuXHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgaWYgKCF0aGlzLmNvbnRlbnQpIHtcblx0ICAgICAgICByZXR1cm4gMDtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gLXRoaXMuY29udGVudC5kcmFnZ2FibGUuYW5nbGU7XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIFNjcm9sbENvbXBvbmVudC5wcm90b3R5cGUuc2Nyb2xsVG9Qb2ludCA9IGZ1bmN0aW9uKHBvaW50LCBhbmltYXRlLCBhbmltYXRpb25PcHRpb25zKSB7XG5cdCAgICB2YXIgY29udGVudFBvaW50O1xuXHQgICAgaWYgKGFuaW1hdGUgPT0gbnVsbCkge1xuXHQgICAgICBhbmltYXRlID0gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIGlmIChhbmltYXRpb25PcHRpb25zID09IG51bGwpIHtcblx0ICAgICAgYW5pbWF0aW9uT3B0aW9ucyA9IHtcblx0ICAgICAgICBjdXJ2ZTogXCJzcHJpbmcoNTAwLDUwLDApXCJcblx0ICAgICAgfTtcblx0ICAgIH1cblx0ICAgIGNvbnRlbnRQb2ludCA9IHRoaXMuX2NhbGN1bGF0ZUNvbnRlbnRQb2ludChwb2ludCk7XG5cdCAgICB0aGlzLmNvbnRlbnQuZHJhZ2dhYmxlLmFuaW1hdGVTdG9wKCk7XG5cdCAgICBpZiAoYW5pbWF0ZSkge1xuXHQgICAgICBwb2ludCA9IHt9O1xuXHQgICAgICBpZiAoY29udGVudFBvaW50Lmhhc093blByb3BlcnR5KFwieFwiKSkge1xuXHQgICAgICAgIHBvaW50LnggPSBjb250ZW50UG9pbnQueDtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoY29udGVudFBvaW50Lmhhc093blByb3BlcnR5KFwieVwiKSkge1xuXHQgICAgICAgIHBvaW50LnkgPSBjb250ZW50UG9pbnQueTtcblx0ICAgICAgfVxuXHQgICAgICBhbmltYXRpb25PcHRpb25zLnByb3BlcnRpZXMgPSBwb2ludDtcblx0ICAgICAgdGhpcy5jb250ZW50LmFuaW1hdGVTdG9wKCk7XG5cdCAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQuYW5pbWF0ZShhbmltYXRpb25PcHRpb25zKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQucG9pbnQgPSBjb250ZW50UG9pbnQ7XG5cdCAgICB9XG5cdCAgfTtcblx0XG5cdCAgU2Nyb2xsQ29tcG9uZW50LnByb3RvdHlwZS5zY3JvbGxUb1RvcCA9IGZ1bmN0aW9uKGFuaW1hdGUsIGFuaW1hdGlvbk9wdGlvbnMpIHtcblx0ICAgIGlmIChhbmltYXRlID09IG51bGwpIHtcblx0ICAgICAgYW5pbWF0ZSA9IHRydWU7XG5cdCAgICB9XG5cdCAgICBpZiAoYW5pbWF0aW9uT3B0aW9ucyA9PSBudWxsKSB7XG5cdCAgICAgIGFuaW1hdGlvbk9wdGlvbnMgPSB7XG5cdCAgICAgICAgY3VydmU6IFwic3ByaW5nKDUwMCw1MCwwKVwiXG5cdCAgICAgIH07XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcy5zY3JvbGxUb1BvaW50KHtcblx0ICAgICAgeDogMCxcblx0ICAgICAgeTogMFxuXHQgICAgfSwgYW5pbWF0ZSwgYW5pbWF0aW9uT3B0aW9ucyk7XG5cdCAgfTtcblx0XG5cdCAgU2Nyb2xsQ29tcG9uZW50LnByb3RvdHlwZS5zY3JvbGxUb0xheWVyID0gZnVuY3Rpb24oY29udGVudExheWVyLCBvcmlnaW5YLCBvcmlnaW5ZLCBhbmltYXRlLCBhbmltYXRpb25PcHRpb25zKSB7XG5cdCAgICB2YXIgc2Nyb2xsUG9pbnQ7XG5cdCAgICBpZiAob3JpZ2luWCA9PSBudWxsKSB7XG5cdCAgICAgIG9yaWdpblggPSAwO1xuXHQgICAgfVxuXHQgICAgaWYgKG9yaWdpblkgPT0gbnVsbCkge1xuXHQgICAgICBvcmlnaW5ZID0gMDtcblx0ICAgIH1cblx0ICAgIGlmIChhbmltYXRlID09IG51bGwpIHtcblx0ICAgICAgYW5pbWF0ZSA9IHRydWU7XG5cdCAgICB9XG5cdCAgICBpZiAoYW5pbWF0aW9uT3B0aW9ucyA9PSBudWxsKSB7XG5cdCAgICAgIGFuaW1hdGlvbk9wdGlvbnMgPSB7XG5cdCAgICAgICAgY3VydmU6IFwic3ByaW5nKDUwMCw1MCwwKVwiXG5cdCAgICAgIH07XG5cdCAgICB9XG5cdCAgICBpZiAoY29udGVudExheWVyICYmIGNvbnRlbnRMYXllci5wYXJlbnQgIT09IHRoaXMuY29udGVudCkge1xuXHQgICAgICB0aHJvdyBFcnJvcihcIkNhbid0IHNjcm9sbCB0byB0aGlzIGxheWVyIGJlY2F1c2UgaXQncyBub3QgaW4gdGhlIFNjcm9sbENvbXBvbmVudC4gQWRkIGl0IHRvIHRoZSBjb250ZW50IGxpa2UgbGF5ZXIucGFyZW50ID0gc2Nyb2xsLmNvbnRlbnQuXCIpO1xuXHQgICAgfVxuXHQgICAgaWYgKCFjb250ZW50TGF5ZXIgfHwgdGhpcy5jb250ZW50LmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICBzY3JvbGxQb2ludCA9IHtcblx0ICAgICAgICB4OiAwLFxuXHQgICAgICAgIHk6IDBcblx0ICAgICAgfTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHNjcm9sbFBvaW50ID0gdGhpcy5fc2Nyb2xsUG9pbnRGb3JMYXllcihjb250ZW50TGF5ZXIsIG9yaWdpblgsIG9yaWdpblkpO1xuXHQgICAgICBzY3JvbGxQb2ludC54IC09IHRoaXMud2lkdGggKiBvcmlnaW5YO1xuXHQgICAgICBzY3JvbGxQb2ludC55IC09IHRoaXMuaGVpZ2h0ICogb3JpZ2luWTtcblx0ICAgIH1cblx0ICAgIHRoaXMuc2Nyb2xsVG9Qb2ludChzY3JvbGxQb2ludCwgYW5pbWF0ZSwgYW5pbWF0aW9uT3B0aW9ucyk7XG5cdCAgICByZXR1cm4gY29udGVudExheWVyO1xuXHQgIH07XG5cdFxuXHQgIFNjcm9sbENvbXBvbmVudC5wcm90b3R5cGUuc2Nyb2xsVG9DbG9zZXN0TGF5ZXIgPSBmdW5jdGlvbihvcmlnaW5YLCBvcmlnaW5ZLCBhbmltYXRlLCBhbmltYXRpb25PcHRpb25zKSB7XG5cdCAgICB2YXIgY2xvc2VzdExheWVyO1xuXHQgICAgaWYgKG9yaWdpblggPT0gbnVsbCkge1xuXHQgICAgICBvcmlnaW5YID0gMDtcblx0ICAgIH1cblx0ICAgIGlmIChvcmlnaW5ZID09IG51bGwpIHtcblx0ICAgICAgb3JpZ2luWSA9IDA7XG5cdCAgICB9XG5cdCAgICBpZiAoYW5pbWF0ZSA9PSBudWxsKSB7XG5cdCAgICAgIGFuaW1hdGUgPSB0cnVlO1xuXHQgICAgfVxuXHQgICAgaWYgKGFuaW1hdGlvbk9wdGlvbnMgPT0gbnVsbCkge1xuXHQgICAgICBhbmltYXRpb25PcHRpb25zID0ge1xuXHQgICAgICAgIGN1cnZlOiBcInNwcmluZyg1MDAsNTAsMClcIlxuXHQgICAgICB9O1xuXHQgICAgfVxuXHQgICAgY2xvc2VzdExheWVyID0gdGhpcy5jbG9zZXN0Q29udGVudExheWVyKG9yaWdpblgsIG9yaWdpblksIGFuaW1hdGUsIGFuaW1hdGlvbk9wdGlvbnMpO1xuXHQgICAgaWYgKGNsb3Nlc3RMYXllcikge1xuXHQgICAgICB0aGlzLnNjcm9sbFRvTGF5ZXIoY2xvc2VzdExheWVyLCBvcmlnaW5YLCBvcmlnaW5ZKTtcblx0ICAgICAgcmV0dXJuIGNsb3Nlc3RMYXllcjtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlmICghY2xvc2VzdExheWVyKSB7XG5cdCAgICAgICAgdGhpcy5zY3JvbGxUb1BvaW50KHtcblx0ICAgICAgICAgIHg6IDAsXG5cdCAgICAgICAgICB5OiAwXG5cdCAgICAgICAgfSk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICB9XG5cdCAgfTtcblx0XG5cdCAgU2Nyb2xsQ29tcG9uZW50LnByb3RvdHlwZS5jbG9zZXN0Q29udGVudExheWVyID0gZnVuY3Rpb24ob3JpZ2luWCwgb3JpZ2luWSkge1xuXHQgICAgdmFyIHNjcm9sbFBvaW50O1xuXHQgICAgaWYgKG9yaWdpblggPT0gbnVsbCkge1xuXHQgICAgICBvcmlnaW5YID0gMDtcblx0ICAgIH1cblx0ICAgIGlmIChvcmlnaW5ZID09IG51bGwpIHtcblx0ICAgICAgb3JpZ2luWSA9IDA7XG5cdCAgICB9XG5cdCAgICBzY3JvbGxQb2ludCA9IFV0aWxzLmZyYW1lUG9pbnRGb3JPcmlnaW4odGhpcy5zY3JvbGxGcmFtZSwgb3JpZ2luWCwgb3JpZ2luWSk7XG5cdCAgICByZXR1cm4gdGhpcy5jbG9zZXN0Q29udGVudExheWVyRm9yU2Nyb2xsUG9pbnQoc2Nyb2xsUG9pbnQsIG9yaWdpblgsIG9yaWdpblkpO1xuXHQgIH07XG5cdFxuXHQgIFNjcm9sbENvbXBvbmVudC5wcm90b3R5cGUuY2xvc2VzdENvbnRlbnRMYXllckZvclNjcm9sbFBvaW50ID0gZnVuY3Rpb24oc2Nyb2xsUG9pbnQsIG9yaWdpblgsIG9yaWdpblkpIHtcblx0ICAgIGlmIChvcmlnaW5YID09IG51bGwpIHtcblx0ICAgICAgb3JpZ2luWCA9IDA7XG5cdCAgICB9XG5cdCAgICBpZiAob3JpZ2luWSA9PSBudWxsKSB7XG5cdCAgICAgIG9yaWdpblkgPSAwO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIF8uZmlyc3QodGhpcy5fY29udGVudExheWVyc1NvcnRlZEJ5RGlzdGFuY2VGb3JTY3JvbGxQb2ludChzY3JvbGxQb2ludCwgb3JpZ2luWCwgb3JpZ2luWSkpO1xuXHQgIH07XG5cdFxuXHQgIFNjcm9sbENvbXBvbmVudC5wcm90b3R5cGUuX3Njcm9sbFBvaW50Rm9yTGF5ZXIgPSBmdW5jdGlvbihsYXllciwgb3JpZ2luWCwgb3JpZ2luWSwgY2xhbXApIHtcblx0ICAgIGlmIChvcmlnaW5YID09IG51bGwpIHtcblx0ICAgICAgb3JpZ2luWCA9IDA7XG5cdCAgICB9XG5cdCAgICBpZiAob3JpZ2luWSA9PSBudWxsKSB7XG5cdCAgICAgIG9yaWdpblkgPSAwO1xuXHQgICAgfVxuXHQgICAgaWYgKGNsYW1wID09IG51bGwpIHtcblx0ICAgICAgY2xhbXAgPSB0cnVlO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIFV0aWxzLmZyYW1lUG9pbnRGb3JPcmlnaW4obGF5ZXIsIG9yaWdpblgsIG9yaWdpblkpO1xuXHQgIH07XG5cdFxuXHQgIFNjcm9sbENvbXBvbmVudC5wcm90b3R5cGUuX2NvbnRlbnRMYXllcnNTb3J0ZWRCeURpc3RhbmNlRm9yU2Nyb2xsUG9pbnQgPSBmdW5jdGlvbihzY3JvbGxQb2ludCwgb3JpZ2luWCwgb3JpZ2luWSkge1xuXHQgICAgaWYgKG9yaWdpblggPT0gbnVsbCkge1xuXHQgICAgICBvcmlnaW5YID0gMDtcblx0ICAgIH1cblx0ICAgIGlmIChvcmlnaW5ZID09IG51bGwpIHtcblx0ICAgICAgb3JpZ2luWSA9IDA7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gVXRpbHMuZnJhbWVTb3J0QnlBYnNvbHV0ZURpc3RhbmNlKHNjcm9sbFBvaW50LCB0aGlzLmNvbnRlbnQuY2hpbGRyZW4sIG9yaWdpblgsIG9yaWdpblkpO1xuXHQgIH07XG5cdFxuXHQgIFNjcm9sbENvbXBvbmVudC5wcm90b3R5cGUuX3BvaW50SW5Db25zdHJhaW50cyA9IGZ1bmN0aW9uKHBvaW50KSB7XG5cdCAgICB2YXIgbWF4WCwgbWF4WSwgbWluWCwgbWluWSwgcmVmO1xuXHQgICAgcmVmID0gdGhpcy5jb250ZW50LmRyYWdnYWJsZS5fY2FsY3VsYXRlQ29uc3RyYWludHModGhpcy5jb250ZW50LmRyYWdnYWJsZS5jb25zdHJhaW50cyksIG1pblggPSByZWYubWluWCwgbWF4WCA9IHJlZi5tYXhYLCBtaW5ZID0gcmVmLm1pblksIG1heFkgPSByZWYubWF4WTtcblx0ICAgIHBvaW50ID0ge1xuXHQgICAgICB4OiAtVXRpbHMuY2xhbXAoLXBvaW50LngsIG1pblgsIG1heFgpLFxuXHQgICAgICB5OiAtVXRpbHMuY2xhbXAoLXBvaW50LnksIG1pblksIG1heFkpXG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIHBvaW50O1xuXHQgIH07XG5cdFxuXHQgIFNjcm9sbENvbXBvbmVudC5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciBldmVudE5hbWUsIGV2ZW50TmFtZXMsIGksIGosIGxlbiwgbGlzdGVuZXIsIHJlc3VsdHM7XG5cdCAgICBldmVudE5hbWVzID0gMiA8PSBhcmd1bWVudHMubGVuZ3RoID8gc2xpY2UuY2FsbChhcmd1bWVudHMsIDAsIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMSkgOiAoaSA9IDAsIFtdKSwgbGlzdGVuZXIgPSBhcmd1bWVudHNbaSsrXTtcblx0ICAgIFNjcm9sbENvbXBvbmVudC5fX3N1cGVyX18uYWRkTGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgIHJlc3VsdHMgPSBbXTtcblx0ICAgIGZvciAoaiA9IDAsIGxlbiA9IGV2ZW50TmFtZXMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcblx0ICAgICAgZXZlbnROYW1lID0gZXZlbnROYW1lc1tqXTtcblx0ICAgICAgaWYgKGluZGV4T2YuY2FsbChfLmtleXMoRXZlbnRNYXBwZXJzKSwgZXZlbnROYW1lKSA+PSAwKSB7XG5cdCAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMuY29udGVudC5vbihFdmVudE1hcHBlcnNbZXZlbnROYW1lXSwgbGlzdGVuZXIpKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXN1bHRzLnB1c2godm9pZCAwKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdHM7XG5cdCAgfTtcblx0XG5cdCAgU2Nyb2xsQ29tcG9uZW50LnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIGV2ZW50TmFtZSwgZXZlbnROYW1lcywgaSwgaiwgbGVuLCBsaXN0ZW5lciwgcmVzdWx0cztcblx0ICAgIGV2ZW50TmFtZXMgPSAyIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBzbGljZS5jYWxsKGFyZ3VtZW50cywgMCwgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxKSA6IChpID0gMCwgW10pLCBsaXN0ZW5lciA9IGFyZ3VtZW50c1tpKytdO1xuXHQgICAgU2Nyb2xsQ29tcG9uZW50Ll9fc3VwZXJfXy5yZW1vdmVMaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgcmVzdWx0cyA9IFtdO1xuXHQgICAgZm9yIChqID0gMCwgbGVuID0gZXZlbnROYW1lcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuXHQgICAgICBldmVudE5hbWUgPSBldmVudE5hbWVzW2pdO1xuXHQgICAgICBpZiAoaW5kZXhPZi5jYWxsKF8ua2V5cyhFdmVudE1hcHBlcnMpLCBldmVudE5hbWUpID49IDApIHtcblx0ICAgICAgICByZXN1bHRzLnB1c2godGhpcy5jb250ZW50Lm9mZihFdmVudE1hcHBlcnNbZXZlbnROYW1lXSwgbGlzdGVuZXIpKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXN1bHRzLnB1c2godm9pZCAwKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdHM7XG5cdCAgfTtcblx0XG5cdCAgU2Nyb2xsQ29tcG9uZW50LnByb3RvdHlwZS5vbiA9IFNjcm9sbENvbXBvbmVudC5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cdFxuXHQgIFNjcm9sbENvbXBvbmVudC5wcm90b3R5cGUub2ZmID0gU2Nyb2xsQ29tcG9uZW50LnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcblx0XG5cdCAgU2Nyb2xsQ29tcG9uZW50LmRlZmluZShcIm1vdXNlV2hlZWxFbmFibGVkXCIsIHtcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9tb3VzZVdoZWVsRW5hYmxlZDtcblx0ICAgIH0sXG5cdCAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgIHRoaXMuX21vdXNlV2hlZWxFbmFibGVkID0gdmFsdWU7XG5cdCAgICAgIHJldHVybiB0aGlzLl9lbmFibGVNb3VzZVdoZWVsSGFuZGxpbmcodmFsdWUpO1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBTY3JvbGxDb21wb25lbnQucHJvdG90eXBlLl9lbmFibGVNb3VzZVdoZWVsSGFuZGxpbmcgPSBmdW5jdGlvbihlbmFibGUpIHtcblx0ICAgIGlmIChlbmFibGUpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMub24oRXZlbnRzLk1vdXNlV2hlZWwsIHRoaXMuX29uTW91c2VXaGVlbCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gdGhpcy5vZmYoRXZlbnRzLk1vdXNlV2hlZWwsIHRoaXMuX29uTW91c2VXaGVlbCk7XG5cdCAgICB9XG5cdCAgfTtcblx0XG5cdCAgU2Nyb2xsQ29tcG9uZW50LnByb3RvdHlwZS5fb25Nb3VzZVdoZWVsID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0ICAgIHZhciBtYXhYLCBtYXhZLCBtaW5YLCBtaW5ZLCBwb2ludCwgcmVmO1xuXHQgICAgaWYgKCF0aGlzLl9tb3VzZVdoZWVsU2Nyb2xsaW5nKSB7XG5cdCAgICAgIHRoaXMuX21vdXNlV2hlZWxTY3JvbGxpbmcgPSB0cnVlO1xuXHQgICAgICB0aGlzLmVtaXQoRXZlbnRzLlNjcm9sbFN0YXJ0LCBldmVudCk7XG5cdCAgICB9XG5cdCAgICB0aGlzLmNvbnRlbnQuYW5pbWF0ZVN0b3AoKTtcblx0ICAgIHJlZiA9IHRoaXMuY29udGVudC5kcmFnZ2FibGUuX2NhbGN1bGF0ZUNvbnN0cmFpbnRzKHRoaXMuY29udGVudC5kcmFnZ2FibGUuY29uc3RyYWludHMpLCBtaW5YID0gcmVmLm1pblgsIG1heFggPSByZWYubWF4WCwgbWluWSA9IHJlZi5taW5ZLCBtYXhZID0gcmVmLm1heFk7XG5cdCAgICBwb2ludCA9IHtcblx0ICAgICAgeDogVXRpbHMuY2xhbXAodGhpcy5jb250ZW50LnggKyAoZXZlbnQud2hlZWxEZWx0YVggKiB0aGlzLm1vdXNlV2hlZWxTcGVlZE11bHRpcGxpZXIpLCBtaW5YLCBtYXhYKSxcblx0ICAgICAgeTogVXRpbHMuY2xhbXAodGhpcy5jb250ZW50LnkgKyAoZXZlbnQud2hlZWxEZWx0YVkgKiB0aGlzLm1vdXNlV2hlZWxTcGVlZE11bHRpcGxpZXIpLCBtaW5ZLCBtYXhZKVxuXHQgICAgfTtcblx0ICAgIHRoaXMuY29udGVudC5wb2ludCA9IHBvaW50O1xuXHQgICAgdGhpcy5lbWl0KEV2ZW50cy5TY3JvbGwsIGV2ZW50KTtcblx0ICAgIHJldHVybiB0aGlzLl9vbk1vdXNlV2hlZWxFbmQoZXZlbnQpO1xuXHQgIH07XG5cdFxuXHQgIFNjcm9sbENvbXBvbmVudC5wcm90b3R5cGUuX29uTW91c2VXaGVlbEVuZCA9IFV0aWxzLmRlYm91bmNlKDAuMywgZnVuY3Rpb24oZXZlbnQpIHtcblx0ICAgIHRoaXMuZW1pdChFdmVudHMuU2Nyb2xsRW5kLCBldmVudCk7XG5cdCAgICByZXR1cm4gdGhpcy5fbW91c2VXaGVlbFNjcm9sbGluZyA9IGZhbHNlO1xuXHQgIH0pO1xuXHRcblx0ICBTY3JvbGxDb21wb25lbnQucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciBjb250ZW50TGF5ZXIsIGNvcHk7XG5cdCAgICBjb3B5ID0gU2Nyb2xsQ29tcG9uZW50Ll9fc3VwZXJfXy5jb3B5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICBjb250ZW50TGF5ZXIgPSBfLmZpcnN0KF8ud2l0aG91dChjb3B5LmNoaWxkcmVuLCBjb3B5LmNvbnRlbnQpKTtcblx0ICAgIGNvcHkuc2V0Q29udGVudExheWVyKGNvbnRlbnRMYXllcik7XG5cdCAgICBjb3B5LnByb3BzID0gdGhpcy5wcm9wcztcblx0ICAgIHJldHVybiBjb3B5O1xuXHQgIH07XG5cdFxuXHQgIFNjcm9sbENvbXBvbmVudC53cmFwID0gZnVuY3Rpb24obGF5ZXIsIG9wdGlvbnMpIHtcblx0ICAgIHJldHVybiB3cmFwQ29tcG9uZW50KG5ldyB0aGlzKG9wdGlvbnMpLCBsYXllciwgb3B0aW9ucyk7XG5cdCAgfTtcblx0XG5cdCAgcmV0dXJuIFNjcm9sbENvbXBvbmVudDtcblx0XG5cdH0pKExheWVyKTtcblx0XG5cdHdyYXBDb21wb25lbnQgPSBmdW5jdGlvbihpbnN0YW5jZSwgbGF5ZXIsIG9wdGlvbnMpIHtcblx0ICB2YXIgaSwgbCwgbGVuLCByZWYsIHJlZjEsIHNjcmVlbkZyYW1lLCBzY3JvbGwsIHdyYXBwZXI7XG5cdCAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuXHQgICAgb3B0aW9ucyA9IHtcblx0ICAgICAgY29ycmVjdDogdHJ1ZVxuXHQgICAgfTtcblx0ICB9XG5cdCAgaWYgKCEobGF5ZXIgaW5zdGFuY2VvZiBMYXllcikpIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcihcIlNjcm9sbENvbXBvbmVudC53cmFwIGV4cGVjdHMgYSBsYXllciwgbm90IFwiICsgbGF5ZXIgKyBcIi4gQXJlIHlvdSBzdXJlIHRoZSBsYXllciBleGlzdHM/XCIpO1xuXHQgIH1cblx0ICBzY3JvbGwgPSBpbnN0YW5jZTtcblx0ICBpZiAob3B0aW9ucy5jb3JyZWN0ID09PSB0cnVlKSB7XG5cdCAgICBpZiAobGF5ZXIuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgIHdyYXBwZXIgPSBuZXcgTGF5ZXI7XG5cdCAgICAgIHdyYXBwZXIubmFtZSA9IFwiU2Nyb2xsQ29tcG9uZW50XCI7XG5cdCAgICAgIHdyYXBwZXIuZnJhbWUgPSBsYXllci5mcmFtZTtcblx0ICAgICAgbGF5ZXIucGFyZW50ID0gd3JhcHBlcjtcblx0ICAgICAgbGF5ZXIueCA9IGxheWVyLnkgPSAwO1xuXHQgICAgICBsYXllciA9IHdyYXBwZXI7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHNjcm9sbC5mcmFtZSA9IGxheWVyLmZyYW1lO1xuXHQgIHNjcm9sbC5wYXJlbnQgPSBsYXllci5wYXJlbnQ7XG5cdCAgc2Nyb2xsLmluZGV4ID0gbGF5ZXIuaW5kZXg7XG5cdCAgaWYgKGxheWVyLm5hbWUgJiYgbGF5ZXIubmFtZSAhPT0gXCJcIikge1xuXHQgICAgc2Nyb2xsLm5hbWUgPSBsYXllci5uYW1lO1xuXHQgIH0gZWxzZSBpZiAoKHJlZiA9IGxheWVyLl9fZnJhbWVySW5zdGFuY2VJbmZvKSAhPSBudWxsID8gcmVmLm5hbWUgOiB2b2lkIDApIHtcblx0ICAgIHNjcm9sbC5uYW1lID0gbGF5ZXIuX19mcmFtZXJJbnN0YW5jZUluZm8ubmFtZTtcblx0ICB9XG5cdCAgaWYgKGxheWVyLmltYWdlKSB7XG5cdCAgICBzY3JvbGwuaW1hZ2UgPSBsYXllci5pbWFnZTtcblx0ICAgIGxheWVyLmltYWdlID0gbnVsbDtcblx0ICB9XG5cdCAgaWYgKGluc3RhbmNlLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiUGFnZUNvbXBvbmVudFwiKSB7XG5cdCAgICByZWYxID0gbGF5ZXIuY2hpbGRyZW47XG5cdCAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYxLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICAgIGwgPSByZWYxW2ldO1xuXHQgICAgICBzY3JvbGwuYWRkUGFnZShsKTtcblx0ICAgIH1cblx0ICB9IGVsc2Uge1xuXHQgICAgc2Nyb2xsLnNldENvbnRlbnRMYXllcihsYXllcik7XG5cdCAgfVxuXHQgIGlmIChvcHRpb25zLmNvcnJlY3QgPT09IHRydWUpIHtcblx0ICAgIHNjcmVlbkZyYW1lID0gc2Nyb2xsLnNjcmVlbkZyYW1lO1xuXHQgICAgaWYgKHNjcmVlbkZyYW1lLnggPCBTY3JlZW4ud2lkdGgpIHtcblx0ICAgICAgaWYgKHNjcmVlbkZyYW1lLnggKyBzY3JlZW5GcmFtZS53aWR0aCA+IFNjcmVlbi53aWR0aCkge1xuXHQgICAgICAgIHNjcm9sbC53aWR0aCA9IFNjcmVlbi53aWR0aCAtIHNjcmVlbkZyYW1lLng7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIGlmIChzY3JlZW5GcmFtZS55IDwgU2NyZWVuLmhlaWdodCkge1xuXHQgICAgICBpZiAoc2NyZWVuRnJhbWUueSArIHNjcmVlbkZyYW1lLmhlaWdodCA+IFNjcmVlbi5oZWlnaHQpIHtcblx0ICAgICAgICBzY3JvbGwuaGVpZ2h0ID0gU2NyZWVuLmhlaWdodCAtIHNjcmVlbkZyYW1lLnk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHNjcm9sbDtcblx0fTtcblxuXG4vKioqLyB9LFxuLyogNDQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBFdmVudHMsIFNjcm9sbENvbXBvbmVudCxcblx0ICBiaW5kID0gZnVuY3Rpb24oZm4sIG1lKXsgcmV0dXJuIGZ1bmN0aW9uKCl7IHJldHVybiBmbi5hcHBseShtZSwgYXJndW1lbnRzKTsgfTsgfSxcblx0ICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG5cdCAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxuXHQgIGluZGV4T2YgPSBbXS5pbmRleE9mIHx8IGZ1bmN0aW9uKGl0ZW0pIHsgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykgeyBpZiAoaSBpbiB0aGlzICYmIHRoaXNbaV0gPT09IGl0ZW0pIHJldHVybiBpOyB9IHJldHVybiAtMTsgfTtcblx0XG5cdEV2ZW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpLkV2ZW50cztcblx0XG5cdFNjcm9sbENvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpLlNjcm9sbENvbXBvbmVudDtcblx0XG5cdFwiUGFnZUNvbXBvbmVudFxcblxcbm9yaWdpblggPG51bWJlcj5cXG5vcmlnaW5ZIDxudW1iZXI+XFxuXFxudmVsb2NpdHlUaHJlc2hvbGQgPG51bWJlcj5cXG5hbmltYXRpb25PcHRpb25zIDxhbmltYXRpb25PcHRpb25zPXt9PlxcbmN1cnJlbnRQYWdlIDxMYXllcj5cXG5jbG9zZXN0UGFnZSg8b3JpZ2luWDpuLCBvcmlnaW5ZOm4+KSA8TGF5ZXI+XFxuXFxubmV4dFBhZ2UoZGlyZWN0aW9uPVxcXCJcXFwiLCBjdXJyZW50UGFnZSlcXG5zbmFwVG9OZXh0UGFnZShkaXJlY3Rpb249XFxcIlxcXCIsIGFuaW1hdGUsIGFuaW1hdGlvbk9wdGlvbnM9e30pXFxuXCI7XG5cdFxuXHRleHBvcnRzLlBhZ2VDb21wb25lbnQgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuXHQgIGV4dGVuZChQYWdlQ29tcG9uZW50LCBzdXBlckNsYXNzKTtcblx0XG5cdCAgUGFnZUNvbXBvbmVudC5kZWZpbmUoXCJvcmlnaW5YXCIsIFBhZ2VDb21wb25lbnQuc2ltcGxlUHJvcGVydHkoXCJvcmlnaW5YXCIsIC41KSk7XG5cdFxuXHQgIFBhZ2VDb21wb25lbnQuZGVmaW5lKFwib3JpZ2luWVwiLCBQYWdlQ29tcG9uZW50LnNpbXBsZVByb3BlcnR5KFwib3JpZ2luWVwiLCAuNSkpO1xuXHRcblx0ICBQYWdlQ29tcG9uZW50LmRlZmluZShcInZlbG9jaXR5VGhyZXNob2xkXCIsIFBhZ2VDb21wb25lbnQuc2ltcGxlUHJvcGVydHkoXCJ2ZWxvY2l0eVRocmVzaG9sZFwiLCAwLjEpKTtcblx0XG5cdCAgUGFnZUNvbXBvbmVudC5kZWZpbmUoXCJhbmltYXRpb25PcHRpb25zXCIsIFBhZ2VDb21wb25lbnQuc2ltcGxlUHJvcGVydHkoXCJhbmltYXRpb25PcHRpb25zXCIsIHtcblx0ICAgIGN1cnZlOiBcInNwcmluZyg1MDAsNTAsMClcIlxuXHQgIH0pKTtcblx0XG5cdCAgZnVuY3Rpb24gUGFnZUNvbXBvbmVudCgpIHtcblx0ICAgIHRoaXMuX3Jlc2V0SGlzdG9yeSA9IGJpbmQodGhpcy5fcmVzZXRIaXN0b3J5LCB0aGlzKTtcblx0ICAgIHRoaXMuX3Njcm9sbEVuZCA9IGJpbmQodGhpcy5fc2Nyb2xsRW5kLCB0aGlzKTtcblx0ICAgIHRoaXMuX29uQW5pbWF0aW9uU3RvcCA9IGJpbmQodGhpcy5fb25BbmltYXRpb25TdG9wLCB0aGlzKTtcblx0ICAgIHRoaXMuX29uQW5pbWF0aW9uU3RlcCA9IGJpbmQodGhpcy5fb25BbmltYXRpb25TdGVwLCB0aGlzKTtcblx0ICAgIHRoaXMuX29uQW5pbWF0aW9uU3RhcnQgPSBiaW5kKHRoaXMuX29uQW5pbWF0aW9uU3RhcnQsIHRoaXMpO1xuXHQgICAgdGhpcy5fc2Nyb2xsTW92ZSA9IGJpbmQodGhpcy5fc2Nyb2xsTW92ZSwgdGhpcyk7XG5cdCAgICB0aGlzLl9zY3JvbGxTdGFydCA9IGJpbmQodGhpcy5fc2Nyb2xsU3RhcnQsIHRoaXMpO1xuXHQgICAgUGFnZUNvbXBvbmVudC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgIHRoaXMuY29udGVudC5kcmFnZ2FibGUubW9tZW50dW0gPSBmYWxzZTtcblx0ICAgIHRoaXMuY29udGVudC5kcmFnZ2FibGUuYm91bmNlID0gZmFsc2U7XG5cdCAgICB0aGlzLmNvbnRlbnQub24oRXZlbnRzLkRyYWdTZXNzaW9uU3RhcnQsIHRoaXMuX3Njcm9sbFN0YXJ0KTtcblx0ICAgIHRoaXMuY29udGVudC5vbihFdmVudHMuRHJhZ1Nlc3Npb25FbmQsIHRoaXMuX3Njcm9sbEVuZCk7XG5cdCAgICB0aGlzLmNvbnRlbnQub24oXCJjaGFuZ2U6ZnJhbWVcIiwgXy5kZWJvdW5jZSh0aGlzLl9zY3JvbGxNb3ZlLCAxNikpO1xuXHQgICAgdGhpcy5jb250ZW50Lm9uKFwiY2hhbmdlOmNoaWxkcmVuXCIsIHRoaXMuX3Jlc2V0SGlzdG9yeSk7XG5cdCAgICB0aGlzLl9yZXNldEhpc3RvcnkoKTtcblx0ICB9XG5cdFxuXHQgIFBhZ2VDb21wb25lbnQuZGVmaW5lKFwiY2xvc2VzdFBhZ2VcIiwge1xuXHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuY2xvc2VzdENvbnRlbnRMYXllckZvclNjcm9sbFBvaW50KHRoaXMuX29yaWdpblNjcm9sbFBvaW50KCksIHRoaXMub3JpZ2luWCwgdGhpcy5vcmlnaW5ZKTtcblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgUGFnZUNvbXBvbmVudC5kZWZpbmUoXCJjdXJyZW50UGFnZVwiLCB7XG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gXy5sYXN0KHRoaXMuX3ByZXZpb3VzUGFnZXMpO1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBQYWdlQ29tcG9uZW50LmRlZmluZShcInByZXZpb3VzUGFnZVwiLCB7XG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fcHJldmlvdXNQYWdlc1t0aGlzLl9wcmV2aW91c1BhZ2VzLmxlbmd0aCAtIDJdO1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBQYWdlQ29tcG9uZW50LnByb3RvdHlwZS5uZXh0UGFnZSA9IGZ1bmN0aW9uKGRpcmVjdGlvbiwgY3VycmVudFBhZ2UsIHdpdGhvdXRDdXJyZW50UGFnZSkge1xuXHQgICAgdmFyIGxheWVycywgcG9pbnQ7XG5cdCAgICBpZiAoZGlyZWN0aW9uID09IG51bGwpIHtcblx0ICAgICAgZGlyZWN0aW9uID0gXCJyaWdodFwiO1xuXHQgICAgfVxuXHQgICAgaWYgKGN1cnJlbnRQYWdlID09IG51bGwpIHtcblx0ICAgICAgY3VycmVudFBhZ2UgPSBudWxsO1xuXHQgICAgfVxuXHQgICAgaWYgKHdpdGhvdXRDdXJyZW50UGFnZSA9PSBudWxsKSB7XG5cdCAgICAgIHdpdGhvdXRDdXJyZW50UGFnZSA9IHRydWU7XG5cdCAgICB9XG5cdCAgICBpZiAoY3VycmVudFBhZ2UgPT0gbnVsbCkge1xuXHQgICAgICBjdXJyZW50UGFnZSA9IHRoaXMuY3VycmVudFBhZ2U7XG5cdCAgICB9XG5cdCAgICBwb2ludCA9IHtcblx0ICAgICAgeDogMCxcblx0ICAgICAgeTogMFxuXHQgICAgfTtcblx0ICAgIGlmIChjdXJyZW50UGFnZSkge1xuXHQgICAgICBwb2ludCA9IFV0aWxzLmZyYW1lUG9pbnRGb3JPcmlnaW4oY3VycmVudFBhZ2UsIHRoaXMub3JpZ2luWCwgdGhpcy5vcmlnaW5ZKTtcblx0ICAgIH1cblx0ICAgIGlmICghd2l0aG91dEN1cnJlbnRQYWdlKSB7XG5cdCAgICAgIHBvaW50ID0ge1xuXHQgICAgICAgIHg6IHRoaXMuc2Nyb2xsWCArICh0aGlzLm9yaWdpblggKiB0aGlzLndpZHRoKSxcblx0ICAgICAgICB5OiB0aGlzLnNjcm9sbFkgKyAodGhpcy5vcmlnaW5ZICogdGhpcy5oZWlnaHQpXG5cdCAgICAgIH07XG5cdCAgICB9XG5cdCAgICBpZiAoZGlyZWN0aW9uID09PSBcInVwXCIgfHwgZGlyZWN0aW9uID09PSBcInRvcFwiIHx8IGRpcmVjdGlvbiA9PT0gXCJub3J0aFwiKSB7XG5cdCAgICAgIGxheWVycyA9IHRoaXMuY29udGVudC5jaGlsZHJlbkFib3ZlKHBvaW50LCB0aGlzLm9yaWdpblgsIHRoaXMub3JpZ2luWSk7XG5cdCAgICB9XG5cdCAgICBpZiAoZGlyZWN0aW9uID09PSBcImRvd25cIiB8fCBkaXJlY3Rpb24gPT09IFwiYm90dG9tXCIgfHwgZGlyZWN0aW9uID09PSBcInNvdXRoXCIpIHtcblx0ICAgICAgbGF5ZXJzID0gdGhpcy5jb250ZW50LmNoaWxkcmVuQmVsb3cocG9pbnQsIHRoaXMub3JpZ2luWCwgdGhpcy5vcmlnaW5ZKTtcblx0ICAgIH1cblx0ICAgIGlmIChkaXJlY3Rpb24gPT09IFwibGVmdFwiIHx8IGRpcmVjdGlvbiA9PT0gXCJ3ZXN0XCIpIHtcblx0ICAgICAgbGF5ZXJzID0gdGhpcy5jb250ZW50LmNoaWxkcmVuTGVmdChwb2ludCwgdGhpcy5vcmlnaW5YLCB0aGlzLm9yaWdpblkpO1xuXHQgICAgfVxuXHQgICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJyaWdodFwiIHx8IGRpcmVjdGlvbiA9PT0gXCJlYXN0XCIpIHtcblx0ICAgICAgbGF5ZXJzID0gdGhpcy5jb250ZW50LmNoaWxkcmVuUmlnaHQocG9pbnQsIHRoaXMub3JpZ2luWCwgdGhpcy5vcmlnaW5ZKTtcblx0ICAgIH1cblx0ICAgIGlmICh3aXRob3V0Q3VycmVudFBhZ2UpIHtcblx0ICAgICAgbGF5ZXJzID0gXy53aXRob3V0KGxheWVycywgY3VycmVudFBhZ2UpO1xuXHQgICAgfVxuXHQgICAgbGF5ZXJzID0gVXRpbHMuZnJhbWVTb3J0QnlBYnNvbHV0ZURpc3RhbmNlKHBvaW50LCBsYXllcnMsIHRoaXMub3JpZ2luWCwgdGhpcy5vcmlnaW5ZKTtcblx0ICAgIHJldHVybiBfLmZpcnN0KGxheWVycyk7XG5cdCAgfTtcblx0XG5cdCAgUGFnZUNvbXBvbmVudC5wcm90b3R5cGUuc25hcFRvUGFnZSA9IGZ1bmN0aW9uKHBhZ2UsIGFuaW1hdGUsIGFuaW1hdGlvbk9wdGlvbnMpIHtcblx0ICAgIGlmIChhbmltYXRlID09IG51bGwpIHtcblx0ICAgICAgYW5pbWF0ZSA9IHRydWU7XG5cdCAgICB9XG5cdCAgICBpZiAoYW5pbWF0aW9uT3B0aW9ucyA9PSBudWxsKSB7XG5cdCAgICAgIGFuaW1hdGlvbk9wdGlvbnMgPSBudWxsO1xuXHQgICAgfVxuXHQgICAgdGhpcy5zY3JvbGxUb0xheWVyKHBhZ2UsIHRoaXMub3JpZ2luWCwgdGhpcy5vcmlnaW5ZLCBhbmltYXRlLCBhbmltYXRpb25PcHRpb25zKTtcblx0ICAgIGlmICh0aGlzLmN1cnJlbnRQYWdlICE9PSBwYWdlKSB7XG5cdCAgICAgIHRoaXMuX3ByZXZpb3VzUGFnZXMucHVzaChwYWdlKTtcblx0ICAgICAgdGhpcy5lbWl0KFwiY2hhbmdlOnByZXZpb3VzUGFnZVwiLCB0aGlzLnByZXZpb3VzUGFnZSk7XG5cdCAgICAgIHJldHVybiB0aGlzLmVtaXQoXCJjaGFuZ2U6Y3VycmVudFBhZ2VcIiwgdGhpcy5jdXJyZW50UGFnZSk7XG5cdCAgICB9XG5cdCAgfTtcblx0XG5cdCAgUGFnZUNvbXBvbmVudC5wcm90b3R5cGUuc25hcFRvTmV4dFBhZ2UgPSBmdW5jdGlvbihkaXJlY3Rpb24sIGFuaW1hdGUsIGFuaW1hdGlvbk9wdGlvbnMpIHtcblx0ICAgIHZhciBuZXh0UGFnZTtcblx0ICAgIGlmIChkaXJlY3Rpb24gPT0gbnVsbCkge1xuXHQgICAgICBkaXJlY3Rpb24gPSBcInJpZ2h0XCI7XG5cdCAgICB9XG5cdCAgICBpZiAoYW5pbWF0ZSA9PSBudWxsKSB7XG5cdCAgICAgIGFuaW1hdGUgPSB0cnVlO1xuXHQgICAgfVxuXHQgICAgaWYgKGFuaW1hdGlvbk9wdGlvbnMgPT0gbnVsbCkge1xuXHQgICAgICBhbmltYXRpb25PcHRpb25zID0gbnVsbDtcblx0ICAgIH1cblx0ICAgIGlmIChhbmltYXRpb25PcHRpb25zID09IG51bGwpIHtcblx0ICAgICAgYW5pbWF0aW9uT3B0aW9ucyA9IHRoaXMuYW5pbWF0aW9uT3B0aW9ucztcblx0ICAgIH1cblx0ICAgIG5leHRQYWdlID0gdGhpcy5uZXh0UGFnZShkaXJlY3Rpb24pO1xuXHQgICAgaWYgKG5leHRQYWdlID09IG51bGwpIHtcblx0ICAgICAgbmV4dFBhZ2UgPSB0aGlzLmNsb3Nlc3RQYWdlO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXMuc25hcFRvUGFnZShuZXh0UGFnZSwgYW5pbWF0ZSwgYW5pbWF0aW9uT3B0aW9ucyk7XG5cdCAgfTtcblx0XG5cdCAgUGFnZUNvbXBvbmVudC5wcm90b3R5cGUuc25hcFRvUHJldmlvdXNQYWdlID0gZnVuY3Rpb24oKSB7XG5cdCAgICBpZiAoIXRoaXMucHJldmlvdXNQYWdlKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHRoaXMuc25hcFRvUGFnZSh0aGlzLnByZXZpb3VzUGFnZSk7XG5cdCAgICByZXR1cm4gdGhpcy5fcHJldmlvdXNQYWdlcyA9IHRoaXMuX3ByZXZpb3VzUGFnZXMuc2xpY2UoMCwgKyh0aGlzLl9wcmV2aW91c1BhZ2VzLmxlbmd0aCAtIDMpICsgMSB8fCA5ZTkpO1xuXHQgIH07XG5cdFxuXHQgIFBhZ2VDb21wb25lbnQucHJvdG90eXBlLmFkZFBhZ2UgPSBmdW5jdGlvbihwYWdlLCBkaXJlY3Rpb24pIHtcblx0ICAgIHZhciBkaXJlY3Rpb25zLCBwb2ludCwgcmVmO1xuXHQgICAgaWYgKGRpcmVjdGlvbiA9PSBudWxsKSB7XG5cdCAgICAgIGRpcmVjdGlvbiA9IFwicmlnaHRcIjtcblx0ICAgIH1cblx0ICAgIGRpcmVjdGlvbnMgPSBbXCJkb3duXCIsIFwiYm90dG9tXCIsIFwic291dGhcIl0gKyBbXCJyaWdodFwiLCBcImVhc3RcIl07XG5cdCAgICBpZiAocmVmID0gIWRpcmVjdGlvbiwgaW5kZXhPZi5jYWxsKGRpcmVjdGlvbnMsIHJlZikgPj0gMCkge1xuXHQgICAgICBkaXJlY3Rpb24gPSBcInJpZ2h0XCI7XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcihkaXJlY3Rpb24gKyBcIiBzaG91bGQgYmUgaW4gXCIgKyBkaXJlY3Rpb25zKTtcblx0ICAgIH1cblx0ICAgIHBvaW50ID0gcGFnZS5wb2ludDtcblx0ICAgIGlmICh0aGlzLmNvbnRlbnQuY2hpbGRyZW4ubGVuZ3RoKSB7XG5cdCAgICAgIGlmIChkaXJlY3Rpb24gPT09IFwicmlnaHRcIiB8fCBkaXJlY3Rpb24gPT09IFwiZWFzdFwiKSB7XG5cdCAgICAgICAgcG9pbnQueCA9IFV0aWxzLmZyYW1lR2V0TWF4WCh0aGlzLmNvbnRlbnQuY29udGVudEZyYW1lKCkpO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChkaXJlY3Rpb24gPT09IFwiZG93blwiIHx8IGRpcmVjdGlvbiA9PT0gXCJib3R0b21cIiB8fCBkaXJlY3Rpb24gPT09IFwic291dGhcIikge1xuXHQgICAgICAgIHBvaW50LnkgPSBVdGlscy5mcmFtZUdldE1heFkodGhpcy5jb250ZW50LmNvbnRlbnRGcmFtZSgpKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcGFnZS5wb2ludCA9IHBvaW50O1xuXHQgICAgaWYgKHBhZ2UucGFyZW50ICE9PSB0aGlzLmNvbnRlbnQpIHtcblx0ICAgICAgcmV0dXJuIHBhZ2UucGFyZW50ID0gdGhpcy5jb250ZW50O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIHRoaXMudXBkYXRlQ29udGVudCgpO1xuXHQgICAgfVxuXHQgIH07XG5cdFxuXHQgIFBhZ2VDb21wb25lbnQucHJvdG90eXBlLnNldENvbnRlbnRMYXllciA9IGZ1bmN0aW9uKGNvbnRlbnRMYXllcikge1xuXHQgICAgaWYgKHRoaXMuY29udGVudCkge1xuXHQgICAgICB0aGlzLl9vbkFuaW1hdGlvblN0b3AoKTtcblx0ICAgICAgdGhpcy5jb250ZW50Lm9mZihFdmVudHMuQW5pbWF0aW9uU3RhcnQsIHRoaXMuX29uQW5pbWF0aW9uU3RhcnQpO1xuXHQgICAgICB0aGlzLmNvbnRlbnQub2ZmKEV2ZW50cy5BbmltYXRpb25TdG9wLCB0aGlzLl9vbkFuaW1hdGlvblN0b3ApO1xuXHQgICAgfVxuXHQgICAgUGFnZUNvbXBvbmVudC5fX3N1cGVyX18uc2V0Q29udGVudExheWVyLmNhbGwodGhpcywgY29udGVudExheWVyKTtcblx0ICAgIHRoaXMuY29udGVudC5vbihFdmVudHMuQW5pbWF0aW9uU3RhcnQsIHRoaXMuX29uQW5pbWF0aW9uU3RhcnQpO1xuXHQgICAgcmV0dXJuIHRoaXMuY29udGVudC5vbihFdmVudHMuQW5pbWF0aW9uU3RvcCwgdGhpcy5fb25BbmltYXRpb25TdG9wKTtcblx0ICB9O1xuXHRcblx0ICBQYWdlQ29tcG9uZW50LnByb3RvdHlwZS5ob3Jpem9udGFsUGFnZUluZGV4ID0gZnVuY3Rpb24ocGFnZSkge1xuXHQgICAgcmV0dXJuIChfLnNvcnRCeSh0aGlzLmNvbnRlbnQuY2hpbGRyZW4sIGZ1bmN0aW9uKGwpIHtcblx0ICAgICAgcmV0dXJuIGwueDtcblx0ICAgIH0pKS5pbmRleE9mKHBhZ2UpO1xuXHQgIH07XG5cdFxuXHQgIFBhZ2VDb21wb25lbnQucHJvdG90eXBlLnZlcnRpY2FsUGFnZUluZGV4ID0gZnVuY3Rpb24ocGFnZSkge1xuXHQgICAgcmV0dXJuIChfLnNvcnRCeSh0aGlzLmNvbnRlbnQuY2hpbGRyZW4sIGZ1bmN0aW9uKGwpIHtcblx0ICAgICAgcmV0dXJuIGwueTtcblx0ICAgIH0pKS5pbmRleE9mKHBhZ2UpO1xuXHQgIH07XG5cdFxuXHQgIFBhZ2VDb21wb25lbnQucHJvdG90eXBlLl9zY3JvbGxTdGFydCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRQYWdlID0gdGhpcy5jdXJyZW50UGFnZTtcblx0ICB9O1xuXHRcblx0ICBQYWdlQ29tcG9uZW50LnByb3RvdHlwZS5fc2Nyb2xsTW92ZSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIGN1cnJlbnRQYWdlO1xuXHQgICAgY3VycmVudFBhZ2UgPSB0aGlzLmN1cnJlbnRQYWdlO1xuXHQgICAgaWYgKGN1cnJlbnRQYWdlICE9PSBfLmxhc3QodGhpcy5fcHJldmlvdXNQYWdlcykgJiYgY3VycmVudFBhZ2UgIT09ICh2b2lkIDApKSB7XG5cdCAgICAgIHRoaXMuX3ByZXZpb3VzUGFnZXMucHVzaChjdXJyZW50UGFnZSk7XG5cdCAgICAgIHJldHVybiB0aGlzLmVtaXQoXCJjaGFuZ2U6Y3VycmVudFBhZ2VcIiwge1xuXHQgICAgICAgIG9sZDogdGhpcy5wcmV2aW91c1BhZ2UsXG5cdCAgICAgICAgXCJuZXdcIjogY3VycmVudFBhZ2Vcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfTtcblx0XG5cdCAgUGFnZUNvbXBvbmVudC5wcm90b3R5cGUuX29uQW5pbWF0aW9uU3RhcnQgPSBmdW5jdGlvbigpIHtcblx0ICAgIHRoaXMuX2lzTW92aW5nID0gdHJ1ZTtcblx0ICAgIHRoaXMuX2lzQW5pbWF0aW5nID0gdHJ1ZTtcblx0ICAgIHJldHVybiB0aGlzLmNvbnRlbnQub24oXCJjaGFuZ2U6ZnJhbWVcIiwgdGhpcy5fb25BbmltYXRpb25TdGVwKTtcblx0ICB9O1xuXHRcblx0ICBQYWdlQ29tcG9uZW50LnByb3RvdHlwZS5fb25BbmltYXRpb25TdGVwID0gZnVuY3Rpb24oKSB7XG5cdCAgICByZXR1cm4gdGhpcy5lbWl0KEV2ZW50cy5Nb3ZlLCB0aGlzLmNvbnRlbnQucG9pbnQpO1xuXHQgIH07XG5cdFxuXHQgIFBhZ2VDb21wb25lbnQucHJvdG90eXBlLl9vbkFuaW1hdGlvblN0b3AgPSBmdW5jdGlvbigpIHtcblx0ICAgIHRoaXMuX2lzTW92aW5nID0gZmFsc2U7XG5cdCAgICB0aGlzLl9pc0FuaW1hdGluZyA9IGZhbHNlO1xuXHQgICAgcmV0dXJuIHRoaXMuY29udGVudC5vZmYoXCJjaGFuZ2U6ZnJhbWVcIiwgdGhpcy5fb25BbmltYXRpb25TdGVwKTtcblx0ICB9O1xuXHRcblx0ICBQYWdlQ29tcG9uZW50LnByb3RvdHlwZS5fc2Nyb2xsRW5kID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgbWF4aW11bVZlbG9jaXR5LCBuZXh0UGFnZSwgdmVsb2NpdHksIHhEaXNhYmxlZCwgeExvY2ssIHlEaXNhYmxlZCwgeUxvY2s7XG5cdCAgICBpZiAodGhpcy5jb250ZW50LmlzQW5pbWF0aW5nKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHZlbG9jaXR5ID0gdGhpcy5jb250ZW50LmRyYWdnYWJsZS52ZWxvY2l0eTtcblx0ICAgIHhEaXNhYmxlZCA9ICF0aGlzLnNjcm9sbEhvcml6b250YWwgJiYgKHRoaXMuZGlyZWN0aW9uID09PSBcInJpZ2h0XCIgfHwgdGhpcy5kaXJlY3Rpb24gPT09IFwibGVmdFwiKTtcblx0ICAgIHlEaXNhYmxlZCA9ICF0aGlzLnNjcm9sbFZlcnRpY2FsICYmICh0aGlzLmRpcmVjdGlvbiA9PT0gXCJkb3duXCIgfHwgdGhpcy5kaXJlY3Rpb24gPT09IFwidXBcIik7XG5cdCAgICB4TG9jayA9IHRoaXMuY29udGVudC5kcmFnZ2FibGUuX2RpcmVjdGlvbkxvY2tFbmFibGVkWCAmJiAodGhpcy5kaXJlY3Rpb24gPT09IFwicmlnaHRcIiB8fCB0aGlzLmRpcmVjdGlvbiA9PT0gXCJsZWZ0XCIpO1xuXHQgICAgeUxvY2sgPSB0aGlzLmNvbnRlbnQuZHJhZ2dhYmxlLl9kaXJlY3Rpb25Mb2NrRW5hYmxlZFkgJiYgKHRoaXMuZGlyZWN0aW9uID09PSBcImRvd25cIiB8fCB0aGlzLmRpcmVjdGlvbiA9PT0gXCJ1cFwiKTtcblx0ICAgIG1heGltdW1WZWxvY2l0eSA9IE1hdGgubWF4KE1hdGguYWJzKHZlbG9jaXR5LngpLCBNYXRoLmFicyh2ZWxvY2l0eS55KSk7XG5cdCAgICBpZiAobWF4aW11bVZlbG9jaXR5IDwgdGhpcy52ZWxvY2l0eVRocmVzaG9sZCB8fCB4TG9jayB8fCB5TG9jayB8fCB4RGlzYWJsZWQgfHwgeURpc2FibGVkKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLnNuYXBUb1BhZ2UodGhpcy5jbG9zZXN0UGFnZSwgdHJ1ZSwgdGhpcy5hbmltYXRpb25PcHRpb25zKTtcblx0ICAgIH1cblx0ICAgIG5leHRQYWdlID0gdGhpcy5uZXh0UGFnZSh0aGlzLmRpcmVjdGlvbiwgdGhpcy5fY3VycmVudFBhZ2UsIGZhbHNlKTtcblx0ICAgIGlmIChuZXh0UGFnZSA9PSBudWxsKSB7XG5cdCAgICAgIG5leHRQYWdlID0gdGhpcy5jbG9zZXN0UGFnZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0aGlzLnNuYXBUb1BhZ2UobmV4dFBhZ2UsIHRydWUsIHRoaXMuYW5pbWF0aW9uT3B0aW9ucyk7XG5cdCAgfTtcblx0XG5cdCAgUGFnZUNvbXBvbmVudC5wcm90b3R5cGUuX29yaWdpblNjcm9sbFBvaW50ID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgc2Nyb2xsUG9pbnQ7XG5cdCAgICBzY3JvbGxQb2ludCA9IHRoaXMuc2Nyb2xsUG9pbnQ7XG5cdCAgICBzY3JvbGxQb2ludC54ICs9IHRoaXMud2lkdGggKiB0aGlzLm9yaWdpblg7XG5cdCAgICBzY3JvbGxQb2ludC55ICs9IHRoaXMuaGVpZ2h0ICogdGhpcy5vcmlnaW5ZO1xuXHQgICAgcmV0dXJuIHNjcm9sbFBvaW50O1xuXHQgIH07XG5cdFxuXHQgIFBhZ2VDb21wb25lbnQucHJvdG90eXBlLl9yZXNldEhpc3RvcnkgPSBmdW5jdGlvbigpIHtcblx0ICAgIHRoaXMuX2N1cnJlbnRQYWdlID0gdGhpcy5jbG9zZXN0UGFnZTtcblx0ICAgIHJldHVybiB0aGlzLl9wcmV2aW91c1BhZ2VzID0gW3RoaXMuX2N1cnJlbnRQYWdlXTtcblx0ICB9O1xuXHRcblx0ICByZXR1cm4gUGFnZUNvbXBvbmVudDtcblx0XG5cdH0pKFNjcm9sbENvbXBvbmVudCk7XG5cblxuLyoqKi8gfSxcbi8qIDQ1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgRXZlbnRzLCBLbm9iLCBMYXllciwgVXRpbHMsXG5cdCAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuXHQgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcblx0ICBiaW5kID0gZnVuY3Rpb24oZm4sIG1lKXsgcmV0dXJuIGZ1bmN0aW9uKCl7IHJldHVybiBmbi5hcHBseShtZSwgYXJndW1lbnRzKTsgfTsgfTtcblx0XG5cdFV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0XG5cdExheWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMykuTGF5ZXI7XG5cdFxuXHRFdmVudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KS5FdmVudHM7XG5cdFxuXHRcIlNsaWRlckNvbXBvbmVudFxcblxcbmtub2IgPGxheWVyPlxcbmtub2JTaXplIDx3aWR0aCwgaGVpZ2h0PlxcbmZpbGwgPGxheWVyPlxcbm1pbiA8bnVtYmVyPlxcbm1heCA8bnVtYmVyPlxcblxcbnBvaW50Rm9yVmFsdWUoPG4+KVxcbnZhbHVlRm9yUG9pbnQoPG4+KVxcblxcbmFuaW1hdGVUb1ZhbHVlKHZhbHVlLCBhbmltYXRpb25PcHRpb25zPXt9KVwiO1xuXHRcblx0RXZlbnRzLlNsaWRlclZhbHVlQ2hhbmdlID0gXCJzbGlkZXJWYWx1ZUNoYW5nZVwiO1xuXHRcblx0S25vYiA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG5cdCAgZXh0ZW5kKEtub2IsIHN1cGVyQ2xhc3MpO1xuXHRcblx0ICBmdW5jdGlvbiBLbm9iKG9wdGlvbnMpIHtcblx0ICAgIEtub2IuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgfVxuXHRcblx0ICBLbm9iLmRlZmluZShcImNvbnN0cmFpbmVkXCIsIEtub2Iuc2ltcGxlUHJvcGVydHkoXCJjb25zdHJhaW5lZFwiLCBmYWxzZSkpO1xuXHRcblx0ICByZXR1cm4gS25vYjtcblx0XG5cdH0pKExheWVyKTtcblx0XG5cdGV4cG9ydHMuU2xpZGVyQ29tcG9uZW50ID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcblx0ICBleHRlbmQoU2xpZGVyQ29tcG9uZW50LCBzdXBlckNsYXNzKTtcblx0XG5cdCAgZnVuY3Rpb24gU2xpZGVyQ29tcG9uZW50KG9wdGlvbnMpIHtcblx0ICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcblx0ICAgICAgb3B0aW9ucyA9IHt9O1xuXHQgICAgfVxuXHQgICAgdGhpcy5fdXBkYXRlVmFsdWUgPSBiaW5kKHRoaXMuX3VwZGF0ZVZhbHVlLCB0aGlzKTtcblx0ICAgIHRoaXMuX3NldFJhZGl1cyA9IGJpbmQodGhpcy5fc2V0UmFkaXVzLCB0aGlzKTtcblx0ICAgIHRoaXMuX3VwZGF0ZUZyYW1lID0gYmluZCh0aGlzLl91cGRhdGVGcmFtZSwgdGhpcyk7XG5cdCAgICB0aGlzLl91cGRhdGVLbm9iID0gYmluZCh0aGlzLl91cGRhdGVLbm9iLCB0aGlzKTtcblx0ICAgIHRoaXMuX3VwZGF0ZUZpbGwgPSBiaW5kKHRoaXMuX3VwZGF0ZUZpbGwsIHRoaXMpO1xuXHQgICAgdGhpcy5fdG91Y2hFbmQgPSBiaW5kKHRoaXMuX3RvdWNoRW5kLCB0aGlzKTtcblx0ICAgIHRoaXMuX3RvdWNoU3RhcnQgPSBiaW5kKHRoaXMuX3RvdWNoU3RhcnQsIHRoaXMpO1xuXHQgICAgXy5kZWZhdWx0cyhvcHRpb25zLCB7XG5cdCAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjY2NjXCIsXG5cdCAgICAgIGJvcmRlclJhZGl1czogNTAsXG5cdCAgICAgIGNsaXA6IGZhbHNlLFxuXHQgICAgICB3aWR0aDogMzAwLFxuXHQgICAgICBoZWlnaHQ6IDEwLFxuXHQgICAgICB2YWx1ZTogMCxcblx0ICAgICAga25vYlNpemU6IDMwXG5cdCAgICB9KTtcblx0ICAgIGlmIChvcHRpb25zLmhpdEFyZWEgPT0gbnVsbCkge1xuXHQgICAgICBvcHRpb25zLmhpdEFyZWEgPSBvcHRpb25zLmtub2JTaXplO1xuXHQgICAgfVxuXHQgICAgdGhpcy5rbm9iID0gbmV3IEtub2Ioe1xuXHQgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2ZmZlwiLFxuXHQgICAgICBzaGFkb3dZOiAxLFxuXHQgICAgICBzaGFkb3dCbHVyOiAzLFxuXHQgICAgICBzaGFkb3dDb2xvcjogXCJyZ2JhKDAsMCwwLDAuMzUpXCIsXG5cdCAgICAgIG5hbWU6IFwia25vYlwiXG5cdCAgICB9KTtcblx0ICAgIHRoaXMuZmlsbCA9IG5ldyBMYXllcih7XG5cdCAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMzMzXCIsXG5cdCAgICAgIHdpZHRoOiAwLFxuXHQgICAgICBmb3JjZTJkOiB0cnVlLFxuXHQgICAgICBuYW1lOiBcImZpbGxcIlxuXHQgICAgfSk7XG5cdCAgICB0aGlzLnNsaWRlck92ZXJsYXkgPSBuZXcgTGF5ZXIoe1xuXHQgICAgICBiYWNrZ3JvdW5kQ29sb3I6IG51bGwsXG5cdCAgICAgIG5hbWU6IFwic2xpZGVyT3ZlcmxheVwiXG5cdCAgICB9KTtcblx0ICAgIFNsaWRlckNvbXBvbmVudC5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgIHRoaXMua25vYlNpemUgPSBvcHRpb25zLmtub2JTaXplO1xuXHQgICAgdGhpcy5rbm9iLnBhcmVudCA9IHRoaXMuZmlsbC5wYXJlbnQgPSB0aGlzLnNsaWRlck92ZXJsYXkucGFyZW50ID0gdGhpcztcblx0ICAgIGlmICh0aGlzLndpZHRoID4gdGhpcy5oZWlnaHQpIHtcblx0ICAgICAgdGhpcy5maWxsLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdGhpcy5maWxsLndpZHRoID0gdGhpcy53aWR0aDtcblx0ICAgIH1cblx0ICAgIHRoaXMuZmlsbC5ib3JkZXJSYWRpdXMgPSB0aGlzLnNsaWRlck92ZXJsYXkuYm9yZGVyUmFkaXVzID0gdGhpcy5ib3JkZXJSYWRpdXM7XG5cdCAgICB0aGlzLmtub2IuZHJhZ2dhYmxlLmVuYWJsZWQgPSB0cnVlO1xuXHQgICAgdGhpcy5rbm9iLmRyYWdnYWJsZS5vdmVyZHJhZyA9IGZhbHNlO1xuXHQgICAgdGhpcy5rbm9iLmRyYWdnYWJsZS5tb21lbnR1bSA9IHRydWU7XG5cdCAgICB0aGlzLmtub2IuZHJhZ2dhYmxlLm1vbWVudHVtT3B0aW9ucyA9IHtcblx0ICAgICAgZnJpY3Rpb246IDUsXG5cdCAgICAgIHRvbGVyYW5jZTogMC4yNVxuXHQgICAgfTtcblx0ICAgIHRoaXMua25vYi5kcmFnZ2FibGUuYm91bmNlID0gZmFsc2U7XG5cdCAgICB0aGlzLmtub2IuYm9yZGVyUmFkaXVzID0gdGhpcy5rbm9iU2l6ZSAvIDI7XG5cdCAgICB0aGlzLl91cGRhdGVGcmFtZSgpO1xuXHQgICAgdGhpcy5fdXBkYXRlS25vYigpO1xuXHQgICAgdGhpcy5fdXBkYXRlRmlsbCgpO1xuXHQgICAgdGhpcy5vbihcImNoYW5nZTpmcmFtZVwiLCB0aGlzLl91cGRhdGVGcmFtZSk7XG5cdCAgICB0aGlzLm9uKFwiY2hhbmdlOmJvcmRlclJhZGl1c1wiLCB0aGlzLl9zZXRSYWRpdXMpO1xuXHQgICAgdGhpcy5rbm9iLm9uKFwiY2hhbmdlOnNpemVcIiwgdGhpcy5fdXBkYXRlS25vYik7XG5cdCAgICB0aGlzLmtub2Iub24oXCJjaGFuZ2U6ZnJhbWVcIiwgdGhpcy5fdXBkYXRlRmlsbCk7XG5cdCAgICB0aGlzLmtub2Iub24oXCJjaGFuZ2U6ZnJhbWVcIiwgdGhpcy5fdXBkYXRlVmFsdWUpO1xuXHQgICAgdGhpcy5zbGlkZXJPdmVybGF5Lm9uKEV2ZW50cy5UYXBTdGFydCwgdGhpcy5fdG91Y2hTdGFydCk7XG5cdCAgICB0aGlzLnNsaWRlck92ZXJsYXkub24oRXZlbnRzLlRhcEVuZCwgdGhpcy5fdG91Y2hFbmQpO1xuXHQgIH1cblx0XG5cdCAgU2xpZGVyQ29tcG9uZW50LnByb3RvdHlwZS5fdG91Y2hTdGFydCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdCAgICB2YXIgb2Zmc2V0WCwgb2Zmc2V0WTtcblx0ICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdCAgICBvZmZzZXRYID0gKHRoaXMubWluIC8gdGhpcy5jYW52YXNTY2FsZVgoKSkgLSB0aGlzLm1pbjtcblx0ICAgIG9mZnNldFkgPSAodGhpcy5taW4gLyB0aGlzLmNhbnZhc1NjYWxlWSgpKSAtIHRoaXMubWluO1xuXHQgICAgaWYgKHRoaXMud2lkdGggPiB0aGlzLmhlaWdodCkge1xuXHQgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZUZvclBvaW50KEV2ZW50cy50b3VjaEV2ZW50KGV2ZW50KS5jbGllbnRYIC0gdGhpcy5zY3JlZW5TY2FsZWRGcmFtZSgpLngpIC8gdGhpcy5jYW52YXNTY2FsZVgoKSAtIG9mZnNldFg7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZUZvclBvaW50KEV2ZW50cy50b3VjaEV2ZW50KGV2ZW50KS5jbGllbnRZIC0gdGhpcy5zY3JlZW5TY2FsZWRGcmFtZSgpLnkpIC8gdGhpcy5jYW52YXNTY2FsZVkoKSAtIG9mZnNldFk7XG5cdCAgICB9XG5cdCAgICB0aGlzLmtub2IuZHJhZ2dhYmxlLl90b3VjaFN0YXJ0KGV2ZW50KTtcblx0ICAgIHJldHVybiB0aGlzLl91cGRhdGVWYWx1ZSgpO1xuXHQgIH07XG5cdFxuXHQgIFNsaWRlckNvbXBvbmVudC5wcm90b3R5cGUuX3RvdWNoRW5kID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0ICAgIHJldHVybiB0aGlzLl91cGRhdGVWYWx1ZSgpO1xuXHQgIH07XG5cdFxuXHQgIFNsaWRlckNvbXBvbmVudC5wcm90b3R5cGUuX3VwZGF0ZUZpbGwgPSBmdW5jdGlvbigpIHtcblx0ICAgIGlmICh0aGlzLndpZHRoID4gdGhpcy5oZWlnaHQpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuZmlsbC53aWR0aCA9IHRoaXMua25vYi5taWRYO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuZmlsbC5oZWlnaHQgPSB0aGlzLmtub2IubWlkWTtcblx0ICAgIH1cblx0ICB9O1xuXHRcblx0ICBTbGlkZXJDb21wb25lbnQucHJvdG90eXBlLl91cGRhdGVLbm9iID0gZnVuY3Rpb24oKSB7XG5cdCAgICBpZiAodGhpcy53aWR0aCA+IHRoaXMuaGVpZ2h0KSB7XG5cdCAgICAgIHRoaXMua25vYi5taWRYID0gdGhpcy5maWxsLndpZHRoO1xuXHQgICAgICByZXR1cm4gdGhpcy5rbm9iLmNlbnRlclkoKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRoaXMua25vYi5taWRZID0gdGhpcy5maWxsLmhlaWdodDtcblx0ICAgICAgcmV0dXJuIHRoaXMua25vYi5jZW50ZXJYKCk7XG5cdCAgICB9XG5cdCAgfTtcblx0XG5cdCAgU2xpZGVyQ29tcG9uZW50LnByb3RvdHlwZS5fdXBkYXRlRnJhbWUgPSBmdW5jdGlvbigpIHtcblx0ICAgIHRoaXMua25vYi5kcmFnZ2FibGUuY29uc3RyYWludHMgPSB7XG5cdCAgICAgIHg6IC10aGlzLmtub2Iud2lkdGggLyAyLFxuXHQgICAgICB5OiAtdGhpcy5rbm9iLmhlaWdodCAvIDIsXG5cdCAgICAgIHdpZHRoOiB0aGlzLndpZHRoICsgdGhpcy5rbm9iLndpZHRoLFxuXHQgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0ICsgdGhpcy5rbm9iLmhlaWdodFxuXHQgICAgfTtcblx0ICAgIGlmICh0aGlzLmtub2IuY29uc3RyYWluZWQpIHtcblx0ICAgICAgdGhpcy5rbm9iLmRyYWdnYWJsZS5jb25zdHJhaW50cyA9IHtcblx0ICAgICAgICB4OiAwLFxuXHQgICAgICAgIHk6IDAsXG5cdCAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG5cdCAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuXHQgICAgICB9O1xuXHQgICAgfVxuXHQgICAgaWYgKHRoaXMud2lkdGggPiB0aGlzLmhlaWdodCkge1xuXHQgICAgICB0aGlzLmZpbGwuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG5cdCAgICAgIHRoaXMua25vYi5jZW50ZXJZKCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aGlzLmZpbGwud2lkdGggPSB0aGlzLndpZHRoO1xuXHQgICAgICB0aGlzLmtub2IuY2VudGVyWCgpO1xuXHQgICAgfVxuXHQgICAgaWYgKHRoaXMud2lkdGggPiB0aGlzLmhlaWdodCkge1xuXHQgICAgICB0aGlzLmtub2IuZHJhZ2dhYmxlLnNwZWVkWSA9IDA7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aGlzLmtub2IuZHJhZ2dhYmxlLnNwZWVkWCA9IDA7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcy5zbGlkZXJPdmVybGF5LmNlbnRlcigpO1xuXHQgIH07XG5cdFxuXHQgIFNsaWRlckNvbXBvbmVudC5wcm90b3R5cGUuX3NldFJhZGl1cyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIHJhZGl1cztcblx0ICAgIHJhZGl1cyA9IHRoaXMuYm9yZGVyUmFkaXVzO1xuXHQgICAgcmV0dXJuIHRoaXMuZmlsbC5zdHlsZS5ib3JkZXJSYWRpdXMgPSByYWRpdXMgKyBcInB4IDAgMCBcIiArIHJhZGl1cyArIFwicHhcIjtcblx0ICB9O1xuXHRcblx0ICBTbGlkZXJDb21wb25lbnQuZGVmaW5lKFwia25vYlNpemVcIiwge1xuXHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX2tub2JTaXplO1xuXHQgICAgfSxcblx0ICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgdGhpcy5fa25vYlNpemUgPSB2YWx1ZTtcblx0ICAgICAgdGhpcy5rbm9iLndpZHRoID0gdGhpcy5fa25vYlNpemU7XG5cdCAgICAgIHRoaXMua25vYi5oZWlnaHQgPSB0aGlzLl9rbm9iU2l6ZTtcblx0ICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZUZyYW1lKCk7XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIFNsaWRlckNvbXBvbmVudC5kZWZpbmUoXCJoaXRBcmVhXCIsIHtcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9oaXRBcmVhO1xuXHQgICAgfSxcblx0ICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgdGhpcy5faGl0QXJlYSA9IHZhbHVlO1xuXHQgICAgICBpZiAodGhpcy53aWR0aCA+IHRoaXMuaGVpZ2h0KSB7XG5cdCAgICAgICAgdGhpcy5zbGlkZXJPdmVybGF5LndpZHRoID0gdGhpcy53aWR0aCArIHRoaXMuaGl0QXJlYTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5zbGlkZXJPdmVybGF5LmhlaWdodCA9IHRoaXMuaGl0QXJlYTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB0aGlzLnNsaWRlck92ZXJsYXkud2lkdGggPSB0aGlzLmhpdEFyZWE7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuc2xpZGVyT3ZlcmxheS5oZWlnaHQgPSB0aGlzLmhlaWdodCArIHRoaXMuaGl0QXJlYTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBTbGlkZXJDb21wb25lbnQuZGVmaW5lKFwibWluXCIsIHtcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9taW4gfHwgMDtcblx0ICAgIH0sXG5cdCAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9taW4gPSB2YWx1ZTtcblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgU2xpZGVyQ29tcG9uZW50LmRlZmluZShcIm1heFwiLCB7XG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fbWF4IHx8IDE7XG5cdCAgICB9LFxuXHQgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fbWF4ID0gdmFsdWU7XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIFNsaWRlckNvbXBvbmVudC5kZWZpbmUoXCJ2YWx1ZVwiLCB7XG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICBpZiAodGhpcy53aWR0aCA+IHRoaXMuaGVpZ2h0KSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVGb3JQb2ludCh0aGlzLmtub2IubWlkWCk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVGb3JQb2ludCh0aGlzLmtub2IubWlkWSk7XG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdCAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgIGlmICh0aGlzLndpZHRoID4gdGhpcy5oZWlnaHQpIHtcblx0ICAgICAgICB0aGlzLmtub2IubWlkWCA9IHRoaXMucG9pbnRGb3JWYWx1ZSh2YWx1ZSk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdGhpcy5rbm9iLm1pZFkgPSB0aGlzLnBvaW50Rm9yVmFsdWUodmFsdWUpO1xuXHQgICAgICB9XG5cdCAgICAgIHRoaXMuX3VwZGF0ZUZpbGwoKTtcblx0ICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZVZhbHVlKCk7XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIFNsaWRlckNvbXBvbmVudC5wcm90b3R5cGUuX3VwZGF0ZVZhbHVlID0gZnVuY3Rpb24oKSB7XG5cdCAgICBpZiAodGhpcy5fbGFzdFVwZGF0ZWRWYWx1ZSA9PT0gdGhpcy52YWx1ZSkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICB0aGlzLl9sYXN0VXBkYXRlZFZhbHVlID0gdGhpcy52YWx1ZTtcblx0ICAgIHRoaXMuZW1pdChcImNoYW5nZTp2YWx1ZVwiLCB0aGlzLnZhbHVlKTtcblx0ICAgIHJldHVybiB0aGlzLmVtaXQoRXZlbnRzLlNsaWRlclZhbHVlQ2hhbmdlLCB0aGlzLnZhbHVlKTtcblx0ICB9O1xuXHRcblx0ICBTbGlkZXJDb21wb25lbnQucHJvdG90eXBlLnBvaW50Rm9yVmFsdWUgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgaWYgKHRoaXMud2lkdGggPiB0aGlzLmhlaWdodCkge1xuXHQgICAgICBpZiAodGhpcy5rbm9iLmNvbnN0cmFpbmVkKSB7XG5cdCAgICAgICAgcmV0dXJuIFV0aWxzLm1vZHVsYXRlKHZhbHVlLCBbdGhpcy5taW4sIHRoaXMubWF4XSwgWzAgKyAodGhpcy5rbm9iLndpZHRoIC8gMiksIHRoaXMud2lkdGggLSAodGhpcy5rbm9iLndpZHRoIC8gMildLCB0cnVlKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gVXRpbHMubW9kdWxhdGUodmFsdWUsIFt0aGlzLm1pbiwgdGhpcy5tYXhdLCBbMCwgdGhpcy53aWR0aF0sIHRydWUpO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpZiAodGhpcy5rbm9iLmNvbnN0cmFpbmVkKSB7XG5cdCAgICAgICAgcmV0dXJuIFV0aWxzLm1vZHVsYXRlKHZhbHVlLCBbdGhpcy5taW4sIHRoaXMubWF4XSwgWzAgKyAodGhpcy5rbm9iLmhlaWdodCAvIDIpLCB0aGlzLmhlaWdodCAtICh0aGlzLmtub2IuaGVpZ2h0IC8gMildLCB0cnVlKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gVXRpbHMubW9kdWxhdGUodmFsdWUsIFt0aGlzLm1pbiwgdGhpcy5tYXhdLCBbMCwgdGhpcy5oZWlnaHRdLCB0cnVlKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cdFxuXHQgIFNsaWRlckNvbXBvbmVudC5wcm90b3R5cGUudmFsdWVGb3JQb2ludCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICBpZiAodGhpcy53aWR0aCA+IHRoaXMuaGVpZ2h0KSB7XG5cdCAgICAgIGlmICh0aGlzLmtub2IuY29uc3RyYWluZWQpIHtcblx0ICAgICAgICByZXR1cm4gVXRpbHMubW9kdWxhdGUodmFsdWUsIFswICsgKHRoaXMua25vYi53aWR0aCAvIDIpLCB0aGlzLndpZHRoIC0gKHRoaXMua25vYi53aWR0aCAvIDIpXSwgW3RoaXMubWluLCB0aGlzLm1heF0sIHRydWUpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiBVdGlscy5tb2R1bGF0ZSh2YWx1ZSwgWzAsIHRoaXMud2lkdGhdLCBbdGhpcy5taW4sIHRoaXMubWF4XSwgdHJ1ZSk7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlmICh0aGlzLmtub2IuY29uc3RyYWluZWQpIHtcblx0ICAgICAgICByZXR1cm4gVXRpbHMubW9kdWxhdGUodmFsdWUsIFswICsgKHRoaXMua25vYi5oZWlnaHQgLyAyKSwgdGhpcy5oZWlnaHQgLSAodGhpcy5rbm9iLmhlaWdodCAvIDIpXSwgW3RoaXMubWluLCB0aGlzLm1heF0sIHRydWUpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiBVdGlscy5tb2R1bGF0ZSh2YWx1ZSwgWzAsIHRoaXMuaGVpZ2h0XSwgW3RoaXMubWluLCB0aGlzLm1heF0sIHRydWUpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfTtcblx0XG5cdCAgU2xpZGVyQ29tcG9uZW50LnByb3RvdHlwZS5hbmltYXRlVG9WYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlLCBhbmltYXRpb25PcHRpb25zKSB7XG5cdCAgICBpZiAoYW5pbWF0aW9uT3B0aW9ucyA9PSBudWxsKSB7XG5cdCAgICAgIGFuaW1hdGlvbk9wdGlvbnMgPSB7XG5cdCAgICAgICAgY3VydmU6IFwic3ByaW5nKDMwMCwyNSwwKVwiXG5cdCAgICAgIH07XG5cdCAgICB9XG5cdCAgICBpZiAodGhpcy53aWR0aCA+IHRoaXMuaGVpZ2h0KSB7XG5cdCAgICAgIGFuaW1hdGlvbk9wdGlvbnMucHJvcGVydGllcyA9IHtcblx0ICAgICAgICB4OiB0aGlzLnBvaW50Rm9yVmFsdWUodmFsdWUpIC0gKHRoaXMua25vYi53aWR0aCAvIDIpXG5cdCAgICAgIH07XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBhbmltYXRpb25PcHRpb25zLnByb3BlcnRpZXMgPSB7XG5cdCAgICAgICAgeTogdGhpcy5wb2ludEZvclZhbHVlKHZhbHVlKSAtICh0aGlzLmtub2IuaGVpZ2h0IC8gMilcblx0ICAgICAgfTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0aGlzLmtub2IuYW5pbWF0ZShhbmltYXRpb25PcHRpb25zKTtcblx0ICB9O1xuXHRcblx0ICBTbGlkZXJDb21wb25lbnQucHJvdG90eXBlLm9uVmFsdWVDaGFuZ2UgPSBmdW5jdGlvbihjYikge1xuXHQgICAgcmV0dXJuIHRoaXMub24oRXZlbnRzLlNsaWRlclZhbHVlQ2hhbmdlLCBjYik7XG5cdCAgfTtcblx0XG5cdCAgcmV0dXJuIFNsaWRlckNvbXBvbmVudDtcblx0XG5cdH0pKExheWVyKTtcblxuXG4vKioqLyB9LFxuLyogNDYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBBcHBsZVdhdGNoMzhCbGFja0xlYXRoZXJEZXZpY2UsIEFwcGxlV2F0Y2gzOERldmljZSwgQXBwbGVXYXRjaDQyRGV2aWNlLCBCYXNlQ2xhc3MsIEJ1aWx0SW5EZXZpY2VzLCBEZWZhdWx0cywgRGV2aWNlcywgRXZlbnRzLCBIVENhOUJhc2VEZXZpY2UsIEhUQ204QmFzZURldmljZSwgTGF5ZXIsIE1TRlRMdW1pYTk1MEJhc2VEZXZpY2UsIE5leHVzNEJhc2VEZXZpY2UsIE5leHVzNUJhc2VEZXZpY2UsIE5leHVzNkJhc2VEZXZpY2UsIE5leHVzOUJhc2VEZXZpY2UsIFNhbXN1bmdHYWxheHlOb3RlNUJhc2VEZXZpY2UsIFV0aWxzLCBfLCBpUGFkQWlyMkJhc2VEZXZpY2UsIGlQYWRNaW5pNEJhc2VEZXZpY2UsIGlQYWRQcm9CYXNlRGV2aWNlLCBpUGhvbmU1QmFzZURldmljZSwgaVBob25lNUNCYXNlRGV2aWNlLCBpUGhvbmU2QmFzZURldmljZSwgaVBob25lNlBsdXNCYXNlRGV2aWNlLCBuZXdEZXZpY2VNaW5WZXJzaW9uLCBvbGREZXZpY2VNYXhWZXJzaW9uLCBvbGRfQXBwbGVXYXRjaDM4RGV2aWNlLCBvbGRfQXBwbGVXYXRjaDQyRGV2aWNlLCBvbGRfTmV4dXM1QmFzZURldmljZSwgb2xkX05leHVzNUJhc2VEZXZpY2VIYW5kLCBvbGRfTmV4dXM5QmFzZURldmljZSwgb2xkX2lQYWRBaXJCYXNlRGV2aWNlLCBvbGRfaVBhZEFpckJhc2VEZXZpY2VIYW5kLCBvbGRfaVBhZE1pbmlCYXNlRGV2aWNlLCBvbGRfaVBhZE1pbmlCYXNlRGV2aWNlSGFuZCwgb2xkX2lQaG9uZTVCYXNlRGV2aWNlLCBvbGRfaVBob25lNUJhc2VEZXZpY2VIYW5kLCBvbGRfaVBob25lNUNCYXNlRGV2aWNlLCBvbGRfaVBob25lNUNCYXNlRGV2aWNlSGFuZCwgb2xkX2lQaG9uZTZCYXNlRGV2aWNlLCBvbGRfaVBob25lNkJhc2VEZXZpY2VIYW5kLCBvbGRfaVBob25lNlBsdXNCYXNlRGV2aWNlLCBvbGRfaVBob25lNlBsdXNCYXNlRGV2aWNlSGFuZCxcblx0ICBiaW5kID0gZnVuY3Rpb24oZm4sIG1lKXsgcmV0dXJuIGZ1bmN0aW9uKCl7IHJldHVybiBmbi5hcHBseShtZSwgYXJndW1lbnRzKTsgfTsgfSxcblx0ICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG5cdCAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxuXHQgIGluZGV4T2YgPSBbXS5pbmRleE9mIHx8IGZ1bmN0aW9uKGl0ZW0pIHsgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykgeyBpZiAoaSBpbiB0aGlzICYmIHRoaXNbaV0gPT09IGl0ZW0pIHJldHVybiBpOyB9IHJldHVybiAtMTsgfTtcblx0XG5cdFV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0XG5cdF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpLl87XG5cdFxuXHRCYXNlQ2xhc3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpLkJhc2VDbGFzcztcblx0XG5cdExheWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMykuTGF5ZXI7XG5cdFxuXHREZWZhdWx0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpLkRlZmF1bHRzO1xuXHRcblx0RXZlbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSkuRXZlbnRzO1xuXHRcblx0XG5cdC8qXG5cdFxuXHREZXZpY2UuX3NldHVwKClcblx0RGV2aWNlLl91cGRhdGUoKVxuXHREZXZpY2UuX3NldHVwQ29udGV4dCgpXG5cdFxuXHREZXZpY2UuZnVsbFNjcmVlbiBib29sXG5cdERldmljZS5kZXZpY2VUeXBlIHN0clxuXHREZXZpY2UucGFkZGluZyBpbnRcblx0XG5cdERldmljZS5vcmllbnRhdGlvbihvcmllbnRhdGlvbjpmbG9hdClcblx0RGV2aWNlLm9yaWVudGF0aW9uTmFtZSBsYW5kc2NhcGV8cG9ydHJhaXR8dW5rbm93blxuXHREZXZpY2Uucm90YXRlTGVmdCgpXG5cdERldmljZS5yb3RhdGVSaWdodCgpXG5cdFxuXHREZXZpY2Uuc2V0RGV2aWNlU2NhbGUoem9vbTpmbG9hdCwgYW5pbWF0ZTpib29sKVxuXHREZXZpY2Uuc2V0Q29udGVudFNjYWxlKHpvb206ZmxvYXQsIGFuaW1hdGU6Ym9vbClcblx0XG5cdERldmljZS5uZXh0SGFuZCgpXG5cdFxuXHQgKiBFdmVudHNcblx0RXZlbnRzLkRldmljZVR5cGVEaWRDaGFuZ2Vcblx0RXZlbnRzLkRldmljZUZ1bGxTY3JlZW5EaWRDaGFuZ2Vcblx0ICovXG5cdFxuXHRleHBvcnRzLkRldmljZUNvbXBvbmVudCA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG5cdCAgZXh0ZW5kKERldmljZUNvbXBvbmVudCwgc3VwZXJDbGFzcyk7XG5cdFxuXHQgIERldmljZUNvbXBvbmVudC5kZWZpbmUoXCJjb250ZXh0XCIsIHtcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0O1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBmdW5jdGlvbiBEZXZpY2VDb21wb25lbnQob3B0aW9ucykge1xuXHQgICAgdmFyIGRlZmF1bHRzO1xuXHQgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuXHQgICAgICBvcHRpb25zID0ge307XG5cdCAgICB9XG5cdCAgICB0aGlzLl9vcmllbnRhdGlvbkNoYW5nZSA9IGJpbmQodGhpcy5fb3JpZW50YXRpb25DaGFuZ2UsIHRoaXMpO1xuXHQgICAgdGhpcy5fdXBkYXRlRGV2aWNlSW1hZ2UgPSBiaW5kKHRoaXMuX3VwZGF0ZURldmljZUltYWdlLCB0aGlzKTtcblx0ICAgIHRoaXMuX3VwZGF0ZSA9IGJpbmQodGhpcy5fdXBkYXRlLCB0aGlzKTtcblx0ICAgIGRlZmF1bHRzID0gRGVmYXVsdHMuZ2V0RGVmYXVsdHMoXCJEZXZpY2VDb21wb25lbnRcIiwgb3B0aW9ucyk7XG5cdCAgICBpZiAoRnJhbWVyLkRlZmF1bHRzLmhhc093blByb3BlcnR5KFwiRGV2aWNlVmlld1wiKSkge1xuXHQgICAgICBkZWZhdWx0cyA9IF8uZXh0ZW5kKGRlZmF1bHRzLCBGcmFtZXIuRGVmYXVsdHMuRGV2aWNlVmlldyk7XG5cdCAgICB9XG5cdCAgICB0aGlzLl9zZXR1cCgpO1xuXHQgICAgdGhpcy5hbmltYXRpb25PcHRpb25zID0gZGVmYXVsdHMuYW5pbWF0aW9uT3B0aW9ucztcblx0ICAgIHRoaXMuZGV2aWNlVHlwZSA9IGRlZmF1bHRzLmRldmljZVR5cGU7XG5cdCAgICBfLmV4dGVuZCh0aGlzLCBfLmRlZmF1bHRzKG9wdGlvbnMsIGRlZmF1bHRzKSk7XG5cdCAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9yaWVudGF0aW9uY2hhbmdlXCIsIHRoaXMuX29yaWVudGF0aW9uQ2hhbmdlLCB0cnVlKTtcblx0ICB9XG5cdFxuXHQgIERldmljZUNvbXBvbmVudC5wcm90b3R5cGUuX3NldHVwID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgaSwgbGF5ZXIsIGxlbiwgcmVmO1xuXHQgICAgaWYgKHRoaXMuX3NldHVwRG9uZSkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICB0aGlzLl9zZXR1cERvbmUgPSB0cnVlO1xuXHQgICAgdGhpcy5iYWNrZ3JvdW5kID0gbmV3IExheWVyO1xuXHQgICAgdGhpcy5iYWNrZ3JvdW5kLmNsaXAgPSB0cnVlO1xuXHQgICAgdGhpcy5iYWNrZ3JvdW5kLmJhY2tncm91bmRDb2xvciA9IFwidHJhbnNwYXJlbnRcIjtcblx0ICAgIHRoaXMuYmFja2dyb3VuZC5jbGFzc0xpc3QuYWRkKFwiRGV2aWNlQmFja2dyb3VuZFwiKTtcblx0ICAgIHRoaXMuaGFuZHMgPSBuZXcgTGF5ZXI7XG5cdCAgICB0aGlzLmhhbmRzSW1hZ2VMYXllciA9IG5ldyBMYXllcih7XG5cdCAgICAgIHBhcmVudDogdGhpcy5oYW5kc1xuXHQgICAgfSk7XG5cdCAgICB0aGlzLnBob25lID0gbmV3IExheWVyKHtcblx0ICAgICAgcGFyZW50OiB0aGlzLmhhbmRzXG5cdCAgICB9KTtcblx0ICAgIHRoaXMuc2NyZWVuID0gbmV3IExheWVyKHtcblx0ICAgICAgcGFyZW50OiB0aGlzLnBob25lXG5cdCAgICB9KTtcblx0ICAgIHRoaXMudmlld3BvcnQgPSBuZXcgTGF5ZXIoe1xuXHQgICAgICBwYXJlbnQ6IHRoaXMuc2NyZWVuXG5cdCAgICB9KTtcblx0ICAgIHRoaXMuY29udGVudCA9IG5ldyBMYXllcih7XG5cdCAgICAgIHBhcmVudDogdGhpcy52aWV3cG9ydFxuXHQgICAgfSk7XG5cdCAgICB0aGlzLmhhbmRzLmJhY2tncm91bmRDb2xvciA9IFwidHJhbnNwYXJlbnRcIjtcblx0ICAgIHRoaXMuaGFuZHMuX2Fsd2F5c1VzZUltYWdlQ2FjaGUgPSB0cnVlO1xuXHQgICAgdGhpcy5oYW5kc0ltYWdlTGF5ZXIuYmFja2dyb3VuZENvbG9yID0gXCJ0cmFuc3BhcmVudFwiO1xuXHQgICAgdGhpcy5waG9uZS5iYWNrZ3JvdW5kQ29sb3IgPSBcInRyYW5zcGFyZW50XCI7XG5cdCAgICB0aGlzLnBob25lLmNsYXNzTGlzdC5hZGQoXCJEZXZpY2VQaG9uZVwiKTtcblx0ICAgIHRoaXMuc2NyZWVuLmNsYXNzTGlzdC5hZGQoXCJEZXZpY2VTY3JlZW5cIik7XG5cdCAgICB0aGlzLnNjcmVlbi5jbGlwID0gdHJ1ZTtcblx0ICAgIHRoaXMudmlld3BvcnQuYmFja2dyb3VuZENvbG9yID0gXCJ0cmFuc3BhcmVudFwiO1xuXHQgICAgdGhpcy52aWV3cG9ydC5jbGFzc0xpc3QuYWRkKFwiRGV2aWNlQ29tcG9uZW50UG9ydFwiKTtcblx0ICAgIHRoaXMuY29udGVudC5iYWNrZ3JvdW5kQ29sb3IgPSBcInRyYW5zcGFyZW50XCI7XG5cdCAgICB0aGlzLmNvbnRlbnQuY2xhc3NMaXN0LmFkZChcIkRldmljZUNvbnRlbnRcIik7XG5cdCAgICB0aGlzLmNvbnRlbnQub3JpZ2luWCA9IDA7XG5cdCAgICB0aGlzLmNvbnRlbnQub3JpZ2luWSA9IDA7XG5cdCAgICBpZiAoIVV0aWxzLmlzTW9iaWxlKCkpIHtcblx0ICAgICAgRnJhbWVyLkN1cnJlbnRDb250ZXh0LmRvbUV2ZW50TWFuYWdlci53cmFwKHdpbmRvdykuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLl91cGRhdGUpO1xuXHQgICAgfVxuXHQgICAgcmVmID0gW3RoaXMuYmFja2dyb3VuZCwgdGhpcy5waG9uZSwgdGhpcy52aWV3cG9ydCwgdGhpcy5jb250ZW50LCB0aGlzLnNjcmVlbl07XG5cdCAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0ICAgICAgbGF5ZXIgPSByZWZbaV07XG5cdCAgICAgIGxheWVyLm9uKFwidG91Y2htb3ZlXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdCAgICAgICAgcmV0dXJuIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgdGhpcy5fY29udGV4dCA9IG5ldyBGcmFtZXIuQ29udGV4dCh7XG5cdCAgICAgIHBhcmVudDogdGhpcy5jb250ZW50LFxuXHQgICAgICBuYW1lOiBcIkRldmljZVwiXG5cdCAgICB9KTtcblx0ICAgIHJldHVybiB0aGlzLl9jb250ZXh0LnBlcnNwZWN0aXZlID0gMTIwMDtcblx0ICB9O1xuXHRcblx0ICBEZXZpY2VDb21wb25lbnQucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciBiYWNrZ3JvdW5kT3ZlcmxhcCwgY29udGVudFNjYWxlRmFjdG9yLCBoZWlnaHQsIGksIGxheWVyLCBsZW4sIHJlZiwgcmVmMSwgd2lkdGg7XG5cdCAgICBjb250ZW50U2NhbGVGYWN0b3IgPSB0aGlzLmNvbnRlbnRTY2FsZTtcblx0ICAgIGlmIChjb250ZW50U2NhbGVGYWN0b3IgPiAxKSB7XG5cdCAgICAgIGNvbnRlbnRTY2FsZUZhY3RvciA9IDE7XG5cdCAgICB9XG5cdCAgICBpZiAodGhpcy5fc2hvdWxkUmVuZGVyRnVsbFNjcmVlbigpKSB7XG5cdCAgICAgIHJlZiA9IFt0aGlzLmJhY2tncm91bmQsIHRoaXMuaGFuZHMsIHRoaXMucGhvbmUsIHRoaXMudmlld3BvcnQsIHRoaXMuY29udGVudCwgdGhpcy5zY3JlZW5dO1xuXHQgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0ICAgICAgICBsYXllciA9IHJlZltpXTtcblx0ICAgICAgICBsYXllci54ID0gbGF5ZXIueSA9IDA7XG5cdCAgICAgICAgbGF5ZXIud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCAvIGNvbnRlbnRTY2FsZUZhY3Rvcjtcblx0ICAgICAgICBsYXllci5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLyBjb250ZW50U2NhbGVGYWN0b3I7XG5cdCAgICAgICAgbGF5ZXIuc2NhbGUgPSAxO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQuc2NhbGUgPSBjb250ZW50U2NhbGVGYWN0b3I7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBiYWNrZ3JvdW5kT3ZlcmxhcCA9IDEwMDtcblx0ICAgICAgdGhpcy5iYWNrZ3JvdW5kLnggPSAwIC0gYmFja2dyb3VuZE92ZXJsYXA7XG5cdCAgICAgIHRoaXMuYmFja2dyb3VuZC55ID0gMCAtIGJhY2tncm91bmRPdmVybGFwO1xuXHQgICAgICB0aGlzLmJhY2tncm91bmQud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCArICgyICogYmFja2dyb3VuZE92ZXJsYXApO1xuXHQgICAgICB0aGlzLmJhY2tncm91bmQuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0ICsgKDIgKiBiYWNrZ3JvdW5kT3ZlcmxhcCk7XG5cdCAgICAgIHRoaXMuaGFuZHMuc2NhbGUgPSB0aGlzLl9jYWxjdWxhdGVQaG9uZVNjYWxlKCk7XG5cdCAgICAgIHRoaXMuaGFuZHMuY2VudGVyKCk7XG5cdCAgICAgIHRoaXMucGhvbmUuY2VudGVyKCk7XG5cdCAgICAgIHJlZjEgPSB0aGlzLl9nZXRPcmllbnRhdGlvbkRpbWVuc2lvbnModGhpcy5fZGV2aWNlLnNjcmVlbldpZHRoIC8gY29udGVudFNjYWxlRmFjdG9yLCB0aGlzLl9kZXZpY2Uuc2NyZWVuSGVpZ2h0IC8gY29udGVudFNjYWxlRmFjdG9yKSwgd2lkdGggPSByZWYxWzBdLCBoZWlnaHQgPSByZWYxWzFdO1xuXHQgICAgICB0aGlzLnNjcmVlbi53aWR0aCA9IHRoaXMudmlld3BvcnQud2lkdGggPSB0aGlzLl9kZXZpY2Uuc2NyZWVuV2lkdGg7XG5cdCAgICAgIHRoaXMuc2NyZWVuLmhlaWdodCA9IHRoaXMudmlld3BvcnQuaGVpZ2h0ID0gdGhpcy5fZGV2aWNlLnNjcmVlbkhlaWdodDtcblx0ICAgICAgdGhpcy5jb250ZW50LndpZHRoID0gd2lkdGg7XG5cdCAgICAgIHRoaXMuY29udGVudC5oZWlnaHQgPSBoZWlnaHQ7XG5cdCAgICAgIHRoaXMuc2NyZWVuLmNlbnRlcigpO1xuXHQgICAgICBpZiAodGhpcy5zZWxlY3RlZEhhbmQgJiYgdGhpcy5fb3JpZW50YXRpb24gPT09IDApIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5zZXRIYW5kKHRoaXMuc2VsZWN0ZWRIYW5kKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cdFxuXHQgIERldmljZUNvbXBvbmVudC5wcm90b3R5cGUuX3Nob3VsZFJlbmRlckZ1bGxTY3JlZW4gPSBmdW5jdGlvbigpIHtcblx0ICAgIGlmICghdGhpcy5fZGV2aWNlKSB7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXHQgICAgaWYgKHRoaXMuZnVsbFNjcmVlbiA9PT0gdHJ1ZSkge1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIGlmICh0aGlzLmRldmljZVR5cGUgPT09IFwiZnVsbHNjcmVlblwiKSB7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXHQgICAgaWYgKFV0aWxzLmRldmljZVR5cGUoKSA9PT0gXCJwaG9uZVwiICYmIFV0aWxzLmRldmljZVR5cGUoKSA9PT0gdGhpcy5fZGV2aWNlLmRldmljZVR5cGUpIHtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdCAgICBpZiAoVXRpbHMuZGV2aWNlVHlwZSgpID09PSBcInRhYmxldFwiICYmIFV0aWxzLmRldmljZVR5cGUoKSA9PT0gdGhpcy5fZGV2aWNlLmRldmljZVR5cGUpIHtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdCAgICBpZiAoVXRpbHMuZGV2aWNlVHlwZSgpID09PSBcInBob25lXCIgJiYgdGhpcy5fZGV2aWNlLmRldmljZVR5cGUgPT09IFwidGFibGV0XCIpIHtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfTtcblx0XG5cdCAgRGV2aWNlQ29tcG9uZW50LnByb3RvdHlwZS5zZXR1cENvbnRleHQgPSBmdW5jdGlvbigpIHtcblx0ICAgIHJldHVybiBGcmFtZXIuQ3VycmVudENvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xuXHQgIH07XG5cdFxuXHQgIERldmljZUNvbXBvbmVudC5kZWZpbmUoXCJmdWxsU2NyZWVuXCIsIHtcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9mdWxsU2NyZWVuO1xuXHQgICAgfSxcblx0ICAgIHNldDogZnVuY3Rpb24oZnVsbFNjcmVlbikge1xuXHQgICAgICByZXR1cm4gdGhpcy5fc2V0RnVsbFNjcmVlbihmdWxsU2NyZWVuKTtcblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgRGV2aWNlQ29tcG9uZW50LnByb3RvdHlwZS5fc2V0RnVsbFNjcmVlbiA9IGZ1bmN0aW9uKGZ1bGxTY3JlZW4pIHtcblx0ICAgIGlmICh0aGlzLl9kZXZpY2VUeXBlID09PSBcImZ1bGxzY3JlZW5cIikge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICBpZiAoIV8uaXNCb29sZWFuKGZ1bGxTY3JlZW4pKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIGlmIChmdWxsU2NyZWVuID09PSB0aGlzLl9mdWxsU2NyZWVuKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHRoaXMuX2Z1bGxTY3JlZW4gPSBmdWxsU2NyZWVuO1xuXHQgICAgaWYgKGZ1bGxTY3JlZW4gPT09IHRydWUpIHtcblx0ICAgICAgdGhpcy5waG9uZS5pbWFnZSA9IFwiXCI7XG5cdCAgICAgIHRoaXMuaGFuZHMuaW1hZ2UgPSBcIlwiO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdGhpcy5fdXBkYXRlRGV2aWNlSW1hZ2UoKTtcblx0ICAgIH1cblx0ICAgIHRoaXMuX3VwZGF0ZSgpO1xuXHQgICAgcmV0dXJuIHRoaXMuZW1pdChcImNoYW5nZTpmdWxsU2NyZWVuXCIpO1xuXHQgIH07XG5cdFxuXHQgIERldmljZUNvbXBvbmVudC5kZWZpbmUoXCJkZXZpY2VUeXBlXCIsIHtcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9kZXZpY2VUeXBlO1xuXHQgICAgfSxcblx0ICAgIHNldDogZnVuY3Rpb24oZGV2aWNlVHlwZSkge1xuXHQgICAgICB2YXIgZGV2aWNlLCBpLCBrZXksIGxEZXZpY2V0eXBlLCBsS2V5LCBsZW4sIHJlZiwgc2hvdWxkWm9vbVRvRml0O1xuXHQgICAgICBpZiAoZGV2aWNlVHlwZSA9PT0gdGhpcy5fZGV2aWNlVHlwZSkge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHQgICAgICBkZXZpY2UgPSBudWxsO1xuXHQgICAgICBpZiAoXy5pc1N0cmluZyhkZXZpY2VUeXBlKSkge1xuXHQgICAgICAgIGxEZXZpY2V0eXBlID0gZGV2aWNlVHlwZS50b0xvd2VyQ2FzZSgpO1xuXHQgICAgICAgIHJlZiA9IF8ua2V5cyhEZXZpY2VzKTtcblx0ICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0ICAgICAgICAgIGtleSA9IHJlZltpXTtcblx0ICAgICAgICAgIGxLZXkgPSBrZXkudG9Mb3dlckNhc2UoKTtcblx0ICAgICAgICAgIGlmIChsRGV2aWNldHlwZSA9PT0gbEtleSkge1xuXHQgICAgICAgICAgICBkZXZpY2UgPSBEZXZpY2VzW2tleV07XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIGlmICghZGV2aWNlKSB7XG5cdCAgICAgICAgdGhyb3cgRXJyb3IoXCJObyBkZXZpY2UgbmFtZWQgXCIgKyBkZXZpY2VUeXBlICsgXCIuIE9wdGlvbnMgYXJlOiBcIiArIChfLmtleXMoRGV2aWNlcykpKTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAodGhpcy5fZGV2aWNlID09PSBkZXZpY2UpIHtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblx0ICAgICAgc2hvdWxkWm9vbVRvRml0ID0gdGhpcy5fZGV2aWNlVHlwZSA9PT0gXCJmdWxsc2NyZWVuXCI7XG5cdCAgICAgIHRoaXMuc2NyZWVuLmJhY2tncm91bmRDb2xvciA9IFwiYmxhY2tcIjtcblx0ICAgICAgaWYgKGRldmljZS5iYWNrZ3JvdW5kQ29sb3IgIT0gbnVsbCkge1xuXHQgICAgICAgIHRoaXMuc2NyZWVuLmJhY2tncm91bmRDb2xvciA9IGRldmljZS5iYWNrZ3JvdW5kQ29sb3I7XG5cdCAgICAgIH1cblx0ICAgICAgdGhpcy5fZGV2aWNlID0gXy5jbG9uZShkZXZpY2UpO1xuXHQgICAgICB0aGlzLl9kZXZpY2VUeXBlID0gZGV2aWNlVHlwZTtcblx0ICAgICAgdGhpcy5mdWxsc2NyZWVuID0gZmFsc2U7XG5cdCAgICAgIHRoaXMuX3VwZGF0ZURldmljZUltYWdlKCk7XG5cdCAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuXHQgICAgICB0aGlzLmVtaXQoXCJjaGFuZ2U6ZGV2aWNlVHlwZVwiKTtcblx0ICAgICAgaWYgKHNob3VsZFpvb21Ub0ZpdCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmRldmljZVNjYWxlID0gXCJmaXRcIjtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBEZXZpY2VDb21wb25lbnQucHJvdG90eXBlLl91cGRhdGVEZXZpY2VJbWFnZSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgaWYgKC9QaGFudG9tSlMvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgaWYgKHRoaXMuX3Nob3VsZFJlbmRlckZ1bGxTY3JlZW4oKSkge1xuXHQgICAgICB0aGlzLnBob25lLmltYWdlID0gXCJcIjtcblx0ICAgICAgcmV0dXJuIHRoaXMuaGFuZHMuaW1hZ2UgPSBcIlwiO1xuXHQgICAgfSBlbHNlIGlmICghdGhpcy5fZGV2aWNlSW1hZ2VVcmwodGhpcy5fZGV2aWNlSW1hZ2VOYW1lKCkpKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLnBob25lLmltYWdlID0gXCJcIjtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRoaXMucGhvbmUuX2Fsd2F5c1VzZUltYWdlQ2FjaGUgPSB0cnVlO1xuXHQgICAgICB0aGlzLnBob25lLmltYWdlID0gdGhpcy5fZGV2aWNlSW1hZ2VVcmwodGhpcy5fZGV2aWNlSW1hZ2VOYW1lKCkpO1xuXHQgICAgICB0aGlzLnBob25lLndpZHRoID0gdGhpcy5fZGV2aWNlLmRldmljZUltYWdlV2lkdGg7XG5cdCAgICAgIHRoaXMucGhvbmUuaGVpZ2h0ID0gdGhpcy5fZGV2aWNlLmRldmljZUltYWdlSGVpZ2h0O1xuXHQgICAgICB0aGlzLmhhbmRzLndpZHRoID0gdGhpcy5waG9uZS53aWR0aDtcblx0ICAgICAgcmV0dXJuIHRoaXMuaGFuZHMuaGVpZ2h0ID0gdGhpcy5waG9uZS5oZWlnaHQ7XG5cdCAgICB9XG5cdCAgfTtcblx0XG5cdCAgRGV2aWNlQ29tcG9uZW50LnByb3RvdHlwZS5fZGV2aWNlSW1hZ2VOYW1lID0gZnVuY3Rpb24oKSB7XG5cdCAgICBpZiAodGhpcy5fZGV2aWNlLmhhc093blByb3BlcnR5KFwiZGV2aWNlSW1hZ2VcIikpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX2RldmljZS5kZXZpY2VJbWFnZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0aGlzLl9kZXZpY2VUeXBlICsgXCIucG5nXCI7XG5cdCAgfTtcblx0XG5cdCAgRGV2aWNlQ29tcG9uZW50LnByb3RvdHlwZS5fZGV2aWNlSW1hZ2VVcmwgPSBmdW5jdGlvbihuYW1lKSB7XG5cdCAgICB2YXIgcmVmLCByZXNvdXJjZVVybDtcblx0ICAgIGlmICghbmFtZSkge1xuXHQgICAgICByZXR1cm4gbnVsbDtcblx0ICAgIH1cblx0ICAgIGlmIChfLnN0YXJ0c1dpdGgobmFtZSwgXCJodHRwOi8vXCIpIHx8IF8uc3RhcnRzV2l0aChuYW1lLCBcImh0dHBzOi8vXCIpKSB7XG5cdCAgICAgIHJldHVybiBuYW1lO1xuXHQgICAgfVxuXHQgICAgaWYgKHJlZiA9IHRoaXMuX2RldmljZVR5cGUsIGluZGV4T2YuY2FsbChCdWlsdEluRGV2aWNlcywgcmVmKSA8IDApIHtcblx0ICAgICAgcmV0dXJuIG5hbWU7XG5cdCAgICB9XG5cdCAgICByZXNvdXJjZVVybCA9IFwiLy9yZXNvdXJjZXMuZnJhbWVyanMuY29tL3N0YXRpYy9EZXZpY2VSZXNvdXJjZXNcIjtcblx0ICAgIGlmIChVdGlscy5pc0ZyYW1lclN0dWRpbygpICYmIHdpbmRvdy5GcmFtZXJTdHVkaW9JbmZvKSB7XG5cdCAgICAgIGlmICh0aGlzLl9kZXZpY2UubWluU3R1ZGlvVmVyc2lvbiAmJiBVdGlscy5mcmFtZXJTdHVkaW9WZXJzaW9uKCkgPj0gdGhpcy5fZGV2aWNlLm1pblN0dWRpb1ZlcnNpb24gfHwgIXRoaXMuX2RldmljZS5taW5TdHVkaW9WZXJzaW9uKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX2RldmljZS5tYXhTdHVkaW9WZXJzaW9uICYmIFV0aWxzLmZyYW1lclN0dWRpb1ZlcnNpb24oKSA8PSB0aGlzLl9kZXZpY2UubWF4U3R1ZGlvVmVyc2lvbiB8fCAhdGhpcy5fZGV2aWNlLm1heFN0dWRpb1ZlcnNpb24pIHtcblx0ICAgICAgICAgIHJlc291cmNlVXJsID0gd2luZG93LkZyYW1lclN0dWRpb0luZm8uZGV2aWNlSW1hZ2VzVXJsO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKFV0aWxzLmlzSlAyU3VwcG9ydGVkKCkgJiYgdGhpcy5fZGV2aWNlLmRldmljZUltYWdlSlAyID09PSB0cnVlKSB7XG5cdCAgICAgIHJldHVybiByZXNvdXJjZVVybCArIFwiL1wiICsgKG5hbWUucmVwbGFjZShcIi5wbmdcIiwgXCIuanAyXCIpKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXNvdXJjZVVybCArIFwiL1wiICsgbmFtZTtcblx0ICB9O1xuXHRcblx0ICBEZXZpY2VDb21wb25lbnQuZGVmaW5lKFwiZGV2aWNlU2NhbGVcIiwge1xuXHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgaWYgKHRoaXMuX3Nob3VsZFJlbmRlckZ1bGxTY3JlZW4oKSkge1xuXHQgICAgICAgIHJldHVybiAxO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiB0aGlzLl9kZXZpY2VTY2FsZSB8fCAxO1xuXHQgICAgfSxcblx0ICAgIHNldDogZnVuY3Rpb24oZGV2aWNlU2NhbGUpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuc2V0RGV2aWNlU2NhbGUoZGV2aWNlU2NhbGUsIGZhbHNlKTtcblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgRGV2aWNlQ29tcG9uZW50LnByb3RvdHlwZS5zZXREZXZpY2VTY2FsZSA9IGZ1bmN0aW9uKGRldmljZVNjYWxlLCBhbmltYXRlKSB7XG5cdCAgICB2YXIgcGhvbmVTY2FsZTtcblx0ICAgIGlmIChhbmltYXRlID09IG51bGwpIHtcblx0ICAgICAgYW5pbWF0ZSA9IGZhbHNlO1xuXHQgICAgfVxuXHQgICAgaWYgKGRldmljZVNjYWxlID09PSBcImZpdFwiIHx8IGRldmljZVNjYWxlIDwgMCkge1xuXHQgICAgICBkZXZpY2VTY2FsZSA9IFwiZml0XCI7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBkZXZpY2VTY2FsZSA9IHBhcnNlRmxvYXQoZGV2aWNlU2NhbGUpO1xuXHQgICAgfVxuXHQgICAgaWYgKGRldmljZVNjYWxlID09PSB0aGlzLl9kZXZpY2VTY2FsZSkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICB0aGlzLl9kZXZpY2VTY2FsZSA9IGRldmljZVNjYWxlO1xuXHQgICAgaWYgKHRoaXMuX3Nob3VsZFJlbmRlckZ1bGxTY3JlZW4oKSkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICBpZiAoZGV2aWNlU2NhbGUgPT09IFwiZml0XCIpIHtcblx0ICAgICAgcGhvbmVTY2FsZSA9IHRoaXMuX2NhbGN1bGF0ZVBob25lU2NhbGUoKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHBob25lU2NhbGUgPSBkZXZpY2VTY2FsZTtcblx0ICAgIH1cblx0ICAgIHRoaXMuaGFuZHMuYW5pbWF0ZVN0b3AoKTtcblx0ICAgIGlmIChhbmltYXRlKSB7XG5cdCAgICAgIHRoaXMuaGFuZHMuYW5pbWF0ZShfLmV4dGVuZCh0aGlzLmFuaW1hdGlvbk9wdGlvbnMsIHtcblx0ICAgICAgICBwcm9wZXJ0aWVzOiB7XG5cdCAgICAgICAgICBzY2FsZTogcGhvbmVTY2FsZVxuXHQgICAgICAgIH1cblx0ICAgICAgfSkpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdGhpcy5oYW5kcy5zY2FsZSA9IHBob25lU2NhbGU7XG5cdCAgICAgIHRoaXMuaGFuZHMuY2VudGVyKCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcy5lbWl0KFwiY2hhbmdlOmRldmljZVNjYWxlXCIpO1xuXHQgIH07XG5cdFxuXHQgIERldmljZUNvbXBvbmVudC5wcm90b3R5cGUuX2NhbGN1bGF0ZVBob25lU2NhbGUgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciBoZWlnaHQsIHBhZGRpbmdPZmZzZXQsIHBob25lU2NhbGUsIHJlZiwgcmVmMSwgd2lkdGg7XG5cdCAgICByZWYgPSB0aGlzLl9nZXRPcmllbnRhdGlvbkRpbWVuc2lvbnModGhpcy5waG9uZS53aWR0aCwgdGhpcy5waG9uZS5oZWlnaHQpLCB3aWR0aCA9IHJlZlswXSwgaGVpZ2h0ID0gcmVmWzFdO1xuXHQgICAgcGFkZGluZ09mZnNldCA9ICgocmVmMSA9IHRoaXMuX2RldmljZSkgIT0gbnVsbCA/IHJlZjEucGFkZGluZ09mZnNldCA6IHZvaWQgMCkgfHwgMDtcblx0ICAgIHBob25lU2NhbGUgPSBfLm1pbihbKHdpbmRvdy5pbm5lcldpZHRoIC0gKCh0aGlzLnBhZGRpbmcgKyBwYWRkaW5nT2Zmc2V0KSAqIDIpKSAvIHdpZHRoLCAod2luZG93LmlubmVySGVpZ2h0IC0gKCh0aGlzLnBhZGRpbmcgKyBwYWRkaW5nT2Zmc2V0KSAqIDIpKSAvIGhlaWdodF0pO1xuXHQgICAgaWYgKHBob25lU2NhbGUgPiAxKSB7XG5cdCAgICAgIHBob25lU2NhbGUgPSAxO1xuXHQgICAgfVxuXHQgICAgdGhpcy5lbWl0KFwiY2hhbmdlOnBob25lU2NhbGVcIiwgcGhvbmVTY2FsZSk7XG5cdCAgICBpZiAodGhpcy5fZGV2aWNlU2NhbGUgJiYgdGhpcy5fZGV2aWNlU2NhbGUgIT09IFwiZml0XCIpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX2RldmljZVNjYWxlO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHBob25lU2NhbGU7XG5cdCAgfTtcblx0XG5cdCAgRGV2aWNlQ29tcG9uZW50LmRlZmluZShcImNvbnRlbnRTY2FsZVwiLCB7XG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fY29udGVudFNjYWxlIHx8IDE7XG5cdCAgICB9LFxuXHQgICAgc2V0OiBmdW5jdGlvbihjb250ZW50U2NhbGUpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuc2V0Q29udGVudFNjYWxlKGNvbnRlbnRTY2FsZSwgZmFsc2UpO1xuXHQgICAgfVxuXHQgIH0pO1xuXHRcblx0ICBEZXZpY2VDb21wb25lbnQucHJvdG90eXBlLnNldENvbnRlbnRTY2FsZSA9IGZ1bmN0aW9uKGNvbnRlbnRTY2FsZSwgYW5pbWF0ZSkge1xuXHQgICAgaWYgKGFuaW1hdGUgPT0gbnVsbCkge1xuXHQgICAgICBhbmltYXRlID0gZmFsc2U7XG5cdCAgICB9XG5cdCAgICBjb250ZW50U2NhbGUgPSBwYXJzZUZsb2F0KGNvbnRlbnRTY2FsZSk7XG5cdCAgICBpZiAoY29udGVudFNjYWxlIDw9IDApIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgaWYgKGNvbnRlbnRTY2FsZSA9PT0gdGhpcy5fY29udGVudFNjYWxlKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHRoaXMuX2NvbnRlbnRTY2FsZSA9IGNvbnRlbnRTY2FsZTtcblx0ICAgIGlmIChhbmltYXRlKSB7XG5cdCAgICAgIHRoaXMuY29udGVudC5hbmltYXRlKF8uZXh0ZW5kKHRoaXMuYW5pbWF0aW9uT3B0aW9ucywge1xuXHQgICAgICAgIHByb3BlcnRpZXM6IHtcblx0ICAgICAgICAgIHNjYWxlOiB0aGlzLl9jb250ZW50U2NhbGVcblx0ICAgICAgICB9XG5cdCAgICAgIH0pKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRoaXMuY29udGVudC5zY2FsZSA9IHRoaXMuX2NvbnRlbnRTY2FsZTtcblx0ICAgIH1cblx0ICAgIHRoaXMuX3VwZGF0ZSgpO1xuXHQgICAgcmV0dXJuIHRoaXMuZW1pdChcImNoYW5nZTpjb250ZW50U2NhbGVcIik7XG5cdCAgfTtcblx0XG5cdCAgRGV2aWNlQ29tcG9uZW50LmRlZmluZShcIm9yaWVudGF0aW9uXCIsIHtcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIGlmIChVdGlscy5pc01vYmlsZSgpKSB7XG5cdCAgICAgICAgcmV0dXJuIHdpbmRvdy5vcmllbnRhdGlvbjtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gdGhpcy5fb3JpZW50YXRpb24gfHwgMDtcblx0ICAgIH0sXG5cdCAgICBzZXQ6IGZ1bmN0aW9uKG9yaWVudGF0aW9uKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLnNldE9yaWVudGF0aW9uKG9yaWVudGF0aW9uLCBmYWxzZSk7XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIERldmljZUNvbXBvbmVudC5wcm90b3R5cGUuc2V0T3JpZW50YXRpb24gPSBmdW5jdGlvbihvcmllbnRhdGlvbiwgYW5pbWF0ZSkge1xuXHQgICAgdmFyIGFuaW1hdGlvbiwgY29udGVudFByb3BlcnRpZXMsIGhlaWdodCwgb2Zmc2V0LCBwaG9uZVByb3BlcnRpZXMsIHJlZiwgcmVmMSwgd2lkdGgsIHgsIHk7XG5cdCAgICBpZiAoYW5pbWF0ZSA9PSBudWxsKSB7XG5cdCAgICAgIGFuaW1hdGUgPSBmYWxzZTtcblx0ICAgIH1cblx0ICAgIGlmIChVdGlscy5mcmFtZXJTdHVkaW9WZXJzaW9uKCkgPT09IG9sZERldmljZU1heFZlcnNpb24pIHtcblx0ICAgICAgb3JpZW50YXRpb24gKj0gLTE7XG5cdCAgICB9XG5cdCAgICBpZiAob3JpZW50YXRpb24gPT09IFwicG9ydHJhaXRcIikge1xuXHQgICAgICBvcmllbnRhdGlvbiA9IDA7XG5cdCAgICB9XG5cdCAgICBpZiAob3JpZW50YXRpb24gPT09IFwibGFuZHNjYXBlXCIpIHtcblx0ICAgICAgb3JpZW50YXRpb24gPSA5MDtcblx0ICAgIH1cblx0ICAgIGlmICh0aGlzLl9zaG91bGRSZW5kZXJGdWxsU2NyZWVuKCkpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgb3JpZW50YXRpb24gPSBwYXJzZUludChvcmllbnRhdGlvbik7XG5cdCAgICBpZiAob3JpZW50YXRpb24gIT09IDAgJiYgb3JpZW50YXRpb24gIT09IDkwICYmIG9yaWVudGF0aW9uICE9PSAoLTkwKSkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICBpZiAob3JpZW50YXRpb24gPT09IHRoaXMuX29yaWVudGF0aW9uKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHRoaXMuX29yaWVudGF0aW9uID0gb3JpZW50YXRpb247XG5cdCAgICBwaG9uZVByb3BlcnRpZXMgPSB7XG5cdCAgICAgIHJvdGF0aW9uWjogLXRoaXMuX29yaWVudGF0aW9uLFxuXHQgICAgICBzY2FsZTogdGhpcy5fY2FsY3VsYXRlUGhvbmVTY2FsZSgpXG5cdCAgICB9O1xuXHQgICAgcmVmID0gdGhpcy5fZ2V0T3JpZW50YXRpb25EaW1lbnNpb25zKHRoaXMuX2RldmljZS5zY3JlZW5XaWR0aCwgdGhpcy5fZGV2aWNlLnNjcmVlbkhlaWdodCksIHdpZHRoID0gcmVmWzBdLCBoZWlnaHQgPSByZWZbMV07XG5cdCAgICB0aGlzLmNvbnRlbnQud2lkdGggPSB3aWR0aDtcblx0ICAgIHRoaXMuY29udGVudC5oZWlnaHQgPSBoZWlnaHQ7XG5cdCAgICBvZmZzZXQgPSAodGhpcy5zY3JlZW4ud2lkdGggLSB3aWR0aCkgLyAyO1xuXHQgICAgaWYgKHRoaXMuX29yaWVudGF0aW9uID09PSAtOTApIHtcblx0ICAgICAgb2Zmc2V0ICo9IC0xO1xuXHQgICAgfVxuXHQgICAgcmVmMSA9IFswLCAwXSwgeCA9IHJlZjFbMF0sIHkgPSByZWYxWzFdO1xuXHQgICAgaWYgKHRoaXMuaXNMYW5kc2NhcGUoKSkge1xuXHQgICAgICB4ID0gb2Zmc2V0O1xuXHQgICAgICB5ID0gb2Zmc2V0O1xuXHQgICAgfVxuXHQgICAgY29udGVudFByb3BlcnRpZXMgPSB7XG5cdCAgICAgIHJvdGF0aW9uWjogdGhpcy5fb3JpZW50YXRpb24sXG5cdCAgICAgIHg6IHgsXG5cdCAgICAgIHk6IHlcblx0ICAgIH07XG5cdCAgICB0aGlzLmhhbmRzLmFuaW1hdGVTdG9wKCk7XG5cdCAgICB0aGlzLnZpZXdwb3J0LmFuaW1hdGVTdG9wKCk7XG5cdCAgICBpZiAoYW5pbWF0ZSkge1xuXHQgICAgICBhbmltYXRpb24gPSB0aGlzLmhhbmRzLmFuaW1hdGUoXy5leHRlbmQodGhpcy5hbmltYXRpb25PcHRpb25zLCB7XG5cdCAgICAgICAgcHJvcGVydGllczogcGhvbmVQcm9wZXJ0aWVzXG5cdCAgICAgIH0pKTtcblx0ICAgICAgdGhpcy52aWV3cG9ydC5hbmltYXRlKF8uZXh0ZW5kKHRoaXMuYW5pbWF0aW9uT3B0aW9ucywge1xuXHQgICAgICAgIHByb3BlcnRpZXM6IGNvbnRlbnRQcm9wZXJ0aWVzXG5cdCAgICAgIH0pKTtcblx0ICAgICAgYW5pbWF0aW9uLm9uKEV2ZW50cy5BbmltYXRpb25FbmQsIChmdW5jdGlvbihfdGhpcykge1xuXHQgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgIHJldHVybiBfdGhpcy5fdXBkYXRlKCk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgfSkodGhpcykpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdGhpcy5oYW5kcy5wcm9wcyA9IHBob25lUHJvcGVydGllcztcblx0ICAgICAgdGhpcy52aWV3cG9ydC5wcm9wcyA9IGNvbnRlbnRQcm9wZXJ0aWVzO1xuXHQgICAgICB0aGlzLl91cGRhdGUoKTtcblx0ICAgIH1cblx0ICAgIGlmICh0aGlzLl9vcmllbnRhdGlvbiAhPT0gMCkge1xuXHQgICAgICB0aGlzLmhhbmRzSW1hZ2VMYXllci5pbWFnZSA9IFwiXCI7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcy5lbWl0KFwiY2hhbmdlOm9yaWVudGF0aW9uXCIsIHRoaXMuX29yaWVudGF0aW9uKTtcblx0ICB9O1xuXHRcblx0ICBEZXZpY2VDb21wb25lbnQucHJvdG90eXBlLl9vcmllbnRhdGlvbkNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdGhpcy5fb3JpZW50YXRpb24gPSB3aW5kb3cub3JpZW50YXRpb247XG5cdCAgICB0aGlzLl91cGRhdGUoKTtcblx0ICAgIHJldHVybiB0aGlzLmVtaXQoXCJjaGFuZ2U6b3JpZW50YXRpb25cIiwgd2luZG93Lm9yaWVudGF0aW9uKTtcblx0ICB9O1xuXHRcblx0ICBEZXZpY2VDb21wb25lbnQucHJvdG90eXBlLmlzUG9ydHJhaXQgPSBmdW5jdGlvbigpIHtcblx0ICAgIHJldHVybiBNYXRoLmFicyh0aGlzLm9yaWVudGF0aW9uKSA9PT0gMDtcblx0ICB9O1xuXHRcblx0ICBEZXZpY2VDb21wb25lbnQucHJvdG90eXBlLmlzTGFuZHNjYXBlID0gZnVuY3Rpb24oKSB7XG5cdCAgICByZXR1cm4gIXRoaXMuaXNQb3J0cmFpdCgpO1xuXHQgIH07XG5cdFxuXHQgIERldmljZUNvbXBvbmVudC5kZWZpbmUoXCJvcmllbnRhdGlvbk5hbWVcIiwge1xuXHQgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgaWYgKHRoaXMuaXNQb3J0cmFpdCgpKSB7XG5cdCAgICAgICAgcmV0dXJuIFwicG9ydHJhaXRcIjtcblx0ICAgICAgfVxuXHQgICAgICBpZiAodGhpcy5pc0xhbmRzY2FwZSgpKSB7XG5cdCAgICAgICAgcmV0dXJuIFwibGFuZHNjYXBlXCI7XG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdCAgICBzZXQ6IGZ1bmN0aW9uKG9yaWVudGF0aW9uTmFtZSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5zZXRPcmllbnRhdGlvbihvcmllbnRhdGlvbk5hbWUsIGZhbHNlKTtcblx0ICAgIH1cblx0ICB9KTtcblx0XG5cdCAgRGV2aWNlQ29tcG9uZW50LnByb3RvdHlwZS5yb3RhdGVMZWZ0ID0gZnVuY3Rpb24oYW5pbWF0ZSkge1xuXHQgICAgaWYgKGFuaW1hdGUgPT0gbnVsbCkge1xuXHQgICAgICBhbmltYXRlID0gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIGlmICh0aGlzLm9yaWVudGF0aW9uID09PSA5MCkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcy5zZXRPcmllbnRhdGlvbih0aGlzLm9yaWVudGF0aW9uICsgOTAsIGFuaW1hdGUpO1xuXHQgIH07XG5cdFxuXHQgIERldmljZUNvbXBvbmVudC5wcm90b3R5cGUucm90YXRlUmlnaHQgPSBmdW5jdGlvbihhbmltYXRlKSB7XG5cdCAgICBpZiAoYW5pbWF0ZSA9PSBudWxsKSB7XG5cdCAgICAgIGFuaW1hdGUgPSB0cnVlO1xuXHQgICAgfVxuXHQgICAgaWYgKHRoaXMub3JpZW50YXRpb24gPT09IC05MCkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcy5zZXRPcmllbnRhdGlvbih0aGlzLm9yaWVudGF0aW9uIC0gOTAsIGFuaW1hdGUpO1xuXHQgIH07XG5cdFxuXHQgIERldmljZUNvbXBvbmVudC5wcm90b3R5cGUuX2dldE9yaWVudGF0aW9uRGltZW5zaW9ucyA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcblx0ICAgIGlmICh0aGlzLmlzTGFuZHNjYXBlKCkpIHtcblx0ICAgICAgcmV0dXJuIFtoZWlnaHQsIHdpZHRoXTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiBbd2lkdGgsIGhlaWdodF07XG5cdCAgICB9XG5cdCAgfTtcblx0XG5cdCAgRGV2aWNlQ29tcG9uZW50LnByb3RvdHlwZS5oYW5kU3dpdGNoaW5nU3VwcG9ydGVkID0gZnVuY3Rpb24oKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fZGV2aWNlLmhhbmRzICE9PSB2b2lkIDA7XG5cdCAgfTtcblx0XG5cdCAgRGV2aWNlQ29tcG9uZW50LnByb3RvdHlwZS5uZXh0SGFuZCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIGhhbmQsIGhhbmRzLCBuZXh0SGFuZCwgbmV4dEhhbmRJbmRleDtcblx0ICAgIGlmICh0aGlzLmhhbmRzLnJvdGF0aW9uWiAhPT0gMCkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICBpZiAodGhpcy5oYW5kU3dpdGNoaW5nU3VwcG9ydGVkKCkpIHtcblx0ICAgICAgaGFuZHMgPSBfLmtleXModGhpcy5fZGV2aWNlLmhhbmRzKTtcblx0ICAgICAgaWYgKGhhbmRzLmxlbmd0aCA+IDApIHtcblx0ICAgICAgICBuZXh0SGFuZEluZGV4ID0gaGFuZHMuaW5kZXhPZih0aGlzLnNlbGVjdGVkSGFuZCkgKyAxO1xuXHQgICAgICAgIG5leHRIYW5kID0gXCJcIjtcblx0ICAgICAgICBpZiAobmV4dEhhbmRJbmRleCA8IGhhbmRzLmxlbmd0aCkge1xuXHQgICAgICAgICAgbmV4dEhhbmQgPSBoYW5kc1tuZXh0SGFuZEluZGV4XTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaGFuZCA9IHRoaXMuc2V0SGFuZChuZXh0SGFuZCk7XG5cdCAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG5cdCAgICAgICAgcmV0dXJuIGhhbmQ7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9O1xuXHRcblx0ICBEZXZpY2VDb21wb25lbnQucHJvdG90eXBlLnNldEhhbmQgPSBmdW5jdGlvbihoYW5kKSB7XG5cdCAgICB2YXIgaGFuZERhdGE7XG5cdCAgICB0aGlzLnNlbGVjdGVkSGFuZCA9IGhhbmQ7XG5cdCAgICBpZiAoIWhhbmQgfHwgIXRoaXMuaGFuZFN3aXRjaGluZ1N1cHBvcnRlZCgpKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmhhbmRzSW1hZ2VMYXllci5pbWFnZSA9IFwiXCI7XG5cdCAgICB9XG5cdCAgICBoYW5kRGF0YSA9IHRoaXMuX2RldmljZS5oYW5kc1toYW5kXTtcblx0ICAgIGlmIChoYW5kRGF0YSkge1xuXHQgICAgICB0aGlzLmhhbmRzLndpZHRoID0gaGFuZERhdGEud2lkdGg7XG5cdCAgICAgIHRoaXMuaGFuZHMuaGVpZ2h0ID0gaGFuZERhdGEuaGVpZ2h0O1xuXHQgICAgICB0aGlzLmhhbmRzLmNlbnRlcigpO1xuXHQgICAgICB0aGlzLnBob25lLmNlbnRlcigpO1xuXHQgICAgICB0aGlzLmhhbmRzSW1hZ2VMYXllci5zaXplID0gdGhpcy5oYW5kcy5zaXplO1xuXHQgICAgICB0aGlzLmhhbmRzSW1hZ2VMYXllci55ID0gMDtcblx0ICAgICAgaWYgKGhhbmREYXRhLm9mZnNldCkge1xuXHQgICAgICAgIHRoaXMuaGFuZHNJbWFnZUxheWVyLnkgPSBoYW5kRGF0YS5vZmZzZXQ7XG5cdCAgICAgIH1cblx0ICAgICAgdGhpcy5oYW5kc0ltYWdlTGF5ZXIuaW1hZ2UgPSB0aGlzLmhhbmRJbWFnZVVybChoYW5kKTtcblx0ICAgICAgcmV0dXJuIGhhbmQ7XG5cdCAgICB9XG5cdCAgfTtcblx0XG5cdCAgRGV2aWNlQ29tcG9uZW50LnByb3RvdHlwZS5oYW5kSW1hZ2VVcmwgPSBmdW5jdGlvbihoYW5kKSB7XG5cdCAgICB2YXIgcmVzb3VyY2VVcmw7XG5cdCAgICByZXNvdXJjZVVybCA9IFwiLy9yZXNvdXJjZXMuZnJhbWVyanMuY29tL3N0YXRpYy9EZXZpY2VSZXNvdXJjZXNcIjtcblx0ICAgIGlmIChVdGlscy5pc0ZyYW1lclN0dWRpbygpICYmIHdpbmRvdy5GcmFtZXJTdHVkaW9JbmZvICYmIFV0aWxzLmZyYW1lclN0dWRpb1ZlcnNpb24oKSA+PSBuZXdEZXZpY2VNaW5WZXJzaW9uKSB7XG5cdCAgICAgIHJlc291cmNlVXJsID0gd2luZG93LkZyYW1lclN0dWRpb0luZm8uZGV2aWNlSW1hZ2VzVXJsO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc291cmNlVXJsICsgXCIvXCIgKyBoYW5kICsgXCIucG5nXCI7XG5cdCAgfTtcblx0XG5cdCAgcmV0dXJuIERldmljZUNvbXBvbmVudDtcblx0XG5cdH0pKEJhc2VDbGFzcyk7XG5cdFxuXHRuZXdEZXZpY2VNaW5WZXJzaW9uID0gNTM7XG5cdFxuXHRvbGREZXZpY2VNYXhWZXJzaW9uID0gNTI7XG5cdFxuXHRpUGFkQWlyMkJhc2VEZXZpY2UgPSB7XG5cdCAgZGV2aWNlSW1hZ2VXaWR0aDogMTg1Nixcblx0ICBkZXZpY2VJbWFnZUhlaWdodDogMjYwOCxcblx0ICBkZXZpY2VJbWFnZUpQMjogdHJ1ZSxcblx0ICBzY3JlZW5XaWR0aDogMTUzNixcblx0ICBzY3JlZW5IZWlnaHQ6IDIwNDgsXG5cdCAgZGV2aWNlVHlwZTogXCJwaG9uZVwiLFxuXHQgIG1pblN0dWRpb1ZlcnNpb246IG5ld0RldmljZU1pblZlcnNpb25cblx0fTtcblx0XG5cdGlQYWRNaW5pNEJhc2VEZXZpY2UgPSB7XG5cdCAgZGV2aWNlSW1hZ2VXaWR0aDogMTkzNixcblx0ICBkZXZpY2VJbWFnZUhlaWdodDogMjY4OCxcblx0ICBkZXZpY2VJbWFnZUpQMjogdHJ1ZSxcblx0ICBzY3JlZW5XaWR0aDogMTUzNixcblx0ICBzY3JlZW5IZWlnaHQ6IDIwNDgsXG5cdCAgZGV2aWNlVHlwZTogXCJwaG9uZVwiLFxuXHQgIG1pblN0dWRpb1ZlcnNpb246IG5ld0RldmljZU1pblZlcnNpb25cblx0fTtcblx0XG5cdGlQYWRQcm9CYXNlRGV2aWNlID0ge1xuXHQgIGRldmljZUltYWdlV2lkdGg6IDI0NDgsXG5cdCAgZGV2aWNlSW1hZ2VIZWlnaHQ6IDM0MzIsXG5cdCAgZGV2aWNlSW1hZ2VKUDI6IHRydWUsXG5cdCAgc2NyZWVuV2lkdGg6IDIwNDgsXG5cdCAgc2NyZWVuSGVpZ2h0OiAyNzMyLFxuXHQgIGRldmljZVR5cGU6IFwicGhvbmVcIixcblx0ICBtaW5TdHVkaW9WZXJzaW9uOiBuZXdEZXZpY2VNaW5WZXJzaW9uXG5cdH07XG5cdFxuXHRpUGhvbmU2QmFzZURldmljZSA9IHtcblx0ICBkZXZpY2VJbWFnZVdpZHRoOiA4NzQsXG5cdCAgZGV2aWNlSW1hZ2VIZWlnaHQ6IDE3OTIsXG5cdCAgZGV2aWNlSW1hZ2VKUDI6IHRydWUsXG5cdCAgc2NyZWVuV2lkdGg6IDc1MCxcblx0ICBzY3JlZW5IZWlnaHQ6IDEzMzQsXG5cdCAgZGV2aWNlVHlwZTogXCJwaG9uZVwiLFxuXHQgIG1pblN0dWRpb1ZlcnNpb246IG5ld0RldmljZU1pblZlcnNpb24sXG5cdCAgaGFuZHM6IHtcblx0ICAgIFwiaXBob25lLWhhbmRzLTJcIjoge1xuXHQgICAgICB3aWR0aDogMjQwMCxcblx0ICAgICAgaGVpZ2h0OiAzNzQwXG5cdCAgICB9LFxuXHQgICAgXCJpcGhvbmUtaGFuZHMtMVwiOiB7XG5cdCAgICAgIHdpZHRoOiAyNDAwLFxuXHQgICAgICBoZWlnaHQ6IDM3NDBcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cdFxuXHRpUGhvbmU2UGx1c0Jhc2VEZXZpY2UgPSB7XG5cdCAgZGV2aWNlSW1hZ2VXaWR0aDogMTQ1Mixcblx0ICBkZXZpY2VJbWFnZUhlaWdodDogMjk2OCxcblx0ICBkZXZpY2VJbWFnZUpQMjogdHJ1ZSxcblx0ICBzY3JlZW5XaWR0aDogMTI0Mixcblx0ICBzY3JlZW5IZWlnaHQ6IDIyMDgsXG5cdCAgZGV2aWNlVHlwZTogXCJwaG9uZVwiLFxuXHQgIG1pblN0dWRpb1ZlcnNpb246IG5ld0RldmljZU1pblZlcnNpb24sXG5cdCAgaGFuZHM6IHtcblx0ICAgIFwiaXBob25lLWhhbmRzLTJcIjoge1xuXHQgICAgICB3aWR0aDogMzk4Nyxcblx0ICAgICAgaGVpZ2h0OiA2MjEyXG5cdCAgICB9LFxuXHQgICAgXCJpcGhvbmUtaGFuZHMtMVwiOiB7XG5cdCAgICAgIHdpZHRoOiAzOTg3LFxuXHQgICAgICBoZWlnaHQ6IDYyMTJcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cdFxuXHRpUGhvbmU1QmFzZURldmljZSA9IHtcblx0ICBkZXZpY2VJbWFnZVdpZHRoOiA3NjgsXG5cdCAgZGV2aWNlSW1hZ2VIZWlnaHQ6IDE2MTIsXG5cdCAgZGV2aWNlSW1hZ2VKUDI6IHRydWUsXG5cdCAgc2NyZWVuV2lkdGg6IDY0MCxcblx0ICBzY3JlZW5IZWlnaHQ6IDExMzYsXG5cdCAgZGV2aWNlVHlwZTogXCJwaG9uZVwiLFxuXHQgIG1pblN0dWRpb1ZlcnNpb246IG5ld0RldmljZU1pblZlcnNpb24sXG5cdCAgaGFuZHM6IHtcblx0ICAgIFwiaXBob25lLWhhbmRzLTJcIjoge1xuXHQgICAgICB3aWR0aDogMjA5OCxcblx0ICAgICAgaGVpZ2h0OiAzMjY5LFxuXHQgICAgICBvZmZzZXQ6IDE5XG5cdCAgICB9LFxuXHQgICAgXCJpcGhvbmUtaGFuZHMtMVwiOiB7XG5cdCAgICAgIHdpZHRoOiAyMDk4LFxuXHQgICAgICBoZWlnaHQ6IDMyNjksXG5cdCAgICAgIG9mZnNldDogMTlcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cdFxuXHRpUGhvbmU1Q0Jhc2VEZXZpY2UgPSB7XG5cdCAgZGV2aWNlSW1hZ2VXaWR0aDogNzc2LFxuXHQgIGRldmljZUltYWdlSGVpZ2h0OiAxNjIwLFxuXHQgIGRldmljZUltYWdlSlAyOiB0cnVlLFxuXHQgIHNjcmVlbldpZHRoOiA2NDAsXG5cdCAgc2NyZWVuSGVpZ2h0OiAxMTM2LFxuXHQgIGRldmljZVR5cGU6IFwicGhvbmVcIixcblx0ICBtaW5TdHVkaW9WZXJzaW9uOiBuZXdEZXZpY2VNaW5WZXJzaW9uLFxuXHQgIGhhbmRzOiB7XG5cdCAgICBcImlwaG9uZS1oYW5kcy0yXCI6IHtcblx0ICAgICAgd2lkdGg6IDIwOTgsXG5cdCAgICAgIGhlaWdodDogMzI2OSxcblx0ICAgICAgb2Zmc2V0OiAyOFxuXHQgICAgfSxcblx0ICAgIFwiaXBob25lLWhhbmRzLTFcIjoge1xuXHQgICAgICB3aWR0aDogMjA5OCxcblx0ICAgICAgaGVpZ2h0OiAzMjY5LFxuXHQgICAgICBvZmZzZXQ6IDI4XG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXHRcblx0TmV4dXM0QmFzZURldmljZSA9IHtcblx0ICBkZXZpY2VJbWFnZVdpZHRoOiA4NjAsXG5cdCAgZGV2aWNlSW1hZ2VIZWlnaHQ6IDE2NjgsXG5cdCAgZGV2aWNlSW1hZ2VKUDI6IHRydWUsXG5cdCAgc2NyZWVuV2lkdGg6IDc2OCxcblx0ICBzY3JlZW5IZWlnaHQ6IDEyODAsXG5cdCAgZGV2aWNlVHlwZTogXCJwaG9uZVwiLFxuXHQgIG1pblN0dWRpb1ZlcnNpb246IG5ld0RldmljZU1pblZlcnNpb24sXG5cdCAgaGFuZHM6IHtcblx0ICAgIFwiaXBob25lLWhhbmRzLTJcIjoge1xuXHQgICAgICB3aWR0aDogMjM2Mixcblx0ICAgICAgaGVpZ2h0OiAzNjgxLFxuXHQgICAgICBvZmZzZXQ6IC01MlxuXHQgICAgfSxcblx0ICAgIFwiaXBob25lLWhhbmRzLTFcIjoge1xuXHQgICAgICB3aWR0aDogMjM2Mixcblx0ICAgICAgaGVpZ2h0OiAzNjgxLFxuXHQgICAgICBvZmZzZXQ6IC01MlxuXHQgICAgfVxuXHQgIH1cblx0fTtcblx0XG5cdE5leHVzNUJhc2VEZXZpY2UgPSB7XG5cdCAgZGV2aWNlSW1hZ2VXaWR0aDogMTIwNCxcblx0ICBkZXZpY2VJbWFnZUhlaWdodDogMjQzMixcblx0ICBkZXZpY2VJbWFnZUpQMjogdHJ1ZSxcblx0ICBzY3JlZW5XaWR0aDogMTA4MCxcblx0ICBzY3JlZW5IZWlnaHQ6IDE5MjAsXG5cdCAgZGV2aWNlVHlwZTogXCJwaG9uZVwiLFxuXHQgIG1pblN0dWRpb1ZlcnNpb246IG5ld0RldmljZU1pblZlcnNpb24sXG5cdCAgaGFuZHM6IHtcblx0ICAgIFwiaXBob25lLWhhbmRzLTJcIjoge1xuXHQgICAgICB3aWR0aDogMzI5Mixcblx0ICAgICAgaGVpZ2h0OiA1MTMwLFxuXHQgICAgICBvZmZzZXQ6IDhcblx0ICAgIH0sXG5cdCAgICBcImlwaG9uZS1oYW5kcy0xXCI6IHtcblx0ICAgICAgd2lkdGg6IDMyOTIsXG5cdCAgICAgIGhlaWdodDogNTEzMCxcblx0ICAgICAgb2Zmc2V0OiA4XG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXHRcblx0TmV4dXM2QmFzZURldmljZSA9IHtcblx0ICBkZXZpY2VJbWFnZVdpZHRoOiAxNTc2LFxuXHQgIGRldmljZUltYWdlSGVpZ2h0OiAzMjIwLFxuXHQgIGRldmljZUltYWdlSlAyOiB0cnVlLFxuXHQgIHNjcmVlbldpZHRoOiAxNDQwLFxuXHQgIHNjcmVlbkhlaWdodDogMjU2MCxcblx0ICBkZXZpY2VUeXBlOiBcInBob25lXCIsXG5cdCAgbWluU3R1ZGlvVmVyc2lvbjogbmV3RGV2aWNlTWluVmVyc2lvbixcblx0ICBoYW5kczoge1xuXHQgICAgXCJpcGhvbmUtaGFuZHMtMlwiOiB7XG5cdCAgICAgIHdpZHRoOiA0MzA0LFxuXHQgICAgICBoZWlnaHQ6IDY3MDcsXG5cdCAgICAgIG9mZnNldDogOFxuXHQgICAgfSxcblx0ICAgIFwiaXBob25lLWhhbmRzLTFcIjoge1xuXHQgICAgICB3aWR0aDogNDMwNCxcblx0ICAgICAgaGVpZ2h0OiA2NzA3LFxuXHQgICAgICBvZmZzZXQ6IDhcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cdFxuXHROZXh1czlCYXNlRGV2aWNlID0ge1xuXHQgIGRldmljZUltYWdlV2lkdGg6IDE4OTYsXG5cdCAgZGV2aWNlSW1hZ2VIZWlnaHQ6IDI2NDgsXG5cdCAgZGV2aWNlSW1hZ2VKUDI6IHRydWUsXG5cdCAgc2NyZWVuV2lkdGg6IDE1MzYsXG5cdCAgc2NyZWVuSGVpZ2h0OiAyMDQ4LFxuXHQgIGRldmljZVR5cGU6IFwicGhvbmVcIixcblx0ICBtaW5TdHVkaW9WZXJzaW9uOiBuZXdEZXZpY2VNaW5WZXJzaW9uXG5cdH07XG5cdFxuXHRIVENhOUJhc2VEZXZpY2UgPSB7XG5cdCAgZGV2aWNlSW1hZ2VXaWR0aDogMTI1Mixcblx0ICBkZXZpY2VJbWFnZUhlaWdodDogMjU5Mixcblx0ICBkZXZpY2VJbWFnZUpQMjogdHJ1ZSxcblx0ICBzY3JlZW5XaWR0aDogMTA4MCxcblx0ICBzY3JlZW5IZWlnaHQ6IDE5MjAsXG5cdCAgZGV2aWNlVHlwZTogXCJwaG9uZVwiLFxuXHQgIG1pblN0dWRpb1ZlcnNpb246IG5ld0RldmljZU1pblZlcnNpb24sXG5cdCAgaGFuZHM6IHtcblx0ICAgIFwiaXBob25lLWhhbmRzLTJcIjoge1xuXHQgICAgICB3aWR0aDogMzQzNixcblx0ICAgICAgaGVpZ2h0OiA1MzU0LFxuXHQgICAgICBvZmZzZXQ6IDM2XG5cdCAgICB9LFxuXHQgICAgXCJpcGhvbmUtaGFuZHMtMVwiOiB7XG5cdCAgICAgIHdpZHRoOiAzNDM2LFxuXHQgICAgICBoZWlnaHQ6IDUzNTQsXG5cdCAgICAgIG9mZnNldDogMzZcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cdFxuXHRIVENtOEJhc2VEZXZpY2UgPSB7XG5cdCAgZGV2aWNlSW1hZ2VXaWR0aDogMTIzMixcblx0ICBkZXZpY2VJbWFnZUhlaWdodDogMjU3Mixcblx0ICBkZXZpY2VJbWFnZUpQMjogdHJ1ZSxcblx0ICBzY3JlZW5XaWR0aDogMTA4MCxcblx0ICBzY3JlZW5IZWlnaHQ6IDE5MjAsXG5cdCAgZGV2aWNlVHlwZTogXCJwaG9uZVwiLFxuXHQgIG1pblN0dWRpb1ZlcnNpb246IG5ld0RldmljZU1pblZlcnNpb24sXG5cdCAgaGFuZHM6IHtcblx0ICAgIFwiaXBob25lLWhhbmRzLTJcIjoge1xuXHQgICAgICB3aWR0aDogMzQzNixcblx0ICAgICAgaGVpZ2h0OiA1MzU0LFxuXHQgICAgICBvZmZzZXQ6IDEyXG5cdCAgICB9LFxuXHQgICAgXCJpcGhvbmUtaGFuZHMtMVwiOiB7XG5cdCAgICAgIHdpZHRoOiAzNDM2LFxuXHQgICAgICBoZWlnaHQ6IDUzNTQsXG5cdCAgICAgIG9mZnNldDogMTJcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cdFxuXHRNU0ZUTHVtaWE5NTBCYXNlRGV2aWNlID0ge1xuXHQgIGRldmljZUltYWdlV2lkdGg6IDE2NjAsXG5cdCAgZGV2aWNlSW1hZ2VIZWlnaHQ6IDMyOTIsXG5cdCAgZGV2aWNlSW1hZ2VKUDI6IHRydWUsXG5cdCAgc2NyZWVuV2lkdGg6IDE0NDAsXG5cdCAgc2NyZWVuSGVpZ2h0OiAyNTYwLFxuXHQgIGRldmljZVR5cGU6IFwicGhvbmVcIixcblx0ICBtaW5TdHVkaW9WZXJzaW9uOiBuZXdEZXZpY2VNaW5WZXJzaW9uLFxuXHQgIGhhbmRzOiB7XG5cdCAgICBcImlwaG9uZS1oYW5kcy0yXCI6IHtcblx0ICAgICAgd2lkdGg6IDQ0OTQsXG5cdCAgICAgIGhlaWdodDogNzAwMyxcblx0ICAgICAgb2Zmc2V0OiAtODRcblx0ICAgIH0sXG5cdCAgICBcImlwaG9uZS1oYW5kcy0xXCI6IHtcblx0ICAgICAgd2lkdGg6IDQ0OTQsXG5cdCAgICAgIGhlaWdodDogNzAwMyxcblx0ICAgICAgb2Zmc2V0OiAtODRcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cdFxuXHRTYW1zdW5nR2FsYXh5Tm90ZTVCYXNlRGV2aWNlID0ge1xuXHQgIGRldmljZUltYWdlV2lkdGg6IDE1NzIsXG5cdCAgZGV2aWNlSW1hZ2VIZWlnaHQ6IDMxNDAsXG5cdCAgZGV2aWNlSW1hZ2VKUDI6IHRydWUsXG5cdCAgc2NyZWVuV2lkdGg6IDE0NDAsXG5cdCAgc2NyZWVuSGVpZ2h0OiAyNTYwLFxuXHQgIGRldmljZVR5cGU6IFwicGhvbmVcIixcblx0ICBtaW5TdHVkaW9WZXJzaW9uOiBuZXdEZXZpY2VNaW5WZXJzaW9uLFxuXHQgIGhhbmRzOiB7XG5cdCAgICBcImlwaG9uZS1oYW5kcy0yXCI6IHtcblx0ICAgICAgd2lkdGg6IDQyNzksXG5cdCAgICAgIGhlaWdodDogNjY2OCxcblx0ICAgICAgb2Zmc2V0OiAtMjRcblx0ICAgIH0sXG5cdCAgICBcImlwaG9uZS1oYW5kcy0xXCI6IHtcblx0ICAgICAgd2lkdGg6IDQyNzksXG5cdCAgICAgIGhlaWdodDogNjY2OCxcblx0ICAgICAgb2Zmc2V0OiAtODRcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cdFxuXHRBcHBsZVdhdGNoNDJEZXZpY2UgPSB7XG5cdCAgZGV2aWNlSW1hZ2VXaWR0aDogNTEyLFxuXHQgIGRldmljZUltYWdlSGVpZ2h0OiA5OTAsXG5cdCAgZGV2aWNlSW1hZ2VKUDI6IHRydWUsXG5cdCAgc2NyZWVuV2lkdGg6IDMxMixcblx0ICBzY3JlZW5IZWlnaHQ6IDM5MCxcblx0ICBtaW5TdHVkaW9WZXJzaW9uOiBuZXdEZXZpY2VNaW5WZXJzaW9uXG5cdH07XG5cdFxuXHRBcHBsZVdhdGNoMzhEZXZpY2UgPSB7XG5cdCAgZGV2aWNlSW1hZ2VXaWR0aDogNDcyLFxuXHQgIGRldmljZUltYWdlSGVpZ2h0OiA3NzIsXG5cdCAgZGV2aWNlSW1hZ2VKUDI6IHRydWUsXG5cdCAgc2NyZWVuV2lkdGg6IDI3Mixcblx0ICBzY3JlZW5IZWlnaHQ6IDM0MCxcblx0ICBtaW5TdHVkaW9WZXJzaW9uOiBuZXdEZXZpY2VNaW5WZXJzaW9uXG5cdH07XG5cdFxuXHRBcHBsZVdhdGNoMzhCbGFja0xlYXRoZXJEZXZpY2UgPSB7XG5cdCAgZGV2aWNlSW1hZ2VXaWR0aDogNDcyLFxuXHQgIGRldmljZUltYWdlSGVpZ2h0OiA3OTYsXG5cdCAgZGV2aWNlSW1hZ2VKUDI6IHRydWUsXG5cdCAgc2NyZWVuV2lkdGg6IDI3Mixcblx0ICBzY3JlZW5IZWlnaHQ6IDM0MCxcblx0ICBtaW5TdHVkaW9WZXJzaW9uOiBuZXdEZXZpY2VNaW5WZXJzaW9uXG5cdH07XG5cdFxuXHRvbGRfaVBob25lNkJhc2VEZXZpY2UgPSB7XG5cdCAgZGV2aWNlSW1hZ2VXaWR0aDogODcwLFxuXHQgIGRldmljZUltYWdlSGVpZ2h0OiAxNzM4LFxuXHQgIGRldmljZUltYWdlSlAyOiB0cnVlLFxuXHQgIHNjcmVlbldpZHRoOiA3NTAsXG5cdCAgc2NyZWVuSGVpZ2h0OiAxMzM0LFxuXHQgIGRldmljZVR5cGU6IFwicGhvbmVcIixcblx0ICBtYXhTdHVkaW9WZXJzaW9uOiBvbGREZXZpY2VNYXhWZXJzaW9uXG5cdH07XG5cdFxuXHRvbGRfaVBob25lNkJhc2VEZXZpY2VIYW5kID0gXy5leHRlbmQoe30sIG9sZF9pUGhvbmU2QmFzZURldmljZSwge1xuXHQgIGRldmljZUltYWdlV2lkdGg6IDE5ODgsXG5cdCAgZGV2aWNlSW1hZ2VIZWlnaHQ6IDIzNjgsXG5cdCAgZGV2aWNlSW1hZ2VKUDI6IHRydWUsXG5cdCAgcGFkZGluZ09mZnNldDogLTE1MCxcblx0ICBtYXhTdHVkaW9WZXJzaW9uOiBvbGREZXZpY2VNYXhWZXJzaW9uXG5cdH0pO1xuXHRcblx0b2xkX2lQaG9uZTZQbHVzQmFzZURldmljZSA9IHtcblx0ICBkZXZpY2VJbWFnZVdpZHRoOiAxNDYwLFxuXHQgIGRldmljZUltYWdlSGVpZ2h0OiAyOTAwLFxuXHQgIGRldmljZUltYWdlSlAyOiB0cnVlLFxuXHQgIHNjcmVlbldpZHRoOiAxMjQyLFxuXHQgIHNjcmVlbkhlaWdodDogMjIwOCxcblx0ICBkZXZpY2VUeXBlOiBcInBob25lXCIsXG5cdCAgbWF4U3R1ZGlvVmVyc2lvbjogb2xkRGV2aWNlTWF4VmVyc2lvblxuXHR9O1xuXHRcblx0b2xkX2lQaG9uZTZQbHVzQmFzZURldmljZUhhbmQgPSBfLmV4dGVuZCh7fSwgb2xkX2lQaG9uZTZQbHVzQmFzZURldmljZSwge1xuXHQgIGRldmljZUltYWdlV2lkdGg6IDMxMjgsXG5cdCAgZGV2aWNlSW1hZ2VIZWlnaHQ6IDM0ODcsXG5cdCAgZGV2aWNlSW1hZ2VKUDI6IHRydWUsXG5cdCAgcGFkZGluZ09mZnNldDogLTE1MCxcblx0ICBtYXhTdHVkaW9WZXJzaW9uOiBvbGREZXZpY2VNYXhWZXJzaW9uXG5cdH0pO1xuXHRcblx0b2xkX2lQaG9uZTVCYXNlRGV2aWNlID0ge1xuXHQgIGRldmljZUltYWdlV2lkdGg6IDc4MCxcblx0ICBkZXZpY2VJbWFnZUhlaWdodDogMTYwOCxcblx0ICBkZXZpY2VJbWFnZUpQMjogdHJ1ZSxcblx0ICBzY3JlZW5XaWR0aDogNjQwLFxuXHQgIHNjcmVlbkhlaWdodDogMTEzNixcblx0ICBkZXZpY2VUeXBlOiBcInBob25lXCIsXG5cdCAgbWF4U3R1ZGlvVmVyc2lvbjogb2xkRGV2aWNlTWF4VmVyc2lvblxuXHR9O1xuXHRcblx0b2xkX2lQaG9uZTVCYXNlRGV2aWNlSGFuZCA9IF8uZXh0ZW5kKHt9LCBvbGRfaVBob25lNUJhc2VEZXZpY2UsIHtcblx0ICBkZXZpY2VJbWFnZVdpZHRoOiAxODg0LFxuXHQgIGRldmljZUltYWdlSGVpZ2h0OiAyMjM0LFxuXHQgIGRldmljZUltYWdlSlAyOiB0cnVlLFxuXHQgIHBhZGRpbmdPZmZzZXQ6IC0yMDAsXG5cdCAgbWF4U3R1ZGlvVmVyc2lvbjogb2xkRGV2aWNlTWF4VmVyc2lvblxuXHR9KTtcblx0XG5cdG9sZF9pUGhvbmU1Q0Jhc2VEZXZpY2UgPSB7XG5cdCAgZGV2aWNlSW1hZ2VXaWR0aDogNzc2LFxuXHQgIGRldmljZUltYWdlSGVpZ2h0OiAxNjEyLFxuXHQgIGRldmljZUltYWdlSlAyOiB0cnVlLFxuXHQgIHNjcmVlbldpZHRoOiA2NDAsXG5cdCAgc2NyZWVuSGVpZ2h0OiAxMTM2LFxuXHQgIGRldmljZVR5cGU6IFwicGhvbmVcIixcblx0ICBtYXhTdHVkaW9WZXJzaW9uOiBvbGREZXZpY2VNYXhWZXJzaW9uXG5cdH07XG5cdFxuXHRvbGRfaVBob25lNUNCYXNlRGV2aWNlSGFuZCA9IF8uZXh0ZW5kKHt9LCBvbGRfaVBob25lNUNCYXNlRGV2aWNlLCB7XG5cdCAgZGV2aWNlSW1hZ2VXaWR0aDogMTg5NCxcblx0ICBkZXZpY2VJbWFnZUhlaWdodDogMjI0NCxcblx0ICBkZXZpY2VJbWFnZUpQMjogdHJ1ZSxcblx0ICBwYWRkaW5nT2Zmc2V0OiAtMjAwLFxuXHQgIG1heFN0dWRpb1ZlcnNpb246IG9sZERldmljZU1heFZlcnNpb25cblx0fSk7XG5cdFxuXHRvbGRfaVBhZE1pbmlCYXNlRGV2aWNlID0ge1xuXHQgIGRldmljZUltYWdlV2lkdGg6IDg3Mixcblx0ICBkZXZpY2VJbWFnZUhlaWdodDogMTI5Mixcblx0ICBkZXZpY2VJbWFnZUpQMjogdHJ1ZSxcblx0ICBzY3JlZW5XaWR0aDogNzY4LFxuXHQgIHNjcmVlbkhlaWdodDogMTAyNCxcblx0ICBkZXZpY2VUeXBlOiBcInRhYmxldFwiLFxuXHQgIG1heFN0dWRpb1ZlcnNpb246IG9sZERldmljZU1heFZlcnNpb25cblx0fTtcblx0XG5cdG9sZF9pUGFkTWluaUJhc2VEZXZpY2VIYW5kID0gXy5leHRlbmQoe30sIG9sZF9pUGFkTWluaUJhc2VEZXZpY2UsIHtcblx0ICBkZXZpY2VJbWFnZVdpZHRoOiAxMzgwLFxuXHQgIGRldmljZUltYWdlSGVpZ2h0OiAyMDcyLFxuXHQgIGRldmljZUltYWdlSlAyOiB0cnVlLFxuXHQgIHBhZGRpbmdPZmZzZXQ6IC0xMjAsXG5cdCAgbWF4U3R1ZGlvVmVyc2lvbjogb2xkRGV2aWNlTWF4VmVyc2lvblxuXHR9KTtcblx0XG5cdG9sZF9pUGFkQWlyQmFzZURldmljZSA9IHtcblx0ICBkZXZpY2VJbWFnZVdpZHRoOiAxNzY5LFxuXHQgIGRldmljZUltYWdlSGVpZ2h0OiAyNTA5LFxuXHQgIGRldmljZUltYWdlSlAyOiB0cnVlLFxuXHQgIHNjcmVlbldpZHRoOiAxNTM2LFxuXHQgIHNjcmVlbkhlaWdodDogMjA0OCxcblx0ICBkZXZpY2VUeXBlOiBcInRhYmxldFwiLFxuXHQgIG1heFN0dWRpb1ZlcnNpb246IG9sZERldmljZU1heFZlcnNpb25cblx0fTtcblx0XG5cdG9sZF9pUGFkQWlyQmFzZURldmljZUhhbmQgPSBfLmV4dGVuZCh7fSwgb2xkX2lQYWRBaXJCYXNlRGV2aWNlLCB7XG5cdCAgZGV2aWNlSW1hZ2VXaWR0aDogNDc0NCxcblx0ICBkZXZpY2VJbWFnZUhlaWdodDogNDEwMSxcblx0ICBkZXZpY2VJbWFnZUpQMjogdHJ1ZSxcblx0ICBwYWRkaW5nT2Zmc2V0OiAtMTIwLFxuXHQgIG1heFN0dWRpb1ZlcnNpb246IG9sZERldmljZU1heFZlcnNpb25cblx0fSk7XG5cdFxuXHRvbGRfTmV4dXM1QmFzZURldmljZSA9IHtcblx0ICBkZXZpY2VJbWFnZVdpZHRoOiAxMjA4LFxuXHQgIGRldmljZUltYWdlSGVpZ2h0OiAyNDQwLFxuXHQgIGRldmljZUltYWdlSlAyOiB0cnVlLFxuXHQgIHNjcmVlbldpZHRoOiAxMDgwLFxuXHQgIHNjcmVlbkhlaWdodDogMTkyMCxcblx0ICBkZXZpY2VUeXBlOiBcInBob25lXCIsXG5cdCAgbWF4U3R1ZGlvVmVyc2lvbjogb2xkRGV2aWNlTWF4VmVyc2lvblxuXHR9O1xuXHRcblx0b2xkX05leHVzNUJhc2VEZXZpY2VIYW5kID0gXy5leHRlbmQoe30sIG9sZF9OZXh1czVCYXNlRGV2aWNlLCB7XG5cdCAgZGV2aWNlSW1hZ2VXaWR0aDogMjY5Mixcblx0ICBkZXZpY2VJbWFnZUhlaWdodDogMjk5Nixcblx0ICBkZXZpY2VJbWFnZUpQMjogdHJ1ZSxcblx0ICBwYWRkaW5nT2Zmc2V0OiAtMTIwLFxuXHQgIG1heFN0dWRpb1ZlcnNpb246IG9sZERldmljZU1heFZlcnNpb25cblx0fSk7XG5cdFxuXHRvbGRfTmV4dXM5QmFzZURldmljZSA9IHtcblx0ICBkZXZpY2VJbWFnZVdpZHRoOiAxNzMzLFxuXHQgIGRldmljZUltYWdlSGVpZ2h0OiAyNTc1LFxuXHQgIGRldmljZUltYWdlSlAyOiB0cnVlLFxuXHQgIHNjcmVlbldpZHRoOiAxNTM2LFxuXHQgIHNjcmVlbkhlaWdodDogMjA0OCxcblx0ICBkZXZpY2VUeXBlOiBcInRhYmxldFwiLFxuXHQgIG1heFN0dWRpb1ZlcnNpb246IG9sZERldmljZU1heFZlcnNpb25cblx0fTtcblx0XG5cdG9sZF9BcHBsZVdhdGNoNDJEZXZpY2UgPSB7XG5cdCAgZGV2aWNlSW1hZ2VXaWR0aDogNTUyLFxuXHQgIGRldmljZUltYWdlSGVpZ2h0OiA5MzgsXG5cdCAgZGV2aWNlSW1hZ2VKUDI6IHRydWUsXG5cdCAgc2NyZWVuV2lkdGg6IDMxMixcblx0ICBzY3JlZW5IZWlnaHQ6IDM5MCxcblx0ICBtYXhTdHVkaW9WZXJzaW9uOiBvbGREZXZpY2VNYXhWZXJzaW9uXG5cdH07XG5cdFxuXHRvbGRfQXBwbGVXYXRjaDM4RGV2aWNlID0ge1xuXHQgIGRldmljZUltYWdlV2lkdGg6IDUwOCxcblx0ICBkZXZpY2VJbWFnZUhlaWdodDogOTAwLFxuXHQgIGRldmljZUltYWdlSlAyOiB0cnVlLFxuXHQgIHNjcmVlbldpZHRoOiAyNzIsXG5cdCAgc2NyZWVuSGVpZ2h0OiAzNDAsXG5cdCAgbWF4U3R1ZGlvVmVyc2lvbjogb2xkRGV2aWNlTWF4VmVyc2lvblxuXHR9O1xuXHRcblx0RGV2aWNlcyA9IHtcblx0ICBcImZ1bGxzY3JlZW5cIjoge1xuXHQgICAgbmFtZTogXCJGdWxsc2NyZWVuXCIsXG5cdCAgICBkZXZpY2VUeXBlOiBcImRlc2t0b3BcIixcblx0ICAgIGJhY2tncm91bmRDb2xvcjogXCJ3aGl0ZVwiXG5cdCAgfSxcblx0ICBcImFwcGxlLWlwYWQtYWlyLTItc2lsdmVyXCI6IF8uY2xvbmUoaVBhZEFpcjJCYXNlRGV2aWNlKSxcblx0ICBcImFwcGxlLWlwYWQtYWlyLTItZ29sZFwiOiBfLmNsb25lKGlQYWRBaXIyQmFzZURldmljZSksXG5cdCAgXCJhcHBsZS1pcGFkLWFpci0yLXNwYWNlLWdyYXlcIjogXy5jbG9uZShpUGFkQWlyMkJhc2VEZXZpY2UpLFxuXHQgIFwiYXBwbGUtaXBhZC1taW5pLTQtc2lsdmVyXCI6IF8uY2xvbmUoaVBhZE1pbmk0QmFzZURldmljZSksXG5cdCAgXCJhcHBsZS1pcGFkLW1pbmktNC1nb2xkXCI6IF8uY2xvbmUoaVBhZE1pbmk0QmFzZURldmljZSksXG5cdCAgXCJhcHBsZS1pcGFkLW1pbmktNC1zcGFjZS1ncmF5XCI6IF8uY2xvbmUoaVBhZE1pbmk0QmFzZURldmljZSksXG5cdCAgXCJhcHBsZS1pcGFkLXByby1zaWx2ZXJcIjogXy5jbG9uZShpUGFkUHJvQmFzZURldmljZSksXG5cdCAgXCJhcHBsZS1pcGFkLXByby1nb2xkXCI6IF8uY2xvbmUoaVBhZFByb0Jhc2VEZXZpY2UpLFxuXHQgIFwiYXBwbGUtaXBhZC1wcm8tc3BhY2UtZ3JheVwiOiBfLmNsb25lKGlQYWRQcm9CYXNlRGV2aWNlKSxcblx0ICBcImFwcGxlLWlwaG9uZS02cy1nb2xkXCI6IF8uY2xvbmUoaVBob25lNkJhc2VEZXZpY2UpLFxuXHQgIFwiYXBwbGUtaXBob25lLTZzLXJvc2UtZ29sZFwiOiBfLmNsb25lKGlQaG9uZTZCYXNlRGV2aWNlKSxcblx0ICBcImFwcGxlLWlwaG9uZS02cy1zaWx2ZXJcIjogXy5jbG9uZShpUGhvbmU2QmFzZURldmljZSksXG5cdCAgXCJhcHBsZS1pcGhvbmUtNnMtc3BhY2UtZ3JheVwiOiBfLmNsb25lKGlQaG9uZTZCYXNlRGV2aWNlKSxcblx0ICBcImFwcGxlLWlwaG9uZS02cy1wbHVzLWdvbGRcIjogXy5jbG9uZShpUGhvbmU2UGx1c0Jhc2VEZXZpY2UpLFxuXHQgIFwiYXBwbGUtaXBob25lLTZzLXBsdXMtcm9zZS1nb2xkXCI6IF8uY2xvbmUoaVBob25lNlBsdXNCYXNlRGV2aWNlKSxcblx0ICBcImFwcGxlLWlwaG9uZS02cy1wbHVzLXNpbHZlclwiOiBfLmNsb25lKGlQaG9uZTZQbHVzQmFzZURldmljZSksXG5cdCAgXCJhcHBsZS1pcGhvbmUtNnMtcGx1cy1zcGFjZS1ncmF5XCI6IF8uY2xvbmUoaVBob25lNlBsdXNCYXNlRGV2aWNlKSxcblx0ICBcImFwcGxlLWlwaG9uZS01cy1nb2xkXCI6IF8uY2xvbmUoaVBob25lNUJhc2VEZXZpY2UpLFxuXHQgIFwiYXBwbGUtaXBob25lLTVzLXNpbHZlclwiOiBfLmNsb25lKGlQaG9uZTVCYXNlRGV2aWNlKSxcblx0ICBcImFwcGxlLWlwaG9uZS01cy1zcGFjZS1ncmF5XCI6IF8uY2xvbmUoaVBob25lNUJhc2VEZXZpY2UpLFxuXHQgIFwiYXBwbGUtaXBob25lLTVjLWJsdWVcIjogXy5jbG9uZShpUGhvbmU1Q0Jhc2VEZXZpY2UpLFxuXHQgIFwiYXBwbGUtaXBob25lLTVjLWdyZWVuXCI6IF8uY2xvbmUoaVBob25lNUNCYXNlRGV2aWNlKSxcblx0ICBcImFwcGxlLWlwaG9uZS01Yy1yZWRcIjogXy5jbG9uZShpUGhvbmU1Q0Jhc2VEZXZpY2UpLFxuXHQgIFwiYXBwbGUtaXBob25lLTVjLXdoaXRlXCI6IF8uY2xvbmUoaVBob25lNUNCYXNlRGV2aWNlKSxcblx0ICBcImFwcGxlLWlwaG9uZS01Yy15ZWxsb3dcIjogXy5jbG9uZShpUGhvbmU1Q0Jhc2VEZXZpY2UpLFxuXHQgIFwiYXBwbGUtd2F0Y2gtMzhtbS1nb2xkLWJsYWNrLWxlYXRoZXItY2xvc2VkXCI6IF8uY2xvbmUoQXBwbGVXYXRjaDM4QmxhY2tMZWF0aGVyRGV2aWNlKSxcblx0ICBcImFwcGxlLXdhdGNoLTM4bW0tcm9zZS1nb2xkLWJsYWNrLWxlYXRoZXItY2xvc2VkXCI6IF8uY2xvbmUoQXBwbGVXYXRjaDM4QmxhY2tMZWF0aGVyRGV2aWNlKSxcblx0ICBcImFwcGxlLXdhdGNoLTM4bW0tc3RhaW5sZXNzLXN0ZWVsLWJsYWNrLWxlYXRoZXItY2xvc2VkXCI6IF8uY2xvbmUoQXBwbGVXYXRjaDM4QmxhY2tMZWF0aGVyRGV2aWNlKSxcblx0ICBcImFwcGxlLXdhdGNoLTM4bW0tYmxhY2stc3RlZWwtYmxhY2stY2xvc2VkXCI6IF8uY2xvbmUoQXBwbGVXYXRjaDM4RGV2aWNlKSxcblx0ICBcImFwcGxlLXdhdGNoLTM4bW0tZ29sZC1taWRuaWdodC1ibHVlLWNsb3NlZFwiOiBfLmNsb25lKEFwcGxlV2F0Y2gzOERldmljZSksXG5cdCAgXCJhcHBsZS13YXRjaC0zOG1tLXJvc2UtZ29sZC1sYXZlbmRlci1jbG9zZWRcIjogXy5jbG9uZShBcHBsZVdhdGNoMzhEZXZpY2UpLFxuXHQgIFwiYXBwbGUtd2F0Y2gtMzhtbS1zcG9ydC1hbHVtaW51bS1ibHVlLWNsb3NlZFwiOiBfLmNsb25lKEFwcGxlV2F0Y2gzOERldmljZSksXG5cdCAgXCJhcHBsZS13YXRjaC0zOG1tLXNwb3J0LWFsdW1pbnVtLWZvZy1jbG9zZWRcIjogXy5jbG9uZShBcHBsZVdhdGNoMzhEZXZpY2UpLFxuXHQgIFwiYXBwbGUtd2F0Y2gtMzhtbS1zcG9ydC1hbHVtaW51bS1ncmVlbi1jbG9zZWRcIjogXy5jbG9uZShBcHBsZVdhdGNoMzhEZXZpY2UpLFxuXHQgIFwiYXBwbGUtd2F0Y2gtMzhtbS1zcG9ydC1hbHVtaW51bS1yZWQtY2xvc2VkXCI6IF8uY2xvbmUoQXBwbGVXYXRjaDM4RGV2aWNlKSxcblx0ICBcImFwcGxlLXdhdGNoLTM4bW0tc3BvcnQtYWx1bWludW0td2FsbnV0LWNsb3NlZFwiOiBfLmNsb25lKEFwcGxlV2F0Y2gzOERldmljZSksXG5cdCAgXCJhcHBsZS13YXRjaC0zOG1tLXNwb3J0LWFsdW1pbnVtLXdoaXRlLWNsb3NlZFwiOiBfLmNsb25lKEFwcGxlV2F0Y2gzOERldmljZSksXG5cdCAgXCJhcHBsZS13YXRjaC0zOG1tLXNwb3J0LWFsdW1pbnVtLWdvbGQtYW50aXF1ZS13aGl0ZS1jbG9zZWRcIjogXy5jbG9uZShBcHBsZVdhdGNoMzhEZXZpY2UpLFxuXHQgIFwiYXBwbGUtd2F0Y2gtMzhtbS1zcG9ydC1hbHVtaW51bS1yb3NlLWdvbGQtc3RvbmUtY2xvc2VkXCI6IF8uY2xvbmUoQXBwbGVXYXRjaDM4RGV2aWNlKSxcblx0ICBcImFwcGxlLXdhdGNoLTM4bW0tc3BvcnQtc3BhY2UtZ3JheS1ibGFjay1jbG9zZWRcIjogXy5jbG9uZShBcHBsZVdhdGNoMzhEZXZpY2UpLFxuXHQgIFwiYXBwbGUtd2F0Y2gtNDJtbS1ibGFjay1zdGVlbC1ibGFjay1jbG9zZWRcIjogXy5jbG9uZShBcHBsZVdhdGNoNDJEZXZpY2UpLFxuXHQgIFwiYXBwbGUtd2F0Y2gtNDJtbS1nb2xkLWJsYWNrLWxlYXRoZXItY2xvc2VkXCI6IF8uY2xvbmUoQXBwbGVXYXRjaDQyRGV2aWNlKSxcblx0ICBcImFwcGxlLXdhdGNoLTQybW0tZ29sZC1taWRuaWdodC1ibHVlLWNsb3NlZFwiOiBfLmNsb25lKEFwcGxlV2F0Y2g0MkRldmljZSksXG5cdCAgXCJhcHBsZS13YXRjaC00Mm1tLXJvc2UtZ29sZC1ibGFjay1sZWF0aGVyLWNsb3NlZFwiOiBfLmNsb25lKEFwcGxlV2F0Y2g0MkRldmljZSksXG5cdCAgXCJhcHBsZS13YXRjaC00Mm1tLXJvc2UtZ29sZC1sYXZlbmRlci1jbG9zZWRcIjogXy5jbG9uZShBcHBsZVdhdGNoNDJEZXZpY2UpLFxuXHQgIFwiYXBwbGUtd2F0Y2gtNDJtbS1zcG9ydC1hbHVtaW51bS1ibHVlLWNsb3NlZFwiOiBfLmNsb25lKEFwcGxlV2F0Y2g0MkRldmljZSksXG5cdCAgXCJhcHBsZS13YXRjaC00Mm1tLXNwb3J0LWFsdW1pbnVtLWZvZy1jbG9zZWRcIjogXy5jbG9uZShBcHBsZVdhdGNoNDJEZXZpY2UpLFxuXHQgIFwiYXBwbGUtd2F0Y2gtNDJtbS1zcG9ydC1hbHVtaW51bS1ncmVlbi1jbG9zZWRcIjogXy5jbG9uZShBcHBsZVdhdGNoNDJEZXZpY2UpLFxuXHQgIFwiYXBwbGUtd2F0Y2gtNDJtbS1zcG9ydC1hbHVtaW51bS1yZWQtY2xvc2VkXCI6IF8uY2xvbmUoQXBwbGVXYXRjaDQyRGV2aWNlKSxcblx0ICBcImFwcGxlLXdhdGNoLTQybW0tc3BvcnQtYWx1bWludW0td2FsbnV0LWNsb3NlZFwiOiBfLmNsb25lKEFwcGxlV2F0Y2g0MkRldmljZSksXG5cdCAgXCJhcHBsZS13YXRjaC00Mm1tLXNwb3J0LWFsdW1pbnVtLXdoaXRlLWNsb3NlZFwiOiBfLmNsb25lKEFwcGxlV2F0Y2g0MkRldmljZSksXG5cdCAgXCJhcHBsZS13YXRjaC00Mm1tLXNwb3J0LWFsdW1pbnVtLWdvbGQtYW50aXF1ZS13aGl0ZS1jbG9zZWRcIjogXy5jbG9uZShBcHBsZVdhdGNoNDJEZXZpY2UpLFxuXHQgIFwiYXBwbGUtd2F0Y2gtNDJtbS1zcG9ydC1hbHVtaW51bS1yb3NlLWdvbGQtc3RvbmUtY2xvc2VkXCI6IF8uY2xvbmUoQXBwbGVXYXRjaDQyRGV2aWNlKSxcblx0ICBcImFwcGxlLXdhdGNoLTQybW0tc3BvcnQtc3BhY2UtZ3JheS1ibGFjay1jbG9zZWRcIjogXy5jbG9uZShBcHBsZVdhdGNoNDJEZXZpY2UpLFxuXHQgIFwiYXBwbGUtd2F0Y2gtNDJtbS1zdGFpbmxlc3Mtc3RlZWwtYmxhY2stbGVhdGhlci1jbG9zZWRcIjogXy5jbG9uZShBcHBsZVdhdGNoNDJEZXZpY2UpLFxuXHQgIFwiZ29vZ2xlLW5leHVzLTRcIjogXy5jbG9uZShOZXh1czRCYXNlRGV2aWNlKSxcblx0ICBcImdvb2dsZS1uZXh1cy01eFwiOiBfLmNsb25lKE5leHVzNUJhc2VEZXZpY2UpLFxuXHQgIFwiZ29vZ2xlLW5leHVzLTZwXCI6IF8uY2xvbmUoTmV4dXM2QmFzZURldmljZSksXG5cdCAgXCJnb29nbGUtbmV4dXMtOVwiOiBfLmNsb25lKE5leHVzOUJhc2VEZXZpY2UpLFxuXHQgIFwiaHRjLW9uZS1hOS1ibGFja1wiOiBfLmNsb25lKEhUQ2E5QmFzZURldmljZSksXG5cdCAgXCJodGMtb25lLWE5LXdoaXRlXCI6IF8uY2xvbmUoSFRDYTlCYXNlRGV2aWNlKSxcblx0ICBcImh0Yy1vbmUtbTgtYmxhY2tcIjogXy5jbG9uZShIVENtOEJhc2VEZXZpY2UpLFxuXHQgIFwiaHRjLW9uZS1tOC1nb2xkXCI6IF8uY2xvbmUoSFRDbThCYXNlRGV2aWNlKSxcblx0ICBcImh0Yy1vbmUtbTgtc2lsdmVyXCI6IF8uY2xvbmUoSFRDbThCYXNlRGV2aWNlKSxcblx0ICBcIm1pY3Jvc29mdC1sdW1pYS05NTAtYmxhY2tcIjogXy5jbG9uZShNU0ZUTHVtaWE5NTBCYXNlRGV2aWNlKSxcblx0ICBcIm1pY3Jvc29mdC1sdW1pYS05NTAtd2hpdGVcIjogXy5jbG9uZShNU0ZUTHVtaWE5NTBCYXNlRGV2aWNlKSxcblx0ICBcInNhbXN1bmctZ2FsYXh5LW5vdGUtNS1ibGFja1wiOiBfLmNsb25lKFNhbXN1bmdHYWxheHlOb3RlNUJhc2VEZXZpY2UpLFxuXHQgIFwic2Ftc3VuZy1nYWxheHktbm90ZS01LWdvbGRcIjogXy5jbG9uZShTYW1zdW5nR2FsYXh5Tm90ZTVCYXNlRGV2aWNlKSxcblx0ICBcInNhbXN1bmctZ2FsYXh5LW5vdGUtNS1waW5rXCI6IF8uY2xvbmUoU2Ftc3VuZ0dhbGF4eU5vdGU1QmFzZURldmljZSksXG5cdCAgXCJzYW1zdW5nLWdhbGF4eS1ub3RlLTUtc2lsdmVyLXRpdGFuaXVtXCI6IF8uY2xvbmUoU2Ftc3VuZ0dhbGF4eU5vdGU1QmFzZURldmljZSksXG5cdCAgXCJzYW1zdW5nLWdhbGF4eS1ub3RlLTUtd2hpdGVcIjogXy5jbG9uZShTYW1zdW5nR2FsYXh5Tm90ZTVCYXNlRGV2aWNlKSxcblx0ICBcImRlc2t0b3Atc2FmYXJpLTEwMjQtNjAwXCI6IHtcblx0ICAgIGRldmljZVR5cGU6IFwiYnJvd3NlclwiLFxuXHQgICAgbmFtZTogXCJEZXNrdG9wIFNhZmFyaSAxMDI0IHggNjAwXCIsXG5cdCAgICBzY3JlZW5XaWR0aDogMTAyNCxcblx0ICAgIHNjcmVlbkhlaWdodDogNjAwLFxuXHQgICAgZGV2aWNlSW1hZ2VXaWR0aDogMTEzNixcblx0ICAgIGRldmljZUltYWdlSGVpZ2h0OiA3NjAsXG5cdCAgICBkZXZpY2VJbWFnZUpQMjogdHJ1ZSxcblx0ICAgIGJhY2tncm91bmRDb2xvcjogXCJ3aGl0ZVwiXG5cdCAgfSxcblx0ICBcImRlc2t0b3Atc2FmYXJpLTEyODAtODAwXCI6IHtcblx0ICAgIGRldmljZVR5cGU6IFwiYnJvd3NlclwiLFxuXHQgICAgbmFtZTogXCJEZXNrdG9wIFNhZmFyaSAxMjgwIHggODAwXCIsXG5cdCAgICBzY3JlZW5XaWR0aDogMTI4MCxcblx0ICAgIHNjcmVlbkhlaWdodDogODAwLFxuXHQgICAgZGV2aWNlSW1hZ2VXaWR0aDogMTM5Mixcblx0ICAgIGRldmljZUltYWdlSGVpZ2h0OiA5NjAsXG5cdCAgICBkZXZpY2VJbWFnZUpQMjogdHJ1ZSxcblx0ICAgIGJhY2tncm91bmRDb2xvcjogXCJ3aGl0ZVwiXG5cdCAgfSxcblx0ICBcImRlc2t0b3Atc2FmYXJpLTE0NDAtOTAwXCI6IHtcblx0ICAgIGRldmljZVR5cGU6IFwiYnJvd3NlclwiLFxuXHQgICAgbmFtZTogXCJEZXNrdG9wIFNhZmFyaSAxNDQwIHggOTAwXCIsXG5cdCAgICBzY3JlZW5XaWR0aDogMTQ0MCxcblx0ICAgIHNjcmVlbkhlaWdodDogOTAwLFxuXHQgICAgZGV2aWNlSW1hZ2VXaWR0aDogMTU1Mixcblx0ICAgIGRldmljZUltYWdlSGVpZ2h0OiAxMDYwLFxuXHQgICAgZGV2aWNlSW1hZ2VKUDI6IHRydWUsXG5cdCAgICBiYWNrZ3JvdW5kQ29sb3I6IFwid2hpdGVcIlxuXHQgIH0sXG5cdCAgXCJpcGhvbmUtNi1zcGFjZWdyYXlcIjogXy5jbG9uZShvbGRfaVBob25lNkJhc2VEZXZpY2UpLFxuXHQgIFwiaXBob25lLTYtc3BhY2VncmF5LWhhbmRcIjogXy5jbG9uZShvbGRfaVBob25lNkJhc2VEZXZpY2VIYW5kKSxcblx0ICBcImlwaG9uZS02LXNpbHZlclwiOiBfLmNsb25lKG9sZF9pUGhvbmU2QmFzZURldmljZSksXG5cdCAgXCJpcGhvbmUtNi1zaWx2ZXItaGFuZFwiOiBfLmNsb25lKG9sZF9pUGhvbmU2QmFzZURldmljZUhhbmQpLFxuXHQgIFwiaXBob25lLTYtZ29sZFwiOiBfLmNsb25lKG9sZF9pUGhvbmU2QmFzZURldmljZSksXG5cdCAgXCJpcGhvbmUtNi1nb2xkLWhhbmRcIjogXy5jbG9uZShvbGRfaVBob25lNkJhc2VEZXZpY2VIYW5kKSxcblx0ICBcImlwaG9uZS02cGx1cy1zcGFjZWdyYXlcIjogXy5jbG9uZShvbGRfaVBob25lNlBsdXNCYXNlRGV2aWNlKSxcblx0ICBcImlwaG9uZS02cGx1cy1zcGFjZWdyYXktaGFuZFwiOiBfLmNsb25lKG9sZF9pUGhvbmU2UGx1c0Jhc2VEZXZpY2VIYW5kKSxcblx0ICBcImlwaG9uZS02cGx1cy1zaWx2ZXJcIjogXy5jbG9uZShvbGRfaVBob25lNlBsdXNCYXNlRGV2aWNlKSxcblx0ICBcImlwaG9uZS02cGx1cy1zaWx2ZXItaGFuZFwiOiBfLmNsb25lKG9sZF9pUGhvbmU2UGx1c0Jhc2VEZXZpY2VIYW5kKSxcblx0ICBcImlwaG9uZS02cGx1cy1nb2xkXCI6IF8uY2xvbmUob2xkX2lQaG9uZTZQbHVzQmFzZURldmljZSksXG5cdCAgXCJpcGhvbmUtNnBsdXMtZ29sZC1oYW5kXCI6IF8uY2xvbmUob2xkX2lQaG9uZTZQbHVzQmFzZURldmljZUhhbmQpLFxuXHQgIFwiaXBob25lLTVzLXNwYWNlZ3JheVwiOiBfLmNsb25lKG9sZF9pUGhvbmU1QmFzZURldmljZSksXG5cdCAgXCJpcGhvbmUtNXMtc3BhY2VncmF5LWhhbmRcIjogXy5jbG9uZShvbGRfaVBob25lNUJhc2VEZXZpY2VIYW5kKSxcblx0ICBcImlwaG9uZS01cy1zaWx2ZXJcIjogXy5jbG9uZShvbGRfaVBob25lNUJhc2VEZXZpY2UpLFxuXHQgIFwiaXBob25lLTVzLXNpbHZlci1oYW5kXCI6IF8uY2xvbmUob2xkX2lQaG9uZTVCYXNlRGV2aWNlSGFuZCksXG5cdCAgXCJpcGhvbmUtNXMtZ29sZFwiOiBfLmNsb25lKG9sZF9pUGhvbmU1QmFzZURldmljZSksXG5cdCAgXCJpcGhvbmUtNXMtZ29sZC1oYW5kXCI6IF8uY2xvbmUob2xkX2lQaG9uZTVCYXNlRGV2aWNlSGFuZCksXG5cdCAgXCJpcGhvbmUtNWMtZ3JlZW5cIjogXy5jbG9uZShvbGRfaVBob25lNUNCYXNlRGV2aWNlKSxcblx0ICBcImlwaG9uZS01Yy1ncmVlbi1oYW5kXCI6IF8uY2xvbmUob2xkX2lQaG9uZTVDQmFzZURldmljZUhhbmQpLFxuXHQgIFwiaXBob25lLTVjLWJsdWVcIjogXy5jbG9uZShvbGRfaVBob25lNUNCYXNlRGV2aWNlKSxcblx0ICBcImlwaG9uZS01Yy1ibHVlLWhhbmRcIjogXy5jbG9uZShvbGRfaVBob25lNUNCYXNlRGV2aWNlSGFuZCksXG5cdCAgXCJpcGhvbmUtNWMtcGlua1wiOiBfLmNsb25lKG9sZF9pUGhvbmU1Q0Jhc2VEZXZpY2UpLFxuXHQgIFwiaXBob25lLTVjLXBpbmstaGFuZFwiOiBfLmNsb25lKG9sZF9pUGhvbmU1Q0Jhc2VEZXZpY2VIYW5kKSxcblx0ICBcImlwaG9uZS01Yy13aGl0ZVwiOiBfLmNsb25lKG9sZF9pUGhvbmU1Q0Jhc2VEZXZpY2UpLFxuXHQgIFwiaXBob25lLTVjLXdoaXRlLWhhbmRcIjogXy5jbG9uZShvbGRfaVBob25lNUNCYXNlRGV2aWNlSGFuZCksXG5cdCAgXCJpcGhvbmUtNWMteWVsbG93XCI6IF8uY2xvbmUob2xkX2lQaG9uZTVDQmFzZURldmljZSksXG5cdCAgXCJpcGhvbmUtNWMteWVsbG93LWhhbmRcIjogXy5jbG9uZShvbGRfaVBob25lNUNCYXNlRGV2aWNlSGFuZCksXG5cdCAgXCJpcGFkLW1pbmktc3BhY2VncmF5XCI6IF8uY2xvbmUob2xkX2lQYWRNaW5pQmFzZURldmljZSksXG5cdCAgXCJpcGFkLW1pbmktc3BhY2VncmF5LWhhbmRcIjogXy5jbG9uZShvbGRfaVBhZE1pbmlCYXNlRGV2aWNlSGFuZCksXG5cdCAgXCJpcGFkLW1pbmktc2lsdmVyXCI6IF8uY2xvbmUob2xkX2lQYWRNaW5pQmFzZURldmljZSksXG5cdCAgXCJpcGFkLW1pbmktc2lsdmVyLWhhbmRcIjogXy5jbG9uZShvbGRfaVBhZE1pbmlCYXNlRGV2aWNlSGFuZCksXG5cdCAgXCJpcGFkLWFpci1zcGFjZWdyYXlcIjogXy5jbG9uZShvbGRfaVBhZEFpckJhc2VEZXZpY2UpLFxuXHQgIFwiaXBhZC1haXItc3BhY2VncmF5LWhhbmRcIjogXy5jbG9uZShvbGRfaVBhZEFpckJhc2VEZXZpY2VIYW5kKSxcblx0ICBcImlwYWQtYWlyLXNpbHZlclwiOiBfLmNsb25lKG9sZF9pUGFkQWlyQmFzZURldmljZSksXG5cdCAgXCJpcGFkLWFpci1zaWx2ZXItaGFuZFwiOiBfLmNsb25lKG9sZF9pUGFkQWlyQmFzZURldmljZUhhbmQpLFxuXHQgIFwibmV4dXMtNS1ibGFja1wiOiBfLmNsb25lKG9sZF9OZXh1czVCYXNlRGV2aWNlKSxcblx0ICBcIm5leHVzLTUtYmxhY2staGFuZFwiOiBfLmNsb25lKG9sZF9OZXh1czVCYXNlRGV2aWNlSGFuZCksXG5cdCAgXCJuZXh1cy05XCI6IF8uY2xvbmUob2xkX05leHVzOUJhc2VEZXZpY2UpLFxuXHQgIFwiYXBwbGV3YXRjaHNwb3J0LTM4LWFsdW1pbnVtLXNwb3J0YmFuZC1ibGFja1wiOiBfLmNsb25lKG9sZF9BcHBsZVdhdGNoMzhEZXZpY2UpLFxuXHQgIFwiYXBwbGV3YXRjaHNwb3J0LTM4LWFsdW1pbnVtLXNwb3J0YmFuZC1ibHVlXCI6IF8uY2xvbmUob2xkX0FwcGxlV2F0Y2gzOERldmljZSksXG5cdCAgXCJhcHBsZXdhdGNoc3BvcnQtMzgtYWx1bWludW0tc3BvcnRiYW5kLWdyZWVuXCI6IF8uY2xvbmUob2xkX0FwcGxlV2F0Y2gzOERldmljZSksXG5cdCAgXCJhcHBsZXdhdGNoc3BvcnQtMzgtYWx1bWludW0tc3BvcnRiYW5kLXBpbmtcIjogXy5jbG9uZShvbGRfQXBwbGVXYXRjaDM4RGV2aWNlKSxcblx0ICBcImFwcGxld2F0Y2hzcG9ydC0zOC1hbHVtaW51bS1zcG9ydGJhbmQtd2hpdGVcIjogXy5jbG9uZShvbGRfQXBwbGVXYXRjaDM4RGV2aWNlKSxcblx0ICBcImFwcGxld2F0Y2gtMzgtYmxhY2stYnJhY2VsZXRcIjogXy5jbG9uZShvbGRfQXBwbGVXYXRjaDM4RGV2aWNlKSxcblx0ICBcImFwcGxld2F0Y2gtMzgtc3RlZWwtYnJhY2VsZXRcIjogXy5jbG9uZShvbGRfQXBwbGVXYXRjaDM4RGV2aWNlKSxcblx0ICBcImFwcGxld2F0Y2hlZGl0aW9uLTM4LWdvbGQtYnVja2xlLWJsdWVcIjogXy5jbG9uZShvbGRfQXBwbGVXYXRjaDM4RGV2aWNlKSxcblx0ICBcImFwcGxld2F0Y2hlZGl0aW9uLTM4LWdvbGQtYnVja2xlLWdyYXlcIjogXy5jbG9uZShvbGRfQXBwbGVXYXRjaDM4RGV2aWNlKSxcblx0ICBcImFwcGxld2F0Y2hlZGl0aW9uLTM4LWdvbGQtYnVja2xlLXJlZFwiOiBfLmNsb25lKG9sZF9BcHBsZVdhdGNoMzhEZXZpY2UpLFxuXHQgIFwiYXBwbGV3YXRjaGVkaXRpb24tMzgtZ29sZC1zcG9ydGJhbmQtYmxhY2tcIjogXy5jbG9uZShvbGRfQXBwbGVXYXRjaDM4RGV2aWNlKSxcblx0ICBcImFwcGxld2F0Y2hlZGl0aW9uLTM4LWdvbGQtc3BvcnRiYW5kLXdoaXRlXCI6IF8uY2xvbmUob2xkX0FwcGxlV2F0Y2gzOERldmljZSksXG5cdCAgXCJhcHBsZXdhdGNoc3BvcnQtNDItYWx1bWludW0tc3BvcnRiYW5kLWJsYWNrXCI6IF8uY2xvbmUob2xkX0FwcGxlV2F0Y2g0MkRldmljZSksXG5cdCAgXCJhcHBsZXdhdGNoc3BvcnQtNDItYWx1bWludW0tc3BvcnRiYW5kLWJsdWVcIjogXy5jbG9uZShvbGRfQXBwbGVXYXRjaDQyRGV2aWNlKSxcblx0ICBcImFwcGxld2F0Y2hzcG9ydC00Mi1hbHVtaW51bS1zcG9ydGJhbmQtZ3JlZW5cIjogXy5jbG9uZShvbGRfQXBwbGVXYXRjaDQyRGV2aWNlKSxcblx0ICBcImFwcGxld2F0Y2hzcG9ydC00Mi1hbHVtaW51bS1zcG9ydGJhbmQtcGlua1wiOiBfLmNsb25lKG9sZF9BcHBsZVdhdGNoNDJEZXZpY2UpLFxuXHQgIFwiYXBwbGV3YXRjaHNwb3J0LTQyLWFsdW1pbnVtLXNwb3J0YmFuZC13aGl0ZVwiOiBfLmNsb25lKG9sZF9BcHBsZVdhdGNoNDJEZXZpY2UpLFxuXHQgIFwiYXBwbGV3YXRjaC00Mi1ibGFjay1icmFjZWxldFwiOiBfLmNsb25lKG9sZF9BcHBsZVdhdGNoNDJEZXZpY2UpLFxuXHQgIFwiYXBwbGV3YXRjaC00Mi1zdGVlbC1icmFjZWxldFwiOiBfLmNsb25lKG9sZF9BcHBsZVdhdGNoNDJEZXZpY2UpLFxuXHQgIFwiYXBwbGV3YXRjaGVkaXRpb24tNDItZ29sZC1idWNrbGUtYmx1ZVwiOiBfLmNsb25lKG9sZF9BcHBsZVdhdGNoNDJEZXZpY2UpLFxuXHQgIFwiYXBwbGV3YXRjaGVkaXRpb24tNDItZ29sZC1idWNrbGUtZ3JheVwiOiBfLmNsb25lKG9sZF9BcHBsZVdhdGNoNDJEZXZpY2UpLFxuXHQgIFwiYXBwbGV3YXRjaGVkaXRpb24tNDItZ29sZC1idWNrbGUtcmVkXCI6IF8uY2xvbmUob2xkX0FwcGxlV2F0Y2g0MkRldmljZSksXG5cdCAgXCJhcHBsZXdhdGNoZWRpdGlvbi00Mi1nb2xkLXNwb3J0YmFuZC1ibGFja1wiOiBfLmNsb25lKG9sZF9BcHBsZVdhdGNoNDJEZXZpY2UpLFxuXHQgIFwiYXBwbGV3YXRjaGVkaXRpb24tNDItZ29sZC1zcG9ydGJhbmQtd2hpdGVcIjogXy5jbG9uZShvbGRfQXBwbGVXYXRjaDQyRGV2aWNlKVxuXHR9O1xuXHRcblx0ZXhwb3J0cy5EZXZpY2VDb21wb25lbnQuRGV2aWNlcyA9IERldmljZXM7XG5cdFxuXHRCdWlsdEluRGV2aWNlcyA9IF8ua2V5cyhEZXZpY2VzKTtcblxuXG4vKioqLyB9LFxuLyogNDcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBDb25maWcsIEV2ZW50RW1pdHRlciwgVXRpbHMsIF8sIGdldFRpbWUsXG5cdCAgYmluZCA9IGZ1bmN0aW9uKGZuLCBtZSl7IHJldHVybiBmdW5jdGlvbigpeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH0sXG5cdCAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuXHQgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblx0XG5cdF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpLl87XG5cdFxuXHRVdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdFxuXHRDb25maWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KS5Db25maWc7XG5cdFxuXHRFdmVudEVtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpLkV2ZW50RW1pdHRlcjtcblx0XG5cdGdldFRpbWUgPSBmdW5jdGlvbigpIHtcblx0ICByZXR1cm4gVXRpbHMuZ2V0VGltZSgpICogMTAwMDtcblx0fTtcblx0XG5cdGV4cG9ydHMuQW5pbWF0aW9uTG9vcCA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG5cdCAgZXh0ZW5kKEFuaW1hdGlvbkxvb3AsIHN1cGVyQ2xhc3MpO1xuXHRcblx0ICBmdW5jdGlvbiBBbmltYXRpb25Mb29wKCkge1xuXHQgICAgdGhpcy5zdGFydCA9IGJpbmQodGhpcy5zdGFydCwgdGhpcyk7XG5cdCAgICB0aGlzLmRlbHRhID0gMSAvIDYwO1xuXHQgICAgdGhpcy5yYWYgPSB0cnVlO1xuXHQgICAgaWYgKFV0aWxzLndlYmtpdFZlcnNpb24oKSA+IDYwMCAmJiBVdGlscy53ZWJraXRWZXJzaW9uKCkgPCA2MDEpIHtcblx0ICAgICAgaWYgKFV0aWxzLmlzRnJhbWVyU3R1ZGlvKCkgfHwgVXRpbHMuaXNEZXNrdG9wKCkpIHtcblx0ICAgICAgICB0aGlzLnJhZiA9IGZhbHNlO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICB0aGlzLm1heGltdW1MaXN0ZW5lcnMgPSBJbmZpbml0eTtcblx0ICB9XG5cdFxuXHQgIEFuaW1hdGlvbkxvb3AucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgX3RpbWVzdGFtcCwgYW5pbWF0aW9uTG9vcCwgdGljaywgdXBkYXRlO1xuXHQgICAgYW5pbWF0aW9uTG9vcCA9IHRoaXM7XG5cdCAgICBfdGltZXN0YW1wID0gZ2V0VGltZSgpO1xuXHQgICAgdXBkYXRlID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgIHZhciBkZWx0YSwgdGltZXN0YW1wO1xuXHQgICAgICBpZiAoYW5pbWF0aW9uTG9vcC5kZWx0YSkge1xuXHQgICAgICAgIGRlbHRhID0gYW5pbWF0aW9uTG9vcC5kZWx0YTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB0aW1lc3RhbXAgPSBnZXRUaW1lKCk7XG5cdCAgICAgICAgZGVsdGEgPSAodGltZXN0YW1wIC0gX3RpbWVzdGFtcCkgLyAxMDAwO1xuXHQgICAgICAgIF90aW1lc3RhbXAgPSB0aW1lc3RhbXA7XG5cdCAgICAgIH1cblx0ICAgICAgYW5pbWF0aW9uTG9vcC5lbWl0KFwidXBkYXRlXCIsIGRlbHRhKTtcblx0ICAgICAgcmV0dXJuIGFuaW1hdGlvbkxvb3AuZW1pdChcInJlbmRlclwiLCBkZWx0YSk7XG5cdCAgICB9O1xuXHQgICAgdGljayA9IGZ1bmN0aW9uKHRpbWVzdGFtcCkge1xuXHQgICAgICBpZiAoYW5pbWF0aW9uTG9vcC5yYWYpIHtcblx0ICAgICAgICB1cGRhdGUoKTtcblx0ICAgICAgICByZXR1cm4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aWNrKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICB1cGRhdGUoKTtcblx0ICAgICAgICAgIHJldHVybiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRpY2spO1xuXHQgICAgICAgIH0sIDApO1xuXHQgICAgICB9XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIHRpY2soKTtcblx0ICB9O1xuXHRcblx0ICByZXR1cm4gQW5pbWF0aW9uTG9vcDtcblx0XG5cdH0pKEV2ZW50RW1pdHRlcik7XG5cblxuLyoqKi8gfSxcbi8qIDQ4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgQ2hyb21lQWxlcnQsIFV0aWxzLCBfLCBnZXRTY2FsZUZyb21OYW1lLCByZXNpemVGcmFtZSwgc2FuaXRpemVMYXllck5hbWUsIHN0YXJ0c1dpdGhOdW1iZXI7XG5cdFxuXHRfID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKS5fO1xuXHRcblx0VXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHRcblx0Q2hyb21lQWxlcnQgPSBcIkltcG9ydGluZyBsYXllcnMgaXMgY3VycmVudGx5IG9ubHkgc3VwcG9ydGVkIG9uIFNhZmFyaS4gSWYgeW91IHJlYWxseSB3YW50IGl0IHRvIHdvcmsgd2l0aCBDaHJvbWUgcXVpdCBpdCwgb3BlbiBhIHRlcm1pbmFsIGFuZCBydW46XFxub3BlbiAtYSBHb29nbGVcXCBDaHJvbWUgLeKAk2FsbG93LWZpbGUtYWNjZXNzLWZyb20tZmlsZXNcIjtcblx0XG5cdHJlc2l6ZUZyYW1lID0gZnVuY3Rpb24oc2NhbGUsIGZyYW1lKSB7XG5cdCAgdmFyIGksIGtleSwgbGVuLCByZWYsIHJlc3VsdDtcblx0ICBpZiAoc2NhbGUgPT09IDEpIHtcblx0ICAgIHJldHVybiBmcmFtZTtcblx0ICB9XG5cdCAgcmVzdWx0ID0ge307XG5cdCAgcmVmID0gW1wieFwiLCBcInlcIiwgXCJ3aWR0aFwiLCBcImhlaWdodFwiXTtcblx0ICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0ICAgIGtleSA9IHJlZltpXTtcblx0ICAgIGlmIChmcmFtZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdCAgICAgIHJlc3VsdFtrZXldID0gZnJhbWVba2V5XSAqIHNjYWxlO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXHRcblx0Z2V0U2NhbGVGcm9tTmFtZSA9IGZ1bmN0aW9uKHN0cikge1xuXHQgIHZhciBtLCByZTtcblx0ICByZSA9IC9AKFtcXGRdK3xbXFxkXSsuW1xcZF0rKXgvO1xuXHQgIG0gPSB2b2lkIDA7XG5cdCAgaWYgKChtID0gcmUuZXhlYyhzdHIpKSAhPT0gbnVsbCkge1xuXHQgICAgaWYgKG1bMV0pIHtcblx0ICAgICAgcmV0dXJuIHBhcnNlRmxvYXQobVsxXSk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiBudWxsO1xuXHR9O1xuXHRcblx0c3RhcnRzV2l0aE51bWJlciA9IGZ1bmN0aW9uKHN0cikge1xuXHQgIHJldHVybiAobmV3IFJlZ0V4cChcIl5bMC05XVwiKSkudGVzdChzdHIpO1xuXHR9O1xuXHRcblx0c2FuaXRpemVMYXllck5hbWUgPSBmdW5jdGlvbihuYW1lKSB7XG5cdCAgdmFyIGksIGxlbiwgcmVmLCBzdWZmaXg7XG5cdCAgcmVmID0gW1wiKlwiLCBcIi1cIiwgXCIucG5nXCIsIFwiLmpwZ1wiLCBcIi5wZGZcIl07XG5cdCAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICBzdWZmaXggPSByZWZbaV07XG5cdCAgICBpZiAoXy5lbmRzV2l0aChuYW1lLnRvTG93ZXJDYXNlKCksIHN1ZmZpeCkpIHtcblx0ICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgKyhuYW1lLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGggLSAxKSArIDEgfHwgOWU5KTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIG5hbWU7XG5cdH07XG5cdFxuXHRleHBvcnRzLkltcG9ydGVyID0gKGZ1bmN0aW9uKCkge1xuXHQgIGZ1bmN0aW9uIEltcG9ydGVyKHBhdGgxLCBzY2FsZTEsIGV4dHJhTGF5ZXJQcm9wZXJ0aWVzKSB7XG5cdCAgICB0aGlzLnBhdGggPSBwYXRoMTtcblx0ICAgIHRoaXMuc2NhbGUgPSBzY2FsZTEgIT0gbnVsbCA/IHNjYWxlMSA6IDE7XG5cdCAgICB0aGlzLmV4dHJhTGF5ZXJQcm9wZXJ0aWVzID0gZXh0cmFMYXllclByb3BlcnRpZXMgIT0gbnVsbCA/IGV4dHJhTGF5ZXJQcm9wZXJ0aWVzIDoge307XG5cdCAgICB0aGlzLnBhdGhzID0ge1xuXHQgICAgICBsYXllckluZm86IFV0aWxzLnBhdGhKb2luKHRoaXMucGF0aCwgXCJsYXllcnMuanNvblwiKSxcblx0ICAgICAgaW1hZ2VzOiBVdGlscy5wYXRoSm9pbih0aGlzLnBhdGgsIFwiaW1hZ2VzXCIpLFxuXHQgICAgICBkb2N1bWVudE5hbWU6IHRoaXMucGF0aC5zcGxpdChcIi9cIikucG9wKClcblx0ICAgIH07XG5cdCAgICB0aGlzLl9jcmVhdGVkTGF5ZXJzID0gW107XG5cdCAgICB0aGlzLl9jcmVhdGVkTGF5ZXJzQnlOYW1lID0ge307XG5cdCAgfVxuXHRcblx0ICBJbXBvcnRlci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIGksIGosIGxheWVyLCBsYXllckluZm8sIGxheWVyc0J5TmFtZSwgbGVuLCBsZW4xLCByZWYsIHJlZjE7XG5cdCAgICBsYXllcnNCeU5hbWUgPSB7fTtcblx0ICAgIGxheWVySW5mbyA9IHRoaXMuX2xvYWRsYXllckluZm8oKTtcblx0ICAgIGlmIChsYXllckluZm8ubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcihcIkltcG9ydGVyOiBubyBsYXllcnMuIERvIHlvdSBoYXZlIGF0IGxlYXN0IG9uZSBsYXllciBncm91cD9cIik7XG5cdCAgICB9XG5cdCAgICBsYXllckluZm8ubWFwKChmdW5jdGlvbihfdGhpcykge1xuXHQgICAgICByZXR1cm4gZnVuY3Rpb24obGF5ZXJJdGVtSW5mbykge1xuXHQgICAgICAgIHJldHVybiBfdGhpcy5fY3JlYXRlTGF5ZXIobGF5ZXJJdGVtSW5mbyk7XG5cdCAgICAgIH07XG5cdCAgICB9KSh0aGlzKSk7XG5cdCAgICByZWYgPSB0aGlzLl9jcmVhdGVkTGF5ZXJzO1xuXHQgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICAgIGxheWVyID0gcmVmW2ldO1xuXHQgICAgICB0aGlzLl9jb3JyZWN0TGF5ZXIobGF5ZXIpO1xuXHQgICAgfVxuXHQgICAgdGhpcy5fY29ycmVjdEFydGJvYXJkcyh0aGlzLl9jcmVhdGVkTGF5ZXJzKTtcblx0ICAgIHJlZjEgPSB0aGlzLl9jcmVhdGVkTGF5ZXJzO1xuXHQgICAgZm9yIChqID0gMCwgbGVuMSA9IHJlZjEubGVuZ3RoOyBqIDwgbGVuMTsgaisrKSB7XG5cdCAgICAgIGxheWVyID0gcmVmMVtqXTtcblx0ICAgICAgaWYgKCFsYXllci5wYXJlbnQpIHtcblx0ICAgICAgICBsYXllci5wYXJlbnQgPSBudWxsO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcy5fY3JlYXRlZExheWVyc0J5TmFtZTtcblx0ICB9O1xuXHRcblx0ICBJbXBvcnRlci5wcm90b3R5cGUuX2xvYWRsYXllckluZm8gPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciBpbXBvcnRlZEtleSwgcmVmO1xuXHQgICAgaW1wb3J0ZWRLZXkgPSB0aGlzLnBhdGhzLmRvY3VtZW50TmFtZSArIFwiL2xheWVycy5qc29uLmpzXCI7XG5cdCAgICBpZiAoKHJlZiA9IHdpbmRvdy5fX2ltcG9ydGVkX18pICE9IG51bGwgPyByZWYuaGFzT3duUHJvcGVydHkoaW1wb3J0ZWRLZXkpIDogdm9pZCAwKSB7XG5cdCAgICAgIHJldHVybiBfLmNsb25lRGVlcCh3aW5kb3cuX19pbXBvcnRlZF9fW2ltcG9ydGVkS2V5XSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gRnJhbWVyLlV0aWxzLmRvbUxvYWRKU09OU3luYyh0aGlzLnBhdGhzLmxheWVySW5mbyk7XG5cdCAgfTtcblx0XG5cdCAgSW1wb3J0ZXIucHJvdG90eXBlLl9jcmVhdGVMYXllciA9IGZ1bmN0aW9uKGluZm8sIHBhcmVudCkge1xuXHQgICAgdmFyIExheWVyQ2xhc3MsIGxheWVyLCBsYXllckluZm8sIHJlZiwgcmVmMTtcblx0ICAgIGlmIChpbmZvLmxheWVyRnJhbWUpIHtcblx0ICAgICAgaW5mby5sYXllckZyYW1lID0gcmVzaXplRnJhbWUodGhpcy5zY2FsZSwgaW5mby5sYXllckZyYW1lKTtcblx0ICAgIH1cblx0ICAgIGlmIChpbmZvLm1hc2tGcmFtZSkge1xuXHQgICAgICBpbmZvLm1hc2tGcmFtZSA9IHJlc2l6ZUZyYW1lKHRoaXMuc2NhbGUsIGluZm8ubWFza0ZyYW1lKTtcblx0ICAgIH1cblx0ICAgIGlmICgoKHJlZiA9IGluZm8uaW1hZ2UpICE9IG51bGwgPyByZWYuZnJhbWUgOiB2b2lkIDApICE9IG51bGwpIHtcblx0ICAgICAgaW5mby5pbWFnZS5mcmFtZSA9IHJlc2l6ZUZyYW1lKHRoaXMuc2NhbGUsIGluZm8uaW1hZ2UuZnJhbWUpO1xuXHQgICAgfVxuXHQgICAgaWYgKCFpbmZvLmNoaWxkcmVuKSB7XG5cdCAgICAgIGluZm8uY2hpbGRyZW4gPSBbXTtcblx0ICAgIH1cblx0ICAgIExheWVyQ2xhc3MgPSBMYXllcjtcblx0ICAgIGxheWVySW5mbyA9IHtcblx0ICAgICAgc2hhZG93OiB0cnVlLFxuXHQgICAgICBuYW1lOiBzYW5pdGl6ZUxheWVyTmFtZShpbmZvLm5hbWUpLFxuXHQgICAgICBmcmFtZTogaW5mby5sYXllckZyYW1lLFxuXHQgICAgICBjbGlwOiBmYWxzZSxcblx0ICAgICAgYmFja2dyb3VuZENvbG9yOiBudWxsLFxuXHQgICAgICB2aXNpYmxlOiAocmVmMSA9IGluZm8udmlzaWJsZSkgIT0gbnVsbCA/IHJlZjEgOiB0cnVlXG5cdCAgICB9O1xuXHQgICAgXy5leHRlbmQobGF5ZXJJbmZvLCB0aGlzLmV4dHJhTGF5ZXJQcm9wZXJ0aWVzKTtcblx0ICAgIGlmIChpbmZvLmltYWdlKSB7XG5cdCAgICAgIGxheWVySW5mby5mcmFtZSA9IGluZm8uaW1hZ2UuZnJhbWU7XG5cdCAgICAgIGxheWVySW5mby5pbWFnZSA9IFV0aWxzLnBhdGhKb2luKHRoaXMucGF0aCwgaW5mby5pbWFnZS5wYXRoKTtcblx0ICAgIH1cblx0ICAgIGlmIChpbmZvLm1hc2tGcmFtZSkge1xuXHQgICAgICBsYXllckluZm8uY2xpcCA9IHRydWU7XG5cdCAgICB9XG5cdCAgICBpZiAoaW5mby5raW5kID09PSBcImFydGJvYXJkXCIpIHtcblx0ICAgICAgbGF5ZXJJbmZvLmJhY2tncm91bmRDb2xvciA9IGluZm8uYmFja2dyb3VuZENvbG9yO1xuXHQgICAgfVxuXHQgICAgaWYgKHBhcmVudCAhPSBudWxsID8gcGFyZW50LmNvbnRlbnRMYXllciA6IHZvaWQgMCkge1xuXHQgICAgICBsYXllckluZm8ucGFyZW50ID0gcGFyZW50LmNvbnRlbnRMYXllcjtcblx0ICAgIH0gZWxzZSBpZiAocGFyZW50KSB7XG5cdCAgICAgIGxheWVySW5mby5wYXJlbnQgPSBwYXJlbnQ7XG5cdCAgICB9XG5cdCAgICBpZiAoc3RhcnRzV2l0aE51bWJlcihsYXllckluZm8ubmFtZSkpIHtcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKFwiKFwiICsgbGF5ZXJJbmZvLm5hbWUgKyBcIikgTGF5ZXIgb3IgQXJ0Ym9hcmQgbmFtZXMgY2FuIG5vdCBzdGFydCB3aXRoIGEgbnVtYmVyXCIpO1xuXHQgICAgfVxuXHQgICAgbGF5ZXIgPSBuZXcgTGF5ZXJDbGFzcyhsYXllckluZm8pO1xuXHQgICAgbGF5ZXIubmFtZSA9IGxheWVySW5mby5uYW1lO1xuXHQgICAgbGF5ZXIuX19mcmFtZXJJbXBvcnRlZEZyb21QYXRoID0gdGhpcy5wYXRoO1xuXHQgICAgaWYgKGxheWVySW5mby5uYW1lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcInNjcm9sbFwiKSAhPT0gLTEpIHtcblx0ICAgICAgbGF5ZXIuc2Nyb2xsID0gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIGlmIChsYXllckluZm8ubmFtZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJkcmFnZ2FibGVcIikgIT09IC0xKSB7XG5cdCAgICAgIGxheWVyLmRyYWdnYWJsZS5lbmFibGVkID0gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIGlmICghbGF5ZXIuaW1hZ2UgJiYgIWluZm8uY2hpbGRyZW4ubGVuZ3RoICYmICFpbmZvLm1hc2tGcmFtZSkge1xuXHQgICAgICBsYXllci5mcmFtZSA9IFV0aWxzLmZyYW1lWmVybygpO1xuXHQgICAgfVxuXHQgICAgXy5jbG9uZShpbmZvLmNoaWxkcmVuKS5yZXZlcnNlKCkubWFwKChmdW5jdGlvbihfdGhpcykge1xuXHQgICAgICByZXR1cm4gZnVuY3Rpb24oaW5mbykge1xuXHQgICAgICAgIHJldHVybiBfdGhpcy5fY3JlYXRlTGF5ZXIoaW5mbywgbGF5ZXIpO1xuXHQgICAgICB9O1xuXHQgICAgfSkodGhpcykpO1xuXHQgICAgaWYgKGluZm8ua2luZCA9PT0gXCJhcnRib2FyZFwiKSB7XG5cdCAgICAgIGxheWVyLnBvaW50ID0ge1xuXHQgICAgICAgIHg6IDAsXG5cdCAgICAgICAgeTogMFxuXHQgICAgICB9O1xuXHQgICAgfSBlbHNlIGlmICghbGF5ZXIuaW1hZ2UgJiYgIWluZm8ubWFza0ZyYW1lKSB7XG5cdCAgICAgIGxheWVyLmZyYW1lID0gbGF5ZXIuY29udGVudEZyYW1lKCk7XG5cdCAgICB9XG5cdCAgICBsYXllci5faW5mbyA9IGluZm87XG5cdCAgICB0aGlzLl9jcmVhdGVkTGF5ZXJzLnB1c2gobGF5ZXIpO1xuXHQgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZWRMYXllcnNCeU5hbWVbbGF5ZXIubmFtZV0gPSBsYXllcjtcblx0ICB9O1xuXHRcblx0ICBJbXBvcnRlci5wcm90b3R5cGUuX2NvcnJlY3RBcnRib2FyZHMgPSBmdW5jdGlvbihsYXllcnMpIHtcblx0ICAgIHZhciBpLCBqLCBsYXllciwgbGVmdE1vc3RMYXllciwgbGVuLCBsZW4xLCBwb2ludE9mZnNldCwgcmVzdWx0cztcblx0ICAgIGxlZnRNb3N0TGF5ZXIgPSBudWxsO1xuXHQgICAgZm9yIChpID0gMCwgbGVuID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICAgIGxheWVyID0gbGF5ZXJzW2ldO1xuXHQgICAgICBpZiAobGF5ZXIuX2luZm8ua2luZCA9PT0gXCJhcnRib2FyZFwiKSB7XG5cdCAgICAgICAgbGF5ZXIucG9pbnQgPSBsYXllci5faW5mby5sYXllckZyYW1lO1xuXHQgICAgICAgIGxheWVyLnZpc2libGUgPSB0cnVlO1xuXHQgICAgICAgIGlmIChsZWZ0TW9zdExheWVyID09PSBudWxsIHx8IGxheWVyLnggPCBsZWZ0TW9zdExheWVyLngpIHtcblx0ICAgICAgICAgIGxlZnRNb3N0TGF5ZXIgPSBsYXllcjtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIGlmICghbGVmdE1vc3RMYXllcikge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICBwb2ludE9mZnNldCA9IGxlZnRNb3N0TGF5ZXIucG9pbnQ7XG5cdCAgICByZXN1bHRzID0gW107XG5cdCAgICBmb3IgKGogPSAwLCBsZW4xID0gbGF5ZXJzLmxlbmd0aDsgaiA8IGxlbjE7IGorKykge1xuXHQgICAgICBsYXllciA9IGxheWVyc1tqXTtcblx0ICAgICAgaWYgKGxheWVyLl9pbmZvLmtpbmQgPT09IFwiYXJ0Ym9hcmRcIikge1xuXHQgICAgICAgIGxheWVyLnggLT0gcG9pbnRPZmZzZXQueDtcblx0ICAgICAgICByZXN1bHRzLnB1c2gobGF5ZXIueSAtPSBwb2ludE9mZnNldC55KTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXN1bHRzLnB1c2godm9pZCAwKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdHM7XG5cdCAgfTtcblx0XG5cdCAgSW1wb3J0ZXIucHJvdG90eXBlLl9jb3JyZWN0TGF5ZXIgPSBmdW5jdGlvbihsYXllcikge1xuXHQgICAgdmFyIHRyYXZlcnNlO1xuXHQgICAgdHJhdmVyc2UgPSBmdW5jdGlvbihsYXllcikge1xuXHQgICAgICB2YXIgY2hpbGQsIGksIGxlbiwgcmVmLCByZXN1bHRzO1xuXHQgICAgICBpZiAobGF5ZXIucGFyZW50KSB7XG5cdCAgICAgICAgbGF5ZXIuZnJhbWUgPSBVdGlscy5jb252ZXJ0UG9pbnQobGF5ZXIuZnJhbWUsIG51bGwsIGxheWVyLnBhcmVudCk7XG5cdCAgICAgIH1cblx0ICAgICAgcmVmID0gbGF5ZXIuY2hpbGRyZW47XG5cdCAgICAgIHJlc3VsdHMgPSBbXTtcblx0ICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICAgICAgY2hpbGQgPSByZWZbaV07XG5cdCAgICAgICAgcmVzdWx0cy5wdXNoKHRyYXZlcnNlKGNoaWxkKSk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHJlc3VsdHM7XG5cdCAgICB9O1xuXHQgICAgaWYgKCFsYXllci5wYXJlbnQpIHtcblx0ICAgICAgcmV0dXJuIHRyYXZlcnNlKGxheWVyKTtcblx0ICAgIH1cblx0ICB9O1xuXHRcblx0ICByZXR1cm4gSW1wb3J0ZXI7XG5cdFxuXHR9KSgpO1xuXHRcblx0ZXhwb3J0cy5JbXBvcnRlci5sb2FkID0gZnVuY3Rpb24ocGF0aCwgc2NhbGUpIHtcblx0ICB2YXIgaW1wb3J0ZXI7XG5cdCAgaWYgKHNjYWxlID09IG51bGwpIHtcblx0ICAgIHNjYWxlID0gZ2V0U2NhbGVGcm9tTmFtZShwYXRoKTtcblx0ICB9XG5cdCAgaWYgKHNjYWxlID09IG51bGwpIHtcblx0ICAgIHNjYWxlID0gMTtcblx0ICB9XG5cdCAgaW1wb3J0ZXIgPSBuZXcgZXhwb3J0cy5JbXBvcnRlcihwYXRoLCBzY2FsZSk7XG5cdCAgcmV0dXJuIGltcG9ydGVyLmxvYWQoKTtcblx0fTtcblxuXG4vKioqLyB9LFxuLyogNDkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdGV4cG9ydHMuVG91Y2hFbXVsYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oNTApO1xuXHRcblx0ZXhwb3J0cy5Nb2JpbGVTY3JvbGxGaXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxKTtcblx0XG5cdGV4cG9ydHMuT21pdE5ldyA9IF9fd2VicGFja19yZXF1aXJlX18oNTIpO1xuXG5cbi8qKiovIH0sXG4vKiA1MCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIEJhc2VDbGFzcywgVG91Y2hFbXVsYXRvciwgVXRpbHMsIGNhbmNlbEV2ZW50LCBjcmVhdGVUb3VjaCwgZGlzcGF0Y2hUb3VjaEV2ZW50LCB0b3VjaEVtdWxhdG9yLFxuXHQgIGJpbmQgPSBmdW5jdGlvbihmbiwgbWUpeyByZXR1cm4gZnVuY3Rpb24oKXsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9OyB9LFxuXHQgIGV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcblx0ICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cdFxuXHRVdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdFxuXHRCYXNlQ2xhc3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpLkJhc2VDbGFzcztcblx0XG5cdGNyZWF0ZVRvdWNoID0gZnVuY3Rpb24oZXZlbnQsIGlkZW50aWZpZXIsIG9mZnNldCkge1xuXHQgIHZhciB0b3VjaDtcblx0ICBpZiAob2Zmc2V0ID09IG51bGwpIHtcblx0ICAgIG9mZnNldCA9IHtcblx0ICAgICAgeDogMCxcblx0ICAgICAgeTogMFxuXHQgICAgfTtcblx0ICB9XG5cdCAgcmV0dXJuIHRvdWNoID0ge1xuXHQgICAgaWRlbnRpZmllcjogaWRlbnRpZmllcixcblx0ICAgIHRhcmdldDogZXZlbnQudGFyZ2V0LFxuXHQgICAgcGFnZVg6IGV2ZW50LnBhZ2VYIC0gb2Zmc2V0LngsXG5cdCAgICBwYWdlWTogZXZlbnQucGFnZVkgLSBvZmZzZXQueSxcblx0ICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFggLSBvZmZzZXQueCxcblx0ICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFkgLSBvZmZzZXQueSxcblx0ICAgIHNjcmVlblg6IGV2ZW50LnNjcmVlblggLSBvZmZzZXQueCxcblx0ICAgIHNjcmVlblk6IGV2ZW50LnNjcmVlblkgLSBvZmZzZXQueVxuXHQgIH07XG5cdH07XG5cdFxuXHRkaXNwYXRjaFRvdWNoRXZlbnQgPSBmdW5jdGlvbih0eXBlLCB0YXJnZXQsIGV2ZW50LCBvZmZzZXQpIHtcblx0ICB2YXIgdG91Y2hFdmVudCwgdG91Y2hlcztcblx0ICBpZiAodGFyZ2V0ID09IG51bGwpIHtcblx0ICAgIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcblx0ICB9XG5cdCAgdG91Y2hFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiTW91c2VFdmVudFwiKTtcblx0ICB0b3VjaEV2ZW50LmluaXRNb3VzZUV2ZW50KHR5cGUsIHRydWUsIHRydWUsIHdpbmRvdywgZXZlbnQuZGV0YWlsLCBldmVudC5zY3JlZW5YLCBldmVudC5zY3JlZW5ZLCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZLCBldmVudC5jdHJsS2V5LCBldmVudC5zaGlmdEtleSwgZXZlbnQuYWx0S2V5LCBldmVudC5tZXRhS2V5LCBldmVudC5idXR0b24sIGV2ZW50LnJlbGF0ZWRUYXJnZXQpO1xuXHQgIHRvdWNoZXMgPSBbXTtcblx0ICB0b3VjaGVzLnB1c2goY3JlYXRlVG91Y2goZXZlbnQsIDEpKTtcblx0ICBpZiAob2Zmc2V0KSB7XG5cdCAgICB0b3VjaGVzLnB1c2goY3JlYXRlVG91Y2goZXZlbnQsIDIsIG9mZnNldCkpO1xuXHQgIH1cblx0ICB0b3VjaEV2ZW50LnRvdWNoZXMgPSB0b3VjaEV2ZW50LmNoYW5nZWRUb3VjaGVzID0gdG91Y2hFdmVudC50YXJnZXRUb3VjaGVzID0gdG91Y2hlcztcblx0ICByZXR1cm4gdGFyZ2V0LmRpc3BhdGNoRXZlbnQodG91Y2hFdmVudCk7XG5cdH07XG5cdFxuXHRjYW5jZWxFdmVudCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdCAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0ICByZXR1cm4gZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH07XG5cdFxuXHRUb3VjaEVtdWxhdG9yID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcblx0ICBleHRlbmQoVG91Y2hFbXVsYXRvciwgc3VwZXJDbGFzcyk7XG5cdFxuXHQgIGZ1bmN0aW9uIFRvdWNoRW11bGF0b3IoKSB7XG5cdCAgICB0aGlzLm1vdXNlbW92ZVBvc2l0aW9uID0gYmluZCh0aGlzLm1vdXNlbW92ZVBvc2l0aW9uLCB0aGlzKTtcblx0ICAgIHRoaXMubW91c2VvdXQgPSBiaW5kKHRoaXMubW91c2VvdXQsIHRoaXMpO1xuXHQgICAgdGhpcy5tb3VzZXVwID0gYmluZCh0aGlzLm1vdXNldXAsIHRoaXMpO1xuXHQgICAgdGhpcy5tb3VzZW1vdmUgPSBiaW5kKHRoaXMubW91c2Vtb3ZlLCB0aGlzKTtcblx0ICAgIHRoaXMubW91c2Vkb3duID0gYmluZCh0aGlzLm1vdXNlZG93biwgdGhpcyk7XG5cdCAgICB0aGlzLmtleXVwID0gYmluZCh0aGlzLmtleXVwLCB0aGlzKTtcblx0ICAgIHRoaXMua2V5ZG93biA9IGJpbmQodGhpcy5rZXlkb3duLCB0aGlzKTtcblx0ICAgIHZhciB0b3VjaFBvaW50ZXJJbml0aWFsT2Zmc2V0O1xuXHQgICAgdGhpcy50b3VjaFBvaW50ZXJJbWFnZSA9IFwidXJsKCdkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUlBQUFBQ0FDQVlBQUFERFBtSExBQUFBQVhOU1IwSUFyczRjNlFBQUlIcEpSRUZVZUFIdG5YbXNaV1dSd04vU2IrbHVVQllqZXpNTkdCeGxaQW1nTURGaEprQVVHU1JwbDJFWnhUQXgwY1JvWlBRL1Rady9ORkhVaEJqL01FRW5CR1FNMDBZWWd3WndRalRZa2JpZ3c2WWdCR1pBSWJJalN5L3ZUZjNPZTc5TDlkZm4zSE8zMSs4TjNrcStWL1ZWMVZkVlgxV2Q3NXg3Mzd2M1RVeU1ZWnlCY1FiR0dSaG5ZSnlCY1FiR0dSaG5ZSnlCY1FiR0dSaG5ZSnlCY1FiR0dSaG5ZSnlCY1FiR0dSaG40RldlZ2NsWCtmN1kzckI3WEh3MTUyalk1S3lsM05UdHBZNDNTTXgxVFZESEc4VDJxcTRaVllKV2F4TmwvSG1lYWVJcjUyMHhsd1hPODB4anA1eTMyVjR6OG42VHNoWUN6ekhYMGZMRXhKenB1cm43S2d1WjU5SWxacTI4a3RidW1zVmxZdFpxb0RsTzZWNndPdXlyaWM1N2Jpb2tmR1c5WXV5cW0zMnNLVG9uWlUwRnRoeE1qazhhM0kxdWttRlMyYkw1Um1UaE1pN3BjbzR4ZUptdkEzbk8xd3p1TlNGN08rQWNGN1J6NmJwNWxrRlBMUWRkMHU1RnVmTUZpY0FXREY1Sk02OGJMTS84UEljR3RMVTBXd00vVGVRYUNLVUtJY2NEN1Z5NkRsTkkrTHZoYzg4OWQvNnl5eTdiZk13eHgyeDY3V3RmZTlqOC9QeWhVMU5UQjhhWW41eWNuQTM5dVJqek1ZQ1hZcnk4dUxpNGZXRmg0YVVZVDd6MDBrdVBQdlBNTTQvY2YvLzlEMy81eTE5KzhQdmYvejQ2Rk5DbUtIRXVmcVpqU2FjeG9JRTEwd2dtZUNtczFmMXBMQmxENTJHUjRVRTduejd1dU9QV1hYMzExU2NjZGRSUngyL1lzT0d2cDZlbmoxaVc1NktWaFFtVjNTRDcwZ2Q0WWRldVhmL3p3Z3N2M1BQQUF3LzgrdUtMTDc3anpqdnYzQm44WFRHMGIwTTR6NzZrY1FZTmlKZG1xL1NUemEwMkdFUEcwSGxZYVBGMHlLY09PdWlnZGJmZWV1dXBtemR2UG1OdWJ1NXZnZ2VmUWpCeWNVaDJMcERKRjlmNTFwZTQ4aGwybU85OCtlV1g3M3p3d1FkdlBlT01NMjUvN0xISGFJWmVmT0pQbnlVTzBkNEhONzczUFM5NTFML0ZobXZDNFVtREhkUGYvdmEzRDN2M3U5LzlEM0dsbnh6OGZXSlE3SExZQ09JeStSWWdsbGFRWTVEdStBd05lT3Rpd0tNWnBKK1BrK0huMTE5Ly9YOWVlT0dGandTZk9QUUp4bzlZT2xnVjN4akU4UGNxc0tuVmdPelhaSXRKTUxUWUsyL2QxcTFiTjcvclhlL2FFbGY3aVNFbmFWeDVIc1c1QVVnNDg3cUU1MlJMbC9IRTBzby9jcHZBd2hOUEhqUUNZL0xGRjEvODFROSs4SU90Vzdac2VURG0vWndLb1Y2QjhUaGZjWnczdnVMT2xoM29NMk9MRGE5TStMcHJycm5teVBlKzk3MFh6c3pNSEJkeUNrdHlkeXhqbThDaWcvTVZSMUpOckJnLzBrRldrSG5FZ0R6SGxXT0RwdWcyQWcrVjBEUGdIVHQyL1BkMTExMTM3VVVYWGZSUXpHMVE0OHF4U1lkYUo1NHlMbVFyQm14a2I0TCt3T1VvQ3o5OTJtbW5yYi94eGh2L2NiLzk5dnY3MENjeEZqNFgzeXZmWktLWFIwdzd5WVh1QjlyaXRRRThCV2dBUm5VaVBQMzAwLzkxempubi9QdTJiZHRlREY2TzAyYkljVW9USC9SZUFUZTRONXpwcTF2aGFZTHFTdnJOYjM1eitwdmYvT2IzeDh1MjF3U1BnbStQa1J1QUpESzM4R0RBUk9MSFJFb2JBM3g1ckNsQm1mcFpMcy9Ud1ppSm04TFRBSndJRlk2WGxNL0dLNFpyanovKytHM0JZeDgwZ2cwZ05tWnhxSFJpaDE0eGNETXI1bURac0g3QWpweEE2T3BJUGZiWVkrZC8vdk9mWDdyUFB2dWNGanlLenNnTlFORVpKSXRrNXFURnRBSjh3TmV2TkhnUWFMS0hMV1RFYnlQWUJEUUE3elZVamZEODg4OXZPL25razYvODdXOS95L3NKeEczejVnWjJMOFlwRHZXVkFZSmVhYkFJWUVkT21QZk9tVzk5NjF1YjdycnJybitONHA4U3VpL0UrSE1hSEtPTWwyUFlGQ1RSSmpDUkpFM2FLNnpFV1FlNmJUVFpzNURFWWJOU1lPSWsvdWRqc0ljWDJCTjdZNDh4cHlrWTNrTE1oL25KT1F1MWxRTWRyWlFIN2VlTnVWbHhkY1ZFY2s1LzA1dmU5RThSQ0h5U1NTSzU4aDBVd1dJSDJkY1ZqbitLYkR5c3o2QU1ESlQ2cFh4SjY1V2Y2aE03TktNNjBRSjdFbkJiNEozSGhidnZ2dnVxdUwzOU5HajJsazhDR3hWL2ppQXJHanh5SU5DVkFtMmJFTEJGQjNldS9JY2VldWpzVFpzMmJRa2VDZUVLTDYveW5KZ1FyM25JZS9XV1FBTndTNmh1Q3c4Ly9QRFdJNDg4OHFhWTIrQTB0L3NFMndCZ1FMdzBHOUZQaXpRaWN4MHoyZ1U3YW92L2h6Lzg0VDBISDN6d1dhSEhGYytnK0hWSkNYWUhTQVoybTVLaURGd0g1ZnBTdjAxZVp6UHpYSTlkOWswVE1Hd0NUb0w1UC83eGp6Y2Zjc2doL3hGMDNYNzNTaE0wSlNoaUdoaTBDWGJVRnYrcHA1NjZPRjdpL1czb2VkLzB5dmZlYmhMYWdzR1BTVWRYR2p3STlHdXZtejR5VGp0eXdPMkFKbUNzanpFZkx4VnYyMy8vL2E4T2VsV2FnSzVjQ1dEVGp0cml4NVcvSllwL2V1anhzT1RWejczZjRsTzhYZ3VvbmppVzlyd1czUkswSTBhZTZYNzBXY2NnSHpRMFI3M1BNZ3ZrSUhMeFlwd0VXNE5mQjZ3UnVzV2dUbDk0MUEzQUpnVWJBRXdUZE83NXYvLzk3OCtNWS8vdmdrZnhlV0ttQWJnQ2FBQTJuRGNkMDFiQWgwbEdXZHFFRFN0dkRhQlFLUDJ4SDNqZ1R2R1g1NHZrSW5MeXpORkhIMzFMOERLNEQzamxYckxld0RTRkdSV3dRUURzMk9QcS84VXZmbkZxL01yMnZORHhwWkluQU1kL2VmV3phVGN1RHRadVBQZ2tWcHhwZVBMRmc4aTFJdzZ6blJneXJUejd5RFRGWjQvc2xhWm43OVZGUUU3SVRjeDllWmh6Wno1emprTjFlT0NxSEJYa0lBbWVlYjczelZ4eHhSV0huWC8rK2Y4Y2ZKSlFWL2hnVjRrbGtZQUpsUlozazZQVEJxTmUzNjg5bThMOWdhZmlObkRjZ1FjZWVHZjhRb24zRG9CczErSXZTVWIwYzFSR2MvR2g3VjRhZ052TVRIVDRobnZ2dmZkZjRoYzYrOFc4NnZyQVB2R3pVWklpTU1lT0NaQUcxMEdwWCtxVTYwdjlVbDZ1TC9WTGVibStGMzNXa0NldStPcFZRZUNOOFl1a3A5NzR4amRlSG45NFFvNjRMWG9xa3ArNnhnbjI0RUFRdzRJMjNKQ1k0alBZNE53VFR6eHgwUUVISEhCODBHeU1ZZkc5SjVLMHZ5UWdUNHhPam9MZXdIanl5U2QvSFNmQk5VSG5ISkVuRzBBY3JNNUZBdDAzMElHakFEZGo4Zk1KTUhQYmJiZWRGTVUvSVJ4eDMvZWhqd2MrT3R5TnVTa2FvVzJvQzg1MDI3cGU1ZG1tUGpMR2pqcVp6anFaempyU3lObTdENysrRkg0eGNuVWlPUXRaTDg4RG9UWTRETnNBRkZ3b202RHE3Qk5PT0dIOTI5NzJ0bk5DeVEzNnhNL1JSakpNQ0haTW1yd3NsNGNPSU02MDY0ZkYyU1kwdm9GZTQrbFZYM3ZrZ2tibzVJaWNrYnZnNVNiSU9RNVJCYmtHOG5yR1F5ME9Mem1nZk5WM2pyVjRqWHQrdk13NU5YVDV4VWcrK2ltU2lRcXlMMkFkdmwwdlBleCttb0pZYVgvRVRmNnEyMlZnYmdYN1BQTElJN2NmZnZqaDN3dTY3bFpnL29qTlBBVFpIMUNvUWNGa0U3Z2J3QjV6SHZ4bUw3Lzg4c1BPUHZ2czg0TXVqMzZQL1J4ODNvUzA4aEtIeVQwMjdab3NjMTNtWlZwNWliTk9wdldSY2JsMmtEaytLR2lHeWRlODVqVkg3cnZ2dnZmZWROTk52Q3J3VkVOSC85TFdnbmxmTVBEQzhNSmFSNzc2cTZmK2tNMC85OXh6bDhTdlFUY0ZYZjFLTkRDZG5JLyttSTVoT1FQbWt2enhDeU5PZ1kzeGR3UVBSeFA4VzlEa0xyOVRha1BraGd1Vi9vRENEUUkyamtHRGJZTHFCUGpLVjc1eVdCUi9jL0M1cnpIeU1WWVhmTjRJY3VaWlQ1NThzWHl4ZkxFMk1sWUd6clE2bWFkT3h2cHEwaS9sNm9ucjdDdmpBaUZYakpmSUlia00ydFBWUE9mY2g3aTZHTUY5QVVZR2dlemNnQWl3T3ZvRDgwdU9DK0lUT1g4Vk5QZCtiZ0ZzeUtNL3lLNkFmWkprZk5KZ29FMitwUFhLejdXbS8wcGtlMUxWQlJSc2ZtRlVQUXZFTDgwZWpGY0cxOGFjQzJta3A4Q2d6d0FrbEpHTGp5M0d6R2MrODVtRDMvbk9kNTRWZEw3NktUN0RJb3FEdFJ0UGZoT3UwOCs2bVVZWHlEem9jcDUxTWwzcUlxdURZZTAxcmE5eXZINzkrb1BpYnd2ditmR1BmK3l6UU5Zbkh1ZDFzWFhsNGFCZnNQaDFEVURYenNlVC8zbng1UCttb0orTHdaTy9YV3VncklVZXhIOHM2NnpWSHJ3TWJmYjE3ZnBTdjAyZWZVR1grcVc4bkpmKzZ1U2VwcHdDKzhiZkR0d1ZieFhmRUxTbmdCZVV0dzVpY0pUMkd1YzRHUlRZUkI3VkxTQStoTG51OWE5Ly9URWg0OGkzOEY3NUJBaVVlSW5iMzA5dHNLcE1LRW1CQjI2Q3ZGNWF6Sm82T3ZOS3U5MWtUYnBOYTRpZFp3RXdlWndocCtRMlByUkt6Y2luZTBTSDBXUXJSTTNBRVQ0STRGQ0E3dHdLdnZ2ZDd4NGJmOHJOU1VEeEdiN2JsNXVBWUVjNVNBYjJ3SmtlcFk5c0svdkl0RHFabDJubGJaZzE1TXMzaUxhVFUzSWJQQzQwODEzV0lVVDlRYjhuQUE1MUtnMG1vT29FZU90YjMvcm1vQ2w4ZnVoalE0Q1lOU1JCVzlMZ1FXQlllNE9zejdGS2k3SEhYdDJmZEQvN1p5ME5RRzdKNWV4eWJ1OE5tbHpUSU9nNDhLMC80d2hXZDhENElLQlRNRGJBMC9HdTFXdzhyVzRLbW9EdFhvOHJOazlnREdsd3BwWDNpN09OVFBkcXg5TUpuT2xlMTVkNk9ZWk1xNWQ1bVZZT2hzOGdqNHp0NUpZY0IwMEQ1TnhiajJEM0I0TTJnRjUwVEVEVFgvemlGemNGSm5oL3dXSHg4OGJxNkp3RU41NnhDWEZ0di9xdUU1ZnIyUTg4QVQyZ1NSKytOaklOVDc1WUc5Mnd1cTRYa3o4dkpFN1ZpUzk5NlV0SEJxcnlIZGo4SXhvSStya0Y0QXpRcVpnbVlreWZldXFwUndUMjNrL2diSURSQzVDZ2JwRGwwdUp5blh3eHNVSzdCL2xpMXBlMGE1QUJwYnlKbC9sNURmeHVVS2NManpnNlRYREtLYWNjSHZQN1lwaDM1SG00cHM1ZXFPNE8vVFFBSzNFa1pLZFZBOFJMdjBOQ3lOVlB3SFp4VDRGb3RBRnJJMlA4TzVmTzhXVlR4SUlNREVpcnJ4MHhPcGxtdmxwQXpKNEUyNWR6ekFsQXpvbmZFV1FGekh1T0hTUDlnZzdGVlNmR1ovcG1OMjdjZUVBWW93RnNBZ0puQXdRa3pqUzh1cEYxTXExdTVrRVBPNHhOKzZQR1pieHQvckkrdWx4UTFTbEFqc2wxekt1OEI3WU80bUQxRG9NMFFMYXUwK2tQZi9qREI0YkFZSFBoeTgza3pUY1ZMdXRrdWxkOTF1U1JZOGkwT3BuWDVHTVlmdDVEcHB0c1poMWp0QWtXbG5QdGd5QTFHQmdHdVFWWWRMQmRPQlZmMGtRREdDUU5ZQk1RSEJ0Rkh3eElnd2VCVWR0cmkyRllmOE9zTjJma3M4cHY1SnFUOW45am1IL3ltSWRyZ3QwZCttbUFzbGpPcXlEaWMyNStqcDhnTFQ3ZEsrU2dwTVhZZ3RhbXRISnRaRnpLOHJ5WDlkbFdTZGZGZzQ0K1NseXVyNXU3cHM1T25UOTUycklCZHNSTHdkY0cwK0lqTjIvcWxtdmw3NEY3YllBNkJ4aURYNDM0elI5QkVXUXVmdDUwaUJxQlJzR09EU01OcmdQc0l0TytkTlpYVnJlK2plZGFNZnFaYmx2ZnI3eHQvOGdaVlg3ai9RQXVOdmJxQ0xLaXdZSTVjVjZMZTIwQUY1Y082VUo0VS9Gd3d0K3ZXWHd3Q2JPZ1FlNEdCZ2NXY29MckVvSmNmWFhGMkNocGZXZy9ZMlhabnJ5c0o2MnNTYjlOcmgxeHFROC94MS91bnp4M2NodTU1aGRFbmR3SGJWeGdiUWZaRHYwMmdCWjF5Qng2YXQyNmRlQ3FRd096QVRhVU54WFREc2dYZHdTSnlESnBNV3AxZEIwUFhaTmkzR1dDUzN2OTZwZnJqVU9NUElOOGNaWkpaNW54VnM4QXk3bTJBZFIzYjg1N3dvTTJBTVp4NkppSXIxL0ZGbThDRVNRQmd3Mkt6VUM3S2VsZTViRzBLL1JpSHdQNjcxYy9yNjBMeEFLQkFmWWxqM2t2L3N3Sit0SmxmckM1RUxubWowY0I1STZLMGUrUFlScEFYd1RnQ1ZBRkdITXdtemJoUWU1R2wzUDF4SFZ5L0dRNU9obEtXVG12MDgwNkpaMzlTWU1CZE9WVmpHVmVTWmMybFlQclpIVThkYjBON0lvVHdQY0JqQ2ZiN1lzZXBBRndxdU1Pdlh3czVjTG56WlJCS2NzWVc4Nmw5Y042WmFXdHVybTY0bTQ2eU5RVFoxNm1sWU9ORWJsMGpoZCtFMlE3NlBSaXo5d3VMT2VhZGZqVFo2YVI5UVNETkVBMnJITjRYdjFzeG9kQU41clhRTFBPVFN2THV0SmlkWnF3dHRRdjdROHJMLzNxUjR5OHBJMmhYTXRjR1ZnbzE4UFB2RTRERlB4c1Exczk0MkViUUVlVE93T2lNd25TNGtOM2c3dzVhSlBTYlUyVGpMWDRNeG5TT1liU0g3Yms5YkllL1F5dWhTY3R6cnk4SnRPbGJpLzdyMTRKUktwNXE5MjlacHQ5MDZOcWdJbjRPdlVkMFFCc2lrSGlwUW5LelJtMG14ZWprMm5tL1lCck05WW5kcVQxWDlvdUd3WTllYVZ1TDNQaTBDZjYwdnJQY1dwUG52TVNJNjhHdVM2Rmc4NUgxUUNMeTBGMWdveUE4dFZIZk4wMmlNd2tvVHNzWUNzWFVMcU1TVCtENkJzek5xVHpIak90anY1S1hMZSsxTkZHem5XZFRsKzhZUnVnczhuNC92eWQ4Zlh0UEtuS0V4dDR4blZCWnYwNmVUODhiWW5iZkpkeTE0bEwzL0xGNWZwZTlKdDBTbjZlVi83SWRXTG1HQks3TjNLUUJzQ2hUanQwZkJEa3hmaTJxNDNMYmp2ODNzS292WUx5VWs4SE1JQjllY3lsbStUb1pDajF5eE1DdWJ5OGJxWG9jaitsSCtPcCtPUjZXU0huT2RQbCtzWTVWK3l3Z09PRitLOFpmR2pCSUNvZS9PWGhYRGw4ZVpsV0h1SktEZ2JRQVhxMXAyNjFLSDVnRjlCK0c4NHg2WE1ZakQ5dFpscWJtUWNOaUtIUnMya1g0MVBEZk5wS2U4Z0hobUVhZ0FBZEUvRWx5QVJGa0xsYjNXQ0pXZWNHdEpHeHNuS2Q4N2IxdmhJQloxb2Z3OXJYVGhNZTFuNjUzdjNHZGlZbTRodkZ1TmlBN0grSjArZlBRUnNBeDBJVlhIekROMEZSZk1CdVhab3RGUnZhQXBiWURicWhNZ0d1YmJKWHJrY1Bub0E5UUwrbHZuNmJjQmxQMjNwOG9TT1UvbzFEWE5vci9XRUhIZkk2ZGZ2dHQ5ZWRBTmtmK2oyQkJXdFRSczlCMC9oWHFid256UmNjclk5UHJ1d2J0NEhUZ3FZUitEZ1lMMVVHQ2lyV3JUYXdWeE5PTE5LcnRSL2lJZGY4Rm5Cai9MT3NiWTgvL2pnZnUvUHJkc2kxcDUzTlE2eXQ4Zlo2QXBTR25PdGtNUUxhRlo4SnBQQTJTcEJWQUIyZExuT0Ricm9pU2h2OTZwZnIyK2I1dHBIcHRuV0R5dHYyUXk2cnZKSmpjbDNrRWptK001VHpMT3ZRdlRZQUMwcUR6aTNhd3U5Kzk3dW5RNDlBQWVRZFdVRXJBMnRISEt4cW5iak9ScmxlTytJeW9hV05jbjJwWDhxMUt5NzFTL3R0ODlJK2U0VW5zQjdRanJMSjVSekxWMC81MHFyZGJjbXJ4ZjAwQUFad2xFY09aR2Q4d2VFeklmZVBGZEVIc3I0MDY2RHora3dyVTc4TmwvYmExdmVyN3hVSHpuUmJYRTN5MG4vZWU1YXhYdURDbWw3T3NiOXlkMTNweHpXdDJLdTFWVEVVcWlNb01FM0Q4RG1BWDAxV1gya1NYM3k4ejUvKzlLY1Q0NzkyY2l0Z0VLakJzZDROU2VzZnZyd2dXMEhkcHZWdDh0SkJtMzRwTDllWDhaZjYvY3F6Zld4eC8xOGY3N1p1Zk4zclh2ZXJlQitBaDBEeXkwZncrQnNNRzdOc2lCQjFoMzVQQUt5eG1UeDB1aENCN2J6bm5udWVEVGxCbTRTeW8vUGFKanFXZDVvbDArcG5tNWx1a21NRFBRRTlvRWtmdm5iVnlWZ1pPTlBxWkY2bWxiZGhZd09ieTJseVM0NlhmV2JmMlI1cmVvWitHd0JIUW5aS01GVVhmdWM3MzNreWFONWh4TFpOa0hXaDh6RUs3WG8zMVlheGdVNXB0MmxlK3NzeFpGdjZ6YnhNS3k5eDFvRnVHMlU4MkRNUHBlMFFWWG1jWHM0dGV1cG1QK2dCOEhvR0N0UVAySTBVbDhGdGdHSnpHK0RsNEliNExtQysyZXJZMmRsWmpxWjhHNGhwQjJ3TS9STzBQSlNrbFhjV05oQnQ2MGN0TDhNbzR5Mzk5YXV2UFhKTWZ0ZkhmeVdkaXorOHZqZStTOWlYMlg1VENDZUNEVUh6NEp2UkUrQmdHTkNaWGJrekF0ejVrNS84aENCcER1eTdHWFhCQm1xM1oxNm1sYmZodkNiVHJzdThUQThxeDBZZTJORnVwck5PcHJOT3B0V1JGMmFYcnY2Zi92U256NVBibUZ0d2NxNCtlZ01CUmVvSEtDWURrQVpUYUVaVjlQaXYycnMrOUtFUDdSOXpBeVpRTnJXM0FIOUFUcEM4SmNudVA1WDFxci83Nmoxbm83Qm5YamxkWnkrNTVKSkg0aDlOY2FMNjZXc3ZPcHRGbjN0RzA0VmpNYnVvN0NFeU1MRzNnYzY3Z3JGaTQ4OSs5ck5OOFhGeG1vSjNxK3phSm44RWoyeWdUY1M2RXJTbHYxSGJMLzIxemN0NFN2MjYrTWhkOWZRZmIvMHV4TGVEUEJ4elR0Yjg3cDk1dFFuRXBmM0dlYjhuQUlaTUtqZ1BBbmFzaTFOZzRRTWYrTUIrd1ROSU51bndOTWdCeXd1MW9RRS9nUDZrSytZQVA0YTFWNjUzcjAzN0o2ODJ3UHdIUC9qQnh5T2ZGSjZYZmJ6dGEwNWRuL2NaNHQ3Qll2YStvcjdvTkJLajh6QVk5TWI0RnlpSG4zVFNTZGoyWVpCakM4QXZRZXRmMmtTaGs2Rk52MDJlYlVHMzZaZnljbjBaNzdENnBUMkx2ejV5T0JIL2N2YVJDS0I4K011M2dJRWJBVWY5QXNFMkRZS2lPK25TSFovODVDZWZDR3h6QkZrQmF3MFluR250b2dndG9BTTA2V2NiV1hkcDFTdTJ0Ri9xNTVneXJiOFNaNTFNbDNyT3MwNm02K1RFVEYzSTI4eGxsMTNHeStvcW40Rzk4ckhSTkVMVU8rQmtFS0RqR1VERzBBUmZqZmlQb0pQSEhIUE03RnZlOGhidVpXeUNEUk40Q2ZMY0ZQSW1YdWFYZHB6akI5Q2Zkc1hJdEpQcEpqazZHVnpicE44bXo3YWdzejQ1NUtYZjNOVlhYLzN5VjcvNlZkNWU5eVZmMC9FZktvT0J4ZXQzdGVzb3RFWDNTcStDRHo0ZkZ0MFFyMTAzM0gvLy9RZkZXNWpjdjlnSVhleUdnK3dKOE1FYS9VbzMyV25UYjVPM0JkVzJ2azNlWko5MVZmN2lMZlg1dUhnZWUrYVpaN2g5TW53RzhCVGd0TFhCYmZpbWZJUnFQUXg2QW1DTllBVnBzS002eHVJUEdLZWVmZmJacVhQUFBaYzNpZ3llZFFZTjNRWnVESnpwcG5WWko5UHE2OXNFd3BlblRqZXNidFA2N0JPNm5HTmJubjdJR3ptclhrM0Y3ZlA1K0xjeDNQZTVjSHA1K0N2dHhiSjJHRVVEbE1YSHE1dXBjRHpJTEo1NDRvbHo4ZCt3OEVmU2ZCZzBPU1hHUnJjTktYTmR2L3JFeFZwalozMkdOdnRaN2pwNXpydGhmWU1keE1MVlAzdjk5ZGN2Zk9wVG4vTG9wL2k4OXZmNFJ6ODNIdk9Cb1NrQnZScGt2YU82NzhmY1d3R2R6RzhKcTF0QnZFVThIMzgzdVAvbXpadlpESnZ5Q0F1eXNzRkdqRWQ2cU0xaCtQOEprRFB5Tng4djkyYmpTNkNlakhmOXVGM21vNThHSUdmbXpTWWdSd1BuQ2FmRGdnR0lDY3lybkNPZndGK09EVzNmc21YTDgzRkxvREhvOUZ4c04rTmFiTW5UN21waVkxbUorR0tyRmF5TDNLeUxIRDFIcm9KVGQrd2JSODdGOHZMQjBEQzNBRDE2QWpEUGRDbWZpcTg4cjhaNTU1M0grd1UrREZwczlQUEd1dEhxZ2dGMGdXNXJocEZwdTNLeS9FT2ZXYWFQek10MEtTZGZYSVRVWWY0akgvbkk5aHR2dk5GMyttZ0FqMyt2ZXRmWCtRNzEvbUZVRGFCbnIycm1KVjAxeHk5LytjdUpGMTU0WWVhc3M4N0NkN2t4N2JSaEUyQkMwSmZYdG5ZVWNuMDErZTlGWHVVamdpRVBjNS8rOUtjWHYvYTFyL0hReDlIUHNQaGNLSjQ4NVFrUW91RmdGQTFBQkc3R2FDeCs1a3RQeG0rMkp1Si80Y3lkZnZycDhNb21NS25kTUg1TXNqNjdZWFcxV2E3dlY2NGRjV212V3l6S3ZQTG40dnQvcHo3M3VjOXh2NjhyZmwxK3RHSGN6dnZHbzJxQTBuRnVBSUowamw1RjMzenp6Uk5ISEhIRVRMeFZ6THl0czlISmRxVEJ2WXhRMjZOaFdDZEkxK0dTNTVvU3F3ZGZHbHdPNUozaVgzbmxsZE1mKzlqSGN1R2hlUWJneXM5WGYybEhINkUyT0l5eUFYS1JpYWljeXpQd3lSdHV1R0ZpYm01dTV1MXZmM3RiRTlBZ2dJMGlYVEZyZnVqRHBLRWlMOU5OOHRLa2E1djAyK1RhWTU4VXYzcXo1d3RmK01LNmozLzg0eHoxTmdDWWgyWWJnUDI2WjdHK1FqUThqTElCaUNZWHZZazJhall5K2FNZi9XZ3kvczV0NWgzdmVBZjY4SHJaYUxWMldkK0VpSVBkS1hZZEQza0o2b0hyaHJIbFBaVTI4cnkwcDR6aTh5cG85aE9mK01TNnozLys4eFNhb3ZzdUgzTmY3MXY4bkk5c04xU0hoMUUzQUJHUnBKeW9USmNiWUQ0WmZ6c3dlZmZkZDgvRXU0VVQ4WDRCUERjdGhwZEhURHRGenJRNm1aZHA1U1hPT3RBbG9BK1U2NXJtNmxhTDRnZUZaOHpHbjNiTlhuVFJSZXUrK2MxdmxzWG5KS0Q0akJXOTc0ZjlEdVRpZEpoREV0b0VPMHdBbUtiakt2Q05JdDRzNG0zaSthT1BQbnIydXV1dVc0aDNEWDBDSmhFbU9jaEdRQWRmWUVBYVhBZkQ2cGMybS96Qlo3RHZ1WGdGTlB1Kzk3MXZPajdjYWZHNSt0bHJYZkU5QWR5L2V4UEhzdUZoSlU0QW9tcEt2Qkc3Q1RjSGZ6SCtRZUlFRDBYeCtZS1orQXNZWlUybmdISndXWURNeTNyU2xUOStMQU44UUhtSnU5bDNuVmhiekNsODlmWnV2TVJiLzU3M3ZHZmlpU2Vlb05nV0h1eXhuNi84dlZMODhGMWRqZUNWZ0Y2YkFOK2RJc2MvU0p6ODRROS95Q2RnWjA4NzdiVEorTktKbkZBTFU4YXJUcGJMSzNWN21idTJ6bDZXYWF2a2VlTE5QUERBQTNOeDVNOWZjY1VWdTJKditjcW4rQjc1cTFKOGdsK3BFOERFdERWQnAvQ3h3R1JYdlBnVjh1VFh2LzcxbWNYRnhia3p6amlEV3dHMjFNYyt0SkFMb0oxdW1IV3V5YlJyeWl0ZVAyTFhabjFrM3VMSTYreG5QL3ZaamU5Ly8vdW40L044RkppQys3RG5MYzZybjcza29kM3NKMVJHRHl2ZEFFVGMxZ1I1azNuamkzSEZUTng2NjYxVDhZY1I4M0ZibUQ3KytPT3pMcmJWbHdiM0N0cENYN29PNnlQanZJYjlNU3orN0ZWWFhiVXgzdE5mLzczdmZTKzJVRjMxK2RpMytPWHJmQnVneVE4K1J3NXR4Um1WUS8yWUxCTW05bDVKUTFZdmt4S3UvaXlhZVR3a1RzWHZ5YmQvOUtNZjVVb2lnVDR0a3p5TEYyUkZZMXVlTkJpQUw0KzV0SEo0M1lEMXhJeCtKL1k0c1RiRWYvcWVqWWM4NHVHcTV3cDNPUGU0TDkva2NRL1lObTV4c0ZZR2V0M3dLTHpyQzV3SENjekRKcWdlbmtKR0ErU21tTm0wYWROVS9OdVU3UmRjY01HTFJ4MTFsQW4xRlFPSnhMNDR5RDBLRGk4RCtpUWJERWhiQVBsZ1lnV0lieXJ1OFRQWFhudnQrbTk4NHh1ejhYZjdGajRYMndhZzRNYUtYaDc0eVNPbTFSeThvdURHVnRSSk1xNC9jRG5LSnNpTjRNdEdtNEhrejhRWFUwN0hnK0ppSExmYkw3MzAwai9IN3hkb0FrK0ZuRkFMS1U0aDFaSk5jUkxqZEh6MGJUcGVyV3pjdW5YcjdMWnQyL2lXVkh4U1hJdnN2VDN6Y213V3Y0elIrTVMxd1kyUzZVWkhhYlBObGo0ekpySE1HV1VqVU95NlpvQmZOUUx5YUlhcEUwNDRZVEVhWXNlWlo1NzVVdnpLbVNMWURFRjJIaHB6Y2pPTmIrYkd3QnBqNFczcnVWdHV1V1UrQ2o1enh4MTNVSFIwTFRoWXVpdzZmT01vQzgvY0dFb2NvcFVITnJzYWtQMUM1MkV6aUNrK3RJMWc0Y1djRHNyUXJVWTB4RVE4TXl4dTNyeDVJVzRUTzkvd2hqZnNpTEV6L2poMUlUNjRPaEhmczdQcjBFTVBwUUFUano3NjZGUjh2OUgwOXUzYkorS1BNYWZ1dSsrK2RURjRDY2NIWEtiaW5rN0JVZlVxRmx0MGNCN0ltV01mbXVKYWJERThSNUFWMkFUT1Z4em5RcXk0c3hvSCtyY0JVTEh3OEtUQkRncHN3ZXN3ZXZEVkYrdERIQ3A3Z0FVUlU2dzhMQ3JZSXRmaHZBWmJ1ZWpRZ0Q2a0srYmUva0V5Vmh1TUlXT0xKS2FJMEdKUGhjNFZIekpwQzU2YndMWElBTzB1elpaKzVvSllRSXZIM09KRFUvUnl5SGROeHRvVzR4RWFFQy9OOXZKUEVyRld3Rmd5dGxCaUc0QzVoWWEySWVUbGVkWmxyellCTkRJZ0Y0RkNBbUFHTW1tS0xnMW1udVhRenFVekRuSEhGL3hWQnhPdzZvRXNCNURqZ1hZdVhZZHRpam9zcjI1ZDNaNXpzVEp0MGVGQjErR3NuMm44T0ljR21LOEpNTUZySXBnVVJJN0w0aUdXVnA3bkplMlZEai9UdXBIbm5NSUtGc2hpdzVlMm1DVkdKL1B5SEJyUTd0SnNEZncwa1dzZ2xOb1FjbnpTNEc1MGt3d0h5bXFkSmFhRnlyaWt5em5MNFdXK0p1VTVYek80MTRTc2RzQTVUdWxlc0RyRTMwVG52ZVZDbGJUelhqRjIxYzArMWhTZGs3S21BdXNTVEk2NWpwWW54bFNtNithNkt3dVc1OUlsWnEyOGt0YnVtc1ZsWXRac29BMkJsZkhuZWFaWlhzNGJUTzdHYmlwczVyT2duTzltWkMxUEJrbktXdDFQM1Y3cWVJUEVYMWZnT3Q0Z3RsZDF6YWdTdEtxYmFIRSs3QjVmRllWdXlkRllQTTdBT0FQakRJd3pNTTdBT0FQakRJd3pNTTdBT0FQakRJd3o4SmVSZ2Y4RGFEd1J1K0RnbUpNQUFBQUFTVVZPUks1Q1lJST0nKVwiO1xuXHQgICAgdGhpcy50b3VjaFBvaW50ZXJJbWFnZUFjdGl2ZSA9IFwidXJsKCdkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUlBQUFBQ0FDQVlBQUFERFBtSExBQUFBQVhOU1IwSUFyczRjNlFBQUhpcEpSRUZVZUFIdG5YdXMzVldWeDl2NzZMMTlVUXB0b1M4c0ZDcWdEc01ycFVSQk93aktTSGhwQkJOR1ptQWtKaEF5Zi9pdk1VWmoxTWpJRUI5TUlpUlFSVjVPakJPRGpqT0FnODRNU0NtRm9WQXAwQmJhQWlPVXR2UkJlOXY1ZnZZNTMrTzZ1Nzl6NzNuZDN0Tjd6MHJXV1d1dnZkZmVhNisxOXQ2LzMrLzg3cmtUSm5TZzQ0R09Cem9lNkhpZzQ0R09Cem9lNkhpZzQ0R09Cem9lNkhpZzQ0R09Cem9lNkhpZzQ0R09Cem9lNkhpZzQ0R09Cem9lNkhoZ3pIcGc0cGlkMmVDSnRXS2VCd1ozT1RaS1BXTmpHb05tVVJUc0l0a2dwUVlMaDMxU2pKUmpHdlJuUTJyNUhHSTU4blNlbDJzWk1BYTVHazgvc2E2V2Z0dWlUU01PYVFmRG85MUZmSkVNdTZPOHFJd3NEMlFzbTg5cHJ1ZDY1RzBOdVVQYTJsZ1pGKzAxWDBTTFpNek5jczh6THlPUHdjdDVseU9OL0ZENkhyT3RhSkVEMnNwQUdSTnROQjlwenVkbDVoTmxzUXhmRFlvQ0cyWHdSdnFveHJzTzJuWmd4N1NkWVRJbzJtWWVtdk9XNVpRNUllc0tPdkJBM2tkSmVuQVFrZThYT3ZEbUhleWhLTHF1aHdmY1Q2blVCcDkyUkJ1WU1zZ0UyeFVwZkMxSWtJMFRiNy85OWxuTGxpMDcvdGhqajUwM2VmTGt1WDE5ZmJPN3VycG1USnc0Y1pKb3I5cE9LaVBCMmIxLy8vNjlCdzRjMkNPNmZjK2VQYTl2MjdidHRVMmJOcTIvN2JiYjF0NTExMTN2cWczdFNBU2pnMng1TE1NRGxwVktiWlFJZHJBTkcyMXFleUt0Rm5TdmJPcTdoU25vRHp6d3dFSUYvUFNqano1NlNXOXY3L0VFVzNVeFdQQ0FBNGErQStWeFk5L21Kd3dNREd6Y3ZuMzdtdFdyVjYvODFLYys5Wng0OXpzUStuTy9EbnFrSGpkUytGRURUM2pVRENnUEhPMkFyNFlPUmdxMjJxWEFQL2pnZzhjdFg3NzhZMGNjY2NRWkN2aE15UW1JZzdOYi9MWXl2aU82dmN5L0o3cTNqUHRFQWU4SWZlS25DdW5yeURLRlo3dzBKanZFMXExYm43am5ubnNldXZIR0c3ZEk3aVR3MkVNbEFuV0FhYWswQ3AvUjhhTXdmQnJTTmtUcUJJZ0JSMFk1QlVFQjcxK3hZc1ZmSDNQTU1lY282TWRJanVQQm5jSTNoWnZMK0graUJKb2dreFF4VUE0QTFHT2Fwa0JMRHVXQjJXVGhnakxPRjUwdVRMYm9xRmozN0xQUC91dFpaNTMxbEdTMkErb2twSCtRc25teGxRUkFOaXJBWkVjVFBMNmRIbWtNZmlYd045MTAwNUZmL3ZLWEw5TVdmNjdPY1ZZc2p0NGwzQ2hjSjN4VnVFZm9vRU1kQ05vNkFBNElZMUp2VzhSV0xoenpKQ0FSR0pNZGdtUllJbnlma091SW5yMTc5MjVZdVhMbEErZWNjODR6S3NlRWMrQk5vdzN3Z0dtcGRJZys0NlFQMFpDVllSeHNCT2FoQkRzR1A2Mnl6MzN1YzlPLy8vM3ZYejFqeG95bDVYb0N5K3IrWCtGTFFyWjZBcy9XVHFDcGQ4Qk5DUURnQUpSS3BYTDBoZmxvajVPQkJJQW42Q1FDMXhnbkN6OGc1TmdnRWRiZGZmZmRkMTUzM1hVa0kyTTdHUmdYRzRvU1FlSkRud1NlS0lNZkt2Q1lrY2FBMittc3RoVDhsMTkrK1lMampqdnVVbTMxL1pJUjJFMUNWdGw2SVFFbitNZ2RkSnllTzFxaWlvUGphbU84V0thZGdib2N2UnZGM1lCRTRFZzRUWGlLY0lyd3dPYk5teDlhc21USnYrellzUU43WWlJNEFVeGpRbGF6UlYyMEhwamNvUVNQbHp1VnNsYytGT2YyM0hmZmZTZGNjY1VWMTNaM2Q4OVhtZUMrSVh4Y3lNcUtLNTRWNWxWVzVGUlZ0d1NpM1VXSndIVUNGNDNzVWljSUorbk9ZY3VQZi96ajJ6Ly8rYzl2Vk5rSjZ1UzByYVlPdnFsVVJoWWNrSkVkcGRTN3g0cE9oSStCWjhXbmxiOSsvZnFMdE9vdkx4dTJRM1NWa08yZWl6eTJlcENnVjF2dHFpb0VuR3RiQ2hzTUk3Uys1eEVUd2NjQ084Qmk0VExoRWNJQjNUcmVmZHBwcC8yM2VDZEJicmVUUUUwT09xS1FqUWcwNDRoNkRQSTRkcHBwREg0Sy9DV1hYREx0cHovOTZRMVRwa3c1VlFNUTVGZUUveVY4VytoVlQrQnhwSjBHOVJnT2tGZFJrUnhackxlT3hFbWUxK2Z5dko1eU9xNUVtUWRIRmNodThHSGhJbUh2bTIrKytmQ2NPWFB1RTQvdFRsNG5Balo0UHJiTlZGVWpBeGcrMHVBeG9CRWRmRHV1VnhkNTgyNjQ0WVovMEZuUHFtR2wvMEg0ckpDcmZJTFBlWS9qY0JTT016aUFkcGpIcE41MWJtc2E1ZWFiMFdjK0FKU2RnSXRGamdUd0xPRmZDdnQwUGJCR1R5WC82ZDEzMzIyTEpJaU9rbjB0Qi9lZkI1NHlqdktXMy91em4vM3N4TXN2di94R3lYQWNWL2YvS2VSaXo4SDMxa21Rdk9KandCeEVWVmVDYnBuYlVjZll1VHpLYUJQclhZY2NjTmswbHlFSDJRbEFKOEZKNHRrTnB1bTV3Ui9mLy83MzM2cGpqaDJPUlBadTRCM0ExSGFicW1sckFVTkhFdXlNU09QS3gwRzlqejc2Nk9ubm5YZmUzNG1uM1d2Q2g0VnMrUVNmd0xQeWNZSWRJemExaFNKSHo5UXlLRkN0RGpsZ1BWUExVcVUrR3RYM1BOa05RRzRSRndxWEM2Y3JDVFlzWGJyMGxxZWZmdHAzTUNRQ3lCdzlUMndDQWROU3FVV2Zka0tMdWh2VURYMjdmNXdCYjZkVVZuNDUrTmVyamttL0pQeXRrTWUxSEFIZUp1MFFpUkxRVis2UUtETnZXbGFya0NKNWxKazNyU2lXbVNKNWxKbjN2RWwwcmduWURVaUN2eEpPMzdWcjE4dXpaOC8rUngwSFB0cDh2REZmejlsSmtNOVhUWm9IREJ3SndBRUdlUENnNE9zWi9oS3QvTDlWSFJOL1FmaUlrT2YxQk45T3dSR0ErNEVDTHR2SlVXYmUxRzFObzN3azlSMDhWamJiUGZQYUtQeU5jTHUrblR4KzQ4YU5meU9lSFlJa1lXSFlUN2JMTmtOYkRnelNhckNoTnR3VDhjU1laTzkzdnZPZGVaZGRkdGtONGdud0s4TGZDVm41M2hLOUF0eFBOU3FWU2pKVWF6T1VmS1QxNlorNWtBUWtOY2NheDl4djRXZk9uSG5XaXkrK2VKSDQzakxhVDlGbVZTVkExbEpnc0pHQWFEeThKNVhPL0FzdnZIRGF6VGZmZkpPdTlpbmpqRWVGTWZnK0MvTitxcFdsZmxBU0ZNbEdVejlQZ2xka0lBKzFkaTlldlBqaVJ4NTU1Qy9FNHcvUS9vSkdtMVZzTGJBYVd3a1lDMEJ0dkxjMVQyN1NxbFdycnUvdjc1K3JObHp0LzRlUXIydForVDREMlRxdGJ3ZElsUG8xamZLaXRrV3lhTjlvNkdPN3ozSW94eDNYQmtmcG9kZXA4c3ZqTDd6d0F0YzlQanJjVnFLUkFaelVhckJqb1E0Q2xBVG9YYnQyN2NlbVRadTJSRHh2MXp3bTNDcmtmQ1Q0ckh3bW5kdVY5NlVtZzFhR3gwUU90TE0rOWpGUEFrM1M4NnpqRGUyR2Zmb0M2UnJ4WGloZU9KNGIxQkI1eXhxaXVhTWE2cVNzRkEwMVQvOGdrK3ErODg0N2p6L3BwSk11RmsvQW54UnVLZk00Z3kzU2VsRDBUTVVtb0F4RXU4MjdMVFR5cmtldlhmUkpjaEllUDNCTndKUE9uWHFoWllrZUdYOVl2Sk1BMjQyZWwrZWdxdWFoVlVlQWpZSmlNTlFaN0l1YnZ2dnZ2Ly92OWNVT3QwSXZDWjhTK2o3ZksxK2lTcERnSFR6M0crdGpIWEtEYmFFYzIwUStyN011OUZEcHgzRllBSUR1Q21lZitOaGpqLzJQdmdHdGRoVDRXSWo2SmUwR1B1MlVCbFFQVXNFZ0kvM0NRMG1FSGozdytJamUwVHRHUEJkN3JQNDgrTmF4SGhTd0hENnZjNXNvajN3NzZ4TklkajBDelU2d1JzaFIwUHVUbi96a0V2RXNISFlDNW04Zk1EZWoyT2FCanBzRkRETFlPQ2g5RS96dWozNzBvOU0rK01FUGZsdzhaOTR6UXBMQTI3N1lOQ2xUOStlK29qeXY4emk1UE9wRVBtODMydnJZQm5BYzRKdW5vWHJON2N4dmZPTWJjOFdubzFPMEtBa2tydmdOdmlHd1F4cFNMaXZSaDlHR3BzQkx6Z09PUHIxV2ZkWGN1WFA1TW1TVDhEZENMZ0RKZXJaK24vMWlFN0F5YkZma3k5VUhrYnhOTEVmK0lNV3lJRzhUeTVFZlNYMENqYSttQ0Q4aVBFRmZHcTJmUG4zNlA0c25NVmdzSkluOWhjK3d6U2kyTVdqRkR1Q1JuUVNtYWV2LzdHYy9PMFBCNXg2WGdLY01GMlV5R0E5Z2czV2dzV3llZG00VCtieDlYajVjOVBFRndlVkJFZDkrN3RhZDBnbmYvZTUzRjRpUHg0RG53endOa2Jlc1p0cVVza1pCMzRoeFlGejkvUnMyYkxoczRjS0ZaMHUrUWZpb2tOWHZqQmFiOUhHQWJUSHZCQ21TSTR2MTFxRS84N0UrbDdlalBuN2ozR2NYV0NaYy9QYmJiNjg5NnFpalZvaG44ZmpSZUV0M0FRTFdDc0NoRWRQcVArT01NeWJQbnorZnJSL2oxNWFwdHkvYU0zN1VVM0ZRMmZhNUxmVlJKL0swQVdKL2g1TSt0bnNYZUZIOFhqMG1Qdm5xcTY4K1Vqeit6T2ZxK2FxcWNiQ0RHdW5CQmtRS1Q1OXBGOUE3ZlI4dVArN2xpZDltSVZ1L0V5Q083VDZRV1o1VFZWV0NDKzk2eXkyelBLZHVGOGRDQmtSWnJ1ZXkyOFcyU2JsRit0Nng4QS8rZWtPNC85dmYvdlo1b2tOZERHS1BiUkpiSDhUSjFhZFphdTJCYlFUOUdYdjBlSk96bjlXL1RoaURIOXZEbzJPWjJNcUVMSXR0WEI5bFkwV2Z1YkVMNEN0OHRsZHZEL0c2T1FuZ0pMQlBKR29lY0Z5ellJTk0wL2F2ekoycisvNlo2cHlyMk5lRVRnREdpK09pQjBUcXZxTE1iWkNOVlgxMkFaQWtZTWZjcVFkblUvVmNZSkY0NWd4RzM5Zy9FamNHWkZVamtCc1J5eGpaODVuUGZJWUxQeTcybUFpN0FGc2JZS05OUzlMNlA4ZXlQcjZ5NzZicE9jcnBLcjhrWkJHeHdLaVBQbGN4Z1k4Umw0ZWxqU1pBM3JHTlNXZS9LcnQxOFhlU0tBYXorc2xvRytmQVVUWXZOa0dSekhVNUxXcGJKTXYxWEM1cVd5UnorNXdXdFMyUzVYb3VGN1ZGQmtBSk1zOU5GczJhTmV0RVVYeWI3d0FTTlFkMDJBdzQ4S2IwMS9YTmIzN3oySjZlbm1uaWVkejdwcERKQUc2WFU5ZkZDVnFXdHkwcXUrMVkwV2MrTEI0dUJuZnBLSjM4dmU5OWI0SDRvaVRBSHcxRE13bFFGQWo2Njdub29vdklXTGF3UHdtWkNBbVFaN3lEcGFwS1pzTjdRcTUzT2RiQnV6N24zZDcxTGg5Tyt0NEo4QjArM0h2KytlZWZJT29kbGpubEtGSDlnSlBxQlE5c1BaZnBLMlhvb2tXTHlGYTJmU2RBYkJzRFk5MUlhWnZiRlhVaUgvWE1qd1Y5NWtJU1ZIdzRiOTY4aFdXL01ILzhIT2VyNGtGbFpNTkM3dWhoRlVLRGFBQzhBOU90eDVqelZNWjRYdTFtSWw3OXRBUGl1RG52ZnQyZmRTd2ZML3JNRjcvaHczMTZWNEJ2VXZNalFLTEdBbzhpRUoxZmt0VC82Y0RRVi9jWHZ2Q0ZJM1hyd210T1BMN2tWUzhtQVhnc0J6UUcySDNRenZYV2NkMTQwN2ZmOE9GZTNxUFFMNUVjSlI0L1JOL2hwNGJCVHEyM0F3Zkp3VUVmdnV2aWl5OCtWcFF6bnovb2hMcXQyRXEyV2hZcHZORVRSQ2Z5cm85NnRJbHkrS2dUK2RqT2VxYXhMdXBFUHJheG5tbXNpenFSajIyc1p4cnIwQUY4N2NUWDUvdDBiVFZIbERyWFcwZWlRWDZtWEJNMGN4dkk0QVpQc2t2bi85RVNzdjN6cFk4bkVOdGFaemdhZFNJL25KN3JvMDdrWFQ4Y2pUcVJIMDdQOVZFbjhxNGZqcUlENGtOOE9hQXYxZkN0Z3cvRnp3RHR2R01rUWEwZjlTYUFqWEwvTGtOVEV1aW5XL2p5QXNQNEl3Z2JSWDAxb0Uyc2orWElqMWQ5NW8wdkIvU1h4VHhacmZpNnpFZmZtYmZmMVdSb3FEY0JodW90R2FZTHdCbHFSTlppZElSb25IbnF6VHZZTGhmVklYTTdlTUR0TFhlNXFBNloyOEVEYm0rNXkwVjF5TndPSG5CN3kxMHVxa1BtZHZDQTIxdnVzdXVRcDhVMGRlcFUvbXJhdTYzcm9RMkR0NU42TzhESWlQU1RETlA3L255ZnpRN0Fkd0NlbE1lSk9xcE80QWtuL1V4R2tmcnhySThQdUtBZWtHOTVvZGIrR01vbjZOUUVMZDhCOU10ZDdwT0hHQmdKQmVCSkNGTW5BM1VBWlNjTVBHQVp2UFZNeDRzK2M3Y1A4UzN6eitkT200YkF3V3BJdWF4a1l4TFZZMHNNWkFmd0JhQURSbk8zaFkrQUhIQjlUSlR4cm85UDhPZUEzcTNJSHdEWmIvaXVJV2hGQXNTQk1RZ2prOEhsQ2hzSkpiQkFrY3h5N3dJdUY3VXRrcm45V05Oblhta3hoUVJBMWhKb0pnRUlRZ3hFNHN0R1loeEpFT3VSeFhLZUROUURibE1xbFQ0dGkzUTg2ZVBMQ2NHMytDSDZ3bnpKVzNWOE5wTUFjWmhvQUlFQjJicUJXRmVTbEQ2cnlXT2JvZmp4cE85ajBFbVBYNXFkZi9KdHF4TEFnWnJJejYwclV6R1Vvd0NJaGlKM09mS3BvVDV5MlZEbHZJNCtjdGxRNWJ5dW5mWHg1UUg1bGhkcjdEL3NiUnBhblFBVDlna21UZUp2SE5JT1FPWnlmaGx5NDExMk1GeW1QVEx2SXVOWkg1K2t4U1RYcHFQQXptZ0Z6UjNjYUo4RUMzQ1d3dk9PTy8zSG9FWStqaDE1dDdHdXkvUVorYWdUZWJjWksvck1JeVZBZVFlbytCcUhOQXZSY2ZYMmhTSFJtTVRyMTY5NEFFUVFTQUJERElaNTZzelQzcnpsVUlQcml0b2hLNUpiRjNxNDYvUHQ2c1N5YjVsUG9lK3BxQmR3VEtzZ0dhVi9vckMxM0NGUEJPMTRSQVRKVUl2Y2JheG5TaCt1ZzY4bWR4dlhteDV1K3N5akQ2UEx2dldpUTlRMDBIbXpNQ2diWDMzMVZSSUFaNmVzTGZPVTg0REVNdlVPVUJFLzN2WFRZdElQUzc0alA5bmZwaEkxRHMwbVFNeEdMdmIyUC9YVVU3d0d4cG5sSGNDQnhrb0hOdzkybEZmang2TSt2Z1A1RHFCcnpabzErRGI1V2RRUVkyQlp6YlRSQklqWkI1K2VWRUgxZTcrOEJZd01vN25McUJiUWpydzIzK0JEZkhsQWJ3YjdEZXZvYzFWVmRnWDR1cURlQkdEZ0lrQ2VVRm02UjMvVnludHM5TTJyNGRDaVlFdDgwTFpQTzhEdEkyK1pxZXRNY3pubHZNNXRZbDNlSnBZakgzVVBsVDdqcEsrQTMzbm5uYTNQUFBPTXYyRzF2N0V2aDJveHl0dWxjcjBKZ0ZJY0lCcmlyV2xnM2JwMS9QZ1RmZk51Z01ld0F5VktBWFppbUZydWR0Q2lPcmR6bmFubFkwbWZvM1M2Y0tMT2YzeHFIME9CNkgrWFUwV3RIeml2RWZEQXBqWXNmUW4weTEvK2NxTTZwVysvd0pEdVkxV093Zkc0eUlCWVo1bmx0ak8yU1VwbFBiZXJWbjg0Nm5zdStMRG5WNy82RlQ3bGEyRjhiSC9iLzZhcXFnK2lvMnZWdEdFNEZTUzRJSS8vdUYyWm9pZUJVL1ZQRmE4c1B4SDhvMlJjdlFJWWlqNFU4UGhGY3JjcHRmeXozbmpSWjk3c29DZnBDZUJFdlEzMHdIdnZ2Y2U3Z2J3ZDVCK01TQXRPNVR3aEpLb052REpxYXoyNEZRR0thQ01HWk9nKy9SKzlWMVJQWXZoVlpyRkRybkxYMnlhb2s4MkpFc3VXV2M5MHJPampPOTRCN05LdmgyNlVUNnNGMnpGZy9uV0RuVldQWWo2Z3k1VUVVR2NEWC8zcVYxOFFaUks4Sk1ydTRJQ0tIUlRZR0ZUYjQrQkNyZWQyNDBHZk9YUDFqKzk2ZnZqREg3S0x4dTNmUG9jYUltL1pzTlNPSHJaaDFzREJ3RkNRUUlPVlkwRDgxTmRmZi8zamVwT1ZNMnlUOEEwaFNUSWNNSkZHN2FMdnNhQ1BUMmNMRitnb2ZWZC9GZlNRZUxaLy90aVdPd0crRmF5Mkk2aXFkbUNnWmdCblIvUXVRTGJ1dS9mZWU1OFhKWk41bjczV1p3TFk1QVJ3b3RWRHg0SytmZGI5aTEvODRrWDV3NnZmRjREUjUvQU5neDFkYndjeElEZ2NqTHNBajRGNUVqaDE4K2JORitoblRxYUtmNzJNR0l4K0VaVzRFbno0b2RvTVZZY3VNRlNib2VwSzJxT2pqeTlaTVBQMW4wVDR1VGhXUHhkK0lLcy92U0VzNm1SZzBURVhvOWphZ2NFYUFROFdxUTNCc0xRRGlPN1YweXQrOTg0WnpWMENpWklua0VRcGliREhkWmFaSXFjK3RySE1iV0tkWmFadUc5dFk1amF4empKVHQ0MXRMSE9iV0dlWnFkdkdOcGE1RFhYNGFwYXdXLzlJYTYwb3Z1UlA3UjN3NlBPY1Y3UDZBQU1hQlhTTkdBNFNYTDRHNWxxQVhZQkhtRk8yYk5seXZuNytsQXVhdDRUOFpBekpnaTRUQUliaXFYYzdlTU5RT201UEc4RGxVcW4wMlk3NjJNUmZBYy9TMmI5SFovKy9pZmV0bjg5K2tnSC9GU1dFeFBVQlFXc0c3RmlvRWNOQURFMzR4UzkrY1pWZVptQnkzTmY2OGJEWVFhc1pXeHl3eU1kMnlHT2RlZlRNeC9id2dPdWc1cU84SGZSWlBDd2FidjBtZmV0YjMzcGFsSXM5ZkJpdkFmQ3pkMXV4aGNtTnZDWmcwR2JBQWFNUDgxQmpjdmp6enorLy85eHp6KzA2OGNRVHViTGxHTmd1ZFBKWVQ2SVVIQ2lBTHVCNlU4dGNOa1Z1bmNpNzNyUmQ5YkY5dnJCZi90cWtuOWhsKytlODkwTWZrb0RBRzczZ0pLcjRFcjR1aUU2cFM3SGMyUG9ZRHc4bHFVRE9Nb0tkamdGKzUwWS9HdjB4L2VBUlpaNE1jbEhJWkdvRituZlNvSk9YaCtzbmI1K1hSMU1mVzFqNWMvVEFaNEwreC9DL0t3bndVYnp3eTIvOW5BQ213OWxmV0I5WFRHR0RZWVFPaUkyQU9rT2h2b0RaczFlZ28rQVBPZ3Jva21jRFhCTTRjWERBY0tnbUNkeU9zY3pYUXN2cUZaMTIwY2NIM0RHbFcyWDlWNVhWQ2o2Qno3ZC9IQmY5SEhsVk5RYk5IZ0dNaXZPQm5Gcm00SFE5OTl4ekF6Tm16Tmk5Yk5teWVhcmt2R09TSkFrUTlhMWp1Y3RGYllhcU94ejAyU25uQ3Z1ZWVPS0o5WmRlZXVsYThWencrYUlQSC9tQ3owa2dVV3ZBRG0yMnR4Z0VNdHBJZ25GSEFMTDFKOVMvU0R0VnYzcDF2TXBjNFBBN2dweHp0b1hNQmloN2xWSTJYMFNwUHh6MThROVgvVlBmZXV1dGR4Y3NXUEE3L1RkUlZqOVAvRUNmLzc2d0pnR2NCUGdCYkFvSVZLdkFCa1dLc2I0aklKT1owQjc5OHVYeittZUp2TjFDOXM4VGtoZ0FRUVN4eTFSc0Fzc2NhTnNPTlg4NDZSTjg3dmVuOGVYWnB6Lzk2WlVLdmgvMDRDdGYvZWRCVjFYemdhY1R3STRybFJyL2pKa0lINDFtaXdlWlZDVUpUajMxMUNmMWtnUHZ1UEhjZ0ZYQUJhTURLTFlDMVFKTWc5amVQRFJDTytvVGZNNzg2ZnFxZC85MTExMzM1TU1QUDh4Rm4xZThFOEJiZjF4VTlyVnBuR3ZkZktzU3dBUG5oam9SNGk2UXpqZGRFKzQrNVpSVFZpb0plSDJNSkpncjVMcUFBR0tYQXlvMmdXMDFkVHNxaS9oMjFhOEVuMmNqWC9yU2wxYXVXTEdDaFpCMlI5RTgrUFpoOUMxemJnblltYTNvekJrWkRiWHgwSmdFYWJKc2VSLzYwSWVlMUQ5UTlrNHdSKzE0QlFxSVNVQXdBUWZWTk1weXZoMzFDVDdQUW5nWU52RnJYL3ZhMC9xM01IeExPdHhGbjMycXBnbnNhNWNicG5ac3d4MFVLRG80cGdUQ2lBUDhxSmd0UHowdTFqT0NQdjBiK1EvbzdvQUhJUndYUENoaVMyelpSTlhYYUlOWGZyKzIvUU5hK2FzVWZLNkR1Tmh6QXJBdzR0blBvc0VITENBblFVdDlnbEd0aHFHU3luVk1BajVOaHEzd1J6LzYwVnNubjN6eWdQNjlIQmRHSkFrSmdqT1lQR0JkcUxGSWJwbmJSTDI4em1YVDJMYVYrc3lGZWZWcjF4dTQ1cHBybnJ6ampqdlk5Ung0S0ZzL3llOXozMEUzYlduZ05VNkNrVWdBT3JZalM2TVVsejJoQ24zd3dRZDM3Tnk1YzdzZUc4L1crNFRjT3ZLQWhIb2NFd015RksrbWxmR0hhbGV0cnBYNjdId2NhVHpsNjlVTE1qcys4WWxQclB6MXIzKzlWZVU4K0Y3NWVRSXcvNHFQeExjVWNNSklnZnUybzMwbVEwazhrTnRBQXMwS2dYSWs5T2tIRVNjLzlOQkRwK2hPZ2ZPU0ZjRFd5RSttc2tvQStzUXBPUjJ1am5vZzEzTjV1THFrWEtNK3V4aGZmakczbnNjZmYzeURibi8vV0w3Vkkvak15U3QvdU9ESEpKQmE2MkNrZGdCYmlHTWo1R1hxUERsbzJ1NjNiZHZHWHhqOVNUODZ1ZnZNTTgrY3FSK2N3SWs4SzhDcDdBYTBCZWpQZlRyQmNobnRZaDFsNitSdFhYWTlla0E5K3ZpVWk3d1VmRjdtMUwvUFdYUFZWVmU5ckxNL3Jub1N3RmY4ekltNXgrMCsrc1h6VlpQV2dpZmEybDRIOStZeDdGdzdFd3JpTUFMTGJnQ3Q3QVR3K3FlVGZmcnZZNHQwTEN3cy8vSUlUdktGVTc0anFHb1FlT3dpQjFKbmVlUmpCL1hxazZRRVArMXVxMWF0Mm5MRkZWZXMxVCtDOWxNOWd1N0ErOHlQNXo3MjVFa2dVY1ZPK0phQ0o5alNUZ3M2OHpoUU1FOEN5azRBSHd2eGFKaDB3UVVYVE5PdXNGai9mcDZMS1J6RldZa1RjYTRUb2Q2QVlnczZ0cThSZmFtbjNZbnJGUUxmcmNlNnU3N3lsYSs4Y050dHQvRUNqQU51aXEwT1BuUHdtYy9ZaHpUNEdxOHljZmlSQmpzWmF2UXVZSnBXanVwakVwQUkzaGttZmZLVG41ejI5YTkvZmNIcHA1L09Nd1A2d1hFNEVRZHpsa0liQmZkWGl6NDJwV3NXVWV6djF0L3Y3N3pycnJ0ZXVmbm1tN20zSjhpMngwRzNESHZqdHA4SDNvbG9xdVlqQTB6NFVJTEhneHB4SHJ5VEFJcHpmVFE0K0pIMkxGNjh1UC9XVzIrZHJ3dXJPZnFyR1FLQkV3R2M2eFZHQUNqWEFqamI5a1hldXRSaGcrM0F2bVR6NXMyYnQ5OS8vLzBieTRGblREQVB1dVhZZzYwUkdTK2lpcWtNSFZId2hFZDBrS3h6andtTm1DZEMzQTE4UE1RQUlFdDQ3YlhYSG5IOTlkZlAxcitxblRWNThtU1NBV2M2OFBBK1o1RzV6Z2xER1Q3YVlwN3hZa0lpVDNicWdtN1A3My8vK3pkdnVlV1dMVC8vK2M5M1NFNkFHY2VyM05SeTJ6QlU0TEVGTUMyVlJ2Q1RDWTBHZUZ3N09xZHBaY2t3S0luZ1pDQWdUb1pJblF6ZFYxNTU1UlI5cHo3ejdMUFBucTdieVJuYUhiaURBQnhvODBtWWZkQ0dNYUhZNUhLeVQvZngyMWF2WHYyMjN0Vi8rd2MvK01FN1NnSVNpc0E2eUY3bExyc3VYL1cyQlFvQ09TMUpSL2lUaVkwV2VPeElrNk5sVUZwbGdYcTdKZEJPQmdjOVV0YzVjYnFXTGwzYXYzejU4c242NG1tS0xpRDdaOCtlM2FlM2JmdjVUZU8rdnI1dW9XNHV1dWhqQWwvTERnd003Tk9QTVEzb3JkejNYbnZ0dFYxcjE2N2RwYXY1bmZmY2M4ODJ2ZDFNSUkwRU4ySU1PbkszaThIUEExK1VBRkk5ZEdEbkg3b1JEeDdKTmpqNE9TMUtoaGpvbUJSUkRsOUpoREpQMzhnQWoxTXEvZm5UUVRHTlczWU1xb09QekFFM2RUc0huRDdjWDA0WkdkbW9BRTVvQjdBZGtUcEFwazRFeWpHd01kRHdzVXc3dDdXZUtmTjIzL0NBZ3dQdndDTXpUNERoSGVCSW85dzZrYnB2S0pEVGt2UVFmK0tBZGdMYkU2bURGR2xNQmdKT25RUHRvRWZxK3FpSHpHRGVRVUh1b0NNelQ4RE5PK0N4REU5NzY1aUhBaTZiVDhMUi9QREVSOU9HZk94b2szbG9yUmdUZ29BRERyeHA3TGZVNHMrZk1VaDVRRjAySlNIYzN0UjFsQUhMWGJZc1ZZNzJoeDB4Mm5ZVWpSOXRNdzgxb21PK0dxV05nNTd6bEswSER6aFk1cUVFRktBdUJ0ZHRxMUhyRkZGa2JRRTRvTjBoMm1nKzBwelB5OHdQbWVVdVE0Y0NBZ3RFbXZNT3Z0dkZlc3NpaFc4cmlFNXBLOE1LakltMkZ2SElMQitPdW51M2N4bnFJQmJ4cm9zMDhrVTZ5Tm9XaWh6UXRzWUd3NkxkUlh5UkRQVW9MeW9qYzBEaGdWZzJuOU5xN1ZJSDdmeVJPNlNkYmExbVd6NkhXSTQ4K25tNVdwOVI3bUFqcThibmRWRy9yZmxHSE5MV0U1SnhSWE1xa3RVN2p4aDg2eGJKWEhkWVVHNlpPbENiQnc3N1lOYzJ6VTZyamdjNkh1aDRvT09CamdjNkh1aDRvT09CamdjNkh1aDRvT09CamdjNkh1aDRvT09CTWVtQi93ZU5laDNSSS9xLzdRQUFBQUJKUlU1RXJrSmdnZz09JylcIjtcblx0ICAgIHRoaXMudG91Y2hQb2ludGVySW1hZ2VTaXplID0gNjQ7XG5cdCAgICB0aGlzLnRvdWNoUG9pbnRlckluaXRpYWxPZmZzZXQgPSB7XG5cdCAgICAgIHg6IDAsXG5cdCAgICAgIHk6IDBcblx0ICAgIH07XG5cdCAgICB0aGlzLmtleVBpbmNoQ29kZSA9IDE4O1xuXHQgICAgdGhpcy5rZXlQYW5Db2RlID0gOTE7XG5cdCAgICB0aGlzLmNvbnRleHQgPSBuZXcgRnJhbWVyLkNvbnRleHQoe1xuXHQgICAgICBuYW1lOiBcIlRvdWNoRW11bGF0b3JcIlxuXHQgICAgfSk7XG5cdCAgICB0aGlzLmNvbnRleHQuX2VsZW1lbnQuc3R5bGUuekluZGV4ID0gMTAwMDA7XG5cdCAgICB0aGlzLndyYXAgPSB0aGlzLmNvbnRleHQuZG9tRXZlbnRNYW5hZ2VyLndyYXA7XG5cdCAgICB0aGlzLndyYXAoZG9jdW1lbnQpLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5tb3VzZWRvd24sIHRydWUpO1xuXHQgICAgdGhpcy53cmFwKGRvY3VtZW50KS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW91c2Vtb3ZlLCB0cnVlKTtcblx0ICAgIHRoaXMud3JhcChkb2N1bWVudCkuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy5tb3VzZXVwLCB0cnVlKTtcblx0ICAgIHRoaXMud3JhcChkb2N1bWVudCkuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5rZXlkb3duLCB0cnVlKTtcblx0ICAgIHRoaXMud3JhcChkb2N1bWVudCkuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIHRoaXMua2V5dXAsIHRydWUpO1xuXHQgICAgdGhpcy53cmFwKGRvY3VtZW50KS5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdXRcIiwgdGhpcy5tb3VzZW91dCwgdHJ1ZSk7XG5cdCAgICB0aGlzLmlzTW91c2VEb3duID0gZmFsc2U7XG5cdCAgICB0aGlzLmlzUGluY2hLZXlEb3duID0gZmFsc2U7XG5cdCAgICB0aGlzLmlzUGFuS2V5RG93biA9IGZhbHNlO1xuXHQgICAgdG91Y2hQb2ludGVySW5pdGlhbE9mZnNldCA9IHRoaXMudG91Y2hQb2ludGVySW5pdGlhbE9mZnNldDtcblx0ICAgIHRoaXMuY29udGV4dC5ydW4oKGZ1bmN0aW9uKF90aGlzKSB7XG5cdCAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgICAgICBfdGhpcy50b3VjaFBvaW50TGF5ZXIgPSBuZXcgTGF5ZXIoe1xuXHQgICAgICAgICAgd2lkdGg6IF90aGlzLnRvdWNoUG9pbnRlckltYWdlU2l6ZSxcblx0ICAgICAgICAgIGhlaWdodDogX3RoaXMudG91Y2hQb2ludGVySW1hZ2VTaXplLFxuXHQgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBudWxsLFxuXHQgICAgICAgICAgb3BhY2l0eTogMFxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJldHVybiBfdGhpcy50b3VjaFBvaW50TGF5ZXIuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gX3RoaXMudG91Y2hQb2ludGVySW1hZ2U7XG5cdCAgICAgIH07XG5cdCAgICB9KSh0aGlzKSk7XG5cdCAgfVxuXHRcblx0ICBUb3VjaEVtdWxhdG9yLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG5cdCAgICB0aGlzLmNvbnRleHQucmVzZXQoKTtcblx0ICAgIHJldHVybiB0aGlzLmNvbnRleHQgPSBudWxsO1xuXHQgIH07XG5cdFxuXHQgIFRvdWNoRW11bGF0b3IucHJvdG90eXBlLmtleWRvd24gPSBmdW5jdGlvbihldmVudCkge1xuXHQgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IHRoaXMua2V5UGluY2hDb2RlKSB7XG5cdCAgICAgIHRoaXMuaXNQaW5jaEtleURvd24gPSB0cnVlO1xuXHQgICAgICB0aGlzLnN0YXJ0UG9pbnQgPSB0aGlzLmNlbnRlclBvaW50ID0gbnVsbDtcblx0ICAgICAgdGhpcy5zaG93VG91Y2hDdXJzb3IoKTtcblx0ICAgICAgdGhpcy50b3VjaFBvaW50TGF5ZXIubWlkWCA9IHRoaXMucG9pbnQueDtcblx0ICAgICAgdGhpcy50b3VjaFBvaW50TGF5ZXIubWlkWSA9IHRoaXMucG9pbnQueTtcblx0ICAgIH1cblx0ICAgIGlmIChldmVudC5rZXlDb2RlID09PSB0aGlzLmtleVBhbkNvZGUpIHtcblx0ICAgICAgdGhpcy5pc1BhbktleURvd24gPSB0cnVlO1xuXHQgICAgICByZXR1cm4gY2FuY2VsRXZlbnQoZXZlbnQpO1xuXHQgICAgfVxuXHQgIH07XG5cdFxuXHQgIFRvdWNoRW11bGF0b3IucHJvdG90eXBlLmtleXVwID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0ICAgIGlmIChldmVudC5rZXlDb2RlID09PSB0aGlzLmtleVBpbmNoQ29kZSkge1xuXHQgICAgICBjYW5jZWxFdmVudChldmVudCk7XG5cdCAgICAgIHRoaXMuaXNQaW5jaEtleURvd24gPSBmYWxzZTtcblx0ICAgICAgdGhpcy5oaWRlVG91Y2hDdXJzb3IoKTtcblx0ICAgIH1cblx0ICAgIGlmIChldmVudC5rZXlDb2RlID09PSB0aGlzLmtleVBhbkNvZGUpIHtcblx0ICAgICAgY2FuY2VsRXZlbnQoZXZlbnQpO1xuXHQgICAgICBpZiAodGhpcy50b3VjaFBvaW50ICYmIHRoaXMucG9pbnQpIHtcblx0ICAgICAgICB0aGlzLmNlbnRlclBvaW50ID0gVXRpbHMucG9pbnRDZW50ZXIodGhpcy50b3VjaFBvaW50LCB0aGlzLnBvaW50KTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5pc1BhbktleURvd24gPSBmYWxzZTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cdFxuXHQgIFRvdWNoRW11bGF0b3IucHJvdG90eXBlLm1vdXNlZG93biA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdCAgICB0aGlzLmlzTW91c2VEb3duID0gdHJ1ZTtcblx0ICAgIHRoaXMudGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuXHQgICAgaWYgKHRoaXMuaXNQaW5jaEtleURvd24pIHtcblx0ICAgICAgZGlzcGF0Y2hUb3VjaEV2ZW50KFwidG91Y2hzdGFydFwiLCB0aGlzLnRhcmdldCwgZXZlbnQsIHRoaXMudG91Y2hQb2ludERlbHRhKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGRpc3BhdGNoVG91Y2hFdmVudChcInRvdWNoc3RhcnRcIiwgdGhpcy50YXJnZXQsIGV2ZW50KTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0aGlzLnRvdWNoUG9pbnRMYXllci5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSB0aGlzLnRvdWNoUG9pbnRlckltYWdlQWN0aXZlO1xuXHQgIH07XG5cdFxuXHQgIFRvdWNoRW11bGF0b3IucHJvdG90eXBlLm1vdXNlbW92ZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdCAgICB0aGlzLnBvaW50ID0ge1xuXHQgICAgICB4OiBldmVudC5wYWdlWCxcblx0ICAgICAgeTogZXZlbnQucGFnZVlcblx0ICAgIH07XG5cdCAgICBpZiAodGhpcy5zdGFydFBvaW50ID09IG51bGwpIHtcblx0ICAgICAgdGhpcy5zdGFydFBvaW50ID0gdGhpcy5wb2ludDtcblx0ICAgIH1cblx0ICAgIGlmICh0aGlzLmNlbnRlclBvaW50ID09IG51bGwpIHtcblx0ICAgICAgdGhpcy5jZW50ZXJQb2ludCA9IHRoaXMucG9pbnQ7XG5cdCAgICB9XG5cdCAgICBpZiAodGhpcy5pc1BpbmNoS2V5RG93biAmJiAhdGhpcy5pc1BhbktleURvd24pIHtcblx0ICAgICAgaWYgKHRoaXMudG91Y2hQb2ludGVySW5pdGlhbE9mZnNldCAmJiB0aGlzLmNlbnRlclBvaW50KSB7XG5cdCAgICAgICAgdGhpcy50b3VjaFBvaW50ID0gVXRpbHMucG9pbnRBZGQodGhpcy50b3VjaFBvaW50ZXJJbml0aWFsT2Zmc2V0LCB0aGlzLnBpbmNoUG9pbnQodGhpcy5wb2ludCwgdGhpcy5jZW50ZXJQb2ludCkpO1xuXHQgICAgICAgIHRoaXMudG91Y2hQb2ludERlbHRhID0gVXRpbHMucG9pbnRTdWJ0cmFjdCh0aGlzLnBvaW50LCB0aGlzLnRvdWNoUG9pbnQpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICBpZiAodGhpcy5pc1BpbmNoS2V5RG93biAmJiB0aGlzLmlzUGFuS2V5RG93bikge1xuXHQgICAgICBpZiAodGhpcy50b3VjaFBvaW50ICYmIHRoaXMudG91Y2hQb2ludERlbHRhKSB7XG5cdCAgICAgICAgdGhpcy50b3VjaFBvaW50ID0gdGhpcy5wYW5Qb2ludCh0aGlzLnBvaW50LCB0aGlzLnRvdWNoUG9pbnREZWx0YSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIGlmICh0aGlzLmlzUGluY2hLZXlEb3duIHx8IHRoaXMuaXNQYW5LZXlEb3duKSB7XG5cdCAgICAgIGlmICh0aGlzLnRvdWNoUG9pbnQpIHtcblx0ICAgICAgICB0aGlzLnRvdWNoUG9pbnRMYXllci52aXNpYmxlID0gdHJ1ZTtcblx0ICAgICAgICB0aGlzLnRvdWNoUG9pbnRMYXllci5taWRYID0gdGhpcy50b3VjaFBvaW50Lng7XG5cdCAgICAgICAgdGhpcy50b3VjaFBvaW50TGF5ZXIubWlkWSA9IHRoaXMudG91Y2hQb2ludC55O1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICBpZiAodGhpcy5pc01vdXNlRG93bikge1xuXHQgICAgICBpZiAoKHRoaXMuaXNQaW5jaEtleURvd24gfHwgdGhpcy5pc1BhbktleURvd24pICYmIHRoaXMudG91Y2hQb2ludERlbHRhKSB7XG5cdCAgICAgICAgcmV0dXJuIGRpc3BhdGNoVG91Y2hFdmVudChcInRvdWNobW92ZVwiLCB0aGlzLnRhcmdldCwgZXZlbnQsIHRoaXMudG91Y2hQb2ludERlbHRhKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gZGlzcGF0Y2hUb3VjaEV2ZW50KFwidG91Y2htb3ZlXCIsIHRoaXMudGFyZ2V0LCBldmVudCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXHRcblx0ICBUb3VjaEVtdWxhdG9yLnByb3RvdHlwZS5tb3VzZXVwID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0ICAgIGlmICh0aGlzLmlzUGluY2hLZXlEb3duIHx8IHRoaXMuaXNQYW5LZXlEb3duKSB7XG5cdCAgICAgIGRpc3BhdGNoVG91Y2hFdmVudChcInRvdWNoZW5kXCIsIHRoaXMudGFyZ2V0LCBldmVudCwgdGhpcy50b3VjaFBvaW50RGVsdGEpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZGlzcGF0Y2hUb3VjaEV2ZW50KFwidG91Y2hlbmRcIiwgdGhpcy50YXJnZXQsIGV2ZW50KTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0aGlzLmVuZE11bHRpVG91Y2goKTtcblx0ICB9O1xuXHRcblx0ICBUb3VjaEVtdWxhdG9yLnByb3RvdHlwZS5tb3VzZW91dCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdCAgICB2YXIgZnJvbUVsZW1lbnQ7XG5cdCAgICBpZiAodGhpcy5pc01vdXNlRG93bikge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICBmcm9tRWxlbWVudCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgZXZlbnQudG9FbGVtZW50O1xuXHQgICAgaWYgKCFmcm9tRWxlbWVudCB8fCBmcm9tRWxlbWVudC5ub2RlTmFtZSA9PT0gXCJIVE1MXCIpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuZW5kTXVsdGlUb3VjaCgpO1xuXHQgICAgfVxuXHQgIH07XG5cdFxuXHQgIFRvdWNoRW11bGF0b3IucHJvdG90eXBlLnNob3dUb3VjaEN1cnNvciA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdGhpcy50b3VjaFBvaW50TGF5ZXIuYW5pbWF0ZVN0b3AoKTtcblx0ICAgIHRoaXMudG91Y2hQb2ludExheWVyLm1pZFggPSB0aGlzLnBvaW50Lng7XG5cdCAgICB0aGlzLnRvdWNoUG9pbnRMYXllci5taWRZID0gdGhpcy5wb2ludC55O1xuXHQgICAgdGhpcy50b3VjaFBvaW50TGF5ZXIuc2NhbGUgPSAxLjg7XG5cdCAgICByZXR1cm4gdGhpcy50b3VjaFBvaW50TGF5ZXIuYW5pbWF0ZSh7XG5cdCAgICAgIHByb3BlcnRpZXM6IHtcblx0ICAgICAgICBvcGFjaXR5OiAxLFxuXHQgICAgICAgIHNjYWxlOiAxXG5cdCAgICAgIH0sXG5cdCAgICAgIHRpbWU6IDAuMSxcblx0ICAgICAgY3VydmU6IFwiZWFzZS1vdXRcIlxuXHQgICAgfSk7XG5cdCAgfTtcblx0XG5cdCAgVG91Y2hFbXVsYXRvci5wcm90b3R5cGUuaGlkZVRvdWNoQ3Vyc29yID0gZnVuY3Rpb24oKSB7XG5cdCAgICB0aGlzLnRvdWNoUG9pbnRMYXllci5hbmltYXRlU3RvcCgpO1xuXHQgICAgcmV0dXJuIHRoaXMudG91Y2hQb2ludExheWVyLmFuaW1hdGUoe1xuXHQgICAgICBwcm9wZXJ0aWVzOiB7XG5cdCAgICAgICAgb3BhY2l0eTogMCxcblx0ICAgICAgICBzY2FsZTogMS4yXG5cdCAgICAgIH0sXG5cdCAgICAgIHRpbWU6IDAuMDhcblx0ICAgIH0pO1xuXHQgIH07XG5cdFxuXHQgIFRvdWNoRW11bGF0b3IucHJvdG90eXBlLm1vdXNlbW92ZVBvc2l0aW9uID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0ICAgIHJldHVybiB0aGlzLnBvaW50ID0ge1xuXHQgICAgICB4OiBldmVudC5wYWdlWCxcblx0ICAgICAgeTogZXZlbnQucGFnZVlcblx0ICAgIH07XG5cdCAgfTtcblx0XG5cdCAgVG91Y2hFbXVsYXRvci5wcm90b3R5cGUuZW5kTXVsdGlUb3VjaCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdGhpcy5pc01vdXNlRG93biA9IGZhbHNlO1xuXHQgICAgdGhpcy50b3VjaFBvaW50TGF5ZXIuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gdGhpcy50b3VjaFBvaW50ZXJJbWFnZTtcblx0ICAgIHJldHVybiB0aGlzLmhpZGVUb3VjaEN1cnNvcigpO1xuXHQgIH07XG5cdFxuXHQgIFRvdWNoRW11bGF0b3IucHJvdG90eXBlLnBpbmNoUG9pbnQgPSBmdW5jdGlvbihwb2ludCwgY2VudGVyUG9pbnQpIHtcblx0ICAgIHJldHVybiBVdGlscy5wb2ludFN1YnRyYWN0KGNlbnRlclBvaW50LCBVdGlscy5wb2ludFN1YnRyYWN0KHBvaW50LCBjZW50ZXJQb2ludCkpO1xuXHQgIH07XG5cdFxuXHQgIFRvdWNoRW11bGF0b3IucHJvdG90eXBlLnBhblBvaW50ID0gZnVuY3Rpb24ocG9pbnQsIG9mZnNldFBvaW50KSB7XG5cdCAgICByZXR1cm4gVXRpbHMucG9pbnRTdWJ0cmFjdChwb2ludCwgb2Zmc2V0UG9pbnQpO1xuXHQgIH07XG5cdFxuXHQgIHJldHVybiBUb3VjaEVtdWxhdG9yO1xuXHRcblx0fSkoQmFzZUNsYXNzKTtcblx0XG5cdHRvdWNoRW11bGF0b3IgPSBudWxsO1xuXHRcblx0ZXhwb3J0cy5lbmFibGUgPSBmdW5jdGlvbigpIHtcblx0ICBpZiAoVXRpbHMuaXNUb3VjaCgpKSB7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXHQgIHJldHVybiB0b3VjaEVtdWxhdG9yICE9IG51bGwgPyB0b3VjaEVtdWxhdG9yIDogdG91Y2hFbXVsYXRvciA9IG5ldyBUb3VjaEVtdWxhdG9yKCk7XG5cdH07XG5cdFxuXHRleHBvcnRzLmRpc2FibGUgPSBmdW5jdGlvbigpIHtcblx0ICBpZiAoIXRvdWNoRW11bGF0b3IpIHtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cdCAgdG91Y2hFbXVsYXRvci5kZXN0cm95KCk7XG5cdCAgcmV0dXJuIHRvdWNoRW11bGF0b3IgPSBudWxsO1xuXHR9O1xuXG5cbi8qKiovIH0sXG4vKiA1MSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIFV0aWxzLFxuXHQgIGJpbmQgPSBmdW5jdGlvbihmbiwgbWUpeyByZXR1cm4gZnVuY3Rpb24oKXsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9OyB9LFxuXHQgIGV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcblx0ICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cdFxuXHRVdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdFxuXHRleHBvcnRzLmVuYWJsZSA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciBNb2JpbGVTY3JvbGxGaXhMYXllciwgaGFuZGxlU2Nyb2xsaW5nTGF5ZXJUb3VjaE1vdmUsIGhhbmRsZVNjcm9sbGluZ0xheWVyVG91Y2hTdGFydDtcblx0ICBkb2N1bWVudC5vbnRvdWNobW92ZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdCAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSBkb2N1bWVudC5ib2R5KSB7XG5cdCAgICAgIHJldHVybiBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgaGFuZGxlU2Nyb2xsaW5nTGF5ZXJUb3VjaE1vdmUgPSBmdW5jdGlvbihldmVudCkge1xuXHQgICAgcmV0dXJuIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHQgIH07XG5cdCAgaGFuZGxlU2Nyb2xsaW5nTGF5ZXJUb3VjaFN0YXJ0ID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0ICAgIHZhciBlbGVtZW50LCBzdGFydFRvcFNjcm9sbDtcblx0ICAgIGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50O1xuXHQgICAgc3RhcnRUb3BTY3JvbGwgPSBlbGVtZW50LnNjcm9sbFRvcDtcblx0ICAgIGlmIChzdGFydFRvcFNjcm9sbCA8PSAwKSB7XG5cdCAgICAgIGVsZW1lbnQuc2Nyb2xsVG9wID0gMTtcblx0ICAgIH1cblx0ICAgIGlmIChzdGFydFRvcFNjcm9sbCArIGVsZW1lbnQub2Zmc2V0SGVpZ2h0ID49IGVsZW1lbnQuc2Nyb2xsSGVpZ2h0KSB7XG5cdCAgICAgIHJldHVybiBlbGVtZW50LnNjcm9sbFRvcCA9IGVsZW1lbnQuc2Nyb2xsSGVpZ2h0IC0gZWxlbWVudC5vZmZzZXRIZWlnaHQgLSAxO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgTW9iaWxlU2Nyb2xsRml4TGF5ZXIgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuXHQgICAgZXh0ZW5kKE1vYmlsZVNjcm9sbEZpeExheWVyLCBzdXBlckNsYXNzKTtcblx0XG5cdCAgICBmdW5jdGlvbiBNb2JpbGVTY3JvbGxGaXhMYXllcihvcHRpb25zKSB7XG5cdCAgICAgIHRoaXMuX3VwZGF0ZVNjcm9sbExpc3RlbmVycyA9IGJpbmQodGhpcy5fdXBkYXRlU2Nyb2xsTGlzdGVuZXJzLCB0aGlzKTtcblx0ICAgICAgTW9iaWxlU2Nyb2xsRml4TGF5ZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiTGF5ZXJcIikge1xuXHQgICAgICAgIHRoaXMub24oXCJjaGFuZ2U6c2Nyb2xsVmVydGljYWxcIiwgdGhpcy5fdXBkYXRlU2Nyb2xsTGlzdGVuZXJzKTtcblx0ICAgICAgICB0aGlzLl91cGRhdGVTY3JvbGxMaXN0ZW5lcnMoKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHRcblx0ICAgIE1vYmlsZVNjcm9sbEZpeExheWVyLnByb3RvdHlwZS5fdXBkYXRlU2Nyb2xsTGlzdGVuZXJzID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgIGlmICh0aGlzLnNjcm9sbFZlcnRpY2FsID09PSB0cnVlKSB7XG5cdCAgICAgICAgdGhpcy5vbihcInRvdWNobW92ZVwiLCBoYW5kbGVTY3JvbGxpbmdMYXllclRvdWNoTW92ZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMub24oXCJ0b3VjaHN0YXJ0XCIsIGhhbmRsZVNjcm9sbGluZ0xheWVyVG91Y2hTdGFydCk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdGhpcy5vZmYoXCJ0b3VjaG1vdmVcIiwgaGFuZGxlU2Nyb2xsaW5nTGF5ZXJUb3VjaE1vdmUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzLm9mZihcInRvdWNoc3RhcnRcIiwgaGFuZGxlU2Nyb2xsaW5nTGF5ZXJUb3VjaFN0YXJ0KTtcblx0ICAgICAgfVxuXHQgICAgfTtcblx0XG5cdCAgICByZXR1cm4gTW9iaWxlU2Nyb2xsRml4TGF5ZXI7XG5cdFxuXHQgIH0pKEZyYW1lci5MYXllcik7XG5cdCAgcmV0dXJuIHdpbmRvdy5MYXllciA9IHdpbmRvdy5GcmFtZXIuTGF5ZXIgPSBNb2JpbGVTY3JvbGxGaXhMYXllcjtcblx0fTtcblxuXG4vKioqLyB9LFxuLyogNTIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdHZhciBzbGljZSA9IFtdLnNsaWNlO1xuXHRcblx0ZXhwb3J0cy5lbmFibGUgPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0ICB2YXIgQ2xhc3NXcmFwcGVyO1xuXHQgIGlmIChtb2R1bGUgPT0gbnVsbCkge1xuXHQgICAgbW9kdWxlID0gd2luZG93O1xuXHQgIH1cblx0ICBDbGFzc1dyYXBwZXIgPSBmdW5jdGlvbihLbGFzcykge1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgICB2YXIgYXJncztcblx0ICAgICAgYXJncyA9IDEgPD0gYXJndW1lbnRzLmxlbmd0aCA/IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSA6IFtdO1xuXHQgICAgICByZXR1cm4gdGhpcy5wcm90b3R5cGUgPSAoZnVuY3Rpb24oZnVuYywgYXJncywgY3Rvcikge1xuXHQgICAgICAgIGN0b3IucHJvdG90eXBlID0gZnVuYy5wcm90b3R5cGU7XG5cdCAgICAgICAgdmFyIGNoaWxkID0gbmV3IGN0b3IsIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY2hpbGQsIGFyZ3MpO1xuXHQgICAgICAgIHJldHVybiBPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0ID8gcmVzdWx0IDogY2hpbGQ7XG5cdCAgICAgIH0pKEtsYXNzLCBhcmdzLCBmdW5jdGlvbigpe30pO1xuXHQgICAgfTtcblx0ICB9O1xuXHQgIG1vZHVsZS5GcmFtZSA9IENsYXNzV3JhcHBlcihGcmFtZXIuRnJhbWUpO1xuXHQgIG1vZHVsZS5MYXllciA9IENsYXNzV3JhcHBlcihGcmFtZXIuTGF5ZXIpO1xuXHQgIG1vZHVsZS5CYWNrZ3JvdW5kTGF5ZXIgPSBDbGFzc1dyYXBwZXIoRnJhbWVyLkJhY2tncm91bmRMYXllcik7XG5cdCAgbW9kdWxlLlZpZGVvTGF5ZXIgPSBDbGFzc1dyYXBwZXIoRnJhbWVyLlZpZGVvTGF5ZXIpO1xuXHQgIHJldHVybiBtb2R1bGUuQW5pbWF0aW9uID0gQ2xhc3NXcmFwcGVyKEZyYW1lci5BbmltYXRpb24pO1xuXHR9O1xuXG5cbi8qKiovIH0sXG4vKiA1MyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIERPTUV2ZW50TWFuYWdlciwgR2VzdHVyZUlucHV0RG91YmxlVGFwVGltZSwgR2VzdHVyZUlucHV0RWRnZVN3aXBlRGlzdGFuY2UsIEdlc3R1cmVJbnB1dEZvcmNlVGFwRGVza3RvcCwgR2VzdHVyZUlucHV0Rm9yY2VUYXBNb2JpbGUsIEdlc3R1cmVJbnB1dEZvcmNlVGFwTW9iaWxlUG9sbFRpbWUsIEdlc3R1cmVJbnB1dExvbmdQcmVzc1RpbWUsIEdlc3R1cmVJbnB1dE1pbmltdW1GaW5nZXJEaXN0YW5jZSwgR2VzdHVyZUlucHV0U3dpcGVUaHJlc2hvbGQsIEdlc3R1cmVJbnB1dFZlbG9jaXR5VGltZSwgVXRpbHMsXG5cdCAgYmluZCA9IGZ1bmN0aW9uKGZuLCBtZSl7IHJldHVybiBmdW5jdGlvbigpeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH07XG5cdFxuXHRVdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdFxuXHRHZXN0dXJlSW5wdXRMb25nUHJlc3NUaW1lID0gMC41O1xuXHRcblx0R2VzdHVyZUlucHV0RG91YmxlVGFwVGltZSA9IDAuMjU7XG5cdFxuXHRHZXN0dXJlSW5wdXRTd2lwZVRocmVzaG9sZCA9IDMwO1xuXHRcblx0R2VzdHVyZUlucHV0RWRnZVN3aXBlRGlzdGFuY2UgPSAzMDtcblx0XG5cdEdlc3R1cmVJbnB1dFZlbG9jaXR5VGltZSA9IDAuMTtcblx0XG5cdEdlc3R1cmVJbnB1dEZvcmNlVGFwRGVza3RvcCA9IE1vdXNlRXZlbnQuV0VCS0lUX0ZPUkNFX0FUX0ZPUkNFX01PVVNFX0RPV047XG5cdFxuXHRHZXN0dXJlSW5wdXRGb3JjZVRhcE1vYmlsZSA9IDAuNztcblx0XG5cdEdlc3R1cmVJbnB1dEZvcmNlVGFwTW9iaWxlUG9sbFRpbWUgPSAxIC8gMzA7XG5cdFxuXHRHZXN0dXJlSW5wdXRNaW5pbXVtRmluZ2VyRGlzdGFuY2UgPSAzMDtcblx0XG5cdERPTUV2ZW50TWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oNDIpLkRPTUV2ZW50TWFuYWdlcjtcblx0XG5cdGV4cG9ydHMuR2VzdHVyZUlucHV0UmVjb2duaXplciA9IChmdW5jdGlvbigpIHtcblx0ICBmdW5jdGlvbiBHZXN0dXJlSW5wdXRSZWNvZ25pemVyKCkge1xuXHQgICAgdGhpcy5fcHJvY2VzcyA9IGJpbmQodGhpcy5fcHJvY2VzcywgdGhpcyk7XG5cdCAgICB0aGlzLmVkZ2Vzd2lwZWRpcmVjdGlvbmVuZCA9IGJpbmQodGhpcy5lZGdlc3dpcGVkaXJlY3Rpb25lbmQsIHRoaXMpO1xuXHQgICAgdGhpcy5lZGdlc3dpcGVkaXJlY3Rpb25zdGFydCA9IGJpbmQodGhpcy5lZGdlc3dpcGVkaXJlY3Rpb25zdGFydCwgdGhpcyk7XG5cdCAgICB0aGlzLmVkZ2Vzd2lwZWRpcmVjdGlvbiA9IGJpbmQodGhpcy5lZGdlc3dpcGVkaXJlY3Rpb24sIHRoaXMpO1xuXHQgICAgdGhpcy5zd2lwZWRpcmVjdGlvbmVuZCA9IGJpbmQodGhpcy5zd2lwZWRpcmVjdGlvbmVuZCwgdGhpcyk7XG5cdCAgICB0aGlzLnN3aXBlZGlyZWN0aW9uID0gYmluZCh0aGlzLnN3aXBlZGlyZWN0aW9uLCB0aGlzKTtcblx0ICAgIHRoaXMuc3dpcGVkaXJlY3Rpb25zdGFydCA9IGJpbmQodGhpcy5zd2lwZWRpcmVjdGlvbnN0YXJ0LCB0aGlzKTtcblx0ICAgIHRoaXMuc3dpcGVlbmQgPSBiaW5kKHRoaXMuc3dpcGVlbmQsIHRoaXMpO1xuXHQgICAgdGhpcy5zd2lwZSA9IGJpbmQodGhpcy5zd2lwZSwgdGhpcyk7XG5cdCAgICB0aGlzLnN3aXBlc3RhcnQgPSBiaW5kKHRoaXMuc3dpcGVzdGFydCwgdGhpcyk7XG5cdCAgICB0aGlzLnJvdGF0ZWVuZCA9IGJpbmQodGhpcy5yb3RhdGVlbmQsIHRoaXMpO1xuXHQgICAgdGhpcy5yb3RhdGUgPSBiaW5kKHRoaXMucm90YXRlLCB0aGlzKTtcblx0ICAgIHRoaXMucm90YXRlc3RhcnQgPSBiaW5kKHRoaXMucm90YXRlc3RhcnQsIHRoaXMpO1xuXHQgICAgdGhpcy5zY2FsZWVuZCA9IGJpbmQodGhpcy5zY2FsZWVuZCwgdGhpcyk7XG5cdCAgICB0aGlzLnNjYWxlID0gYmluZCh0aGlzLnNjYWxlLCB0aGlzKTtcblx0ICAgIHRoaXMuc2NhbGVzdGFydCA9IGJpbmQodGhpcy5zY2FsZXN0YXJ0LCB0aGlzKTtcblx0ICAgIHRoaXMucGluY2hlbmQgPSBiaW5kKHRoaXMucGluY2hlbmQsIHRoaXMpO1xuXHQgICAgdGhpcy5waW5jaCA9IGJpbmQodGhpcy5waW5jaCwgdGhpcyk7XG5cdCAgICB0aGlzLnBpbmNoc3RhcnQgPSBiaW5kKHRoaXMucGluY2hzdGFydCwgdGhpcyk7XG5cdCAgICB0aGlzLnBhbnJpZ2h0ID0gYmluZCh0aGlzLnBhbnJpZ2h0LCB0aGlzKTtcblx0ICAgIHRoaXMucGFubGVmdCA9IGJpbmQodGhpcy5wYW5sZWZ0LCB0aGlzKTtcblx0ICAgIHRoaXMucGFuZG93biA9IGJpbmQodGhpcy5wYW5kb3duLCB0aGlzKTtcblx0ICAgIHRoaXMucGFudXAgPSBiaW5kKHRoaXMucGFudXAsIHRoaXMpO1xuXHQgICAgdGhpcy5wYW5lbmQgPSBiaW5kKHRoaXMucGFuZW5kLCB0aGlzKTtcblx0ICAgIHRoaXMucGFuID0gYmluZCh0aGlzLnBhbiwgdGhpcyk7XG5cdCAgICB0aGlzLnBhbnN0YXJ0ID0gYmluZCh0aGlzLnBhbnN0YXJ0LCB0aGlzKTtcblx0ICAgIHRoaXMuZm9yY2V0YXBlbmQgPSBiaW5kKHRoaXMuZm9yY2V0YXBlbmQsIHRoaXMpO1xuXHQgICAgdGhpcy5mb3JjZXRhcHN0YXJ0ID0gYmluZCh0aGlzLmZvcmNldGFwc3RhcnQsIHRoaXMpO1xuXHQgICAgdGhpcy5mb3JjZXRhcGNoYW5nZSA9IGJpbmQodGhpcy5mb3JjZXRhcGNoYW5nZSwgdGhpcyk7XG5cdCAgICB0aGlzLl91cGRhdGVNYWNGb3JjZSA9IGJpbmQodGhpcy5fdXBkYXRlTWFjRm9yY2UsIHRoaXMpO1xuXHQgICAgdGhpcy5fdXBkYXRlVG91Y2hGb3JjZSA9IGJpbmQodGhpcy5fdXBkYXRlVG91Y2hGb3JjZSwgdGhpcyk7XG5cdCAgICB0aGlzLmxvbmdwcmVzc2VuZCA9IGJpbmQodGhpcy5sb25ncHJlc3NlbmQsIHRoaXMpO1xuXHQgICAgdGhpcy5sb25ncHJlc3NzdGFydCA9IGJpbmQodGhpcy5sb25ncHJlc3NzdGFydCwgdGhpcyk7XG5cdCAgICB0aGlzLmRvdWJsZXRhcCA9IGJpbmQodGhpcy5kb3VibGV0YXAsIHRoaXMpO1xuXHQgICAgdGhpcy50YXBlbmQgPSBiaW5kKHRoaXMudGFwZW5kLCB0aGlzKTtcblx0ICAgIHRoaXMudGFwc3RhcnQgPSBiaW5kKHRoaXMudGFwc3RhcnQsIHRoaXMpO1xuXHQgICAgdGhpcy50YXAgPSBiaW5kKHRoaXMudGFwLCB0aGlzKTtcblx0ICAgIHRoaXMudG91Y2hlbmQgPSBiaW5kKHRoaXMudG91Y2hlbmQsIHRoaXMpO1xuXHQgICAgdGhpcy50b3VjaG1vdmUgPSBiaW5kKHRoaXMudG91Y2htb3ZlLCB0aGlzKTtcblx0ICAgIHRoaXMudG91Y2hzdGFydCA9IGJpbmQodGhpcy50b3VjaHN0YXJ0LCB0aGlzKTtcblx0ICAgIHRoaXMuc3RhcnRUb3VjaCA9IGJpbmQodGhpcy5zdGFydFRvdWNoLCB0aGlzKTtcblx0ICAgIHRoaXMuc3RhcnRNb3VzZSA9IGJpbmQodGhpcy5zdGFydE1vdXNlLCB0aGlzKTtcblx0ICAgIHRoaXMuZW0gPSBuZXcgRE9NRXZlbnRNYW5hZ2VyKCk7XG5cdCAgICB0aGlzLmVtLndyYXAod2luZG93KS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMuc3RhcnRNb3VzZSk7XG5cdCAgICB0aGlzLmVtLndyYXAod2luZG93KS5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0aGlzLnN0YXJ0VG91Y2gpO1xuXHQgIH1cblx0XG5cdCAgR2VzdHVyZUlucHV0UmVjb2duaXplci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuZW0ucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG5cdCAgfTtcblx0XG5cdCAgR2VzdHVyZUlucHV0UmVjb2duaXplci5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG5cdCAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuc2Vzc2lvbi5wcmVzc1RpbWVyKTtcblx0ICAgIHJldHVybiB0aGlzLnNlc3Npb24gPSBudWxsO1xuXHQgIH07XG5cdFxuXHQgIEdlc3R1cmVJbnB1dFJlY29nbml6ZXIucHJvdG90eXBlLnN0YXJ0TW91c2UgPSBmdW5jdGlvbihldmVudCkge1xuXHQgICAgaWYgKHRoaXMuc2Vzc2lvbikge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICB0aGlzLmVtLndyYXAod2luZG93KS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMudG91Y2htb3ZlKTtcblx0ICAgIHRoaXMuZW0ud3JhcCh3aW5kb3cpLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMudG91Y2hlbmQpO1xuXHQgICAgcmV0dXJuIHRoaXMudG91Y2hzdGFydChldmVudCk7XG5cdCAgfTtcblx0XG5cdCAgR2VzdHVyZUlucHV0UmVjb2duaXplci5wcm90b3R5cGUuc3RhcnRUb3VjaCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdCAgICBpZiAodGhpcy5zZXNzaW9uKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHRoaXMuZW0ud3JhcCh3aW5kb3cpLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy50b3VjaG1vdmUpO1xuXHQgICAgdGhpcy5lbS53cmFwKHdpbmRvdykuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMudG91Y2hlbmQpO1xuXHQgICAgcmV0dXJuIHRoaXMudG91Y2hzdGFydChldmVudCk7XG5cdCAgfTtcblx0XG5cdCAgR2VzdHVyZUlucHV0UmVjb2duaXplci5wcm90b3R5cGUudG91Y2hzdGFydCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdCAgICBpZiAodGhpcy5zZXNzaW9uKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHRoaXMuZW0ud3JhcCh3aW5kb3cpLmFkZEV2ZW50TGlzdGVuZXIoXCJ3ZWJraXRtb3VzZWZvcmNlY2hhbmdlZFwiLCB0aGlzLl91cGRhdGVNYWNGb3JjZSk7XG5cdCAgICB0aGlzLnNlc3Npb24gPSB7XG5cdCAgICAgIHN0YXJ0RXZlbnQ6IHRoaXMuX2dldEdlc3R1cmVFdmVudChldmVudCksXG5cdCAgICAgIGxhc3RFdmVudDogbnVsbCxcblx0ICAgICAgc3RhcnRNdWx0aUV2ZW50OiBudWxsLFxuXHQgICAgICBzdGFydFRpbWU6IERhdGUubm93KCksXG5cdCAgICAgIHByZXNzVGltZXI6IHdpbmRvdy5zZXRUaW1lb3V0KHRoaXMubG9uZ3ByZXNzc3RhcnQsIEdlc3R1cmVJbnB1dExvbmdQcmVzc1RpbWUgKiAxMDAwKSxcblx0ICAgICAgc3RhcnRlZDoge30sXG5cdCAgICAgIGV2ZW50czogW10sXG5cdCAgICAgIGV2ZW50Q291bnQ6IDBcblx0ICAgIH07XG5cdCAgICBldmVudCA9IHRoaXMuX2dldEdlc3R1cmVFdmVudChldmVudCk7XG5cdCAgICB0aGlzLnRhcHN0YXJ0KGV2ZW50KTtcblx0ICAgIGlmIChEYXRlLm5vdygpIC0gdGhpcy5kb3VibGVUYXBUaW1lIDwgKEdlc3R1cmVJbnB1dERvdWJsZVRhcFRpbWUgKiAxMDAwKSkge1xuXHQgICAgICB0aGlzLmRvdWJsZXRhcChldmVudCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aGlzLmRvdWJsZVRhcFRpbWUgPSBEYXRlLm5vdygpO1xuXHQgICAgfVxuXHQgICAgdGhpcy5fcHJvY2VzcyhldmVudCk7XG5cdCAgICBpZiAoVXRpbHMuaXNUb3VjaCgpKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl91cGRhdGVUb3VjaEZvcmNlKCk7XG5cdCAgICB9XG5cdCAgfTtcblx0XG5cdCAgR2VzdHVyZUlucHV0UmVjb2duaXplci5wcm90b3R5cGUudG91Y2htb3ZlID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0ICAgIHJldHVybiB0aGlzLl9wcm9jZXNzKHRoaXMuX2dldEdlc3R1cmVFdmVudChldmVudCkpO1xuXHQgIH07XG5cdFxuXHQgIEdlc3R1cmVJbnB1dFJlY29nbml6ZXIucHJvdG90eXBlLnRvdWNoZW5kID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0ICAgIHZhciBldmVudE5hbWUsIHJlZiwgcmVmMSwgdmFsdWU7XG5cdCAgICBpZiAoZXZlbnQudG91Y2hlcyAhPSBudWxsKSB7XG5cdCAgICAgIGlmIChVdGlscy5pc1RvdWNoKCkpIHtcblx0ICAgICAgICBpZiAoIShldmVudC50b3VjaGVzLmxlbmd0aCA9PT0gMCkpIHtcblx0ICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgaWYgKCEoZXZlbnQudG91Y2hlcy5sZW5ndGggPT09IGV2ZW50LmNoYW5nZWRUb3VjaGVzLmxlbmd0aCkpIHtcblx0ICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHRoaXMuZW0ud3JhcCh3aW5kb3cpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy50b3VjaG1vdmUpO1xuXHQgICAgdGhpcy5lbS53cmFwKHdpbmRvdykucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy50b3VjaGVuZCk7XG5cdCAgICB0aGlzLmVtLndyYXAod2luZG93KS5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRoaXMudG91Y2htb3ZlKTtcblx0ICAgIHRoaXMuZW0ud3JhcCh3aW5kb3cpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLnRvdWNoZW5kKTtcblx0ICAgIHRoaXMuZW0ud3JhcCh3aW5kb3cpLmFkZEV2ZW50TGlzdGVuZXIoXCJ3ZWJraXRtb3VzZWZvcmNlY2hhbmdlZFwiLCB0aGlzLl91cGRhdGVNYWNGb3JjZSk7XG5cdCAgICBldmVudCA9IHRoaXMuX2dldEdlc3R1cmVFdmVudChldmVudCk7XG5cdCAgICByZWYgPSB0aGlzLnNlc3Npb24uc3RhcnRlZDtcblx0ICAgIGZvciAoZXZlbnROYW1lIGluIHJlZikge1xuXHQgICAgICB2YWx1ZSA9IHJlZltldmVudE5hbWVdO1xuXHQgICAgICBpZiAodmFsdWUpIHtcblx0ICAgICAgICB0aGlzW2V2ZW50TmFtZSArIFwiZW5kXCJdKGV2ZW50KTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKCEoKHJlZjEgPSB0aGlzLnNlc3Npb24pICE9IG51bGwgPyByZWYxLnN0YXJ0RXZlbnQgOiB2b2lkIDApKSB7XG5cdCAgICAgIHRoaXMudGFwKGV2ZW50KTtcblx0ICAgIH0gZWxzZSBpZiAodGhpcy5zZXNzaW9uLnN0YXJ0RXZlbnQudGFyZ2V0ID09PSBldmVudC50YXJnZXQpIHtcblx0ICAgICAgdGhpcy50YXAoZXZlbnQpO1xuXHQgICAgfVxuXHQgICAgdGhpcy50YXBlbmQoZXZlbnQpO1xuXHQgICAgcmV0dXJuIHRoaXMuY2FuY2VsKCk7XG5cdCAgfTtcblx0XG5cdCAgR2VzdHVyZUlucHV0UmVjb2duaXplci5wcm90b3R5cGUudGFwID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0ICAgIHJldHVybiB0aGlzLl9kaXNwYXRjaEV2ZW50KFwidGFwXCIsIGV2ZW50KTtcblx0ICB9O1xuXHRcblx0ICBHZXN0dXJlSW5wdXRSZWNvZ25pemVyLnByb3RvdHlwZS50YXBzdGFydCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdCAgICByZXR1cm4gdGhpcy5fZGlzcGF0Y2hFdmVudChcInRhcHN0YXJ0XCIsIGV2ZW50KTtcblx0ICB9O1xuXHRcblx0ICBHZXN0dXJlSW5wdXRSZWNvZ25pemVyLnByb3RvdHlwZS50YXBlbmQgPSBmdW5jdGlvbihldmVudCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX2Rpc3BhdGNoRXZlbnQoXCJ0YXBlbmRcIiwgZXZlbnQpO1xuXHQgIH07XG5cdFxuXHQgIEdlc3R1cmVJbnB1dFJlY29nbml6ZXIucHJvdG90eXBlLmRvdWJsZXRhcCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdCAgICByZXR1cm4gdGhpcy5fZGlzcGF0Y2hFdmVudChcImRvdWJsZXRhcFwiLCBldmVudCk7XG5cdCAgfTtcblx0XG5cdCAgR2VzdHVyZUlucHV0UmVjb2duaXplci5wcm90b3R5cGUubG9uZ3ByZXNzc3RhcnQgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciBldmVudDtcblx0ICAgIGlmICghdGhpcy5zZXNzaW9uKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIGlmICh0aGlzLnNlc3Npb24uc3RhcnRlZC5sb25ncHJlc3MpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgZXZlbnQgPSB0aGlzLl9nZXRHZXN0dXJlRXZlbnQodGhpcy5zZXNzaW9uLnN0YXJ0RXZlbnQpO1xuXHQgICAgdGhpcy5zZXNzaW9uLnN0YXJ0ZWQubG9uZ3ByZXNzID0gZXZlbnQ7XG5cdCAgICB0aGlzLl9kaXNwYXRjaEV2ZW50KFwibG9uZ3ByZXNzc3RhcnRcIiwgZXZlbnQpO1xuXHQgICAgcmV0dXJuIHRoaXMuX2Rpc3BhdGNoRXZlbnQoXCJsb25ncHJlc3NcIiwgZXZlbnQpO1xuXHQgIH07XG5cdFxuXHQgIEdlc3R1cmVJbnB1dFJlY29nbml6ZXIucHJvdG90eXBlLmxvbmdwcmVzc2VuZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdCAgICByZXR1cm4gdGhpcy5fZGlzcGF0Y2hFdmVudChcImxvbmdwcmVzc2VuZFwiLCBldmVudCk7XG5cdCAgfTtcblx0XG5cdCAgR2VzdHVyZUlucHV0UmVjb2duaXplci5wcm90b3R5cGUuX3VwZGF0ZVRvdWNoRm9yY2UgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciBldmVudCwgcmVmLCByZWYxO1xuXHQgICAgaWYgKCEoKHJlZiA9IHRoaXMuc2Vzc2lvbikgIT0gbnVsbCA/IChyZWYxID0gcmVmLmxhc3RFdmVudCkgIT0gbnVsbCA/IHJlZjEudG91Y2hlcy5sZW5ndGggOiB2b2lkIDAgOiB2b2lkIDApKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHRoaXMuc2Vzc2lvbi5mb3JjZSA9IHRoaXMuc2Vzc2lvbi5sYXN0RXZlbnQudG91Y2hlc1swXS5mb3JjZSB8fCAwO1xuXHQgICAgZXZlbnQgPSB0aGlzLl9nZXRHZXN0dXJlRXZlbnQodGhpcy5zZXNzaW9uLmxhc3RFdmVudCk7XG5cdCAgICB0aGlzLmZvcmNldGFwY2hhbmdlKGV2ZW50KTtcblx0ICAgIGlmICh0aGlzLnNlc3Npb24uZm9yY2UgPj0gR2VzdHVyZUlucHV0Rm9yY2VUYXBNb2JpbGUpIHtcblx0ICAgICAgdGhpcy5mb3JjZXRhcHN0YXJ0KGV2ZW50KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRoaXMuZm9yY2V0YXBlbmQoZXZlbnQpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHNldFRpbWVvdXQodGhpcy5fdXBkYXRlVG91Y2hGb3JjZSwgR2VzdHVyZUlucHV0Rm9yY2VUYXBNb2JpbGVQb2xsVGltZSk7XG5cdCAgfTtcblx0XG5cdCAgR2VzdHVyZUlucHV0UmVjb2duaXplci5wcm90b3R5cGUuX3VwZGF0ZU1hY0ZvcmNlID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0ICAgIGlmICghdGhpcy5zZXNzaW9uKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHRoaXMuc2Vzc2lvbi5mb3JjZSA9IFV0aWxzLm1vZHVsYXRlKGV2ZW50LndlYmtpdEZvcmNlLCBbMCwgM10sIFswLCAxXSk7XG5cdCAgICB0aGlzLmZvcmNldGFwY2hhbmdlKHRoaXMuX2dldEdlc3R1cmVFdmVudChldmVudCkpO1xuXHQgICAgaWYgKGV2ZW50LndlYmtpdEZvcmNlID49IEdlc3R1cmVJbnB1dEZvcmNlVGFwRGVza3RvcCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5mb3JjZXRhcHN0YXJ0KGV2ZW50KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmZvcmNldGFwZW5kKGV2ZW50KTtcblx0ICAgIH1cblx0ICB9O1xuXHRcblx0ICBHZXN0dXJlSW5wdXRSZWNvZ25pemVyLnByb3RvdHlwZS5mb3JjZXRhcGNoYW5nZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdCAgICByZXR1cm4gdGhpcy5fZGlzcGF0Y2hFdmVudChcImZvcmNldGFwY2hhbmdlXCIsIGV2ZW50KTtcblx0ICB9O1xuXHRcblx0ICBHZXN0dXJlSW5wdXRSZWNvZ25pemVyLnByb3RvdHlwZS5mb3JjZXRhcHN0YXJ0ID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0ICAgIGlmICghdGhpcy5zZXNzaW9uKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIGlmICh0aGlzLnNlc3Npb24uc3RhcnRlZC5mb3JjZXRhcCkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICB0aGlzLnNlc3Npb24uc3RhcnRlZC5mb3JjZXRhcCA9IGV2ZW50O1xuXHQgICAgdGhpcy5fZGlzcGF0Y2hFdmVudChcImZvcmNldGFwc3RhcnRcIiwgZXZlbnQpO1xuXHQgICAgcmV0dXJuIHRoaXMuX2Rpc3BhdGNoRXZlbnQoXCJmb3JjZXRhcFwiLCBldmVudCk7XG5cdCAgfTtcblx0XG5cdCAgR2VzdHVyZUlucHV0UmVjb2duaXplci5wcm90b3R5cGUuZm9yY2V0YXBlbmQgPSBmdW5jdGlvbihldmVudCkge1xuXHQgICAgaWYgKCF0aGlzLnNlc3Npb24pIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgaWYgKCF0aGlzLnNlc3Npb24uc3RhcnRlZC5mb3JjZXRhcCkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICB0aGlzLnNlc3Npb24uc3RhcnRlZC5mb3JjZXRhcCA9IG51bGw7XG5cdCAgICByZXR1cm4gdGhpcy5fZGlzcGF0Y2hFdmVudChcImZvcmNldGFwZW5kXCIsIGV2ZW50KTtcblx0ICB9O1xuXHRcblx0ICBHZXN0dXJlSW5wdXRSZWNvZ25pemVyLnByb3RvdHlwZS5wYW5zdGFydCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdCAgICB0aGlzLnNlc3Npb24uc3RhcnRlZC5wYW4gPSBldmVudDtcblx0ICAgIHJldHVybiB0aGlzLl9kaXNwYXRjaEV2ZW50KFwicGFuc3RhcnRcIiwgZXZlbnQsIHRoaXMuc2Vzc2lvbi5zdGFydGVkLnBhbi50YXJnZXQpO1xuXHQgIH07XG5cdFxuXHQgIEdlc3R1cmVJbnB1dFJlY29nbml6ZXIucHJvdG90eXBlLnBhbiA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdCAgICB2YXIgZGlyZWN0aW9uO1xuXHQgICAgdGhpcy5fZGlzcGF0Y2hFdmVudChcInBhblwiLCBldmVudCwgdGhpcy5zZXNzaW9uLnN0YXJ0ZWQucGFuLnRhcmdldCk7XG5cdCAgICBkaXJlY3Rpb24gPSB0aGlzLl9nZXREaXJlY3Rpb24oZXZlbnQuZGVsdGEpO1xuXHQgICAgaWYgKGRpcmVjdGlvbikge1xuXHQgICAgICByZXR1cm4gdGhpc1tcInBhblwiICsgZGlyZWN0aW9uXShldmVudCk7XG5cdCAgICB9XG5cdCAgfTtcblx0XG5cdCAgR2VzdHVyZUlucHV0UmVjb2duaXplci5wcm90b3R5cGUucGFuZW5kID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0ICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnQoXCJwYW5lbmRcIiwgZXZlbnQsIHRoaXMuc2Vzc2lvbi5zdGFydGVkLnBhbi50YXJnZXQpO1xuXHQgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi5zdGFydGVkLnBhbiA9IG51bGw7XG5cdCAgfTtcblx0XG5cdCAgR2VzdHVyZUlucHV0UmVjb2duaXplci5wcm90b3R5cGUucGFudXAgPSBmdW5jdGlvbihldmVudCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX2Rpc3BhdGNoRXZlbnQoXCJwYW51cFwiLCBldmVudCwgdGhpcy5zZXNzaW9uLnN0YXJ0ZWQucGFuLnRhcmdldCk7XG5cdCAgfTtcblx0XG5cdCAgR2VzdHVyZUlucHV0UmVjb2duaXplci5wcm90b3R5cGUucGFuZG93biA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdCAgICByZXR1cm4gdGhpcy5fZGlzcGF0Y2hFdmVudChcInBhbmRvd25cIiwgZXZlbnQsIHRoaXMuc2Vzc2lvbi5zdGFydGVkLnBhbi50YXJnZXQpO1xuXHQgIH07XG5cdFxuXHQgIEdlc3R1cmVJbnB1dFJlY29nbml6ZXIucHJvdG90eXBlLnBhbmxlZnQgPSBmdW5jdGlvbihldmVudCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX2Rpc3BhdGNoRXZlbnQoXCJwYW5sZWZ0XCIsIGV2ZW50LCB0aGlzLnNlc3Npb24uc3RhcnRlZC5wYW4udGFyZ2V0KTtcblx0ICB9O1xuXHRcblx0ICBHZXN0dXJlSW5wdXRSZWNvZ25pemVyLnByb3RvdHlwZS5wYW5yaWdodCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdCAgICByZXR1cm4gdGhpcy5fZGlzcGF0Y2hFdmVudChcInBhbnJpZ2h0XCIsIGV2ZW50LCB0aGlzLnNlc3Npb24uc3RhcnRlZC5wYW4udGFyZ2V0KTtcblx0ICB9O1xuXHRcblx0ICBHZXN0dXJlSW5wdXRSZWNvZ25pemVyLnByb3RvdHlwZS5waW5jaHN0YXJ0ID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0ICAgIHRoaXMuc2Vzc2lvbi5zdGFydGVkLnBpbmNoID0gZXZlbnQ7XG5cdCAgICB0aGlzLnNjYWxlc3RhcnQoZXZlbnQsIHRoaXMuc2Vzc2lvbi5zdGFydGVkLnBpbmNoLnRhcmdldCk7XG5cdCAgICB0aGlzLnJvdGF0ZXN0YXJ0KGV2ZW50LCB0aGlzLnNlc3Npb24uc3RhcnRlZC5waW5jaC50YXJnZXQpO1xuXHQgICAgcmV0dXJuIHRoaXMuX2Rpc3BhdGNoRXZlbnQoXCJwaW5jaHN0YXJ0XCIsIGV2ZW50KTtcblx0ICB9O1xuXHRcblx0ICBHZXN0dXJlSW5wdXRSZWNvZ25pemVyLnByb3RvdHlwZS5waW5jaCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdCAgICB0aGlzLl9kaXNwYXRjaEV2ZW50KFwicGluY2hcIiwgZXZlbnQpO1xuXHQgICAgdGhpcy5zY2FsZShldmVudCwgdGhpcy5zZXNzaW9uLnN0YXJ0ZWQucGluY2gudGFyZ2V0KTtcblx0ICAgIHJldHVybiB0aGlzLnJvdGF0ZShldmVudCwgdGhpcy5zZXNzaW9uLnN0YXJ0ZWQucGluY2gudGFyZ2V0KTtcblx0ICB9O1xuXHRcblx0ICBHZXN0dXJlSW5wdXRSZWNvZ25pemVyLnByb3RvdHlwZS5waW5jaGVuZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdCAgICB0aGlzLl9kaXNwYXRjaEV2ZW50KFwicGluY2hlbmRcIiwgZXZlbnQpO1xuXHQgICAgdGhpcy5zY2FsZWVuZChldmVudCwgdGhpcy5zZXNzaW9uLnN0YXJ0ZWQucGluY2gudGFyZ2V0KTtcblx0ICAgIHRoaXMucm90YXRlZW5kKGV2ZW50LCB0aGlzLnNlc3Npb24uc3RhcnRlZC5waW5jaC50YXJnZXQpO1xuXHQgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi5zdGFydGVkLnBpbmNoID0gbnVsbDtcblx0ICB9O1xuXHRcblx0ICBHZXN0dXJlSW5wdXRSZWNvZ25pemVyLnByb3RvdHlwZS5zY2FsZXN0YXJ0ID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0ICAgIHJldHVybiB0aGlzLl9kaXNwYXRjaEV2ZW50KFwic2NhbGVzdGFydFwiLCBldmVudCk7XG5cdCAgfTtcblx0XG5cdCAgR2VzdHVyZUlucHV0UmVjb2duaXplci5wcm90b3R5cGUuc2NhbGUgPSBmdW5jdGlvbihldmVudCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX2Rpc3BhdGNoRXZlbnQoXCJzY2FsZVwiLCBldmVudCk7XG5cdCAgfTtcblx0XG5cdCAgR2VzdHVyZUlucHV0UmVjb2duaXplci5wcm90b3R5cGUuc2NhbGVlbmQgPSBmdW5jdGlvbihldmVudCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX2Rpc3BhdGNoRXZlbnQoXCJzY2FsZWVuZFwiLCBldmVudCk7XG5cdCAgfTtcblx0XG5cdCAgR2VzdHVyZUlucHV0UmVjb2duaXplci5wcm90b3R5cGUucm90YXRlc3RhcnQgPSBmdW5jdGlvbihldmVudCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX2Rpc3BhdGNoRXZlbnQoXCJyb3RhdGVzdGFydFwiLCBldmVudCk7XG5cdCAgfTtcblx0XG5cdCAgR2VzdHVyZUlucHV0UmVjb2duaXplci5wcm90b3R5cGUucm90YXRlID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0ICAgIHJldHVybiB0aGlzLl9kaXNwYXRjaEV2ZW50KFwicm90YXRlXCIsIGV2ZW50KTtcblx0ICB9O1xuXHRcblx0ICBHZXN0dXJlSW5wdXRSZWNvZ25pemVyLnByb3RvdHlwZS5yb3RhdGVlbmQgPSBmdW5jdGlvbihldmVudCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX2Rpc3BhdGNoRXZlbnQoXCJyb3RhdGVlbmRcIiwgZXZlbnQpO1xuXHQgIH07XG5cdFxuXHQgIEdlc3R1cmVJbnB1dFJlY29nbml6ZXIucHJvdG90eXBlLnN3aXBlc3RhcnQgPSBmdW5jdGlvbihldmVudCkge1xuXHQgICAgdGhpcy5fZGlzcGF0Y2hFdmVudChcInN3aXBlc3RhcnRcIiwgZXZlbnQpO1xuXHQgICAgdGhpcy5zZXNzaW9uLnN0YXJ0ZWQuc3dpcGUgPSBldmVudDtcblx0ICAgIHJldHVybiB0aGlzLnN3aXBlZGlyZWN0aW9uc3RhcnQoZXZlbnQpO1xuXHQgIH07XG5cdFxuXHQgIEdlc3R1cmVJbnB1dFJlY29nbml6ZXIucHJvdG90eXBlLnN3aXBlID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0ICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnQoXCJzd2lwZVwiLCBldmVudCk7XG5cdCAgICByZXR1cm4gdGhpcy5zd2lwZWRpcmVjdGlvbihldmVudCk7XG5cdCAgfTtcblx0XG5cdCAgR2VzdHVyZUlucHV0UmVjb2duaXplci5wcm90b3R5cGUuc3dpcGVlbmQgPSBmdW5jdGlvbihldmVudCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX2Rpc3BhdGNoRXZlbnQoXCJzd2lwZWVuZFwiLCBldmVudCk7XG5cdCAgfTtcblx0XG5cdCAgR2VzdHVyZUlucHV0UmVjb2duaXplci5wcm90b3R5cGUuc3dpcGVkaXJlY3Rpb25zdGFydCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdCAgICB2YXIgZGlyZWN0aW9uLCBtYXhYLCBtYXhZLCByZWYsIHJlZjEsIHJlZjIsIHJlZjMsIHN3aXBlRWRnZTtcblx0ICAgIGlmICghZXZlbnQub2Zmc2V0RGlyZWN0aW9uKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIGlmICh0aGlzLnNlc3Npb24uc3RhcnRlZC5zd2lwZWRpcmVjdGlvbikge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICB0aGlzLnNlc3Npb24uc3RhcnRlZC5zd2lwZWRpcmVjdGlvbiA9IGV2ZW50O1xuXHQgICAgZGlyZWN0aW9uID0gdGhpcy5zZXNzaW9uLnN0YXJ0ZWQuc3dpcGVkaXJlY3Rpb24ub2Zmc2V0RGlyZWN0aW9uO1xuXHQgICAgdGhpcy5fZGlzcGF0Y2hFdmVudChcInN3aXBlXCIgKyBkaXJlY3Rpb24gKyBcInN0YXJ0XCIsIGV2ZW50KTtcblx0ICAgIHN3aXBlRWRnZSA9IHRoaXMuX2VkZ2VGb3JTd2lwZURpcmVjdGlvbihkaXJlY3Rpb24pO1xuXHQgICAgbWF4WCA9IFV0aWxzLmZyYW1lR2V0TWF4WChTY3JlZW4uY2FudmFzRnJhbWUpO1xuXHQgICAgbWF4WSA9IFV0aWxzLmZyYW1lR2V0TWF4WShTY3JlZW4uY2FudmFzRnJhbWUpO1xuXHQgICAgaWYgKHN3aXBlRWRnZSA9PT0gXCJ0b3BcIiAmJiAoMCA8IChyZWYgPSBldmVudC5zdGFydC55IC0gU2NyZWVuLmNhbnZhc0ZyYW1lLnkpICYmIHJlZiA8IEdlc3R1cmVJbnB1dEVkZ2VTd2lwZURpc3RhbmNlKSkge1xuXHQgICAgICB0aGlzLmVkZ2Vzd2lwZWRpcmVjdGlvbnN0YXJ0KGV2ZW50KTtcblx0ICAgIH1cblx0ICAgIGlmIChzd2lwZUVkZ2UgPT09IFwicmlnaHRcIiAmJiAobWF4WCAtIEdlc3R1cmVJbnB1dEVkZ2VTd2lwZURpc3RhbmNlIDwgKHJlZjEgPSBldmVudC5zdGFydC54KSAmJiByZWYxIDwgbWF4WCkpIHtcblx0ICAgICAgdGhpcy5lZGdlc3dpcGVkaXJlY3Rpb25zdGFydChldmVudCk7XG5cdCAgICB9XG5cdCAgICBpZiAoc3dpcGVFZGdlID09PSBcImJvdHRvbVwiICYmIChtYXhZIC0gR2VzdHVyZUlucHV0RWRnZVN3aXBlRGlzdGFuY2UgPCAocmVmMiA9IGV2ZW50LnN0YXJ0LnkpICYmIHJlZjIgPCBtYXhZKSkge1xuXHQgICAgICB0aGlzLmVkZ2Vzd2lwZWRpcmVjdGlvbnN0YXJ0KGV2ZW50KTtcblx0ICAgIH1cblx0ICAgIGlmIChzd2lwZUVkZ2UgPT09IFwibGVmdFwiICYmICgwIDwgKHJlZjMgPSBldmVudC5zdGFydC54IC0gU2NyZWVuLmNhbnZhc0ZyYW1lLngpICYmIHJlZjMgPCBHZXN0dXJlSW5wdXRFZGdlU3dpcGVEaXN0YW5jZSkpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuZWRnZXN3aXBlZGlyZWN0aW9uc3RhcnQoZXZlbnQpO1xuXHQgICAgfVxuXHQgIH07XG5cdFxuXHQgIEdlc3R1cmVJbnB1dFJlY29nbml6ZXIucHJvdG90eXBlLnN3aXBlZGlyZWN0aW9uID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0ICAgIHZhciBkaXJlY3Rpb247XG5cdCAgICBpZiAoIXRoaXMuc2Vzc2lvbi5zdGFydGVkLnN3aXBlZGlyZWN0aW9uKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIGRpcmVjdGlvbiA9IHRoaXMuc2Vzc2lvbi5zdGFydGVkLnN3aXBlZGlyZWN0aW9uLm9mZnNldERpcmVjdGlvbjtcblx0ICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnQoXCJzd2lwZVwiICsgZGlyZWN0aW9uLCBldmVudCk7XG5cdCAgICBpZiAodGhpcy5zZXNzaW9uLnN0YXJ0ZWQuZWRnZXN3aXBlZGlyZWN0aW9uKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmVkZ2Vzd2lwZWRpcmVjdGlvbihldmVudCk7XG5cdCAgICB9XG5cdCAgfTtcblx0XG5cdCAgR2VzdHVyZUlucHV0UmVjb2duaXplci5wcm90b3R5cGUuc3dpcGVkaXJlY3Rpb25lbmQgPSBmdW5jdGlvbihldmVudCkge1xuXHQgICAgdmFyIGRpcmVjdGlvbjtcblx0ICAgIGlmICghdGhpcy5zZXNzaW9uLnN0YXJ0ZWQuc3dpcGVkaXJlY3Rpb24pIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgZGlyZWN0aW9uID0gdGhpcy5zZXNzaW9uLnN0YXJ0ZWQuc3dpcGVkaXJlY3Rpb24ub2Zmc2V0RGlyZWN0aW9uO1xuXHQgICAgcmV0dXJuIHRoaXMuX2Rpc3BhdGNoRXZlbnQoXCJzd2lwZVwiICsgZGlyZWN0aW9uICsgXCJlbmRcIiwgZXZlbnQpO1xuXHQgIH07XG5cdFxuXHQgIEdlc3R1cmVJbnB1dFJlY29nbml6ZXIucHJvdG90eXBlLmVkZ2Vzd2lwZWRpcmVjdGlvbiA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdCAgICB2YXIgc3dpcGVFZGdlO1xuXHQgICAgc3dpcGVFZGdlID0gdGhpcy5fZWRnZUZvclN3aXBlRGlyZWN0aW9uKHRoaXMuc2Vzc2lvbi5zdGFydGVkLmVkZ2Vzd2lwZWRpcmVjdGlvbi5vZmZzZXREaXJlY3Rpb24pO1xuXHQgICAgU2NyZWVuLmVtaXQoXCJlZGdlc3dpcGVcIiwgdGhpcy5fY3JlYXRlRXZlbnQoXCJlZGdlc3dpcGVcIiwgZXZlbnQpKTtcblx0ICAgIHJldHVybiBTY3JlZW4uZW1pdChcImVkZ2Vzd2lwZVwiICsgc3dpcGVFZGdlLCB0aGlzLl9jcmVhdGVFdmVudChcImVkZ2Vzd2lwZVwiICsgc3dpcGVFZGdlLCBldmVudCkpO1xuXHQgIH07XG5cdFxuXHQgIEdlc3R1cmVJbnB1dFJlY29nbml6ZXIucHJvdG90eXBlLmVkZ2Vzd2lwZWRpcmVjdGlvbnN0YXJ0ID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0ICAgIHZhciBzd2lwZUVkZ2U7XG5cdCAgICBpZiAodGhpcy5zZXNzaW9uLnN0YXJ0ZWQuZWRnZXN3aXBlZGlyZWN0aW9uKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHRoaXMuc2Vzc2lvbi5zdGFydGVkLmVkZ2Vzd2lwZWRpcmVjdGlvbiA9IGV2ZW50O1xuXHQgICAgc3dpcGVFZGdlID0gdGhpcy5fZWRnZUZvclN3aXBlRGlyZWN0aW9uKHRoaXMuc2Vzc2lvbi5zdGFydGVkLmVkZ2Vzd2lwZWRpcmVjdGlvbi5vZmZzZXREaXJlY3Rpb24pO1xuXHQgICAgU2NyZWVuLmVtaXQoXCJlZGdlc3dpcGVzdGFydFwiLCB0aGlzLl9jcmVhdGVFdmVudChcImVkZ2Vzd2lwZXN0YXJ0XCIsIGV2ZW50KSk7XG5cdCAgICByZXR1cm4gU2NyZWVuLmVtaXQoXCJlZGdlc3dpcGVcIiArIHN3aXBlRWRnZSArIFwic3RhcnRcIiwgdGhpcy5fY3JlYXRlRXZlbnQoXCJlZGdlc3dpcGVcIiArIHN3aXBlRWRnZSArIFwic3RhcnRcIiwgZXZlbnQpKTtcblx0ICB9O1xuXHRcblx0ICBHZXN0dXJlSW5wdXRSZWNvZ25pemVyLnByb3RvdHlwZS5lZGdlc3dpcGVkaXJlY3Rpb25lbmQgPSBmdW5jdGlvbihldmVudCkge1xuXHQgICAgdmFyIHN3aXBlRWRnZTtcblx0ICAgIHN3aXBlRWRnZSA9IHRoaXMuX2VkZ2VGb3JTd2lwZURpcmVjdGlvbih0aGlzLnNlc3Npb24uc3RhcnRlZC5lZGdlc3dpcGVkaXJlY3Rpb24ub2Zmc2V0RGlyZWN0aW9uKTtcblx0ICAgIFNjcmVlbi5lbWl0KFwiZWRnZXN3aXBlZW5kXCIsIHRoaXMuX2NyZWF0ZUV2ZW50KFwiZWRnZXN3aXBlZW5kXCIsIGV2ZW50KSk7XG5cdCAgICByZXR1cm4gU2NyZWVuLmVtaXQoXCJlZGdlc3dpcGVcIiArIHN3aXBlRWRnZSArIFwiZW5kXCIsIHRoaXMuX2NyZWF0ZUV2ZW50KFwiZWRnZXN3aXBlXCIgKyBzd2lwZUVkZ2UgKyBcImVuZFwiLCBldmVudCkpO1xuXHQgIH07XG5cdFxuXHQgIEdlc3R1cmVJbnB1dFJlY29nbml6ZXIucHJvdG90eXBlLl9wcm9jZXNzID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0ICAgIGlmICghdGhpcy5zZXNzaW9uKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHRoaXMuc2Vzc2lvbi5ldmVudHMucHVzaChldmVudCk7XG5cdCAgICBldmVudC5ldmVudENvdW50ID0gdGhpcy5zZXNzaW9uLmV2ZW50Q291bnQrKztcblx0ICAgIGlmIChNYXRoLmFicyhldmVudC5kZWx0YS54KSA+IDAgfHwgTWF0aC5hYnMoZXZlbnQuZGVsdGEueSkgPiAwKSB7XG5cdCAgICAgIGlmICghdGhpcy5zZXNzaW9uLnN0YXJ0ZWQucGFuKSB7XG5cdCAgICAgICAgdGhpcy5wYW5zdGFydChldmVudCk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdGhpcy5wYW4oZXZlbnQpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICBpZiAodGhpcy5zZXNzaW9uLnN0YXJ0ZWQucGluY2ggJiYgZXZlbnQuZmluZ2VycyA9PT0gMSkge1xuXHQgICAgICB0aGlzLnBpbmNoZW5kKGV2ZW50KTtcblx0ICAgIH0gZWxzZSBpZiAoIXRoaXMuc2Vzc2lvbi5zdGFydGVkLnBpbmNoICYmIGV2ZW50LmZpbmdlcnMgPT09IDIpIHtcblx0ICAgICAgdGhpcy5waW5jaHN0YXJ0KGV2ZW50KTtcblx0ICAgIH0gZWxzZSBpZiAodGhpcy5zZXNzaW9uLnN0YXJ0ZWQucGluY2gpIHtcblx0ICAgICAgdGhpcy5waW5jaChldmVudCk7XG5cdCAgICB9XG5cdCAgICBpZiAoIXRoaXMuc2Vzc2lvbi5zdGFydGVkLnN3aXBlICYmIChNYXRoLmFicyhldmVudC5vZmZzZXQueCkgPiBHZXN0dXJlSW5wdXRTd2lwZVRocmVzaG9sZCB8fCBNYXRoLmFicyhldmVudC5vZmZzZXQueSkgPiBHZXN0dXJlSW5wdXRTd2lwZVRocmVzaG9sZCkpIHtcblx0ICAgICAgdGhpcy5zd2lwZXN0YXJ0KGV2ZW50KTtcblx0ICAgIH0gZWxzZSBpZiAodGhpcy5zZXNzaW9uLnN0YXJ0ZWQuc3dpcGUpIHtcblx0ICAgICAgdGhpcy5zd2lwZShldmVudCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcy5zZXNzaW9uLmxhc3RFdmVudCA9IGV2ZW50O1xuXHQgIH07XG5cdFxuXHQgIEdlc3R1cmVJbnB1dFJlY29nbml6ZXIucHJvdG90eXBlLl9nZXRFdmVudFBvaW50ID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0ICAgIHZhciByZWY7XG5cdCAgICBpZiAoKHJlZiA9IGV2ZW50LnRvdWNoZXMpICE9IG51bGwgPyByZWYubGVuZ3RoIDogdm9pZCAwKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9nZXRUb3VjaFBvaW50KGV2ZW50LCAwKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB7XG5cdCAgICAgIHg6IGV2ZW50LnBhZ2VYLFxuXHQgICAgICB5OiBldmVudC5wYWdlWVxuXHQgICAgfTtcblx0ICB9O1xuXHRcblx0ICBHZXN0dXJlSW5wdXRSZWNvZ25pemVyLnByb3RvdHlwZS5fZ2V0R2VzdHVyZUV2ZW50ID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0ICAgIHZhciBldmVudHMsIGksIGxlbiwgcG9pbnRLZXksIHJlZiwgcmVmMSwgcmVmMiwgcmVmMywgcmVmNCwgcmVmNSwgcmVmNiwgcmVmNywgcmVmOCwgcmVmOSwgdG91Y2hQb2ludEEsIHRvdWNoUG9pbnRCO1xuXHQgICAgXy5leHRlbmQoZXZlbnQsIHtcblx0ICAgICAgdGltZTogRGF0ZS5ub3coKSxcblx0ICAgICAgcG9pbnQ6IHRoaXMuX2dldEV2ZW50UG9pbnQoZXZlbnQpLFxuXHQgICAgICBzdGFydDogdGhpcy5fZ2V0RXZlbnRQb2ludChldmVudCksXG5cdCAgICAgIHByZXZpb3VzOiB0aGlzLl9nZXRFdmVudFBvaW50KGV2ZW50KSxcblx0ICAgICAgb2Zmc2V0OiB7XG5cdCAgICAgICAgeDogMCxcblx0ICAgICAgICB5OiAwXG5cdCAgICAgIH0sXG5cdCAgICAgIG9mZnNldFRpbWU6IDAsXG5cdCAgICAgIG9mZnNldEFuZ2xlOiAwLFxuXHQgICAgICBvZmZzZXREaXJlY3Rpb246IG51bGwsXG5cdCAgICAgIGRlbHRhOiB7XG5cdCAgICAgICAgeDogMCxcblx0ICAgICAgICB5OiAwXG5cdCAgICAgIH0sXG5cdCAgICAgIGRlbHRhVGltZTogMCxcblx0ICAgICAgZGVsdGFBbmdsZTogMCxcblx0ICAgICAgZGVsdGFEaXJlY3Rpb246IG51bGwsXG5cdCAgICAgIGZvcmNlOiAwLFxuXHQgICAgICB2ZWxvY2l0eToge1xuXHQgICAgICAgIHg6IDAsXG5cdCAgICAgICAgeTogMFxuXHQgICAgICB9LFxuXHQgICAgICBmaW5nZXJzOiAoKHJlZiA9IGV2ZW50LnRvdWNoZXMpICE9IG51bGwgPyByZWYubGVuZ3RoIDogdm9pZCAwKSB8fCAwLFxuXHQgICAgICB0b3VjaENlbnRlcjogdGhpcy5fZ2V0RXZlbnRQb2ludChldmVudCksXG5cdCAgICAgIHRvdWNoT2Zmc2V0OiB7XG5cdCAgICAgICAgeDogMCxcblx0ICAgICAgICB5OiAwXG5cdCAgICAgIH0sXG5cdCAgICAgIHRvdWNoRGlzdGFuY2U6IDAsXG5cdCAgICAgIHNjYWxlOiAxLFxuXHQgICAgICBzY2FsZURpcmVjdGlvbjogbnVsbCxcblx0ICAgICAgcm90YXRpb246IDBcblx0ICAgIH0pO1xuXHQgICAgaWYgKChyZWYxID0gdGhpcy5zZXNzaW9uKSAhPSBudWxsID8gcmVmMS5zdGFydEV2ZW50IDogdm9pZCAwKSB7XG5cdCAgICAgIGV2ZW50LnN0YXJ0ID0gdGhpcy5zZXNzaW9uLnN0YXJ0RXZlbnQucG9pbnQ7XG5cdCAgICAgIGV2ZW50Lm9mZnNldCA9IFV0aWxzLnBvaW50U3VidHJhY3QoZXZlbnQucG9pbnQsIGV2ZW50LnN0YXJ0KTtcblx0ICAgICAgZXZlbnQub2Zmc2V0VGltZSA9IGV2ZW50LnRpbWUgLSB0aGlzLnNlc3Npb24uc3RhcnRFdmVudC50aW1lO1xuXHQgICAgICBldmVudC5vZmZzZXRBbmdsZSA9IFV0aWxzLnBvaW50QW5nbGUodGhpcy5zZXNzaW9uLnN0YXJ0RXZlbnQucG9pbnQsIGV2ZW50LnBvaW50KTtcblx0ICAgICAgZXZlbnQub2Zmc2V0RGlyZWN0aW9uID0gdGhpcy5fZ2V0RGlyZWN0aW9uKGV2ZW50Lm9mZnNldCk7XG5cdCAgICAgIGV2ZW50LnRvdWNoQ2VudGVyU3RhcnQgPSB0aGlzLnNlc3Npb24uc3RhcnRFdmVudC50b3VjaENlbnRlcjtcblx0ICAgIH1cblx0ICAgIGlmICgocmVmMiA9IHRoaXMuc2Vzc2lvbikgIT0gbnVsbCA/IHJlZjIubGFzdEV2ZW50IDogdm9pZCAwKSB7XG5cdCAgICAgIGV2ZW50LnByZXZpb3VzID0gdGhpcy5zZXNzaW9uLmxhc3RFdmVudC5wb2ludDtcblx0ICAgICAgZXZlbnQuZGVsdGFUaW1lID0gZXZlbnQudGltZSAtIHRoaXMuc2Vzc2lvbi5sYXN0RXZlbnQudGltZTtcblx0ICAgICAgZXZlbnQuZGVsdGEgPSBVdGlscy5wb2ludFN1YnRyYWN0KGV2ZW50LnBvaW50LCB0aGlzLnNlc3Npb24ubGFzdEV2ZW50LnBvaW50KTtcblx0ICAgICAgZXZlbnQuZGVsdGFBbmdsZSA9IFV0aWxzLnBvaW50QW5nbGUoZXZlbnQucG9pbnQsIHRoaXMuc2Vzc2lvbi5sYXN0RXZlbnQucG9pbnQpO1xuXHQgICAgICBldmVudC5kZWx0YURpcmVjdGlvbiA9IHRoaXMuX2dldERpcmVjdGlvbihldmVudC5kZWx0YSk7XG5cdCAgICB9XG5cdCAgICBpZiAoZXZlbnQuZmluZ2VycyA+IDEpIHtcblx0ICAgICAgdG91Y2hQb2ludEEgPSB0aGlzLl9nZXRUb3VjaFBvaW50KGV2ZW50LCAwKTtcblx0ICAgICAgdG91Y2hQb2ludEIgPSB0aGlzLl9nZXRUb3VjaFBvaW50KGV2ZW50LCAxKTtcblx0ICAgICAgZXZlbnQudG91Y2hDZW50ZXIgPSBVdGlscy5wb2ludENlbnRlcih0b3VjaFBvaW50QiwgdG91Y2hQb2ludEEpO1xuXHQgICAgICBldmVudC50b3VjaE9mZnNldCA9IFV0aWxzLnBvaW50U3VidHJhY3QodG91Y2hQb2ludEIsIHRvdWNoUG9pbnRBKTtcblx0ICAgICAgZXZlbnQudG91Y2hEaXN0YW5jZSA9IF8ubWF4KFtHZXN0dXJlSW5wdXRNaW5pbXVtRmluZ2VyRGlzdGFuY2UsIFV0aWxzLnBvaW50RGlzdGFuY2UodG91Y2hQb2ludEEsIHRvdWNoUG9pbnRCKV0pO1xuXHQgICAgICBldmVudC5yb3RhdGlvbiA9IFV0aWxzLnBvaW50QW5nbGUodG91Y2hQb2ludEEsIHRvdWNoUG9pbnRCKTtcblx0ICAgIH1cblx0ICAgIGlmICgocmVmMyA9IHRoaXMuc2Vzc2lvbikgIT0gbnVsbCA/IHJlZjMuZXZlbnRzIDogdm9pZCAwKSB7XG5cdCAgICAgIGV2ZW50cyA9IF8uZmlsdGVyKHRoaXMuc2Vzc2lvbi5ldmVudHMsIGZ1bmN0aW9uKGUpIHtcblx0ICAgICAgICBpZiAoZS5ldmVudENvdW50ID09PSAwKSB7XG5cdCAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBlLnRpbWUgPiAoZXZlbnQudGltZSAtIChHZXN0dXJlSW5wdXRWZWxvY2l0eVRpbWUgKiAxMDAwKSk7XG5cdCAgICAgIH0pO1xuXHQgICAgICBldmVudC52ZWxvY2l0eSA9IHRoaXMuX2dldFZlbG9jaXR5KGV2ZW50cyk7XG5cdCAgICB9XG5cdCAgICBpZiAoKHJlZjQgPSB0aGlzLnNlc3Npb24pICE9IG51bGwgPyByZWY0LnN0YXJ0ZWQucGluY2ggOiB2b2lkIDApIHtcblx0ICAgICAgZXZlbnQuc2NhbGUgPSBldmVudC50b3VjaERpc3RhbmNlIC8gdGhpcy5zZXNzaW9uLnN0YXJ0ZWQucGluY2gudG91Y2hEaXN0YW5jZTtcblx0ICAgICAgZXZlbnQuc2NhbGVEaXJlY3Rpb24gPSB0aGlzLl9nZXRTY2FsZURpcmVjdGlvbihldmVudC5zY2FsZSAtIHRoaXMuc2Vzc2lvbi5sYXN0RXZlbnQuc2NhbGUpO1xuXHQgICAgICBpZiAoIWV2ZW50LnNjYWxlRGlyZWN0aW9uICYmICgocmVmNSA9IHRoaXMuc2Vzc2lvbikgIT0gbnVsbCA/IHJlZjUubGFzdEV2ZW50IDogdm9pZCAwKSkge1xuXHQgICAgICAgIGV2ZW50LnNjYWxlRGlyZWN0aW9uID0gdGhpcy5zZXNzaW9uLmxhc3RFdmVudC5zY2FsZURpcmVjdGlvbjtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKChyZWY2ID0gdGhpcy5zZXNzaW9uKSAhPSBudWxsID8gcmVmNi5sYXN0RXZlbnQgOiB2b2lkIDApIHtcblx0ICAgICAgaWYgKChldmVudC5maW5nZXJzICE9PSAocmVmNyA9IHRoaXMuc2Vzc2lvbi5sYXN0RXZlbnQuZmluZ2VycykgJiYgcmVmNyA9PT0gMikpIHtcblx0ICAgICAgICBldmVudC5kZWx0YSA9IHtcblx0ICAgICAgICAgIHg6IDAsXG5cdCAgICAgICAgICB5OiAwXG5cdCAgICAgICAgfTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoZXZlbnQuZmluZ2VycyA9PT0gMiAmJiB0aGlzLnNlc3Npb24ubGFzdEV2ZW50LmZpbmdlcnMgPT09IDIpIHtcblx0ICAgICAgICBldmVudC5kZWx0YSA9IFV0aWxzLnBvaW50U3VidHJhY3QoZXZlbnQudG91Y2hDZW50ZXIsIHRoaXMuc2Vzc2lvbi5sYXN0RXZlbnQudG91Y2hDZW50ZXIpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICBpZiAoKHJlZjggPSB0aGlzLnNlc3Npb24pICE9IG51bGwgPyByZWY4Lmxhc3RFdmVudCA6IHZvaWQgMCkge1xuXHQgICAgICBpZiAodGhpcy5zZXNzaW9uLmZvcmNlKSB7XG5cdCAgICAgICAgZXZlbnQuZm9yY2UgPSB0aGlzLnNlc3Npb24uZm9yY2U7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJlZjkgPSBbXCJwb2ludFwiLCBcInN0YXJ0XCIsIFwicHJldmlvdXNcIiwgXCJvZmZzZXRcIiwgXCJkZWx0YVwiLCBcInZlbG9jaXR5XCIsIFwidG91Y2hDZW50ZXJcIiwgXCJ0b3VjaE9mZnNldFwiXTtcblx0ICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZjkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0ICAgICAgcG9pbnRLZXkgPSByZWY5W2ldO1xuXHQgICAgICBldmVudFtwb2ludEtleSArIFwiWFwiXSA9IGV2ZW50W3BvaW50S2V5XS54O1xuXHQgICAgICBldmVudFtwb2ludEtleSArIFwiWVwiXSA9IGV2ZW50W3BvaW50S2V5XS55O1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGV2ZW50O1xuXHQgIH07XG5cdFxuXHQgIEdlc3R1cmVJbnB1dFJlY29nbml6ZXIucHJvdG90eXBlLl9nZXRUb3VjaFBvaW50ID0gZnVuY3Rpb24oZXZlbnQsIGluZGV4KSB7XG5cdCAgICB2YXIgcG9pbnQ7XG5cdCAgICByZXR1cm4gcG9pbnQgPSB7XG5cdCAgICAgIHg6IGV2ZW50LnRvdWNoZXNbaW5kZXhdLnBhZ2VYLFxuXHQgICAgICB5OiBldmVudC50b3VjaGVzW2luZGV4XS5wYWdlWVxuXHQgICAgfTtcblx0ICB9O1xuXHRcblx0ICBHZXN0dXJlSW5wdXRSZWNvZ25pemVyLnByb3RvdHlwZS5fZ2V0RGlyZWN0aW9uID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG5cdCAgICBpZiAoTWF0aC5hYnMob2Zmc2V0LngpID4gTWF0aC5hYnMob2Zmc2V0LnkpKSB7XG5cdCAgICAgIGlmIChvZmZzZXQueCA+IDApIHtcblx0ICAgICAgICByZXR1cm4gXCJyaWdodFwiO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChvZmZzZXQueCA8IDApIHtcblx0ICAgICAgICByZXR1cm4gXCJsZWZ0XCI7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIGlmIChNYXRoLmFicyhvZmZzZXQueCkgPCBNYXRoLmFicyhvZmZzZXQueSkpIHtcblx0ICAgICAgaWYgKG9mZnNldC55IDwgMCkge1xuXHQgICAgICAgIHJldHVybiBcInVwXCI7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKG9mZnNldC55ID4gMCkge1xuXHQgICAgICAgIHJldHVybiBcImRvd25cIjtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIG51bGw7XG5cdCAgfTtcblx0XG5cdCAgR2VzdHVyZUlucHV0UmVjb2duaXplci5wcm90b3R5cGUuX2VkZ2VGb3JTd2lwZURpcmVjdGlvbiA9IGZ1bmN0aW9uKGRpcmVjdGlvbikge1xuXHQgICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJkb3duXCIpIHtcblx0ICAgICAgcmV0dXJuIFwidG9wXCI7XG5cdCAgICB9XG5cdCAgICBpZiAoZGlyZWN0aW9uID09PSBcImxlZnRcIikge1xuXHQgICAgICByZXR1cm4gXCJyaWdodFwiO1xuXHQgICAgfVxuXHQgICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJ1cFwiKSB7XG5cdCAgICAgIHJldHVybiBcImJvdHRvbVwiO1xuXHQgICAgfVxuXHQgICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJyaWdodFwiKSB7XG5cdCAgICAgIHJldHVybiBcImxlZnRcIjtcblx0ICAgIH1cblx0ICAgIHJldHVybiBudWxsO1xuXHQgIH07XG5cdFxuXHQgIEdlc3R1cmVJbnB1dFJlY29nbml6ZXIucHJvdG90eXBlLl9nZXRTY2FsZURpcmVjdGlvbiA9IGZ1bmN0aW9uKG9mZnNldCkge1xuXHQgICAgaWYgKG9mZnNldCA+IDApIHtcblx0ICAgICAgcmV0dXJuIFwidXBcIjtcblx0ICAgIH1cblx0ICAgIGlmIChvZmZzZXQgPCAwKSB7XG5cdCAgICAgIHJldHVybiBcImRvd25cIjtcblx0ICAgIH1cblx0ICAgIHJldHVybiBudWxsO1xuXHQgIH07XG5cdFxuXHQgIEdlc3R1cmVJbnB1dFJlY29nbml6ZXIucHJvdG90eXBlLl9jcmVhdGVFdmVudCA9IGZ1bmN0aW9uKHR5cGUsIGV2ZW50KSB7XG5cdCAgICB2YXIgaywgdG91Y2hFdmVudCwgdjtcblx0ICAgIHRvdWNoRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIk1vdXNlRXZlbnRcIik7XG5cdCAgICB0b3VjaEV2ZW50LmluaXRNb3VzZUV2ZW50KHR5cGUsIHRydWUsIHRydWUsIHdpbmRvdywgZXZlbnQuZGV0YWlsLCBldmVudC5zY3JlZW5YLCBldmVudC5zY3JlZW5ZLCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZLCBldmVudC5jdHJsS2V5LCBldmVudC5zaGlmdEtleSwgZXZlbnQuYWx0S2V5LCBldmVudC5tZXRhS2V5LCBldmVudC5idXR0b24sIGV2ZW50LnJlbGF0ZWRUYXJnZXQpO1xuXHQgICAgdG91Y2hFdmVudC50b3VjaGVzID0gZXZlbnQudG91Y2hlcztcblx0ICAgIHRvdWNoRXZlbnQuY2hhbmdlZFRvdWNoZXMgPSBldmVudC50b3VjaGVzO1xuXHQgICAgdG91Y2hFdmVudC50YXJnZXRUb3VjaGVzID0gZXZlbnQudG91Y2hlcztcblx0ICAgIGZvciAoayBpbiBldmVudCkge1xuXHQgICAgICB2ID0gZXZlbnRba107XG5cdCAgICAgIHRvdWNoRXZlbnRba10gPSB2O1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRvdWNoRXZlbnQ7XG5cdCAgfTtcblx0XG5cdCAgR2VzdHVyZUlucHV0UmVjb2duaXplci5wcm90b3R5cGUuX2Rpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbih0eXBlLCBldmVudCwgdGFyZ2V0KSB7XG5cdCAgICB2YXIgcmVmLCByZWYxLCB0b3VjaEV2ZW50O1xuXHQgICAgdG91Y2hFdmVudCA9IHRoaXMuX2NyZWF0ZUV2ZW50KHR5cGUsIGV2ZW50KTtcblx0ICAgIGlmICh0YXJnZXQgPT0gbnVsbCkge1xuXHQgICAgICB0YXJnZXQgPSAocmVmID0gdGhpcy5zZXNzaW9uKSAhPSBudWxsID8gKHJlZjEgPSByZWYuc3RhcnRFdmVudCkgIT0gbnVsbCA/IHJlZjEudGFyZ2V0IDogdm9pZCAwIDogdm9pZCAwO1xuXHQgICAgfVxuXHQgICAgaWYgKHRhcmdldCA9PSBudWxsKSB7XG5cdCAgICAgIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0YXJnZXQuZGlzcGF0Y2hFdmVudCh0b3VjaEV2ZW50KTtcblx0ICB9O1xuXHRcblx0ICBHZXN0dXJlSW5wdXRSZWNvZ25pemVyLnByb3RvdHlwZS5fZ2V0VmVsb2NpdHkgPSBmdW5jdGlvbihldmVudHMpIHtcblx0ICAgIHZhciBjdXJyZW50LCBmaXJzdCwgdGltZSwgdmVsb2NpdHk7XG5cdCAgICBpZiAoZXZlbnRzLmxlbmd0aCA8IDIpIHtcblx0ICAgICAgcmV0dXJuIHtcblx0ICAgICAgICB4OiAwLFxuXHQgICAgICAgIHk6IDBcblx0ICAgICAgfTtcblx0ICAgIH1cblx0ICAgIGN1cnJlbnQgPSBldmVudHNbZXZlbnRzLmxlbmd0aCAtIDFdO1xuXHQgICAgZmlyc3QgPSBldmVudHNbMF07XG5cdCAgICB0aW1lID0gY3VycmVudC50aW1lIC0gZmlyc3QudGltZTtcblx0ICAgIHZlbG9jaXR5ID0ge1xuXHQgICAgICB4OiAoY3VycmVudC5wb2ludC54IC0gZmlyc3QucG9pbnQueCkgLyB0aW1lLFxuXHQgICAgICB5OiAoY3VycmVudC5wb2ludC55IC0gZmlyc3QucG9pbnQueSkgLyB0aW1lXG5cdCAgICB9O1xuXHQgICAgaWYgKHZlbG9jaXR5LnggPT09IEluZmluaXR5KSB7XG5cdCAgICAgIHZlbG9jaXR5LnggPSAwO1xuXHQgICAgfVxuXHQgICAgaWYgKHZlbG9jaXR5LnkgPT09IEluZmluaXR5KSB7XG5cdCAgICAgIHZlbG9jaXR5LnkgPSAwO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHZlbG9jaXR5O1xuXHQgIH07XG5cdFxuXHQgIHJldHVybiBHZXN0dXJlSW5wdXRSZWNvZ25pemVyO1xuXG5cdH0pKCk7XG5cblxuLyoqKi8gfSxcbi8qIDU0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRleHBvcnRzLmRhdGUgPSAxNDYxOTMxMzM4O1xuXHRcblx0ZXhwb3J0cy5icmFuY2ggPSBcImJlbi1jb21wb25lbnRzXCI7XG5cdFxuXHRleHBvcnRzLmhhc2ggPSBcIjE3Y2Y0ODZcIjtcblx0XG5cdGV4cG9ydHMuYnVpbGQgPSAxNjc3O1xuXHRcblx0ZXhwb3J0cy52ZXJzaW9uID0gZXhwb3J0cy5icmFuY2ggKyBcIi9cIiArIGV4cG9ydHMuaGFzaDtcblxuXG4vKioqLyB9XG4vKioqKioqLyBdKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZyYW1lci5qcy5tYXAiXX0=
